learning presence finitely infinitely irrelevant attributes avrim blum school computer science carnegie mellon university pittsburgh pa avrim theory cs cmu edu lisa hellerstein department eecs northwestern university sheridan road evanston il eecs nwu edu nick littlestone nec research institute independence way princeton nj research nj nec com supported nsf postdoctoral fellowship 
part research conducted author mit supported nsf graduate fellowship 
research supported part siemens nsf 
part research conducted author massachusetts institute technology university california santa cruz 
research primarily conducted author harvard university supported onr darpa afosr 
please send proofs lisa hellerstein department eecs northwestern university sheridan road evanston il proposed running head learning irrelevant attributes 
list symbols ff alpha infinity hat phi star tilde calligraphic calligraphic ceiling floor summation capital sigma addresses problem learning boolean functions query mistake bound models presence irrelevant attributes 
learning concept learner may observe great attributes concept depends sense presence extra irrelevant attributes change underlying concept learned 
interested learnability concept classes classes learned algorithm attribute efficient dependence mistake bound number queries number irrelevant attributes low 
results apply projection embedding closed concept classes 
show class learnable attribute efficiently mistake bound model learnable infinite attribute mistake bound model 
show addition convert algorithm learns class mistake bound model membership queries algorithm learns class attribute efficiently model infinite attribute version 
membership query model show learnability imply attribute efficient learnability deterministic algorithms 
describe large class functions including set monotone functions learnability imply attribute efficient learnability model 
addresses problem learning boolean functions presence irrelevant attributes 
learning concept learner may observe great attributes concept depends 
arbitrariness selection attributes observed learner sense presence extra irrelevant attributes change underlying concept learned 
interested learnability concept classes classes learned algorithm attribute efficient 
mean roughly dependence algorithm performance terms number mistakes number queries number irrelevant attributes low 
motivated part previous attempts design polynomial algorithms learn specific concepts perform presence irrelevant attributes :10.1.1.130.9013
littlestone describes algorithms classes concepts mistake bound learning model particularly efficient sense :10.1.1.130.9013
blum describes variant standard model infinite attribute model examples way algorithm may run polynomial time spaces infinitely irrelevant attributes long small number appear positively instance 
address general questions related results 
classes functions learnable model may unbounded number irrelevant attributes 
second models classes functions learnable attribute efficiently 
ability learner queries affect issue 
results partially answer questions 
models consider learning models mistake bound mb model infinite attribute mistake bound imb model standard mistake bound model augmented membership queries model infinite attribute mistake bound model augmented membership queries model model exact learning membership queries qu model 
introduce models 
fv countably infinite set variables finite infinite subset instance assignment element denote set assignments 
set fv 
element vn represented boolean vector ha 
concept boolean function concept class collection concepts 
mistake bound model mb target function vn learning proceeds sequence trials :10.1.1.130.9013
trial learner instance vn represented bit tuple 
learner attempts predict value told prediction correct 
count number trials algorithm prediction incorrect number mistakes 
model imb similar instances chosen represented finite tuples represented listing names variables set 
assumed instances algorithm finite length 
finite sequence trials denote maximum number variables instance seen 
denote description length number bits longest instance fixed method representing lists variables 
representation instances learning proceeds model imb model mb 
membership oracle takes input instance returns 
queries oracle called membership queries 
model mb model trial algorithm allowed membership queries requests instance predict count total number mistakes queries 
model defined analogously queries restricted instances finite number variables set 
time query proportional length model description length instance model 
results assume loss generality algorithms mb imb models conservative :10.1.1.130.9013
conservative algorithm updates hypothesis uses prediction mistake receives answer query 
particular time algorithm told predicted correctly forgets saw instance changing state requests instance 
qu model cf 
angluin algorithm learns concept membership queries trials 
algorithm required terminate output representation function count total number queries 
define qu model finite domains 
say function depends variable exist assignments variable relevant variable depends bounds depend additional parameters measure complexity target function denoted number relevant variables target function 
say algorithm learn attribute efficient polynomial constant ff number mistakes queries target function defined variables relevant ff ff imb models 
say strongly attribute efficient number mistakes queries log log imb models 
provide definitions transformations attribute efficiency give logarithmic dependence transformations attribute efficient algorithms require ff ff dependency 
interesting open question learnability weaker sense implies learnability stronger sense general classes study 
reader may wish compare status occam algorithms definition similar form sublinear dependence number examples 
learning algorithms input 
qu model straightforward extension qu model infinite domain concept classes learned finite time 
problem finite number queries algorithm may able tell relevant variables target concept 
possible guess values quantities double square guesses necessary reduce problem case values known 
difficulty applying doubling techniques qu model comes fact may feasible acceptable number queries ascertain target concept successfully identified number guesses needs doubled 
note computational complexity concern mb model achieve mistake bound depending logarithmically halving algorithm defined :10.1.1.130.9013
variation algorithm see gives logarithmic dependence imb model 
difficulty models finding polynomial time algorithms exhibit behavior 
models mb say learning algorithm polynomial time worst case time spent computation trial polynomial imb models allow time polynomial trial 
qu model learning algorithm polynomial time total running time polynomial class polynomially learnable model polynomial time algorithm learns number mistakes queries applicable polynomial models mb qu models imb 
note algorithm learning class models necessarily take time linear order set queries read counterexamples 
designing attribute efficient algorithms try time algorithm depend sublinearly mistakes queries 
rest say learnable implicitly refer polynomial learnability 
informal statement results results apply set function classes projection closed embedding closed 
informally class functions projection closed closed operation function class fixing assignments variables yielding new function smaller domain 
class embedding closed closed operation function class renaming variables domain adding additional irrelevant variables domain 
see projection embedding closed function classes behaved number ways 
widely studied concept classes including cnf dnf term cnf term dnf decision lists read formulas contained class significantly harder learn original class 
example class projection closed set functions variables variables depend log 
example class embedding closed set boolean functions exactly satisfying assignment 
prove main results 
show class learnable attribute efficiently mb model learnable imb model 
class learnable strongly attribute efficiently mb model learnable strongly imb model 
show addition class learnable models learnable strongly attribute efficiently models 
qu model show learnability imply attribute efficient learnability require learning algorithm deterministic 
prove large class functions including set monotone functions learnability imply strongly attribute efficient learnability 
section show mb models number mistakes queries performed learning algorithm omega gamma 
qu model number queries bounded log gamma delta simple information theory argument 
remain open questions relation learnability attribute efficient learnability various models 
class may useful study resolving questions class boolean functions compute parity subset inputs 
class including constant functions functions compute negation parity 
parity learnable mb model 
known learnable attribute efficiently mb model known learnable imb model 
show parity learnable attribute efficiently qu model randomized algorithm exact identification high probability allowed deterministic algorithm 
additional definitions variable sets embedding domain domain injective mapping concept boolean function natural way define corresponding concept define denote function 
say embedding concept 
partial assignment mapping variable assigned total partial assignments assigns values subset variables assigns values remainder denote assignment agrees variables assigned agrees remainder 
partial assignment variables leaves exactly variables unassigned 
function denote function defined 
natural interpretation function original domain conflicts argument resolved favor 
denote function domain 
consider problem learning various learning models concept classes subclasses 
concepts boolean functions defined set fv 

class associate corresponding class contains functions embeds note function embedding function defined finite number variables 
say learn class mb imb models mean functions defined property 
example function assignments lim 
learned mb models learned imb model 
define set concepts depend relevant variables 
complexity function associated concepts 
assume functions property projection 
assume embedding 
concept class embedding closed embeddings fx 
fx 
projection closed partial assignments variables jw set variables assigned embedding fv 
jw class projection embedding closed easily shown proofs implicitly fact defined finite set variables partial assignment leaves relevant variables unassigned holds class form hold arbitrary functions defined example suppose assignments lim 
variable relevant projections assign values infinite number variables note definition relevant variables applies functions entire domain example domain consists points unclear variables considered relevant 
consider incomplete domains 
transformation attribute efficient mb algorithm clearly learning infinite attribute mistake bound model hard learning standard finite attribute model 
theorem show partial converse 
open question full converse holds mb learnability implies imb learnability general 
theorem class learnable mb model attribute efficient algorithm learnable imb model 
proof theorem follows lemma 
lemma suppose exists polynomial time attribute efficient algorithm learn class mb model mistakes concepts size restriction complexity function theorems significantly simpler state 
imply true size function sense description length example consider different embeddings disjunction variables 
imb models fact variables may high description length taken care term denoting length longest instance seen see section 
non decreasing polynomially computable 
exists polynomial time algorithm learn imb model integral upper bound size longest instance qh mistakes size integer 
assume correctness lemma postponing proof section 
proof theorem lemma suppose imb algorithm 
ff constant ff lemma 
solving mq ff yields ff mq gammaff value chosen mq gammaff number mistakes algorithm mq ff gammaff polynomial ff 
proves theorem 
algorithm imb model guesses unknown values algorithm lemma doubles necessary 
doubles guess mistake bound ff exceeded doubles guess instance attributes seen 
estimate revised algorithm restarts scratch 
ith guess jth guess starting 
fixed guess number mistakes ff gammaff ff gammaff ff gammaff ff gammaff ff gammaff ff gammaff ff gammaff 
summing guesses get mistake bound ff gammaff ff gammaff polynomial desired 
notice bound proof algorithm sufficiently attribute efficient dependence ff ff resulting algorithm imb model attribute efficient 
lemma prove theorem 
theorem class learnable mb model strongly attribute efficient algorithm learnable strongly attribute efficient algorithm imb model 
proof log lemma gives mq upper bound mq log mq mq log mq mq mq 
number mistakes algorithm log mq strongly attribute efficient 
proves theorem imb algorithm 
remove assumption double estimate proof theorem square guessed value previous guess exceeded doubling introduces extra log factor 
ith guess value jth guess value duration fixed pair guesses maximum number mistakes log simplicity may upper bound log log 
total number mistakes log log log log log log yielding desired result 
proofs theorems imb algorithm learn starts new iteration mb algorithm time receives example size exceeds current estimate 
note size largest instance seen far keeps doubling squaring theorem iteration imb algorithm completed imb algorithm continue making mistakes forever despite staying mistake bound 
convergence desired case obtained interleaving imb algorithm imb algorithm guaranteed converge possibly worse mistake bounds 
interleaved algorithm uses procedures predict mistake switches 
procedures converges interleaved algorithm mistake bound interleaved algorithm twice mistake bound original possibly non converging procedure 
sample converging procedure follows 
works phases starting phase 
ith phase procedure assumes relevant attributes target function contained set fg 
phase procedure projects instance assignment ignores assignment variables outside runs algorithm associated boolean vector 
allotted number mistakes procedure abandons phase proceeds phase 
set unioned set variables seen instances mistakes 
contain relevant variable phase contain relevant variables procedure converge 
note procedure achieve mistake bound lemma 
proof lemma algorithm learning mb model making mistakes concepts size assume loss generality conservative 
heart conversion consists procedure takes instances imb model representation converts finite tuples length accepted algorithm fact concept class projection embedding closed allows conversion straightforward fashion 
describe calculated proof 
statement lemma upper bound imb model instance received form list attributes 
conversion procedure maintains list attributes seen instance far sequentially gives indices 
instance contains new attributes ones appearing previous instance procedure gives consecutive indices starting unassigned index 
attribute index keeps 
need assign total indices conversion procedure halts reporting failure 
procedure constructs tuple components 
ith component attribute current instance index attribute index corresponding attribute absent current instance 
tuple mb model algorithm prediction reported reinforcement correct incorrect relayed back 
conversion procedure fine problem may unnecessarily bind give indices variables instances algorithm predicted correctly 
long stretch instances mistake easily exceed bound number indices 
conservative 
algorithm predicts correctly trial may reset bindings state trial 
permanently give indices attributes instances mistake mistake bound bound number indices need 
final procedure algorithm consider successful run conversion finite sequence trials 
denote set attributes indices 
give index associated attributes algorithm 
partial assignment sets variables outside zero instances seen algorithm consistent function 
hypothesis concept learnable mistake bound 
required minimum value total number distinct attributes instances mistakes plus additional temporary bindings instances algorithm predicts correctly 
number mistakes bq long conversion algorithm runs variables bind algorithm succeeds 
algorithm find integer linear search necessary understood 
non decreasing value satisfying large suffices mistake bound lemma 
learning attribute efficiently models follows applying technique learnability model implies strongly attribute efficient learnability models 
technique lemma 
lemma 
suppose assignments 
set variables assignments differ fv ja contains relevant variable variable dlog queries membership oracle proof assignments 
jsj form path jsj assignment path differs bit preceding assignment treating assignments bit vectors 
binary search path find index dlog queries 
differ bit variable corresponding bit relevant theorem suppose exists polynomial algorithm learn class model mistakes queries concepts size non decreasing 
exists polynomial algorithm learn model dlog ne mistakes queries concepts size proof theorem mimics proof provide sketch 
proof sketch alg algorithm learning model making mistakes queries concepts size denote set variables algorithm run 
assume alg conservative 
new algorithm keeps set variables initially empty knows relevant 
algorithm chooses arbitrary partial assignment setting variables gamma leaving variables unassigned 
tries learn simulating alg jsj 
alg membership query assignment algorithm queries returns value alg continues simulating 
alg requests instance predict algorithm receives instance gives alg restriction domain alg prediction instance 
algorithm gives prediction value algorithm told correct tells alg correct continues simulation 
told incorrect algorithm queries membership oracle algorithm tells alg incorrect proceeds simulation 
implies algorithm procedure described lemma find new relevant variable gamma algorithm restarts simulation fvg 
alg conservative need worry instances predicted correctly simulation 
straightforward verify mistake plus query bound theorem statement 
similar proof yields theorem improves result blum 
theorem suppose exists polynomial algorithm learn class model mistakes queries concepts size non decreasing 
exists polynomial algorithm learn model dlog mistakes queries concepts size algorithms model learn concepts model resulting mistake bound replaces follows theorem class learnable models learnable strongly attribute efficiently models 
learning attribute efficiently membership queries constrained instance oracle function takes input partial assignment variables constant value equal constant function constrained instance oracle returns returns assignment theorem suppose exists polynomial algorithm learn class qu model queries concepts size suppose size constrained instance oracle simulated poly time membership oracle queries 
exists polynomial algorithm learn qu model ne queries concepts size proof alg polynomial algorithm learning satisfies conditions theorem alg particular version algorithm learning denote set variables algorithm run 
algorithm learns efficiently ne queries 


execution algorithm subset equal size 
simulate execution alg set alg terminates asks membership query 
alg terminates function return alg asks membership query assignment arbitrary extension variables 
query membership oracle find 
simulate constrained instance oracle input thought partial assignment answer return alg go back 
assignment returned 

assignments agree variables assignments membership queries described lemma discover relevant variable gamma add increase go step new simulation 
show algorithm just described continue contains relevant variables suppose relevant variable gamma start step 
assignments differ assignments 
assignments exist relevant 
partial assignments setting variables gamma respectively leaving variables unassigned 
clearly restriction functions furthermore agreed membership queries current simulation alg received answer 
guaranteed test step simulation constrained instance oracle 
alg distinguish membership query 
eventually contain exactly relevant variables point arbitrary partial assignment setting just variables gamma clearly simulation alg step simulated constrained instance oracle return gamma contain relevant variables responses queries alg step consistent algorithm terminate correct result 
bounds algorithm easily verified 
corollary class monotone boolean functions polynomially learned model qu learned strongly attribute efficiently polynomial algorithm qu 
proof constrained instance oracle class monotone boolean functions simulated follows 
inputs evaluate assignment setting gamma variables set answer return return tested assignment 
works class monotone 
apply theorem 
corollary prove efficient algorithm learning class question possible learn strongly attribute efficiently qu model depends entirely queries takes algorithm learn constant formulas 
corollary depends fact qu algorithm told number relevant variables target function 
corollary class functions 
learned attribute efficiently qu model polynomial algorithm iff polynomial algorithm learns qu model ff ff queries constant function size polynomial similarly learned strongly attribute efficiently qu polynomial algorithm iff polynomial algorithm learns qu model polynomial log queries size proof prove statement corollary 
second proved similarly 
forward direction corollary follows directly definition attribute efficient 
prove converse alg algorithm learns efficiently qu model ff queries target concept show alg efficiently simulate constrained instance oracle membership oracle 
assume just contain single function simulation trivial 
suppose inputs constrained instance oracle 
run alg membership oracle simulate membership oracle alg ff queries terminates whichever comes 
answers membership queries consistent constant function assignment queried 
lies projection closed assumption corollary alg correctly identifies constant function answer constrained instance oracle 
hand assignments queried answer constrained instance oracle 
existence attribute efficient algorithm learning follows directly theorem 
classes learned polynomial time algorithm qu model learned attribute efficiently qu model deterministic algorithms 
example consider class parity functions 
parity function boolean function takes fixed subset inputs computes parity sum mod assignments inputs 
subset empty concept identically 
example mod parity function 
learned polynomial time queries treating target function assignments vectors length binary vector space vectors added componentwise modulo dimensional vector space gf 
assignments correspond vectors natural way parity functions correspond characteristic vector indicating subset variables parity taken parity function 
value target parity function assignment inner product corresponding vectors 
learn target function including constant function linearly independent queries assignments necessary sufficient 
identically consistent functions fewer queries 
learned attribute efficiently deterministic algorithm 
note argument relies fact algorithm know number relevant variables 
randomized algorithm qu model fact strongly learns high probability 
follows fact constrained instance oracle probability success simulated follows 
partial assignment evaluate random assignment querying membership oracle return answer return constant function simulation clearly returns correct answer 
constant equal parity negation nonempty subset variables probability membership query returns value 
procedure repeated log times attain failure probability simulation 
lower bounds section prove lower bounds learning embedding closed classes various learning models discussed 
lower bounds lower bound vapnik chervonenkis dimension see embedding closed concept classes 
dimension class cdim size largest set instances shattered set shattered class labeling instances consistent concept jsj different ways label instances concepts 
lemma embedding closed concept class containing concept depends exactly relevant variables 
cdim proof construct set points shattered exactly relevant variables 
blog loss generality assume relevant variables fv 


jn assignment 
value change complemented witness relevance 
construct matrix composed subblocks defined follows ji denote block rows columns entry ji entries block match 
denote block rows columns entries columns distinct possible columns included 
matrix kr rows columns formed matrix blocks 
block jth row ith column block array ji note form set kr elements rows extend arbitrary suffixes necessary form points claim set points shattered concept class 
create concept desired set values points embed variables depends full set variables appropriately 
keep variables order letting fall ith group variables collection variables 
note jth group points value embedded function depend jth group falls groups variables fall constancy diagonal blocks 
choose embedded function desired set values point jth group points 
done due nature 
jn witness relevance doing variables create desired embedded function demonstrating class shatters set kr points desired 
theorem embedding closed class 
algorithm learning model omega gamma mistakes queries concept gamma gamma empty 
similarly algorithm learning model omega gamma mistakes queries concepts gamma gamma empty 
proof follows lemma fact model number mistakes queries learning class omega gamma cdim 
mb imb models improve constants get 
theorem embedding closed class 
algorithm learning mb model mistakes concept gamma gamma empty 
similarly algorithm learning imb model mistakes concept gamma gamma empty 
proof consider non empty member lemma vc dimension mistake bound learning class bounded vc dimension :10.1.1.130.9013
learning algorithm algorithm learning mb model mistakes concept analogous bound imb model follows trivially simple information theory argument qu algorithm learning class log jdj queries 
note empty embedding closed log jcj log gamma delta qu algorithm learning embedding closed class log gamma delta queries concept empty 
angluin 
queries concept learning 
machine learning 
angluin hellerstein karpinski 
learning read formulas queries 
technical report university california report 
ucb csd 
appear jacm 
blum 
learning boolean functions infinite attribute space 
machine learning 
blumer andrzej ehrenfeucht david haussler manfred warmuth 
occam razor 
information processing letters april 
blumer andrzej ehrenfeucht david haussler manfred warmuth 
learnability vapnik chervonenkis dimension 
journal acm 
raymond board leonard pitt 
necessity occam algorithms 
theoretical computer science 
hancock 
identifying decision trees formulas constrained instance queries 
manuscript harvard university 
david haussler 
space efficient learning algorithms 
technical report ucsc crl university california santa cruz september 
revised march 
littlestone :10.1.1.130.9013
learning quickly irrelevant attributes abound new linear threshold algorithm 
machine learning 
wolfgang maass turan 
complexity learning counterexamples membership queries 
proceedings st annual ieee symposium foundations computer science pages 

