hereditarily sequential functionals theoretische informatik fb universitat gh siegen siegen germany email informatik uni siegen de order define models simply typed functional programming languages closer operational semantics languages notions sequentiality stability introduced 
works originated definability problem pcf posed sco full abstraction problem pcf raised plo 
computation model forming class hereditarily sequential functionals game play describes interaction functional arguments computation 
approach influenced kleene kle gandy gan kahn plotkin kp berry curien bc cur cur cartwright felleisen cf :10.1.1.22.1024
characterize computable elements model different ways recursiveness requirements game definability schemata related definability pcf 
turns definitions give class computable functionals 
robust notion sequential computability higher types 
ordinary computability theory reasonable computation models equivalent leading church thesis right notion computability coincides intuitive notion computability 
contrast higher types consensus computation model captures computable functionals particular interested higher type complexity 
common notion computable functional approaches higher type complexity ck wei 
view complexity notion higher type computability needed terminating computations finite research supported part esprit bra bra objects 
particular amount information inputs oracles terminating computation finite 
considered functionals partial continuous 
algorithms sequential sense computations proceed stepwise focus time 
computed functional depend extension input particular intension describing input 
pcf typed lambda calculus constants arithmetic recursion types plo fulfills conditions long allow pcf definable inputs 
satisfactory model pcf purposes 
mention 
standard model partial continuous functionals contains functions sequential parallel violates cf 
plo 
model berry curien bc cur sequential algorithms gives concrete description interaction program input possible intensional aspects inputs violates 
example algorithms left strict right strict distinguishable sequential algorithm input output behaviour 
starting observations analysing kleene functionals kle new computation model developed concrete sequential algorithm model fulfills 
model game called game higher types 
describes interaction functional program arguments oracle input play players 
move enabled question enabled certain opposing question answer open question 
prevent intensional aspects choice move depend moves played extensional view 
sequential strategy partial function set views set possible moves 
sequential strategies form computation model extensional application sequential strategies extensional sense 
sequential strategy relate functional describing extension call functionals hereditarily sequential set functionals hsf give interpretation sequential strategies partial continuous functionals denoted 
functionals called sequential set functionals sf sequential functionals essentially serial functionals saz 
give definitions elements hsf sf computable 
recursive elements hsf sf extensions recursive sequential strategies 
correspond effectively serial functionals saz 
secondly consider class kleene recursive functionals definable kleene schemata kle hsf sf strongly related definability pcf pla 
show notions coincide 
computation model higher types fulfilling requirements robust notion computable functional 
limited space proofs sketched 
version including full proofs available technical report series informatik berichte informatik universitat gh siegen 
game higher types types type structures consider simple types fl 
types inductively clauses 
fl type types fl type 
unary types defined fl fl 
occurrence fl type identified finite sequence integers way occurrence fl fl occurrence fl right hand side arrow fl identified empty sequence 
fl occurrence identification corresponding occurrence fl identified jaj denote length sequence example type fl fl fl fl fl considered tree tree occurrences fl fl fl fl fl gamma gamma gamma gamma gamma gamma gamma gamma type unary iff occurrences identified sequences ones 
fl serves name fixed set values consider case set natural numbers 
type structure collection sets fd typeg fl ii fl set maps theta delta delta delta theta fl example examples type structures hereditarily total functionals ht ht fl ht fl set total maps ht theta delta delta delta theta ht scott ershov hierarchy partial continuous functionals flat domain fl 
occurrence denote type corresponding subtree root tree related sequel useful lambda notation defining functions type type structure oe oe purpose assume set variables fx occurence ranges denote sequence successors empty sequence leaf 
list occurrences am am addition occurrence am parameterized definition element fl stands corresponding map theta delta delta delta theta fl possibly parameters left 
depending type structure element 
leaf example fl fl fl fl fl type example fl fl fl fl corresponding notation fl fl 

game mentioned describe interaction functional type arguments play players game higher types 
play sequence alternating moves players player program opponent oracle 
moves questions denoted occurrence answers denoted set values 
choice moves restricted rules 
player play questions jaj odd player jaj 
question played question open moment 
open occurrence enabling moves enabling hidden opposing player gets answered 
answer answers open question moves question hidden opposing player 
question open played answered hidden 
play starts enabled repeatable question play finished initial question answered 
answer call result play 
finished play call sequence moves hidden player turn view play 
turn call view view 
give justifications choice rules 
rules hiding played moves avoid intensional aspects 
question asks th argument answer depend knowledge arguments evaluated especially depend order arguments evaluated 
hiding moves serves exactly request 
hiding moves respective answer causes answer counts way get 
example visible arguments evaluated get result 
contrast sequential algorithm approach strictness tester definable 
sequential strategies play describes interaction functional arguments functionals arguments represented strategies respectively 
sequential strategy partial function views allowed moves sequential strategy partial function views allowed moves 
example give example strategy example representing functional gz strategy strategy representing component function xy second constant show strategies defined strategies lower types 
fl 
views exists questions form case gammai result omitting question substituting question gammai view questions form gammai undefined 
vice versa start view get view substituting question adding question new element 
gammai gammai gammai defined 
example view gamma 
sequential strategy fl get sequential strategy gammai gammai vice versa sequential strategy get sequential strategy gammai gammai gammai sequential strategies representable tuple sequential strategies 
case write example strategy example written need sequential strategies called simply sequential strategies 
seqstr denote set sequential strategies set sequential strategies seqstr seqstr sequential strategy fl sequential strategies exists finished play strategy strategy value write undefined 
note finished play unique exists 
means delta partial function seqstr theta delta delta delta theta seqstr 
example strategies examples respectively 
play proceeds follows player view move value play 
decision trees consider representation sequential strategies 
representation form similar cartwright felleisen cf sequential algorithms bucciarelli buc kleene oracles relevant part strategy shown :10.1.1.22.1024
instance strategy play view starting 
value views irrelevant 
formally define relevant part largest closed conditions ffl dom ffl gamma gamma dom gamma gamma obviously delta delta 
relevant part visualized decision tree labeled tree labels edges stand moves labels vertices stand moves 
gamma path labeled gamma root vertex labeled example strategies examples respectively 
contain irrelevant information corresponding decision trees fact trees infinite 
instance notation means subtree form 
hereditarily sequential functionals definition hsf consider input output behaviour extension sequential strategies 
seqstr define functional case call sequential strategy functionals possess sequential strategies called hereditarily sequential 
write hsf set hereditarily sequential functionals type hsf hsf fl exactly view view 
undefined strategy mapped strategy giving final answer mapped hsf fl 
fl define hsf theta delta delta delta theta hsf 
definedness show independent choice sequential strategies means prove lemma simultaneously definition hereditarily sequential functionals 
lemma sequential strategy fl sequential strategies 
proved straightforward tedious case analysis restriction rules game 
definition sf subsection consider possible interpretation sequential strategies yielding partial continuous functionals call sequential 
formally define interpretation map delta seqstr scott ershov hierarchy partial continuous functionals natural numbers 
image delta call sf seqstr finite corresponding decision tree 
semantics finite decision tree fixed inductively 





range arbitrary seqstr set finiteg supremum exists finite holds 
words semantics map delta seqstr continuous 
note collection fsf typeg form type structure defined 
hereditarily sequential functionals sequential functionals nicely related lemma shows 
lemma seqstr implies sf sf proof note follows fact sequential strategies seqstr seqstr hereditarily sequential functional seen restriction sequential functional hereditarily sequential arguments words relation 
sf defines bijection hsf sf sf example shows reverse implication lemma hold general classes sf hsf fact different 
example seqstr fl fl fl fl decision trees iff 


note sequential 
class sf sequential functionals essentially class serial functionals defined saz 
serial functionals characterized terms kind oracle turing machine questions oracles posed form applicative terms pcf terms 
scope explore connections approach details 
extensional sequential ordering set hsf naturally ordered different orderings 
pointwise extensional ordering defined dom theorem hsf scott domain algebraic bounded complete cpo 
hereditarily sequential functionals continuous example shows hereditarily functionals general stable preserving bounded meets extensional ordering example seqstr fl fl fl fl seqstr fl fl fl decision trees hereditarily sequential functionals respectively 
note obtain showing stable note hsf isomorphic unary type 
case isomorphic sf 
second ordering closely related definition hsf ordering inherited sequential strategies 
called sequential ordering defined seqstr theorem hsf di domain 
hereditarily sequential functionals stable proof note seqstr di domain exist delta stable function seqstr theta delta delta delta theta seqstr 

computability hsf sf section give definitions elements hsf sf considered computable recursive elements hsf sf extensions recursive sequential strategies kleene recursive functionals definable kleene schemata hsf sf 
show notions define class computable elements hsf sf 
equivalence proof get characterization class sf recursive sequential functionals element hsf recursive exists recursive sequential strategy recursive sequential strategy mean sequential strategy recursive ordinary sense respect suitable coding views moves 
denote set recursive sequential functionals hsf way call element sf recursive recursive sequential strategy 
recursive sequential functionals considered way correspond effectively serial functionals defined saz cf 

kleene recursive sequential functionals element hsf sf called kleene recursive definable kleene schemata hsf sf kle 
denote set kleene recursive sequential functionals hsf sf 
schemata 
schemata define functionals hypothesis defined variables range hsf sf 
notation explained section 
successor fl constants 
identity fl composition primitive recursion ae gamma permutation permutation function application fl fl fl fl functional application fl recursion show kleene recursive hereditarily sequential functional recursive hsf hsf sf sf theorem recursive hereditarily sequential functionals closed schemata 
proof 
give recursive sequential strategies schemata depending strategies successor recursive sequential strategy fl 
constants recursive sequential strategy 
identity recursive sequential strategy fl 
function application recursive sequential strategy fl fl fl fl ends ends schemata define recursive sequential strategy assumption recursive sequential strategies respectively 
show recursion schemata handled similarly 
idea computing simulate strategy recursively argument needs evaluation partial information arguments outermost simulation information consumed reaction concerning arguments outermost simulation outcome 
visualized picture delta delta delta delta delta delta delta delta delta delta delta delta xy xxxxxx xy xy xxx xy delta delta delta delta delta delta delta delta reverse true hsf hsf sf sf theorem recursive hereditarily sequential functionals definable schemata 
proof 
define kleene recursive functional eval type fl fl fl universal hereditarily sequential functionals fl seqstr holds eval ranges eval ranges hsf suitable coding game higher types 
delta coding game higher types primitive recursive functions working codes handle views plays moves 
note primitive recursive functions type fl fl fl definable schemata 
idea simulate play indeterminate opponent finite family functionals moves list occurrences contains open opposing questions unfinished play moves 
enabled moves moves view moves moves view moves leaf moves 
moves successors set eval 
summarize proved hsf hsf sf sf analyse proofs case necessarily recursive get result corollary sequential functionals sf exactly partial continuous functionals definable partial continuous functionals starting partial functions base functions 
result corresponds characterization serial functionals saz lcf expressible serial functions stands set constants partial functions 
goal finding new model dealing sequential computations higher types model suited analyse complexity achieved remains done 
relation fully model pcf worked detail 
difficult extend definition hsf get cartesian closed category 
pcf schemata strongly related pla theorem shows get model pcf 
theorem shows compact elements model pcf definable 
theorem milner mil model isomorphic order extensional fully model pcf 
give new view model deeper insights possible help sequential strategies 
interested structure domains hsf find order theoretical conditions characterizing domains hsf conditions concrete domains kp example 
manageable notion sequential neighbourhood analogy stable neighbourhoods zha 
stated computation model base study complexity higher types 
bc berry 
curien 
sequential algorithms concrete data structures 
theoretical computer science 
bc berry 
curien 
theory practice sequential algorithms kernel applicative language cds 
nivat reynolds editors algebraic methods semantics pp 
cambridge university press 
buc antonio bucciarelli 
sequential models pcf contributions approach full abstraction 
phd thesis universit di pisa genova udine td 
cf cartwright felleisen :10.1.1.22.1024
observable sequentiality full abstraction 
th acm symposium principles programming languages pp 
acm press 
ck cook 
characterizations basic feasible functionals finite type 
buss scott editors feasible mathematics mathematical sciences institute workshop pages birkhauser 
cur 
curien 
categorical combinators 
information computation 
cur 
curien 
observable algorithms concrete data structures 
th ieee symposium logic computer science pp 
ieee computer society press 
ers yu 
ershov 
theorie der ii 
zeitschrift fur mathematische logik und grundlagen der mathematik 
gan gandy 
computable functionals finite type crossley editor sets models recursion theory logic colloquium pp 
north holland 
kle kleene 
recursive functionals quantifiers finite types transactions ams 
kle kleene 
recursive functionals quantifiers finite types revisited fenstad gandy sacks editors generalized recursion theory ii pp 
north holland 
kp kahn plotkin 
structures de donn ees 
rapport 
mil milner 
fully models typed calculi 
theoretical computer science 
pla platek 
foundations recursion theory 
phd thesis stanford university 
plo plotkin 
lcf considered programming language 
theoretical computer science 
saz yu 
sazonov 
expressibility functions scott lcf language 
algebra logic english translation 
sco scott 
continuous lattices 
lawvere editor toposes algebraic geometry logic pp 
springer 
wei weihrauch 
type recursion theory 
theoretical computer science 
zha zhang 
logic domains 
birkhauser 

