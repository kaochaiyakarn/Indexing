framework practical automated black box testing component software stephen edwards virginia tech dept computer science hall blacksburg va usa edwards cs vt edu outlines general strategy automated black box testing software components includes automatic generation component test drivers automatic generation black box test data automatic semi automatic generation component wrappers serve test oracles 
research progress unifies threads testing research preliminary indicates practical levels testing automation possible 
keywords test drivers test oracles self checking software test adequacy integration testing modular construction built test preprint article published june issue software testing verification reliability vol 

copyright copyright owner specified journal 
visit journal website www interscience wiley com 
move component software development offers promises improved productivity quality highlights need effective methods testing reusable software parts 
components independently developed commercially purchased underscore need detect errors system integration time 
components increase complexity need urgent 
adopting systematic approach testing components automating approach possible solution 
outlines general strategy automated black box testing software components 
strategy involves pronged attack covering automatic generation component test drivers automatic generation test data automatic semi automatic generation wrappers serving role test oracles 
combination thrusts build complete component testing strategy entirely automated 
unifies threads testing research coherent 
interesting tough research questions remain open preliminary results suggest practical levels automation achievable components include formal behavioral descriptions 
section describes assumptions components necessary approach presents example component specification satisfying assumptions 
section discusses critical piece strategy pre postcondition checking wrappers component test 
building foundation section lays vision automated testing framework 
section briefly discusses related followed open research issues directions section 
example component way list strategy proposed builds key requirement component clear description intended behavior 
description important automating tasks generating test data checking test results 
initial requirement research described component formally specified interface described modelbased specification language 
resolve selected specification language research model specification languages applicable 
choice specification language pragmatic reasons researchers involved familiar language provides natural collaboration path fielding tools 
researchers ohio state university west virginia university collaborating software composition workbench resolve technology ideal environment evaluate apply testing tools described 
initial research requirement components formally specified interfaces tools making approach provide graceful fallback positions semiformal informal component behavioral descriptions available 
informal descriptions require human intervention process easy way automatically extract behavioral requirements 
result strategy applied formal behavioral descriptions cost reduced automation greater programmer intervention 
general software component may simple individual class module sophisticated java bean com object 
interests simplicity examples terms object oriented classes techniques easily generalized larger grained components 
resolve specification way list ground discussion formally specified components presents resolve specification way list component originally described sitaraman 
generic component parameterized type contain 
way list ordered sequence items type 
may move forward sequence accessing individual elements turn jump sequence 
zweben presents similar component supports bi directional movement 
way list may implemented singly linked chain dynamically allocated nodes dynamically allocated array building components stack queue vec vector alternatives 
sketches equivalent base class template 
mathematical model way list shown pair mathematical strings finite sequences 
explicit notion current position cursor current location implicit fact string partitioned left right segments 
intuitively items left current location closer front sequence right front rear 
preconditions clauses postconditions clauses operation supported component described terms mathematical model 
postconditions hash symbol refer incoming value parameter outgoing value 
central focus built test capabilities cornerstone automated testing framework micro architecture providing built test bit support software components 
architecture builds current research systematically detecting interface violations component software 
essence software component provides simple hook interface run time overhead component sophisticated bit capabilities 
illustrates idea 
sophisticated decorator components wrappers provide number self testing features underlying component 
innovative properties strategy bit wrappers completely transparent client component code 
bit wrappers inserted removed changing client code declaration need modified 
capability require preprocessor current languages 
bit support removed run time cost underlying component 
internal external assertions component behavior checked 
precondition postcondition invariant checks written terms component mathematical model directly terms component internal representation structure 
checking code completely separated underlying component 
violations detected occur propagate components source violation reported specific method operation responsible 
routine aspects bit wrappers automatically generated 
interface way list bit access client interface component component provides hooks bit infrastructure representation layer check internal consistency convert model approach works formally specified components require formal specification 
approach provides full observability component internal state breaking encapsulation clients 
actions taken response detected violations separated bit wrapper code 
illustrates component ply bit wrapper 
inner layer wrapper responsible directly safely accessing component internals performing internal consistency checks converting internal state information program manipulable model component state 
outer layer responsible model check clients obligations underlying component check component maintains invariant properties advertises results operation extent desired self testing purposes 
client code accesses component just 
outlines class declaration bit wrapper context way list example 
client component representation layer layer wrapper surrounds component implementing necessary testing functions layer check client obligations operation postconditions external invariants way list bit wrapper describing implementation wrapper scope article full details appear 
provides pseudocode checking process wrapper outlining operation 
issues critical design bit wrapper interference overhead 
sure wrapper interfere behavior underlying component component inherent behavior affect results tests 
bit wrapper guarantees modifications wrapped object implementing bit wrapper method performs virtually actions copy object state 
leads second issue overhead imposed bit wrapper 
goals bit wrappers led design encourages comprehensive expensive checks easily enabled disabled simple declaration changes 
expectation bit wrappers functional testing integration removed non functional tests time space performance example delivery 
bit strategy designed provide maximal support unit testing debugging integration testing 
component bit wrapper unit testing thorough testing achieved ad hoc strategies developers employ 
test case executed large number internal consistency checks performed potential revealing errors 
checks automatically performed operations executed component test case effect multiplying tester ability detect errors 
errors full visibility internal state provided bit strategy helpful debugging 
particular strategy provides programmer additional capabilities input output internal state information ability modify internal state information debugging purposes 
capabilities require additional design coding time developer inclusion original bit hooks underlying component 
integration testing bit wrappers provide firewalls components incremental integration 
new units added system wrappers detect unforeseen interactions 
strategy supports bottom top hybrid incremental integration strategies 
vision automated testing framework bit infrastructure provides natural mechanism supporting semi fully automatic testing 
simply put framework described rests legs automatic semi automatic generation component bit wrapper 
automatic generation component test driver 
automatic semi automatic generation test cases component 
generation strategies rely information complete behavioral description component interface contract 
combining generation strategies possible create test driver test suite bit wrapper directly component specification 
bit wrapper provides comprehensive checks postconditions exported operations effect acting test oracle combination produce highly automated testing debugging capability outlined 
test suite generating bit wrappers generator designed implemented process resolve style component specifications template interfaces generate bit wrappers 
underlying principles creating wrappers independent particular specification technique implementation language readily extended languages 
external interface bit wrapper identical corresponding base component 
semantically differ behave pre postcondition operation violated 
particular regular component guarantees operation invoked conditions violating precondition bit wrapper guarantees perform specific notification action 
bit wrapper checks precondition violations called way checking wrapper 
similarly way checking wrapper guarantees 
carry precondition notification action precondition hold 
establish postcondition true operation completion 
carry postcondition notification action postcondition hold 
test driver component representation layer layer general testing setup test output defect report way way checking wrappers extremely useful 
way wrappers correspond traditional notion defensive shell protects component errant clients 
way wrappers hand akin self checking components confirm spotting erroneous client behavior 
constructing bit wrappers straightforward process raises question automatically generate pre postcondition checks 
components checking precondition straightforward automated 
model conversion approach described precondition postcondition assertions converted code simple transliteration process 
example complete pre postcondition checks automatically generated way list specification 
assertions non trivial 
example code checking assertions containing quantifiers generated mechanically 
provide greater support automated bit wrapper construction face difficulties possibilities explored semi automatic generation dynamic assertion verification components implementations 
semi automatic generation possible automatically generate checking code preconditions clauses postconditions 
possible approach solving problem automatically generate appropriate allow human provide code checks automated 
experience prototype wrapper generator indicates simple process separate human contributed checks infrastructure code necessary support bit wrapper 
person creating checks write client level terms mathematical model component state terms implementation component test 
dynamic assertion verification alternative uses current generation verification tools 
current verification tools trouble complex quantified assertions arise static formal verification simpler assertions arise run time bit wrapper variables specific values amenable existing proof tools 
possible automatically generate complete bit wrapper relies verification proof engine assertion checking specific parameter values run time approach termed dynamic verification 
components implementations implementation component inefficient exists possible automatically generate bit wrapper executes unit test implementation uses results implementation judge correctness unit test 
form testing called back back testing larger scale purpose conformance compliance testing 
wishes ensure candidate implementation meets published api standard example trusted implementation judge assessing candidate implementation standard test suite 
effect approach small automated fashion bit wrapper 
approach invites intriguing enhancements possible recover internal errors wrapper stands client implementations se pass implementation results unit test fails 
bit infrastructure easily extended allow data produced implementation force recovery unit test 
leads defensive wrapper close 
generating test drivers compared difficulties involved generating bit wrappers generating test drivers simpler problem 
research described interpreter model test drivers test driver viewed command interpreter reads test cases translates actions component test 
point view straightforward parse component interface definition identify operations construct interpreter 
filtering invalid operation requests handled bit wrapper component test run time checking produced output 
major weaknesses approach effectively handling components rely inversion control substantial human interaction component 
test driver generator strategy designed currently implemented 
resolve serves underlying implementation language components preliminary subset adopted test case definition language 
shows sample test case way list component 
test case test driver name unit test surrounding concrete class implementing specification instantiated contain integer elements 
architecture interpreter test driver uses envelope letter paradigm handling internal values uses exemplar dispatching strategy handling operations user defined objects 
result core interpreter engine directly refer component test methods 
means support unit test added requiring changes recompilation interpreter engine 
driver generator creates glue source file compiled linked existing interpreter object files produces custom driver component test 
preliminary experience approach indicates interpreter provides significant direct compilation test cases large test sets 
generating test data number strategies generating black box test data component behavioral description 
generation approach taken flowgraphs described thoroughly 
adapted black box test adequacy criteria described zweben black box test adequacy describes construct flow graph behavioral specification 
directed graph single entry representing object creation single exit representing object destruction 
object lifetime composed legal sequence operations applied object represented possibly cyclic path graph 
way list test case flow graph possible testing strategies evident 
zweben describe natural analogues white box control data flow testing strategies adapted black box flow graphs including node coverage branch coverage definition coverage coverage du path coverage length path coverage 
branches graph represent different choices method calls sequence logical control flow decisions easier generate test cases exercise branches 
black box test generation strategies approach faces open issues correctly efficiently decide edges included graph address problem satisfiability choosing test data values individual test cases 
perfect solutions problems computable practical heuristics provide approximate solutions available 
combined bit wrapper surrounding component test invalid test cases automatically screened removed allowing overly optimistic heuristics practice 
internal checks performed bit wrappers possibility revealing defects directly observable output produced operations 
property lead automated testing approach greater defect revealing capability traditional black box strategies 
preliminary evaluation effectiveness approach provided encouraging evidence feasibility 
experiment conducted resolve specified components stack queue way list partial map defects seeded mutation approach 
faults injected expression selective mutation 
version mutation testing uses mutation operators abs aor lcr ror significantly reduces number mutants generated experimentally shown achieve nearly complete mutation coverage 
equivalent mutants identified hand removed collection ensure mutants study guaranteed differ original legitimate object lifetime manner observable parameter values returned component methods 
test sets adequacy criteria evaluation 
results experiment indicate black box analog uses criteria extremely effective identifying faults detecting faults seeded components faults seeded com component experiment partial map 
experiment hand written bit wrappers separately tabulated number defects detectable observing component output versus detected internal checks performed bit wrapper 
provides graphical summary percentage mutants killed adequacy criterion component increased detection rate provided bit wrappers 
way checking bit wrappers provided improvement defect revealing capability case ranging bit wrapper output stack queue way list partial map stack queue way list partial map stack queue way list partial map defs nodes uses defect detection rates mutants killed 
greatest improvement seen weakest test sets example definitions test set queue component revealed defects examining test output rate increased bit wrapper 
test sets achieved detection seeded defects required bit wrappers defects detected component output 
magnification effect bit wrappers provide revealing defects interesting explore 
mutants study observably different original object lifetime seeded defect uncovered solely observing output test case 
test cases cause defect executed necessarily produce observably different behavior 
example suppose component described section implemented singly linked chain dynamically allocated nodes stored integer recording length list 
number seeded defects component lead internal corruption encapsulated data object method call observed subsequent method calls 
stored length may incorrect chain nodes may broken pointer referring node chain may invalid 
unfortunately test case causes defect executed fails follow proper combination additional method calls may fail produce observable difference output 
bit wrappers experiment performed consistency checks internal state wrapped component corruption detected soon occurred 
additional defects detected bit wrappers detected observable output experiment nature 
explains magnification effect greatest testing weakest test suites sophisticated cover combinations methods individual test cases reveal defect bit wrapper hand identifies corruption soon occurs simpler test suites 
preliminary results provided experiment promising difficult generalize 
complete presentation experiment results threats validity generality appears 
results experience generator indicate potential practical automation testing strategy 
related bit wrappers built philosophy best phrased bertrand meyer design contract preconditions operations responsibility callers postconditions obligations implementers implementers may assume preconditions hold time invocation 
proposed different allocations responsibilities 
key difference approach advocated responsibility checking obligations met separated client implementer 
addition decoupling checking code client component opens opportunity performing checks client level terms component level implementation details 
results highly reusable wrappers easily added removed system 
discussed idea run time assertion checking 
annotation pre processor described rosenblum example 
approaches typically distinguish view component state perceived clients concrete implementation details seen implementers 
addition approaches rarely integrated strategy automated testing 
eiffel provides known approach pre postcondition checking runtime 
complete discussion differences bit wrappers eiffel assertion checking provided eiffel approach combined systematic approach producing test drivers test data 
flowgraph test data generation research summarized section related large body prior including astoot 
complete discussion prior area appears 
published approaches specification testing object procedural software components influenced 
research described differs way incorporates run time interface violation checking strategy generating test data design unit integration test drivers way separates testing infrastructure code completely units test system 
briefly sketches general strategy automated black box testing software components 
strategy combining techniques automatic generation component test drivers automatic generation test data automatic semi automatic generation wrappers serving role test oracles 
research progress unifies threads testing research coherent 
difficult research questions remain open date indicates practical levels testing automation possible 
primary goals include applying technique larger scale realistic examples 
evaluating costs benefits testing approach relative existing testing techniques traditional manual approaches alternative automated approaches formal behavioral specifications 
evaluating effectiveness test data generation approach comprehensively 
empirically evaluating alternative heuristics generating flow graphs specifications selecting specific data values generated test cases 
experimentally assessing overhead incurred bit wrappers 
exploring practicality including nonfunctional properties time space utilization suitable specification framework extension approach 
exploring limits semi automatic generation postcondition checking code bit wrappers 
assessing feasibility dynamic verification postconditions alternative implementation strategy bit wrappers 
completing evaluating test driver generator 
developing evaluating automation tool efforts 
ideas feedback provided members reusable software research group ohio state university west virginia university helped shape direct research 
addition graduates students contributed exploratory described vinay nikhil cai gupta bob hall mandar joshi hunter jason kent swartz wei wang 
contribution gratefully acknowledged 

beizer black box testing techniques functional testing software systems 
wiley new york 

bennett sitaraman validation results testing data types method automation 
proc 
st int conf 
software quality dayton ohio oct 

coplien jo 
advanced programming styles idioms 
addison wesley reading ma 

frankl pg 
astoot approach testing object oriented programs 
acm trans 
software engineering methodology 

edwards sitaraman weide bw hollingsworth framework detecting interface violations component software 
proc 
th int conf 
software reuse ieee cs press los alamitos ca pp 


edwards sh 
black box testing flowgraphs experimental assessment effectiveness automation potential 
software testing verification reliability dec pp 


gannon jd pr hamlet data abstraction implementation specification testing 
acm trans 
programming languages systems july 

hoffman test graphs automated testing classes 
object oriented programming nov dec 

king kn offutt fortran language system mutation software testing 
software practice experience jul 

liskov guttag abstraction specification program development 
mcgraw hill new york 

meyer object oriented software construction nd edition 
prentice hall ptr upper saddle river new jersey 

offutt lee rothermel rh experimental determination sufficient mutant operators 
acm trans 
software engineering methodology april 

applying conventional unit testing techniques data type operations 
int software eng 
knowledge eng mar 

perry de 
inscape environment 
proc 
th intl 
conf 
software eng 
ieee cs press los alamitos ca pp 


rosenblum ds 
practical approach programming assertions 
ieee trans 
software eng jan 

systematic generator detecting interface violations component software 
report dept computer science elec 
engineering west virginia univ wv 

sitaraman welch lr harms de 
specification reusable software components 
int software eng 
knowledge eng 

sitaraman weide bw eds 
component software engineering resolve 
acm sigsoft software notes 

wang musser dr dynamic verification generic algorithms 
ieee trans 
software eng may 

wing jm 
specifier formal methods 
ieee computer sept 

zhu hall pav may 
software unit test coverage adequacy 
acm computing surveys dec 

zweben systematic testing data abstractions software specifications 
software testing verification reliability 

