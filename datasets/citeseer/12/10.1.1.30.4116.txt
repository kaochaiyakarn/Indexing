generic programming designing data structure polyhedral surfaces lutz kettner inst 
theoretical computer science eth zurich ch zurich switzerland appeared computational geometry theory applications 
software design solutions combinatorial data structures polyhedral surfaces planar maps tailored program libraries computational geometry 
design issues considered flexibility time space efficiency ease 
focus topological aspects polyhedral surfaces evaluate edge representations respect design goals 
design polyhedral surfaces halfedge data structure developed generic programming paradigm known standard template library stl 
connections shown planar maps face structures 
key words library design generic programming combinatorial data structure polyhedral surface halfedge data structure combinatorial structures planar maps fundamental computational geometry 
order useful practice solid library computational geometry provide generic flexible solutions fundamental cornerstones 
report revised solution proposed computational geometry algorithms library cgal joint effort academic institutes europe 
design criteria flexibility time space efficiency 
flexibility obvious goal library 
part research carried author freie universit berlin scholarship mathematik dfg 
support swiss federal office education science projects esprit iv ltr cgal acknowledged 
www cs uu nl cgal preprint submitted elsevier preprint february ease considered design easy learn accessible non experts 
efficiency needed qualify industrial applications 
focus edge representations dimensional polyhedral surfaces illustrate connections planar maps face structures maintain polygons holes facets 
concentrate topological aspects derive solutions applicable data structures 
particular want vary internal storage organization kind incidences stored 
additional user data integrated easily 
top level interface ensures ease combinatorial integrity 
hand protected access internal representation granted 
part define polyhedral surfaces review known edge boundary representations 
second part short modern design principles available known generic programming paradigm example stl standard template library 
derive design goals evaluate previous 
continue overview design separation geometry topology layered structure responsibilities layers example programs realization templates 
conclude design technique protected access internal representation new concept circulators 
main advantages design flexibility completely resolved compile time runtime overhead due flexibility 
second memory allocated features 
example polyhedron information facets allocate facet nodes facet pointers 
third benefits sacrificed ease data structure 
just contrary generic programming paradigm achieve flexibility enabled encapsulate flexibility 
example top level interface data structure looks despite representation chosen underneath 
completeness include realization design 
note understood developer user 
polyhedral surfaces boundary representation polyhedral surface consists set vertices set edges set facets incidence relation 
introductions 
living example see 
fig 

orientable manifold vertices 
homeomorphic sphere 
split facet join facet join vertex split vertex fig 

euler operator examples polyhedral surfaces 
types boundary representations manifold non manifold surfaces 
point manifold surface exists neighborhood homeomorphic open disc 
non manifold example tetrahedra glued single vertex common edge 
distinction orientable non orientable manifold surfaces 
going details surface orientable consistent orientation assigned facet edge incident facets opposite orientations edge 
example non orientable manifold klein bottle 
consider orientable manifolds data structure 
natural operations manifolds closed euler operations shown 
principal characteristic euler operation invariance euler poincar formula 
sufficiency proof specific set euler operations 
note manifolds closed boolean operations 
class representable surfaces restricted kind geometry associated vertices edges facets 
vertices map points far polyhedra concerned edges typically straight line segments endpoints facets simple planar polygons 
classes allow curved surfaces facets vertices projective space model unbounded facets 
currently provided cgal 
definition polyhedral surfaces steinitz 
definition combinatorial nature reasoning data structure convenient example facet appear sides edge 
leads directly integrity definition related test function polyhedral surface data structure 
definition captures class representable surfaces informally introduced far may require different combinatorial representation 
example facet incident sides edge needs split facets 
definition structural complex union disjoint sets incidence relation 
call vertices edges facets structural complex 
incidence relation symmetric 
elements set incident 
incident incident incident definition polyhedral complex structural complex additional conditions 
edge incident vertices 
edge incident facets 
incident pair exactly edges incident 
vertex facet incident element 
neighborhood vertex edges facets incident vertex 
restrict incidence relation neighborhood condition facet incident exactly edges condition edge incident exactly facets 
neighborhood decomposes disjoint cycles cycle alternating sequence edges facets 
polyhedral complex manifold neighborhood vertex decomposes single cycle 
definition polyhedral complex symmetric vertices facets 
symmetrically defined neighborhood facet decomposes cycles incident edges vertices 
assuming neighborhood facet single cycle geometrically boundary facet single connected component facet holes define polyhedral complex oriented cycle facet oriented edge cycles incident facets oriented opposite directions 
polyhedral complex orientable exists orientation 
definition boundary representation polyhedron orientable polyhedral complex neighborhood vertex facet single cycle mapping mapping extends edges mapping edge open straight line segment endpoints 
additional conditions hold 
image neighborhood facet boundary simple planar polygon 
mapping extends facets open region polygons 
elements images pairwise disjoint 
surface defined boundary representation orientable manifold 
useful properties example neighborhoods vertices edge facets common edge vertex graphs connected connected component surface facet edges boundary 
smallest possible configuration tetrahedron 
closed surfaces considered far extended surfaces boundaries 
need relax condition allow edges incident facet called border edges 
induces modification definition neighborhood vertex decomposes single cycle collection open paths going border edge border edge 
surface longer closed orientation defines solid side surface 
minimal configuration surfaces boundaries triangle 
data structures describe polyhedra surfaces boundaries 
border edges simply marked missing facet side null pointer 
suitable data structure definition polyhedral surfaces successfully project contour edge polyhedron visualization take advantage strict properties imposed definitions example definition contour edges orientable manifold property lack holes facets simplifies algorithms 
initial implementation data structure easy compute silhouette polyhedral surface 
extension data structure design advantages sections 
visualization polyhedron usually represented called indexed facet set sequence points followed sequence facets 
facet list indices referring sequence points 
shared edges derived implicitly points shared facets 
examples internal representation file formats vrml open inventor object file format 
formats strict purposes represent non orientable manifolds may violate condition polyhedral complex 
represent holes facets 
pcw fig 

winged edge 
data structures boundary representations survey edge data structures addresses sufficiency modeling topology efficiency primitive operations storage costs 
representative example chosen traversal vertex edge edge counterclockwise direction 
winged edge data structure 
winged edge data structure stores oriented edge vertices faces incident edges share faces vertices pcw called wings see 
edge oriented source vertex target vertex 
face left oriented edge surface seen outside 
data structure able model orientable manifolds 
sufficient curved surface environments loops multi edges allowed 
basic operations include traversal vertex facet 
high level operations maintaining integrity euler operators 
edge counterclockwise vertex edge equal pcw 
variants possible vertex facet pointers omitted losing traversal capabilities previously visited edge known 
loops multi edges allowed edge pointers remain 
traversal vertex facet longer uniquely defined 
winged edge data structure wings omitted called doubly connected edge list name commonly halfedge data structure 
order avoid confusion name turned ambiguous 
fact name misleading denoting possible variants single linking 
opposite ccw cw facet vertex halfedge fig 

fe structure 
ccw cw facet vertex halfedge opposite fig 

structure 
symmetric parts winged edge correspond possible orientations edge 
inefficient case distinction traversal computation results fact pointer edge encode orientation currently 
extension winged edge maintains additional bit edge pointer code orientation lead cumbersome storage layouts function interfaces 
halfedge data structure 
orientation problem solved winged edge data structure splitting edge symmetric records called adding mutual links 
ways splitting edge edge split facets oriented belong facets incident edge see split belonging vertices incident edge see 
variants dual considering usual notion duality graphs vertex facet dual dual edge edge incident facets endpoints 
splitting variants halfedge contains pointer incident vertex incident facet opposite halfedge 
matter convention source target vertex chosen stored halfedge facet left right stored 
source vertex facet right chosen 
fe structure additionally stores pointer clockwise halfedge optionally pointer previous counterclockwise halfedge facet 
biased traversals incident facet 
dual structure vertex facet vertex facet fig 

quad edge data structure 
depicted 
optional previous pointer refer counterclockwise clockwise incident vertex 
traversal operation directly accessible single pointer access available opposite halfedge 
example halfedge incident source vertex fe structure opposite 
different conventions independent 
convention defines halfedge order facet clockwise halfedge order vertex counterclockwise vice versa 
halfedge data structure able model orientable manifolds 
sufficient modeling topology presence loops multi edges occur curved surface environments 
high level operations maintaining integrity euler operators 
solid modeling system halfedge data structure uses additional edge record opposite access efficient 
minimal rendering tool mrt uses halfedge data structure polygonal surfaces 
quad edge data structure 
similar idea edge split quad edges obtain quad edge data structure 
provides fully symmetric view primal dual graph seen 
opposite pointers bit counter address slot edge record quad edges 
data structure able model non orientable manifolds additional bit denoting flipped status edge 
quad edge data structure formally defined edge algebra operations rot flip 
quad edge represented triple record quad edges incident current edge 
operations implemented calculus modulus modulus follows table comparison edge data structures 
winged edge half edge quad edge modeling space orientable manifold manifold operations euler operator splice duality adaptor compile time rot runtime holes facets basic traversal case distinction direct access mod operation min size edge ptr ptr ptr bits max size edge ptr ptr ptr bits rot flip flip rot different orientations edge considered orientations vertex vertex orientations dual edge facet facet 
rot operator rotates edge degrees oscillating primal dual view structure 
non orientable manifolds edge additionally seen surface encoded bit 
flip operation changes view vice versa 
operation gives quad edge counterclockwise order source vertex origin quad edge clockwise order equal 
values simply stored record edge pointers times bits 
operations simplify considerably orientable manifolds 
simplified dual graph needed 
result winged edge data structure enriched bit encode orientation 
single high level operation modifies quad edge data structure splice operation 
dual 
usual euler operators implemented terms splice 
quad edge data structure provides unified view primal dual graph 
implies vertices facets distinguished strong type checking compile time 
definition duality implies furthermore facets single connected boundary 
holes facets allowed 
strong type checking desired splice operation needed twice primal view dual view 
splice provided halfedge data structure 
incident vertex opposite halfedge halfedge incident facet previous halfedge halfedge fig 

halfedge data structure 
comparison edge representations 
main differences edge representations captured table 
differences basic traversal capabilities negligible especially considering modern microprocessor architectures conditional branching slower computing order magnitude 
storage size requirements quite similar 
design focus flexibility trading runtime storage costs 
interested minimal maximal configurations halfedge data structure space efficiency quad edge data structure 
issue preference strong type checking compile time 
polyhedral surfaces different information stored vertices facets points plane equations 
treated duals strongly typed geometry kernel cgal provides different types represented differently 
additional information color destroy typeless symmetry duality assumed quad edges 
holes facets modeled winged edge halfedge data structure implication vertex edge graph disconnected connected surfaces 
furthermore dual facet edge graph manifold holes facets 
neglect non orientable manifolds example threedimensional surface solid physical object orientable 
respect library design refer general non manifold data structure model non orientable manifolds 
chosen halfedge data structure comparable fe structure 
conventions depicted 
opposite prev pointers 
incident vertex target vertex oriented halfedge 
incident facet left halfedge implies counterclockwise ordering facet clockwise ordering vertex seen outside 
complies right hand rule facing normals plane equations facets 
generic object oriented programming major design issues considered polyhedral surfaces flexibility time efficiency space efficiency ease 
realize generic flexible designs basically paradigms available object oriented programming generic programming 
available object oriented programming inheritance base classes virtual member functions generic programming class templates function templates 
objectoriented programming known smalltalk eiffel java generic programming ada generic java name examples 
stick notion choice cgal 
flexibility object oriented programming paradigm achieved base class defines interface derived classes implement interface 
generic functionality programmed terms base class user select derived classes base class required 
classes may determined runtime generic functionality implemented knowing derived classes 
called virtual member functions runtime type information support paradigm 
base class usually pure virtual base class 
advantages explicit definition interface runtime flexibility 
main disadvantages paradigm provide strong type checking compile time dynamic casts necessary achieve flexibility 
paradigm enforces tight coupling inheritance relationship requires additional memory object called virtual function table pointer adds call virtual member function indirection virtual function table 
particular interest considering runtime performance virtual member functions usually inline subject code optimization calling function modern microprocessor architectures optimize runtime runtime predictions difficult mechanisms fail virtual member functions 
effects negligible larger functions small functions suffer loss runtime orders magnitude 
significant examples access point coordi notable exceptions compiler deduce virtual member function actual member function called allows compiler optimize call 
keyword final introduced java support intention 
techniques realized compilers far succeed cases arguable typical uses cgal optimized 
distributing library precompiled components hinder optimization done link time 
arithmetic low dimensional geometric objects see example case study traversals combinatorial structures 
vertices edges facets polyhedra anticipated small objects simple member functions 
space runtime overhead introduced virtual member functions negligible 
generic programming paradigm features known class templates function templates 
templates incompletely specified components types left open represented formal placeholders template arguments 
compiler generates separate translation component actual types replacing formal placeholders template 
process called template instantiation 
actual types function template implicitly types function arguments instantiation time 
example swap function exchanges value variables arbitrary types 
actual types class template explicitly provided programmer 
example generic list class arbitrary item types 
definitions enable list int actual type int explicitly list integers swap integer variables expression swap actual type int implicitly 
template class 
class list placeholder represents item type symbolically 
template class 
void swap tmp tmp example swap function illustrates template usually requires certain properties template arguments variables type assignable 
actual type template instantiation comply assumptions order obtain correct template instantiation 
distinguish syntactical requirements assignment operator needed example semantical requirements operator copy value 
syntactical requirements fulfilled compilation simply fails 
semantical requirements checkable compile time 
useful connect specific semantical requirement artificial newly introduced syntactical requirement tag similar iterator tags 
technique allows decisions compile time actual type tags 
set requirements needed obtain correct instantiation member function class template usually fraction requirements template arguments class template 
subset member functions instantiation class template sufficient actual types fulfill requirements needed subset member functions 
possible long compiler explicitly forced compiler allowed instantiate member functions possible compilation errors due missing functionality actual types occur 
enables design class templates optional functionality actual types template instantiation fulfill additional requirements 
example optional previous pointer halfedge halfedge data structure 
user provides actual halfedge type template argument halfedge data structure class template 
halfedge provides previous pointer bidirectional access facet vertex available data structure previous pointer provided access unidirectional 
example illustrating generic programming standard template library 
generality flexibility achieved carefully chosen set concepts concept defined set requirements 
swap function example appropriate concept named assignable includes requirement assignment operator 
actual type fulfills requirements concept model concept 
example int model concept assignable 
algorithmic abstraction key goal generic programming 
aspect reduce interface data types algorithm set simple general concepts 
iterator concept abstraction pointers 
iterators serve purposes refer item traverse sequence items stored data structure known container class stl 
different categories defined iterators input output forward bidirectional iterators different possibilities accessing items container class 
usual pointer referring array model random access iterator 
generic algorithms written particular container class stl iterators 
example sequences items specified iterators forming range 
notion half open interval denotes sequence iterators obtained starting advancing reached include 
container class supposed provide local type model iterator member functions returns start iterator sequence returns iterator referring past position sequence 
example generic contains function written model input iterator 
returns true iff value contained values range 
template class inputiterator class 
bool contains inputiterator inputiterator const value value return advantages generic programming paradigm strong type checking compile time template instantiation need extra storage additional indirections function calls full support inline member functions code optimization compile time 
specific disadvantage generic programming lack notation declare syntactical requirements template argument equivalent virtual base class object oriented programming paradigm 
syntactical requirements scattered implementation template 
concise collection requirements left program documentation 
general flexibility resolved compile time gives advantages mentioned seen disadvantage runtime flexibility needed 
generic data structures algorithms parameterized base class object oriented programming achieve runtime flexibility 
applied mainly generic programming paradigm achieve flexibility efficiency cgal 
compliance stl important promote re existing generic algorithms container classes important unify look feel design cgal standard 
cgal easy learn easy familiar stl 
places object oriented programming paradigm example protected access internal representation polyhedral surface see section 
design goals polyhedral surfaces polyhedron viewed container class managing vertices facets polyhedral surface maintaining combinatorial structure 
design issues taken account design actual storage organization vertices edges facets influences space runtime efficiency 
doubly connected list representation allows random insertion removal providing bidirectional iterators enumerate items 
space efficient storage uses stl vector allows efficient removal items vector provides random access iterators 
variants possible managing chunks memory simple allocation heap iterators 
necessary incidence relations depend application 
order keep halfedge data structure connected need opposite pointer halfedge 
incidences optional 
example prev pointer simulated search vertex facet opposite direction 
triangulations simple expression prev 
assuming constant degree vertices constant number edges facets constant time operation 
information needs attached vertices facets storage allocated referencing pointers halfedge omitted 
limit data structure reduces undirected graph structure 
easy user add additional information different items color facets 
geometry attached technique 
redefining item hinder re items example adding color facets imply new vertex type declared 
data structure provide easy high level interface 
interface protect internal combinatorial integrity data structure definition 
advanced algorithms concerned efficiency file scanner allowed access internal structure controlled manner 
management connected components containment relations inner outer boundaries facets nesting relationships shells seen independent functionality added separately example layer flexibility 
edge data structures discussed section natural notion edges vertex edges facet 
costly provide iterators kind circular sequences notion ranges past value extend naturally 
propose concept similar iterators call kind structure 
stl containers base interfaces iterators 
polyhedral surfaces order items stored polyhedron defined perspective user euler operations 
fall back concept handles item denoting part iterators ignore traversal capabilities 
particular model iterator model handle 
handle known trivial iterator 
concentrate combinatorial aspects polyhedral surface 
additional issues appear considering geometry example flexibility point type geometric predicates 
technique explored variation traits classes known standard library see cgal 
previous design major revision design described 
previous design available cgal release 
original design user provides space incidence information vertices facets terms void pointers 
halfedge data structure uses type casts provide correct type safe pointers polyhedron converts pointers iterators handles 
main drawback tricky nested implementation users extend vertices facets conveniently incidences 
new incidences captured process type casting 
revised design layers design share type informations 
vertices facets correct handle types provide space various incidences decoupled vertex type hard code actual type related halfedge type 
internally new design saves implementation layer needed type casting 
library efficient datatypes algorithms leda provides rich body algorithms data types 
leda includes example number types exact arithmetic dictionaries priority queues graph algorithms dimensional geometry 
design homogeneous easy 
leda notion iterators generic flexible framework incompatible approach taken stl 
extensions leda compliant stl fact replaces stl 
leda contains data structure specifically tailored dimensional polyhedra provides general data structure graphs planar maps derived graph data structure 
additional information attached node arrays edge arrays parameterized graph 
parameterized graph class template template arguments auxiliary information vertices auxiliary information edges 
disadvantage types needed dummy type template argument wastes memory 
node edge arrays associative arrays hashing allow easy addition information temporary purposes 
disadvantages additional cost lookup operation additional memory consumption 
subtle disadvantage revealed considering example iterator graph nodes simple pointer node general sufficient state iterator iterator able give access associated attributes node 
additional associative arrays stored iterator alternatively node 
current memory requirements equivalent www mpi sb mpg de leda leda html vertex halfedge facet halfedge data structure topological map topology geometry planar map polyhedron fig 

overview design separation topology geometry 
pointers graph node pointers directed graph edge 
flexibility obtaining smaller graph structures 
leda reach flexibility tuning runtime space efficiency achieved approach 
minimal rendering tool mrt uses halfedge data structure represent polyhedral surfaces 
implemented class hierarchy provides euler operations maintain combinatorial integrity 
internal representation accessible construction time protected 
access granted 
separates geometry topology vertices point incorporated just combinatorial level efficiency reasons 
flexibility achieved virtual member functions geometric properties 
flexibility available topological level 
facets responsible storing ring boundary 
summarizing approach leads larger nodes vertices facets slower functions geometric properties solution propose 
design overview illustrates separation topology geometry design 
vertices facets store 
container class structure manages items topological relations 
topological map adds halfedge data structure management holes facets enumerates inner outer boundaries facets 
usually classified face representation 
polyhedron adds geometric operations 
definition polyhedral surfaces guarantees consistent representation costly self intersection test polygon planarity test 
halfedge data structure restricted definitions useful implementing data structures polyhedron represent surfaces restricted definition example polyhedron protects combinatorial integrity provides ease defines circulators defines extended vertex halfedge facet defines handles iterators halfedge data structure manages storage container class vertex halfedge facet items stores actual information contains user added data functions vertex facet halfedge fig 

responsibilities different layers design 
edge distinct endpoints 
planar map topological map maintains holes facets 
items vertex halfedge facet concepts 
currently different models provided halfedge datastructure stl vector list representations manage items internally 
various models provided items easily extended user example additional attributes 
illustrates layers polyhedral surface design items halfedge data structure polyhedron 
items provide space information stored member variables access member functions vertex halfedge facet respectively 
required provide halfedge opposite halfedge 
optionally may provide previous halfedge incident vertex incident facet 
vertices facets may empty 
optionally may provide incident halfedge 
options mentioned supported halfedge data structure polyhedron example euler operations update optional 
furthermore item classes extended arbitrary attributes member functions promoted inheritance actual classes polyhedral surfaces 
implementations vertices facets provided fulfill mandatory part requirements 
base classes extensions user 
richer implementations provided serve defaults polyhedra provide optional incidences dimensional point vertex type plane equation facet type 
vertices facets passed local types items class halfedge data structure polyhedron 
implementation detail explained depth section 
halfedge data structure responsible storage organization items 
currently implementations internally bidirectional list stl vector provided 
halfedge data structure defines handles iterators belonging items 
types promoted declaration items provide incident items 
promotion types done template parameter item types see section 
halfedge data structure provides member functions insert delete items traverse items gives access items order manipulate items 
different models available 
kept interface small 
functionality common models separated helper class shown placed side halfedge data structure broadens interface hide 
helper class contains operations useful implement operations layer example polyhedron 
adds example euler operations partial operations euler operations built inserting edge ring edges vertex 
furthermore helper class contains adaptive functionality 
example prev member function provided find prev member function helper class searches positive direction facet previous halfedge 
prev member function provided find prev member function simply calls 
distinction resolved compile time technique called compile time tags similar iterator tags see section 
polyhedron provides easy interface high level functions hides flexibility provided underneath 
interface designed protect integrity internal representation handles longer mutable 
polyhedron adds convenient efficient circulators see section accessing circular sequence edges vertex facet 
achieve polyhedron derives new vertices facets provided items 
new items gives coherent type structure design especially compared previous design 
polyhedron adds geometric interpretation 
vertices polyhedron required store geometric point 
program examples default template arguments allow hide flexibility provided halfedge data structure 
example program polyhedron needs instantiated geometric kernel 
cgal traits class actual geometric kernel data structures algorithms allows provide adaptors easily kernels 
declaration default polyhedron cartesian kernel doubles looks follows typedef double 
kernel typedef kernel 
traits typedef traits 
polyhedron function applies affine transformation points polyhedron 
note transform generic algorithm stl 
design encourages re providing function affine transformations polyhedron provides iterator accessing points affine transformation cgal unary function object suitable transform function 
void apply polyhedron const kernel transform default polyhedron provides plane equation facets 
example replace default facet type facet type providing normal vector full plane equation 
define facet type replace facet default items type far 
facet base class available cgal 
template argument refs explained section 
handle iterator types halfedge data structure available items 
traits argument provides local type normal vector type 
items class contains template member classes representing vertex type halfedge type facet type respectively 
names template arguments fixed halfedge data structure create objects types 
inheritance default items class polyhedron re old vertex halfedge types 
facet replaced 
related template member class provide local type facet redefined facet type 
new items class second template argument polyhedron class replaces default items class 
third template argument replace default halfedge data structure illustrated 
traits argument 
template class refs class traits 
struct public refs 
typename traits vector normal struct public template class refs class traits 
struct typedef refs traits 
facet typedef traits 
polyhedron example computes normal vectors facets modified facet type previous example 
generic algorithm stl apply function object facet polyhedron 
function object assumes convex facets compute facing normal vector ignores numerical stability issues 
obtain consecutive vertices boundary facet compute normal vector cross product 
function object uses template member function gives generic implementation facet type compliant normal member variable keeps incident halfedge 
facet knows type vertex handle 
struct template class facet 
void operator facet typedef typename facet halfedge vertex halfedge vertex halfedge vertex normal point point point point void polyhedron foreach implementation design templates necessary details implementation templates prove feasibility design 
simplified version presenting technique decouple item types halfedge data structure 
realization polyhedron class 
omit details const correctness cgal prefix 
note developer user data structure know details design 
key certain item type example vertex know actual types related items example halfedge type 
knows formal placeholder type 
put formal placeholders single template argument refs local types 
indicate halfedge handle vertex type provides incident halfedge 
template class refs 
struct vertex typedef typename refs halfedge return void private item types implemented similarly 
halfedge data structure parameterized item types 
item types class templates need templates template arguments halfedge data structure 
order type declarations halfedge data structure vertex halfedge type container classes item types handle types known container classes 
type dependencies contain cycle item types need template argument tells handle types 
halfedge data structure knows handle types actual type refs argument item types handles declared point 
difference declaration definition allows declared type halfedge data structure item type instantiation fully defined point 
respect instantiation approach similar template pattern described inheritance 
omit facet type example 
template template class 
vertex template class 
halfedge 
struct typedef 
vertex halfedge 
self typedef vertex self 
typedef halfedge self 
typedef list vlist typedef list typedef typename vlist iterator typedef typename iterator 
remains show intermediate items class polyhedron class protected access items connection geometric kernel traits class compile time tags adapt functions flexibility provided items 
item type usually template arguments refs explained traits argument 
traits contains geometric types basic operations available types 
optional functionality item types indicated tags 
example vertex type add local type supports vertex halfedge 
predefined classes tag true tag false 
tag indicates incident halfedge provided 
template class refs class traits 
struct vertex typedef 
functionality tag adapt compile time 
example euler operations implemented compile time tag 
update automatically provided 
example uses function overloading distinguish different implementations function foo depending tag 
single argument function called vertex argument 
function call forwarded corresponding parameter function matches actual type compile time tag 
void foo vertex foo vertex void foo vertex implementation making halfedge method 
void foo vertex implementation making halfedge method 
intermediate items class puts definition item types vertex halfedge facet 
uses member template classes template class 
passed instantiating item types 
furthermore halfedge data structure written templates template parameters 
names template arguments items class fixed member class templates called wrapper template arguments refs traits 
wrappers provide local type named corresponding item vertex example refers actual class 
technical reasons convenient pass item types single parameter halfedge data structure 
easier items classes defined library 
hand new items class needs derived single item type exchanged see example previous section 
advantage possible separation kind template parameters user specified parameters specified halfedge data structure refs traits 
user specified parameters passed additional template arguments halfedge data structure user items class template class provide actual types instantiating polyhedron 
items class example additional user parameters looks follows struct template class refs class traits 
struct typedef vertex refs traits 
vertex similar halfedge facet polyhedron derives new item types item types enhance functionality circulators protect combinatorial structure 
member functions allow changing incidences items private remaining functionality especially user added functionality remains available user public inheritance 
solution repeat explicitly functionality remain public user added functionality captured way lost 
solution chosen may sound weak respect protection user provides bases user protection mechanism 
solution prohibits accidental misuse main purpose protection 
new item types collected items class halfedge data structure polyhedron 
consequence halfedge data structure uses correct items defined polyhedron 
original items provided user parameterized handles derived item types correct types achieve coherent type system 
consistent derived item types prohibits allowed change incidences polyhedron halfedge data structure 
provide type base class derived item types 
halfedge data structure polyhedron change incidences calling member functions base class similar implementation set halfedge member function example 
template class 
struct public typedef base private void typename base base template class items 
struct template class refs class traits 
struct typedef typename items refs traits 
wrapper typedef typename wrapper vertex typedef 
vertex similar halfedge facet polyhedron class template template parameters traits items hds default arguments 
declares derived item types instantiates halfedge data structure hds internal representation 
hds parameter template template parameter 
halfedge data structure template template parameter third level templates allowed 
items class avoids workarounds possible 
template class traits class items template class class 
class hds 
struct polyhedron typedef items 
hds traits 
hds 
halfedge data structure remains basically unchanged 
delegate modifier base modifier hds halfedge data structure modifier base operator hds delegate modifier base modifier modifier halfedge data structure validity check polyhedron operator hds scanner hds fig 

class diagram illustrating safe access internal representation polyhedron 
separate item types pass traits parameter items class parameter 
item types extracted wrappers items class 
set predefined implementations classes library easy combine extend 
flexibility demanded design section realized 
default list representation halfedge data structure replaced representations 
incidences encode bases stored tags implement adaptive functionality corresponding incidences provided example vertices allocated halfedge data structure referenced 
adding additional information easily done deriving item types replacing definitions items class 
achieved runtime storage overhead compromises ease top level 
granting access internal representation algorithms polyhedra may intermediate states invalid representations 
efficient need access internal representation 
protected access subclasses modifier base 
design motivated strategy pattern different intent 
illustrates class design example file scanner creating polyhedron file 
approach similar callback function encapsulated function object 
polyhedron accepts modifier object argument delegate member function calls virtual operator member function modifier object 
passes internal halfedge data structure argument modifier object 
scanner class example derived modifier base im operator member function access internal representation 
achievement delegate member function polyhedron verify validity internal representation operator member function returns execution 
scanner class charge returning valid representation case failure 
approach known database systems transactions modifier succeeds modifier fails supposed clean 
special task scanner accomplishes creation new items enables implement transaction scheme efficiently 
simple rollback function removes items created far case failure 
general rollback costly 
circulators concept iterators stl tailored linear sequences 
contrast circular sequences occur naturally combinatorial geometric structures 
examples polyhedral surfaces planar maps edges emanating vertex edges facet form circular sequence 
circular sequences provide efficient iterators introduced new concept circulators cgal 
share requirements iterators main difference lack past position sequence 
appropriate adaptors provided iterators circulators integrate circulators smoothly framework stl 
give short circulators discuss advantages disadvantages 
rewrite example generic contains function circulators 
usual circular structures loop preferable specific input elements sequence reached 
template class class 
bool contains const value null value return true return false categories defined forward bidirectional circulators 
operation denotes item refers 
operation advances item steps bidirectional item backwards 
circulators advances steps 
circulators compared equality 
circulators different notion reachability ranges iterators 
called reachable equal finitely applications operator 
due circularity sequence true circulators refer items sequence 
particular reachable circulators range denotes circulators obtained starting advancing reached include far range definition iterators 
difference lies denote items circular sequence iterator range denotes empty range 
long range behaves iterator range stl algorithms 
circulators additional test null required returns true circular sequence empty 
case said singular value 
supporting iterators circulators generic algorithm just simple supporting iterators 
requirements circulators described cgal manual 
conceptual main reason inventing new concept similar intent iterators efficiency 
iterator supposed light weight object merely pointer single indirection advance iterator 
iterators written circular sequences know efficient solution 
missing past situation circular sequences solved arbitrary sentinel cyclic order destroy natural symmetry structure bad idea additional bookkeeping items checking iterator advance method reduces efficiency 
solution may bookkeeping iterator start item current item kind zero iterator past situation introduced concept circulators allows light weight implementations cgal support library provides adaptor classes convert iterators circulators corresponding penalty efficiency integrate new concept framework stl 
currently implemented cgal adaptor class provides pair iterators 
serious design problem slight change semantic ranges compared iterator ranges 
semantic defined intuitive operators keep circulators ranges stl algorithms 
useful feature definition full range stl algorithm treat empty range 
likelihood mistake may overestimated container supporting circulators member function expression sort fail 
easy distinguish iterators circulators compile time allows generic algorithms supporting arguments 
possible protect algorithms inappropriate arguments technique scope extend stl algorithms 
design framework combinatorial data structures polyhedral surfaces planar maps 
extended model topology curved surfaces applied combinatorial data structures triangle structures triangulations 
proper definition modeling space polyhedral surfaces strictness proven useful applications 
suitable edge data structures literature discussed halfedge data structure chosen implementation 
discussion revealed desirable options data structure led demand flexibility design especially tradeoffs space time 
example cgal manual uses similar idea encoding indices quad edge data structure uses bit pointer encode opposite halfedge 
generic programming paradigm led easy flexible design 
explore tradeoffs time storage efficiency iterator categories modifiability 
solutions design goals section order actual storage organization item types easily changed selecting appropriate halfedge data structure provided library 
provided incidence relations selected user kind item types 
predefined item types library sufficient new incidences easily added similar addition attributes 
optional incidences supported halfedge data structure polyhedron 
compile time tags implement support 
data functions easily added item types derivation predefined item types replacing items class 
coherent type system templates decouples item types example adding color facet imply vertex type halfedge type needs changed 
data structure provides easy high level interface appropriate concepts euler operators iterators circulators 
concepts support optional incidences item types compile time tags 
furthermore integrity representation maintained protected access internal representation granted special function objects derived base class modifier base 
management connected components containment relations separated layer example topological map 
concept circulators supports circular sequences edges vertex facet 
concept integrated framework stl 
concept handles introduced 
internally handles defined iterators container classes 
handles required arguments iterators circulators 
design open incorporate techniques runtime flexibility appropriate additional template parameters 
expect continuation approach cgal 
author wishes emo welzl freedom encouraging guidance studies michael hoffmann nora falk martin reading commenting previous versions andreas fabri geert jan giezeman stefan schirra sven intensive discussions design software engineering started cgal kernel years ago 
cgal project grown author wants members project inspiring environment especially people attending cgal meeting inria sophia antipolis connection planar map polyhedral surface design discussed 
jean daniel boissonnat encouragement anonymous referees valuable comments 

polyhedron representation computer vision 
national computer conference pages anaheim ca 
afips 

modellierung der grundlagen zur modellierung und 
editor modeling virtual worlds distributed graphics pages bad bonn november 
schirra veltkamp editors 
cgal manual 
january 
cgal 
international standard iso iec programming languages 
american national standards institute west nd street new york 
coplien 
curiously recurring template patterns 
report pages february 
de berg van overmars schwarzkopf 
computational geometry algorithms applications 
springer 
fabri giezeman kettner schirra 
cgal kernel basis geometric computation 
lin manocha editors acm workshop applied computational geometry pages philadelphia may 
lecture notes computer science 
fabri giezeman kettner schirra 
design cgal computational geometry algorithms library 
software practice experience 
appear 
gamma helm johnson 
design patterns elements reusable object oriented software 
addison wesley 
giezeman veltkamp 
getting started cgal january 
cgal 
glassner 
maintaining winged edge models 
arvo editor graphics gems ii pages 
academic press 
guibas stolfi 
primitives manipulation general subdivisions computation voronoi diagrams 
acm transaction graphics july 
hartman 
vrml handbook building moving worlds web 
addison wesley 
hoffmann 
geometric solid modeling 
morgan kaufmann 
hoffmann 
line sweep auf einem 
diplomarbeit 
freie universitat berlin germany 
kettner 
designing data structure polyhedral surfaces 
proc 
th annu 
acm sympos 
comput 
geom pages 
kettner welzl 
contour edge analysis polyhedron projections 
klein rau editors geometric modeling theory practice 
springer 
proc 
int 
conf 
theory practice geometric modeling germany oct 

large scale software design 
addison wesley 
lippman 
inside object model 
addison wesley 

solid modeling 
computer science press rockville maryland 
mehlhorn 
leda platform combinatorial geometric computing 
communications acm january 
mehlhorn uhrig 
leda user manual version 
leda software gmbh saarbrucken germany 
muller preparata 
finding intersection convex polyhedra 
theoretical computer science 
musser 
stl tutorial guide programming standard template library 
addison wesley 
musser stepanov 
generic programming 
st intl 
joint conf 
issac pages 
springer lncs 
musser stepanov 
algorithm oriented generic libraries 
software practice experience july 
myers 
traits new useful template technique 
report june 
overmars 
designing computational geometry algorithms library cgal 
lin manocha editors acm workshop applied computational geometry philadelphia may 
lecture notes computer science 
phillips 
manual version silicon graphics workstations 
geometry center university minnesota october 
schirra 
case study cost geometric computing 
proc 

appear 
silicon graphics computer systems standard template library programmer guide 
www sgi com technology stl 
steinitz rademacher 
uber die theorie der unter der der topologie 
springer 
stepanov lee 
standard template library 
www cs rpi edu musser doc ps october 
stroustrup 
programming language 
addison wesley rd edition 
weiler 
edge data structures solid modeling curved surface environments 
ieee computer graphics application january 

inventor mentor programming object oriented graphics open inventor release 
addison wesley 

