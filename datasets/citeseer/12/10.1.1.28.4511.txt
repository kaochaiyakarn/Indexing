dissertation faculty school engineering applied science university virginia partial fulfillment requirements degree doctor philosophy computer science design representation systems autonomous agents glenn scott wasson copyright rights reserved glenn wasson june approval sheet dissertation submitted partial fulfillment requirements degree doctor philosophy computer science accepted school engineering applied science dean richard school engineering applied science dissertation read approved examining committee june worthy martin thesis advisor randy pausch committee chairman james french robins bennett david kortenkamp glenn wasson iv proposes design methodology creating representation systems robots operate dynamic uncertain domains 
order efficient effective domains robot control achieved tight coupling sensors effectors constrains design representation 
methodology attempts guide designer creating representations effective robots control systems 
methodology assists designer analyzing robot task capabilities environment answer questions represent structure representation keep representation consistent changing environment 
efficacy validity methodology documented agent designs successfully carried implementation 
key feature agents action oriented portion architectures systems representation employ 
large number people contributed different ways hard 
know special people 
parents sister expressing continual belief eventually finish 
various student members vision group come tenure 
particularly frank brill ferrer jim helping start robotics group 
advisor worthy martin provided invaluable assistance leading times master plan fact get point 
need tom olsen advising early days kept interested stay ph road graduate school seldom travelled cast characters willing provide 
aaron cass anand john jones various times providing means mechanisms outstanding occasions 
acknowledgments vi table contents iv acknowledgments changing views action selection representation design design representation systems representation objects action oriented architecture applicability designs domain characteristics environment dynamic task contains different aspects knowledge large scale space required task decomposed entire plan priori occur environment suitably quantifiable coarse metrics agent architecture agent perception overview related perception representation representations navigation agent architecture design methodologies psychological representation design methodologies scaling problems representation design methodology task domains design methodology task decomposition example task decomposition decomposition rationale decomposition summary identify task roles example task roles task roles rationale summary representation task roles example task representation representation rationale representation summary perception vii example task perception perception rationale perception summary communication example task communication communication rationale communication summary architecture example task architecture architecture rationale architecture summary post methodology methodology summary applying methodology bruce task decomposition identify task roles representation task roles perception communication architecture bruce implementation bruce representation pa layer main loop pa loop step update markers pa loop step instantiate markers pa loop step select execute action task implementation inter layer communication applying methodology spot task decomposition identify task roles representation task roles perception communication architecture spot implementation spot representation skill layer main loop pa layer skills summary applying methodology marcus task decomposition identify task roles observations roles representation perception viii communication architecture implementation pa layer main loop pa loop step update markers pa loop step instantiate markers pa loop step select execute action pa layer behaviors task executor te main loop check monitors handle completed actions determine execute action plan step structure summary evaluation requirements evaluation design methodologies subsumption methodology architecture pure architecture soar architecture evaluation design summary action selection redux fundamental representation design representation maintenance representation organization surprises contributions appendix robot implementations bruce implementation navigation system perception system task executor marcus implementation local global coordinate conversion vice versa pose detection detecting adjacency handling completed actions marcus task executor te starts new plan step appendix marcus task figures marcus task flow diagrams marcus task role diagrams marcus role mappings ix appendix task constraints walk dog task constraints list figures 
dog walking environment task specification 
walk dog 
walk dog decomposition hierarchy 
walk dog subtask flow diagrams task specification 
pour cup coffee task specification 
drive store 
walk dog task roles task specification 
mole task specification 
pick covered pot 
categories role maintenance requirements 
bruce opponents 
search plan 
hide seek task decomposition 
hide seek task flow diagrams 
hide seek task roles 
obstacle avoidance look occluder 
image opponent 
spot 
serve patrons task decomposition 
serve patrons task flow 
serve patrons task roles 
marcus arch lab 
marcus environment portion olsson hall 
top level task decomposition marcus 
top level task decomposition marcus continued 
locomotion building task decompositions marcus 
manipulation task decompositions marcus 
door task decompositions marcus 
door location tracking 
local global coordinate conversion markers 
example stack views 
zones determine item pose 
example adjacency measurements 
marcus task flow diagram 
marcus task flow diagram 
marcus task flow diagram 
marcus task flow diagram 
marcus task flow diagram 
top level task roles marcus 
top level task roles marcus continued 
top level task roles marcus continued 
locomotion building task roles marcus 
manipulation task roles marcus 
door task roles marcus xi list tables table summary domain characteristics table representation component summary table representation component summary table task controlling capabilities table components bruce markers table mapping tasks activating marker components table components spot markers table marcus top level decomposition summary table locomotion task descriptions table manipulation task descriptions table building task descriptions table door task descriptions table entities environment fulfill roles plan step tasks table components marcus markers table components marcus protomarkers table plan step components table summary pose zones table te handles completed pa layer actions table te actions starting new plan step table role mappings fundamental question designers physically embodied ai systems systems decide 
answer question affected choices new decisions information considered making 
choices turn put constraints types computation decision making process 
thesis addresses question information consider providing methodology developing symbolic models environment efficient effective agents quickly continually decisions dynamic environments 

changing views action selection action selection refers agent procedure deciding choosing actions 
time action selection mechanisms designed lead rethinking means agent decide 
action selection done deliberative thinking planning 
planning involves symbolic model agent goals capabilities environment generate series actions meet agent goals 
plan carried executive simply performs actions achieves goals 
possible generate optimal plans approach planning systems fairly unsuccessful dynamic real world domains unrealistic assumptions models chapter duty owe history rewrite 
oscar wilde environment 
information considered action selection process world model assumed complete accurate static changes agent actions 
speed agents generated plans frequency undertook effort effected correctness selected actions 
fortunate inferencing collection facts world model proved computationally complex slow practice 
mid brooks challenged world model assumptions planners sense plan act model robot architectures subsumption architecture 
architecture internal model world time consuming deliberation process 
changes notion action selection deciding series actions making momentary decision 
agent stores information world decide current sensor values 
doesn sense select series actions take information past world states base selection 
actions taken subsumption architecture simple short lived effector commands executed particular patterns detected agent sensors 
action takes little time execute agent operates tight loop selecting executing actions current sensor data 
action selection mechanisms reactive agents differed predecessors decided frequently considered far information doing 
agents stored world model information part environment sensor range particular moment 
approach advantage agent continually senses world re decides action take quickly detect respond changes dynamic environment 
information world stored agents fairly myopic 
agents proved difficult design simple tasks information relevant determining effector command determined agent sensors time 
success subsumption similar reactive systems pointed problems planning world model assumptions operating dynamic domains 
agent knowledge world rarely complete world changes due factors agent control 
realization inherent problems incomplete knowledge frame problem brooks assertion human intelligence achieved representation lead internal representation world impeded action selection reactive agents 
complexity useful world model said expensive build expensive sort data decide 
time agent selected action world inevitably changed selected action wrong 
avoiding temptation representation world design avoid moving back sense plan act paradigm 
thinking concluded representation obstacle performance 
brill shown need case 
representation inevitably lead planning reactive style action selection mechanisms benefit representation 
key representation agent need spend long time searching require agent elaborate inferencing planning deduce correct action 
thesis concentrates designing systems repre sentation autonomous agents operating dynamic domains 

representation design thesis investigate design representation systems action oriented portions agent architectures put forward design methodology 
thesis methodology produce systems representation action oriented components agent architecture efficient effective dynamic domains 
remainder section give basic definitions terms elaborated chapters 
design thesis proposes form task oriented design creating representation agent architectures 
task oriented means representations specialized task capabilities agent consideration similar general software design process discussed 
tasks interest thesis see section take place dynamic environments agents assumed selecting actions rapid sense act cycle typical reactive systems 
course agent architectures today multiple action selection mechanisms decide actions various granularities system may decide agent action drive store system decide particular motor commands steer car unpredictable traffic 
section discusses types action selection mechanisms applicable 
agent capabilities strongly influence design process 
capabilities designer start design process 
may include hard ware sensors available 
accurate 
wheels 
wings 
software sensor processing routines device drivers manufacturer provided libraries 
capabilities define designer starting point determine basic actions agent capable entities represented perceived manipulated methodology designer examine tasks capabilities create representation allows agents efficient effective tasks representation 
representation systems representation mean data structures hold information agent environment 
representation system collection data structures describing part environment sufficient detail agent effectively efficiently complete tasks 
chapter reader see effort devoted representing required agent effective representing agent remain efficient 
important distinguish explicit representation considered thesis implicit representation reactive agents 
explicit representation refers actual memory structures store properties world 
implicit representation referred catch phrase world best model 
words properties world need stored memory agent needs know merely needs observe world compute 
dynamic physical environment real sensors implicit representation computationally expensive impractical environment perceived time see section 
word representation refers explicit variety 
representation objects representation describes agent environment environment represented fundamentally believe objects represented 
unit representation store data object environment 
object suitably distinct physical entity agent act act respect manipulate 
holding definition suitably distinct moment objects need represented actions take place respect objects 
purpose system representation assist agent action selection data important action objects represented 
level object defined actions taken 
chair sit object sit said chair 
actions taken object depend acting agent 
different agents different capabilities different possible actions 
example robot plug wall built understand wall socket object robot capability may treat socket part wall 
gets back notion suitably distinct 
object distinct surroundings example arbitrary points space indistinguishable portions carpet treated objects 
distinguished obviously depend agent perceptual capabilities agent task 
example agent wanted write note need writing implement 
agent perceptual routines detect pencils pencil writing implement 
agent act write pencil perceptual capabilities treat 
say physical entity clarify mean objects programming constructs 
pencil distinct object 
suppose agent mistake wants erase 
eraser pencil 
previously eraser separate object pencil involved writing action 
pencil detection routine may needed eraser part sensory signature pencil agent need give eraser representation needs erase 
words task determines constitutes object 
point worth mentioning object representation system different kind representation system robots 
robots representation space usually free space notion occupied space segments important objects 
action oriented architecture stateless reactive agents robust certain tasks proved difficult design 
lack representation difficult scale systems agent current state reduce complexity examining environment large number perceptual stimuli 
planning may inefficient action selection certain tasks useful time permits consideration alternate courses action cost wrong action high 
response limitations reactive systems hybrid architectures developed 
hybrid architectures combine traditional planner executive 
executive may divided multiple components refer action oriented portion architecture control agent interaction world 
parts architecture exert control agent actions action oriented portion portion timeliness deciding critical 
portion architecture operates tight action selection loop sense act paradigm action oriented portion architecture 
leaves portion architecture needs inference planner 
representation systems result methodology thesis specifically targeted portion agent architecture speed react events world 
speed useful representation portion architecture different representation planners 
order efficient effective representation systems provide useful information agent providing information 
agent update representation correspond current state world consult representation determine action certain time frame 
time frame representation corresponds closely changing environment selected action appropriate 

applicability designs representation systems developed methodology useful agents operating domains possessing characteristics described section 
agents fundamental similarity action oriented portions architectures described section 
perception important agent capability impact representation design discussed section 
domain characteristics number characteristics agent domain task capabilities environment amenable representation systems designed methodology 
characteristics environment dynamic dynamic environment properties environment important agent task change time 
means current sensor data valid previous sensor data 
task contains different aspects different aspects means different portions agent task handled different portions agent architecture 
task requires rapid interaction environment agent handle mechanism consideration alternatives sequencing actions performed mechanisms available 
means task involve different types computation 
focus entirely real time performance provide reward deliberative thinking 
environment dynamic agent reduce reaction time planning 
knowledge large scale space required large scale space environment spatial structure significantly larger scale sensory horizon observer 
agent environment time able perceive important aspects environment 
agent benefit form memory representation remember important previ ously perceived data 
memory hold expectations environment 
may come long ago explorations human operator 
note large scale space disjoint refers 
local space area agent sensors representation action oriented portion architecture currently give information 
existence large scale space means multiple local spaces 
task decomposed means agent task decomposed hierarchy tasks subtasks agent goals achieved tasks top agents capabilities form basis tasks bottom 
course task decomposed subtasks decomposition past capabilities interest fact library may translate move forward command motor voltages beneath concern designer library abstracts away 
different tasks view world different levels abstraction 
part common abstraction agent treat object task collection parts task 
example task goal pick pot stove may represent pot single entity 
task decomposition agent capabilities caused agent pick pot handles individual handles may represented subtasks 
entire plan priori occur characteristic means agent complete knowledge environment classical planning ineffective 
say agent knowledge obtain information exploration 
fact environ ment dynamic agent able generate complete plan blindly executed complete knowledge world state change plan generated 
sufficiently plans crafted domain environment able change replanning needs occur 
note thesis concerned planning plans generated organization planner representation concerned plans 
domain environment sufficiently complex difficult traditional state space planner previously discussed world model assumptions operate effectively 
means intelligence embedded action oriented portion architecture needs action selection machinery execute plans 
environment suitably quantifiable coarse metrics means crude maps environment effective agent tasks 
environments quantifiable degree important idea agent need precise metric information environment get 
agent sensors inaccurate map information task execution 
agent architecture methodology designed agents perception action pa systems 
perception action systems operate tight loop coupling sensation action 
control loops effective avoid lengthy action selection process believe practically necessary agents operating dynamic environments 
simple transforms agent sensor values select possible actions 
action process agent continually deciding continue current course action switch new 
action picking object may involve sending dozens control commands effector motors time 
long sensors indicate picking object agent doing continue action 
assume perception action system small control programs called skills behaviors 
programs watch sensors respond appropriate 
multiple skills active time agent behavior combination output 
skills define situated control rules agent accomplish goal 
situated means skills expect operating context interpret agent sensor data accordingly 
recall agent goal plugging wall socket 
agent skill plug may interpret short sonar reading approaching wall socket 
different skill navigating agent room may interpret sonar reading obstacle avoided 
skills thesis similar skills traditional reactive agents complex purely stateless representation 
skills thought sets situation action rules situation world state specified current sensor values data stored skill representation action effector control command execute 
skill continually samples environment determine situation currently applicable executes action 
representation skill variables associated objects environment run time juggling skill number ball variables rep resentation associated juggle able objects 
making association referred binding representation 
doesn matter objects rubber balls long agent juggle 
pa system skills current sensor values information contained representation context select actions 
important aspect skills designed fool proof recognize fail 
referred cognizant failure allows skill contain small set rules interaction environment 
try handle exceptional cases seemingly impossible task skill merely reports failed skill portion architecture tries correct problem 
principles cognizant failure situated ness allow skills operate extremely fast need deal full complexity world 
simplifying assumptions world streamline actions world moves outside assumptions merely need recognize fact report failure 
design methodology concerned agents pa systems domain characteristics show agents components architectures 
specifically methodology appropriate agents layered architectures 
layers don deal directly sensors effectors action oriented portion architecture planning 
agents developed chapters layered architectures current agent architectures 
thesis concerned architectural design agents developed methodology architecture discuss designed design systems representation architecture 
sense architecture interacts world pa system 
thesis pa layer referred lowest layer directly connected actual environment 
higher layers connected layers 
typically highest layer sort planner 
worth noting existing robot architectures layers pa layer planner pa layer sequencer planner 
compelling case literature layers 
architectures layers example implemented real world task extra layers divide pa layer tasks extra layers designed control mobile robots 
agent perception representation dynamic environment necessarily means updating representation world changes 
perception important design consideration system representation 
thesis mainly concerned vision agents agent derive information world vision 
issues explored design methodology applicable sensor modalities discussed terms vision vision presents computational problems sensors commonly robots 

overview section provides overview representation design methodology remainder thesis 
methodology designed create hierarchical systems rep resentation agents acting dynamic uncertain domains 
methodology organized series questions designer 
question designed highlight certain aspect agent design implications representations created 
methodology algorithm art involved agent creation 
particularly true regard methodology step decomposing agent task subtasks applicable software engineering technique 
methodology advocates iterative design process designer modifies answers previous methodology questions answers produce unworkable representation systems 
unworkable means agent operate efficiently effectively domain 
point reached design phase building prototype chapters contain examples task decomposition created individual tasks analyzed determine information environment important information extracted environment 
information stored agent representation involves trade usefulness information cost verifying dynamic world 
methodology advocates making tradeoff information easy compute information skills behaviors information 
methodology laid different agent designs chapters 
agents performs different task uses systems representation designed methodology chapter 
evaluating design methodology difficult case comparative anal ysis hard methodologies address design representation systems action oriented portion agent architecture 
chapter discuss popular architecture design methodologies address task agent chapter 
develop criteria evaluate efficiency effectiveness representation systems show design methodologies fail create representation systems meet criteria 
main contribution thesis structured approach design representation autonomous robots 
contributions discussed chapter 
today debate robot totally reactive totally deliberative needs elements 
similarly debate robots representation representation useful comes liabilities 
thesis explores representations efficient effective extending reactive systems small amount task dependent representation addressing issues represent structure representation take data stored representations kept consistent changes dynamic world 
section analyze previous agent representation systems agent design methodologies 
agents designed methodological guidance 
current methodologies explicitly address problem representation design representation systems corresponding implemented agents examined 

perception representation main goal design representations environment effective action oriented portion agent architecture 
action complex dynamic worlds relies great deal perception provide timely information environment 
agent representation closely tied perception 
words representation continually modified perceptual information 
researchers developed agents representation perceptual system 
pengi system agre chapman plays video game simulated agent penguin battle enemies bees rectilinear maze ice blocks 
agent uses data structures known markers 
structures associated particular elements video game currently importance agent running away bee need look ahead block blocking route determine escape 
markers similar representa chapter related secret creativity learning hide sources 
albert einstein tion agents chapters store position task function objects environment 
task function important ice block block blocking route task projectile kick 
chapman sonja system played complex video game fewer constraints agent actions 
pengi sonja markers bridge gap early vision action 
markers hold locations important entities environment spatial locations markers agent determine action 
markers limited form representation hold locations agent dimensional omniscient overhead view 
memory store important locations outside current view allow markers persist perception action cycles 
addition system addresses perceptual problems early vision 
sonja compute early visual properties determine locations markers pengi directly accesses video game internal data structures handle problems physical sensors limited field view person perspective occlusion unconstrained nature vision problem 
kuniyoshi developed agent uses data structures call markers hold positions task dependent points space 
agent operates real world uses stereo optical flow update positions markers 
kuniyoshi state markers associated perceivable features move outside field view 
addition single marker system store positions multiple points space markers specify paths example ll discuss chapter difficult update 
brill created simulated agent operates person domain 
agent represents important task dependent objects environment markers similar pengi 
markers represent information outside current field view 
expanded area called effective field view set behaviors choose agent action 
term effective field view denotes area environment agent access decision making process 
includes area currently range agent sensors certain task dependent percepts stored agent internal representation 
stored data treated sensor agent continue operate reactive fashion may selecting actions stored data 
brill agent uses system representation similar portions ones agents chapters 
expanded concept markers effective inter layer communication defining concept marker instantiation separating concepts brill system 
example perceptual properties objects associated brill markers determined object role task food red red objects food 
brill addressed issue representation improve performance perception action system addresses issue design representation systems 
horswill created agents associate unary predicates visual trackers determine truth value predicate look position tracker 
trackers inside outside field view updated correspondingly odometry vision 
agents avoid scaling problems inherent agre chapman system see section limiting number trackers horswill provides theory methodology design system control allocation 
chapter discuss design multi layered representation systems goal mind 
ballard discusses agents animated foveated vision systems 
agents store coordinates important objects previously foveated visual systems 
ballard advocates storing coordinates objects object centered coordinates relative objects 
way agent needs maintain transform current foveal position object stored object object transforms transfer fovea important entity 
may efficient cases ego centric coordinate system proposed chapter ego centric coordinate updated agent moves ballard approach fragile objects move relative 
thesis assumes agents designed methodology operating dynamic environments object centered approach brittle advocates paying computational price ego centric representation 

representations navigation maps agent environment common form spatial representation 
tasks autonomous robots including thesis require navigation maps quite useful 
grid maps called occupancy certainty grids implemented sonar stereo vision 
representations describe free space surrounding robot suited navigation obstacle avoidance 
techniques register occupancy representation suitable general representation important properties objects environment 
kuipers developed maps indoor outdoor large scale environments :10.1.1.29.1915
tour model defines semantic hierarchy information pairs accumulated form topological metric maps 
pair means doing action put agent position sensors perceive view 
occupancy grids tour model maps map representations represents space objects 
means computational effort expended extract object data map 
typical tasks autonomous agents including navigation respect object pick book go store hit ball need object data 
perception action system map representation large map prohibitively expensive extract object information 
layers architecture agents thesis maps 
kuipers complementary mine maps inappropriate representation pa layer choosing actions pa layer build map tour model 
pair right granularity pa layer generate correspond phases pa layer execution loop perception view action 
synthesis process builds maps performed layer architecture receives tuples pa layer 
researchers map representations 
kak developed agent navigates cad models environment visually matching model features perceived features 
cad representations difficult obtain create model brittle 
brittleness due fact cad models model static properties environment portions thought change 
agents interest exist domains dynamic static features environment important 
miller presents mapping representation regions 
region defines number degrees freedom robot determine position local sensory information 
open area robot determine position orientation dense area objects robot may able totally orient 
mataric uses topological map built distributed collection behaviors 
activation energy spreads outward node robot located activating nearby behavior nodes looking associated sensory signatures sonar input 
main advantage technique map actively maintains adding removing links nodes agent travels fails travel perceptually distinct areas environment 
maps non metric efficient path plans just topologically short ones 
representations useful self localization determining position respect map representation general tasks 
thesis provides means breaking large scale spatial knowledge contained maps making available pa layer computationally affordable chunks local space information 

agent architecture design methodologies agent design methodologies existence today 
concerned dividing agent tasks various components agent architecture nature tasks 
scarcely address design representation systems brooks exception advocate representation systems 
early design agent architectures dynamic environments done brooks 
proposed eliminating representation invariably inconsistent state world lead agent incorrect decisions 
approach rejected heavy handed researchers including representation subgroup aaai spring symposium lessons learned implemented software architectures physical agents cause re evaluation role structure representation perception action components agent architectures 
brooks internal state representation robots 
rap system number autonomous agents multi tiered architectures part architecture 
raps lisp style predicate structures describe state world 
certain advantages systems written lisp ability perform unification ability fact database classical planning system fairly unstructured perception action systems 
unstructured means limit number content predicates 
rap system designed operate tight perception action loops environment surprising representation system inefficient purposes 
original rap simulated perception system wrote time stamped sensor predicates rap memory 
required rap system search list facts determine current required form garbage collection 
searches unacceptable time sink agents dynamic environments result trying pa system operate planner 
architecture uses layer rap system called skill layer 
layer sends event messages rap system low bandwidth channel allowing rap memory contain smaller numbers higher level facts 
example pouring cup coffee storing visual state accurately track coffee pot aligning cup rap memory simply hold fact pot aligned cup allowing rap engine tell skill layer pouring task 
accumulation perception action information events reduces number predicates search process rap layer dissertation argues representation system efficient appropriate structure 
chapter describes agent uses structured representation encode higher level properties world stored rap system need perform unification derive database information 
noted dismiss rap system sequencing capabilities processing engine 
fact representation design methodology complementary system raps address design representation address structuring agent processing capabilities mentioned previously architecture lowest layer collection independent parallel behaviors called skills 
skills typically arbitrary code pass arbitrary data structures rap system 
design philosophy concerned deciding tasks handled layers agent architecture 
design processes carry tasks left 
address structure agent architecture believe multi tiered architectures 
designed sequencing layers agents chapters assert sequencing layers superior rap system merely perform similar functions 
agent programmer 
thesis methodology proposes arbitrary data structures wrong representation pa systems force pa system unacceptable amounts sort represented data 
slows pa system decision making process 
addition arbitrary amounts data take arbitrary amounts time verify 
pa system check arbitrary representation consistent world state remain responsive 
gat atlantis architecture representation layers 
skills atlantis perception action layer written language called alfa allows internal state variables 
variables simple data types integers floating points implement loops effective model environment 
course data types encode information environment alfa atlantis place limit structure representation representation deficiency arbitrary data structure representation allowed 
gat sequencer layer sits pa layer modeled firby rap system uses similar memory structures benefits limitations alternative architectural layout proposed tca architecture 
concerned interleaving planning sensing execution tca plan representation fundamentally different type representation addressed thesis 
tca modules appear hold internal state state construction left module designer suffers potential arbitrary data structures 
architecture noreils chatila somewhat similar division tasks components architecture 
allow arbitrary data struc tures technique similar representation instantiation see chapters 
beliefs world expressed sensory modules try fit world data 
architecture layers lisp clause fundamental unit information 
layers share common memory system problem firby rap memory expensive find forget throw away information predicates 
albus rcs architecture developed nist designed control types mechanical devices just mobile robots 
defines general representation structure levels architecture higher layers progressively powerful inferencing capabilities 
unfortunately allows planners pa layers representation structures 
believe techniques available planners allow representational structures ineffective perception action systems 
recommend creating separate linked representations world planners pa layers avoid temptation inference pa layer 
arkin aura architecture separates pa layer planner functionality mainly concerned navigation pa layer 
representation geared potential fields representing travel paths agent 
connell sss architecture limited representation environment geometry symbolic layer subsumption servo layers 
architecture applied navigation lack representation reasonable 
stated previously believe stateless systems reasonable general tasks 
circa architecture concerned making real time guarantees performance 
authors address design efficient representation systems rap system reason designed representation architecture 
certain extensions soar architecture soar air soar represent cognitive architectures control agents interact world 
soar cognitive architecture pursue number hierarchical goals simultaneously 
key feature soar architecture different multi tiered architectures layer soar control structure just operates different problem space 
am interested representation design scope thesis address advantages disadvantages architectural structure vs layered systems 
address representation architecture 
soar level memory system working memory contain knowledge agent environment long term memory contains productions contain control information agent uses select reason actions 
thesis interested designing representation function akin working memory 
number problems memory system versions soar style representation uniform representation layers 
discussed detail chapter 
uniform representation layers soar layers essentially production systems 
problem means information long term planning reactive dynamic environment contained structure 
designer store information useful planning layer concerned reacting 
trying constrain contained representation layers soar systems interact world soar methodology allows lay ers bog trying search maintain information 

psychological representation considerable psychologists form function representation action oriented portions human cognitive architecture 
humans represent information purpose symbolic cognitive thought planning sensori motor system carrying actions studies show people memory option available proposed humans representational system manner brooks 
particularly visual domain representation plays important role 
aloimonos shown certain ill posed vision problems shape motion posed agent multiple camera views understanding motions 
implies memory previous images implies representation hold memories 
shimon ullman proposes model intermediate human visual system small programs called visual routines 
important concept programs ability remember mark portions image analyzed 
proposes marking map holds location portions scene described incremental representations built scene analysis 
pylyshyn storm propose model limited number tokens bound visual features track 
associating visual feature prerequisite processing involving feature 
model object model attention opposed location model point particular locations space particular visual features continue features move 
different attentional models supposes attention directed multiple places parallel 
position supported experiments show people track multiple independent elements imagining vertices virtual polygon 
previous works concerned targets visual field attneave show subjects remember track locations elements initially visual field moved view 
parallel object model attention targets visual field consistent representation systems designed thesis 
researchers concentrated representations action 
ballard describe cognition scale actions approximately second consist small programs variables bound action time 
variables bound objects parts objects visual features appropriate world aspects manipulated action program 
thesis advocates creation linked layers representation represented information gets complex requires computation determine layers get pa layer 
psychology researchers investigated similar links representations different bodily systems 
feldman investigates connection representation visual motor system cognitive representations tasks 
describes hierarchical representation system levels 
representation space current fovea second synthesizes various foveal fixations ego represent stable world 
system feldman says primarily interacts environmental frame encompasses levels represents space non body coordinate system 
strictly dealing representation handed rod manipulation experiments guiard show usefulness multiple representations 
people manipulate rod handled tools rake broom having hand perform coarse motion fine motion 
fine motion hand operates coordinate system set coarse motion hand 
plausible people represent rod handled tool single conceptual entity need manipulate representations rod different coordinate systems needed 
deictic program paradigm ballard variables right left hand positions bound portions rod probably hand position defined terms 

design methodologies designing software robot architecture exercise software engineering methodologies field examined 
principal places current software engineering design strategies applied decomposition agent goals design agent representation 
primary concern thesis necessary step methodology chapter 
current software engineering methodology addresses design representation systems autonomous robots address methodologies decomposing agent task may lead system representation 
structured programming decomposes problem top approach 
problem divided sub problems divided basic level implementability reached 
methodology applies ap proach bottom approach decompose agent goals series tasks 
structured programming tool general software design little say implementation various tasks decomposition open problems arbitrary data structures representation 
object oriented design philosophy decomposing software functional lines collection cooperating entities called objects encapsulate data functions operate data 
object oriented design map problem decomposing agent tasks structured programming 
decomposition function designer creating goal objects agent capabilities represent functions move world state data goal 
goal entities sub goal entities moved portions parent goal world state goal 
possible interpretations objects agent system possible pure functional decomposition needed 
designer reason agent capabilities achieve goals definition objects get way 
methodologies object oriented approach offer design representation systems 
representation systems developed chapters object object refers relevant aspect world physical object 
representations encode object relevance particular task particular action carried object 
example agent task pick soda representation indicate object soda picking means positioning effector certain way 
note action picking dumbbell require different effector positions representation indicated object dumbbell encode 
combination function data single structure similar object oriented philosophy 
fact encapsulation information hiding aspect object oriented model particularly appealing maps thesis concept creating roles tasks filled various entities environment see section 
roles form equivalence classes objects agent perform function 
details selected object hidden agent action selector 
object oriented paradigm abstraction class hierarchies useful design levels representation 
different levels different layers agent architecture different abstractions environment placed different levels different layers operate data right granularity decision making processes 
object oriented model point issues effect structures agent representation 
methodology directs designer considering structural impact issues perception action communication 
communication functional units objects functions software design important issue 
data driven event programming proposed model communication units 
communication agent architecture concern thesis paradigms 
data driven programming structures program units functional blocks data flows defined pathways 
units defined terms inputs outputs internal design left designer possibly methodol ogy 
programs data flow graphs define order execution data availability notion system wide program counter 
modeling communicating skill networks way appealing natural parallelism exploited 
dataflow graphs say data structured data communicated 
design methodology addresses questions 
communication paradigm event paradigm 
paradigm computational units register units receive notification certain events take place 
programming paradigm gui systems represent asynchronous events mouse key clicks 
paradigm behaviors may communicate having agent perceptual system generate events response certain changes world state 
changes captured specific data structures representation event 
behavior registered receive notification particular event receive representation event generated 
agents developed chapters behaviors communicate manner similar blackboard system events means informing behaviors new data available blackboard 
implementation detail address format data thesis 

scaling problems researchers investigated term scaling problem action oriented architectures 
architectures perform complex tasks 
architectures brooks agre chapman differ state perform planning follow plans 
pre defined instruction sequence may sense dynamic environments researchers questioned limits tasks agents perform 
kirsh refutes brooks claim substitute control representation agent architecture 
order true perceivable view occluded cues environment agent select action adverse consequences road 
way agent ultimately get away considering alternate courses action planning 
kirsh believes reasoning planning required complex tasks planning requires symbolic model world 
representations brooks seeks eliminate removed agent architecture entirely 
tsotsos argues pure approach agent construction scale human intelligence showing visual search common activity intelligent agents np complete target explicit target meaning agent doesn description target simplify search process unbounded visual search involves grouping random collections pixels analyzing see agent stimuli agent execute response 
interestingly tsotsos shows small amount state description target sought visual search linear 
perceptual description stored representation 
representation designed methodology provides targeted visual search 
pengi limited state visual system limit complexity search task 
agre chapman refer systems limited state deictic pointing state points holds currently relevant aspects game 
pointed ballard pengi architecture cognitive visual 
advantage architecture simplicity process selecting current action behavioral variables markers bound different objects game time 
problem agent stores internal state store moment 
agent search entire perceivable portion environment time stimuli agent response 
marker bound need rebound different object bee closest changes different bee 
agre chapman access game internal data structures contained unique labeling object game 
allowed switch markers new targets little computational expense 
systems deal physical sensors complex domain important aspects register computational burden perception system 
maes creates behavior system similar scaling problem 
architecture behaviors connected behaviors preconditions achieve 
sensors put activation energy behavior network precondition predicates detect true behavior preconditions activated run possibly activating behaviors 
complex task huge numbers predicates agent needs monitor behavior hierarchy means limiting network considering predicates needed current task 
words agent look stimuli related tasks want execute time requisite predicates may true causing switch agent activity 
bryson argues complexity creating debugging tuning fully parallel behavior system opposed control hierarchy outweighs benefits reaction time parallel systems may provide 
study tuning system difficult perform system behavior hierarchy task 
stateless purely deictic behavior approach scales 
ll see succeeding chapters agents attempt avoid scaling problem looking aspects environment important current task lose ability recognize serendipitous circumstances 
related piece psychological seifert 
show humans encode known goals goals associating objects required complete 
subject sees item needed complete goal re currently pursuing may grab ll need soon 
interesting shows people recognize objects useful related current activity 
leave humans open scaling problem experiments show people recognize objects useful get goals 
strike balance number pending goals items recognize important achieving 
goals people focus time fail recognize important objects pending goals 
methodology proposed thesis preclude examining environment aspects may useful 
caution designer computational cost look ahead ruin reaction time agent 
chapter proposes design methodology autonomous agents operating dynamic environments 
main contribution methodology structured method analyzing agent task capabilities guide development agent representation system 
agent designs methodology intended interact world rapid stimulus response fashion 
time delay perception action small possible 
component agent architecture dealing sensors effectors called perception action pa system conceptualized running tight loop sensor data control effectors effectors manipulate objects direct sensors 
due computational complexity pa system explicit inferencing capabilities remain responsive 
agents designed methodology assumed operate dynamic domains environmental change causes perceptions outdated 
understood methodology algorithm agent software design 
methodology generate provably optimal agents lines 
fact tasks necessitate methodology 
methodology powerful tool focus designer attention certain aspects critical importance creation autonomous systems particularly representation control structure 
argue methodology help chapter representation design methodology methods may learn wisdom reflection second imitation easiest third experience 
designers create agents efficient effective tasks domains concern defined 

task domains discussed section task domains interest thesis share number characteristics 
summarized table 
domains characteristics suited agents perception action systems 
methodology emphasizes aspects design process important domains 

design methodology section outlines design methodology autonomous agents 
steps methodology take form series questions designer answer 
table summary domain characteristics environment dynamic current sensor data valid previous sensor data 
task contains different aspects 
different facets task handled independent architectural components agent 
knowledge large scale space required 
agent perceive important aspects environment priori time 
task decomposed 
task described hierarchy tasks subtasks allows important environmental entities viewed different levels abstraction part 
entire plan priori occur 
task requires agent going higher level control 
environment suitable quantifiable coarse metrics 
agent crude maps effectively 
step briefly describe questions illustrate running example agent designed walk dog 
discuss rationale questions summarize contributions step design process 
start design process certain facts agent task environment known 
task environment high level specification exist availability detailed information necessary 
agent designer needs description capabilities 
example task agent walk dog planned route park see play fetch dog 
exposition purposes represents number constraints task 
agent follow indicated route stay sidewalk cross street indicated complete list constraints appears appendix agent environment consists road sidewalk crosswalk dog 
flower beds route park possibly cars street 
important agent bed park sidewalk dog walking route road crosswalk 
dog walking environment car corner mailbox bilities include navigation abilities leash effector keep dog various distances pressure sensor detect direction dog pulling leash vision system identify important landmarks roses dog leash ball mailbox cars ball launching system agent play fetch dog 
chapter refer agents tasks including walk dog agent 
task environment capabilities agents summarized task specification 
thesis broadly defines capabilities designer design process 
capabilities detailed hardware descriptions stepper motor full behaviors navigate landmark 
walk dog example agent capabilities behaviors navigation system maneuver landmarks wheels camera agents bottom thinking applied turn capability descriptions behaviors see chapters 
hyphenated phrases walk dog proper nouns aid reader task walk dog park play fetch 
dog kept safe cars route 
environment park surroundings route street sidewalk cars crosswalk mailbox 
flower beds contain roses 
agent perception capabilities landmark detection system identify corner park crosswalk obstacle detector navigation sidewalk edge detector tulip rose bed detector dog leash detector dog tired ness sensor proprioceptive sensors detect motion 
task specification 
walk dog agent action capabilities leash effector direction sensor allowing agent keep dog close street moving forward ball launch system allowing agent throw ball get back dog navigation ability allowing agent move objects street 
understanding goal task 
phrases appear certain steps methodology trivial merely names stripped semantic content titles task 
easier understand goal walk task dog walked opposed goal task dog walked 

task decomposition step methodology involves creating hierarchical decomposition agent tasks agent certain capabilities hardware software designer 
thought agent primitive skills fundamental processes agent actions built see section 
task decomposition thought tree original task specification root skills leaves 
job designer bridge gap task specification skills 
creating decomposition important consider agent primitive skills 
answer question depends agent capabilities degree viewed black box 
design begins considering skills ultimately creating task decomposition top bottom process 
designer decide agent skills breaking task sequence subtasks achieve agent goals 
brings important questions 
tasks decomposed sequential subtasks 
decomposed 
task decomposition major part general requirements analysis remains art 
methodology provides structure practice art 
parallel subtasks 
interior nodes decomposition tree broken subtasks outcome meant complete parent task 
way leaf skills combined achieve greater range behavior individual skills 
example task decomposition see dog taken certain route park remember task specification represent task constraints 
dog walked sidewalk street corner crosswalk 
agent dog cross street crosswalk go park 
task specification says agent play fetch dog 
derive specifications steps way park examining map 
example keep dog sidewalk dog kept street 
crosswalk crossing street agent look oncoming cars 
details discerned careful thought processes involved 
walking dog agent moves dog meant follow 
dog follow agent tug leash 
leash agent mechanism controlling dog leash manipulated keep dog safe sidewalk keep dog moving forward 
strategy controlling dog keep nearby just tug leash dog heading needs changed designer 
agent park needs play fetch dog repeating cycle throwing ball waiting dog retrieve 
game come dog exercise agent needs periodically check dog tire 
shows hierarchical task decomposition walk dog task described 
ovals represent tasks subtasks lines represent subtask relationship higher oval parent task lower oval subtask 
subtasks decomposed additional subtasks figures 
task walking dog broken tasks follow pre planned route give dog exercise 
consists set leaf tasks implemented agent capabilities task specification 
example keep dog moving forward keep dog street keep dog close reel flowers leash control skills monitor dog position tighten loosen leash various times 
keep dog street monitors positions dog street tugs leash close 
keep dog nearby allows dog certain amount leash depending agent location route 
walk corner walk park move clear agent navigation skills 
watch flowers watch cars crosswalk wait dog return perceptual skills known characteristics agent vision system 
open area get ball dog returns ball handling skills agent ball launching system 
dog tired perceptual skill determines dog tired playing fetch 
course tasks multiple capabilities throw ball open area uses vision system detect clear place dog run ball launching system throw ball 
discussion implementation tasks reasons specific decomposition unimportant 
important leaf nodes represent primitive actions agent capabilities actions effect produces right qualitative behavior 
keep dog outof flowers walk dog cross street walk dog play dog walk dog top level decomposition watch reel flowers keep forward keep street keep walk keep dog outof flowers walk dog watch cars cross clear keep throw open area dog tired 
get ball returns keep dog flowers decomposition walk dog corner decomposition cross street play dog cross street decomposition play fetch dog decomposition 
walk dog decomposition hierarchy keep forward keep street keep walk walk dog walk dog park decomposition walk dog top level subtask flow keep dog outof flowers walk dog cross street walk dog play dog watch reel flowers keep dog outof flowers keep forward keep street keep walk walk dog watch cars keep cross street keep forward keep street keep walk walk dog throw open area dog tired 
get ball returns play dog walk dog corner subtask flow keep dog flowers subtask flow cross street subtask flow walk dog park subtask flow play fetch dog subtask flow 
walk dog subtask flow diagrams cross clear figures show flow control task execution order subtasks executed achieve parent task goals 
subtask ovals stacked indicate subtasks executed parallel 
solid arrow subtask indicates left subtask completes control transfers right subtask 
arrow higher oval lower indicates parent task executes child subtasks 
dashed arrow subtask back parent task indicates child achieved goal control flows back parent task 
shows basic flow walk dog task described go corner cross street go park play fetch dog 
figures show number subtasks executed parallel agent walks dog location 
subtasks control dog keep safe street nearby keep headed forward 
final subtask moves agent destination 
route corner lined flower beds agent keep dog walking corner 
shows parallel subtasks monitor flowers reel leash detected 
control flow back parent indicating subtasks continue execute event external task causes agent executing parent task executing subtasks case agent continue run subtasks keep dog flowers walk dog corner completes 
shows agent crosses street 
agent checks oncoming cars crosses crosswalk keeping dog close 
play fetch dog task shows series tasks play fetch dog 
agent throws ball waits dog return ball checks dog tired 
subtask tests dog status obvious change control flow information 
dog passed play fetch dog task task determines follow dashed arrow throw ball open area dashed arrow walk dog 
decomposition rationale purpose step methodology designer think relationship agent task agent capabilities 
hierarchical task decomposition provide form information hiding tasks 
tasks layer hierarchy need understand internal workings tasks layers mechanism communicate see section 
designer needs create hierarchy top bottom 
designer think services task certain layer decomposition available layer 
time designer consider goal achieving behaviors multiple tasks certain layer combined abstraction layer 
tasks lowest layer decomposition referred behaviors come directly agent capabilities tasks highest layers rely abstractions tasks layers 
creation task decomposition begins designing agent skills 
exactly constitutes skill depend agent capabilities abstraction black box 
exam task pour coffee pot coffee machine cup environment coffee machine coffee pot machine coffee cup agent pair dof arms attached grippers visual sensor detect pot cup alignment task specification 
pour cup coffee ple agent arm gripper effector capability grasp objects close gripper fingers object pre software libraries allow agent pick objects involving moving arm object positioning gripper grasping lifting object 
agent point view pick behavior black box 
example consider agent capabilities described task specification 
agent hardware description designer create behaviors grasp objects cup coffee pot pull pot coffee machine align pot cup tilt pot pour coffee 
agent basic behaviors designed designer decide skills combined achieve various task goals bottom various task goals decomposed goals achieved tasks top 
done considering effects executing various tasks starting skills parallel sequence tasks broken sequences subtask groups parallel executing subtasks example pouring cup coffee see task specification consists sequence grasping coffee pot handle removing machine aligning cup tilting proper angle 
tasks composed subtasks execute parallel desired behavior emerges 
example driving task task specification 
reader note discussion serial parallel execution tasks mean task decomposition tree 
task decompositions methodology branches particular subtask may select various choices deciding 
task drive car store environment car road cars lane markings street signs traffic lights start agent grasping pulling effector obstacle landmark lane detector steering skill color detector task specification 
drive store consist steering stay lane avoiding cars watching location need turn 
activities done parallel order drive safely consider part normal driving 
designer look create behaviors bottom executing groups primitive behaviors parallel 
example designer watch lane changes check brake lights behaviors execute parallel create avoid cars behavior 
worth pointing subtasks ultimately decompose kind hardware triggered transitions agent electronics 
details level abstraction important design time decomposition level agent capabilities 
reader may ask agent behaviors ultimately arise execution collection agent skills decompose agent task flat ordering skills 
argument hierarchical decomposition necessary task discuss allows designer create agent architecture separates agent acting concerns allow efficient effective operation dynamic domains 
task multiple feasible decompositions 
particular decomposition represent different possible orderings steps agent task choices alternatives available agent 
example pour cup coffee agent align cup pot pot cup 
case probably doesn matter designer just pick 
car driving agent may able take routes want select weather traffic conditions case designer want think various decompositions part larger tree runtime decision branch tree subtasks executed 
designer think larger tree tree node complete hierarchical decomposition type advocated methodology decision points tree possibly nodes 
designer aware creating task decomposition iterative process rest methodology 
answers questions remainder methodology dependent task decomposition designer arrive situation question satisfactorily resolved changing decomposition 
example designer may believe task different parts decomposition 
perception question section designer discovers situations task occur suitably different parts environment perception needs different case 
involve changing decomposition different situated tasks original 
designer task decomposition task flow diagrams created 
process assisted fact decomposing task subtasks designer imagined ordering subtasks 
part creating decomposition task flow diagrams part art agent design thesis little specific suggest 
software engineering provides number methodologies decomposing tasks smaller conceptual units 
popular methodologies discussed chapter 
decomposition summary step designer create hierarchical decomposition agent task 
begins deciding agent primitive behaviors 
designer considers agent top level goals broken subgoals behaviors combined achieve subgoals 
step takes advantage domain characteristics see sections exploiting innate hierarchical structure task steps specialized representations tasks created 
hierarchical decomposition useful ways 
hierarchy gives shape final control structure agent see section 
second tasks hide operational details parent task parent task need spend time considering fine details 

identify task roles task roles 
creating task decomposition step identify roles task 
task roles aspects environment effect outcome task 
typically objects agent acts task hat agent task put hat 
entities fulfill roles 
task roles determined designer decide entities agent environment fulfill roles 
example task roles consider environment shown 
designer consider entities environment important walking dog corner 
agent needs know corner order identify navigate 
obviously agent needs dog 
agent needs conscious flowers way location street sidewalk edge respect dog 
primary entities corner dog street flowers needed get corner accordance task specification 
designer decide aspects environment important crossing street 
agent needs conscious oncoming cars needs identify crosswalk get legal manner course needs dog 
crossing street task walking dog park easier walking dog corner flowers part route 
agent need concerned location dog street park 
playing fetch dog agent able detect open areas throw ball detect dog ball retrieve ball dog returns 
obviously dog important entity determining dog tired 
various phrases know concept concerned designate aspects environment important agent specific task 
describing task phrases key designer associated aspect role task 
phrases signify object environment possesses qualities agent sense respond 
dog role tasks agent monitor dog location redirect dog necessary 
agent perceptual capabilities designate portion environment dog portion actions task role dog 
convenience repeated decomposition roles bold 
keep dog outof flowers walk dog corner cross street walk dog park play dog walk dog top level roles watch flowers reel flowers keep forward keep street keep walk corner keep dog outof flowers walk dog corner keep throw open area dog tired 
get ball dog returns keep dog flowers roles walk dog corner roles cross street play dog cross street roles play fetch dog roles 
walk dog task roles keep forward keep street keep walk park walk dog park walk dog park roles watch cars crosswalk cross clear caution reader hyphenated task name phrases figures appear selection roles obvious designer crafted names developing decomposition 
method allows designer identify task roles create english language task names describe task goals words 
nouns roles task 
skill doing allow agent designers create sort semantically meaningful task names thesis 
goal describing task name roles may obvious chapters contain examples 
roles arise interaction tasks partly implementation issue 
example agent chapter task detects obstacles task role obstacle 
task agent wheels role obstacle task steers agent 
second obstacle role needed detect obstacles finds obstacles expects task steer 
entities fulfill task roles determined environment example information environment encapsulated 
dog role 
task specification provides details dog agent dog detector 
dog role filled entity environment identified detector corner corner right side street crosswalk 
park park side street 
walking dog corner flowers roses 
street edge sidewalk 
note boldface denote task role plain text denote ac 
dog detector agent capability simplify discussion oversimplification complex problem 
tual entities world 
dog represents dog necessarily explicitly discussed section agent walking dog may just dogs environment important 
designer choose important portion street fill street role cross street task 
solution street represent area edges side street crosswalk 
car role fulfilled large moving object street 
case role name slightly misleading car played car played truck bus grand piano rolling street agent dog 
large street moving agent avoided 
ball play fetch dog whichever ball agent carries park agent sure dog returns ball thrown done get ball dog returns task 
means ball play role ball ball throwing reloading tasks 
open area park space clear objects dog avoid determined section 
open area play open area role 
task roles rationale roles task specific descriptions environmental aspects influence agent behavior agent sense act 
dynamic environment agent afford concerned 
task roles important 
force designer pick important particular task allow agent concentrate resources just entities 
just matter efficiency effectiveness 
generally impossible agent build complete model world keeps date reasonably dynamic environment 
simply information available agent agent extract decide 
agent concern environmental aspects relevant current task 
allows agent designed accomplish tasks tight perception action loops involve determining information object associated task role choosing corresponding effector commands 
pour cup coffee task task specification requires object play role coffee pot object play role coffee cup 
environmental aspects important 
cups cup getting filled important myriad data may available agent sensors contents kitchen cabinets color floor 
point clear role description environmental aspects necessarily refer perceptual qualities red round possibly qualities meaning current task 
example navigation task steer obstacles heading goal 
obstacles goal determine agent route obstacle goal roles 
entity fulfills obstacle role positioned agent goal regardless perceptual properties 
task entity may play different role 
course 
define reasonably dynamic environment somewhat circular manner 
environment changes occur rate precludes agent acting quickly accomplish goals tries build complete world model 
definition clearer viewed perspective slowly environment change modern computers keep 
example consider robot spot discussed chapter 
spot uses mhz pentium mmx monitor area approximately pixels square pixel image 
spot compute stereo motion information area approximately times second 
allows tracking object space slow walk 
spot perform computations entire image process approximately times slower 
computers get faster factor reduced agent able handle dynamic environment ignoring unimportant aspects 
perceptual information important 
agent wanted entity play role select object perceptual quality rough surface 
description task role may involve perceptual information task dependent information 
designer understand roles just descriptions properties entities environment contain semantic information 
semantic information allows tasks flexible tells task act respect certain entities providing specific descriptions entities 
obstacle role tells designer associated entity perceptual description agent path 
question roles task deeply question entities fulfill roles 
term bound denote role associated object environment 
role said bound object object said fulfill role 
task achieve correct result role bound specific entity drive car done correctly car associated car owned agent 
times multiple entities fulfill task role 
example flowers role walk dog example played roses 
pour cup coffee task coffee cup mug tea cup cup 
task roles need associated single objects 
typically objects bear spatial relationship 
example task bowl apples role fulfilled bowl object apple inside 
roles may represent nebulous entities lawn lawn 
necessary designer exhaustively specify entity fulfill task role description class entities 
example car role watch cars crosswalk subtask walk dog bound entity fitting large moving agent description 
actual implementation agent perception system perceptual description allow recognition set entities 
routines necessarily contain descriptions perceptual qualities search unique object identifiers 
number entities match description depend capabilities agent implementation agent perceptual system amount noise perceptual process 
designer take note role depends 
means information agent gets entity associated role effects information agent entities associated dependent roles 
occurs role parent task roles child subtasks 
example street cross street depends crosswalk cross crosswalk watch cars crosswalk important part street defined side crosswalk 
position information crosswalk effects agent notion position street 
primarily occurs task uses properties entity tasks task role associated entity portion entity example assume drive store task car role car driven pre drive inspection contained check tire subtask tire role 
dependence role car role tire flat car un 
agent may store fact car car role indication 
fact tire flat stored tire role 
note roles dependent role check tire task separate roles car tires 
car dependent tire roles 
dependency need symmetric car depends state tires state tires determined just car car gas 
identifying dependencies important representation design representation structured communicate information dependent roles 
return issue section 
roles context dependent meaning derived agent current situated activity defined section tasks simple reusable 
agent needs walk number destinations keep executing walk task just change entity associate destination 
available task context designers create tasks need perform inferencing environment see section discussion inferencing tasks avoided 
semantic meaning object associated role pre defined task actions pre defined 
semantics roles allow designer situational control rules flexible 
roles bound different entities task treat 
general trade flexibility task bind roles different entities situatedness task 
restrictive task specific objects bind roles designer optimize task operate entities 
entities task bind roles easier reuse task different situations 
particularly important agents planners tasks agent execute determine operators planner considers 
fewer easier plan course fewer tasks need implemented 
deciding task roles may easiest designer start task roles leaf nodes decomposition hierarchy 
see leaf subtasks tend executed responsive layer agent architecture places strict time constraints amount processing done 
computationally straightforward nature leaf subtasks means task roles usually easy identify 
subtasks aptly described simple verb noun phrases grasp coffee mug open door 
summary designer identify task roles agent focus resources aspects environment important current task 
designing agents way addresses domain characteristic see section allows designer concentrate agent processing dynamic environment impossible monitor 
identification objects environment fulfill roles important information objects structure remaining steps methodology 

representation task roles role bindings shared tasks 
recall task role entity binding refers agent having selected entity environment play specific role current task 
task actions take place object 
example pour coffee task cup role 
agent selects particular cup set cups fit task role perceptual description considered bound cup task role entity filled coffee 
sharing refers roles different tasks associated object 
refers dependent roles hold different information different abstraction entity 
designer remember tasks levels decomposition hierarchy may share roles 
information entity bound task role needed task 
roles useful develop explicit representation 
explicitly representing task role means data structure exists hold information previous question entity bound task role 
see section discussion implicit vs explicit representation 
task role information verified 
agent check stored information valid 
remainder dissertation term maintenance refer active process verifying validity piece information allocating perceptual computational resources task determining information 
maintenance information contrast storage information refers passively holding data memory 
refer deciding task role information verified deciding rate maintenance role 
example task representation determining role bindings shared tasks need examine task environment decomposition 
dog role occurs tasks walk dog surprisingly dog central agent purpose 
tasks dog role bound dog role binding shared 
route shown see agent needs pay attention corner crosswalk park roles time order accomplish walk dog corner cross street walk dog park tasks respectively 
roles shared tasks 
roles shared various subtrees particular task decomposition see consider subtrees detail 
walk dog corner consists controlling path dog leash navigating landmark named corner 
time agent keep lookout flowers possibly additional leash manipulation keep dog away 
corner walk dog corner physical corner walk corner corner shared parent child tasks 
dog corner important roles tasks active time flowers street 
flowers shared subtask creates role binding watch flowers leash control skill reel leash near flowers leash control skill reacts flowers bound pulling dog away 
obviously subtasks need refer flowers 
street keep dog street bound different parts street agent walks 
correspond portion street range dog current leash length 
roles flowers street shared subtasks subtasks try control dog respect flower beds keeping dog moving forward 
reader may ask keep dog street isn broken watch street reel near street manner keep dog flowers 
arbitrary decision am making mainly purposes discussion 
street cross street different street keep dog street 
street bound crosswalk corner area 
crosswalk shared watch cars crosswalk cross clear tasks agent cross crosswalk just determined free cars 
walk dog park similar walk dog corner park role shared parent walk park subtask 
street shared subtasks subtasks concerned different aspects dog motion 
final task walk dog play fetch dog 
dog shared role task subtasks ball 
agent throw ball retrieve dog ought ball cases 
chapter mentioned position entities bound task roles information agent tasks need 
agent tasks involve moving dog certain path getting close particular points flowers 
position information computed task roles 
designer consider shared roles explicit form representation 
dog role shared tasks subtasks domain argue represented 
dog position important top level tasks 
dog moving agent agent monitoring entities bound task roles street flowers having dog representation allow agent remember dog position dog seen 
information indicating dog position shared subtasks walk dog corner walk dog park 
providing explicit representation dog position allows sharing parallel subtasks passing dog information subtasks 
addition dog role corner role park role walk dog corner walk dog park tasks need form representation 
position entities fulfilling task roles drive agent locomotion system 
agent times monitoring dog street flowers directly perceiving corner park 
limited field view argument representation applies discussed section 
basically agent perceive street flowers time opposite sides sidewalk agent vision system covers limited area 
agent forget existence entities just looking 
case representation flowers street keep dog flowers keep dog street tasks similar positions entities leash effector control 
detecting entities tracking positions facilitates computation geometric properties proximity entities dog 
consistent psychological literature compelling reason represent entities limited field view argument 
street cross street task may need representation 
stated section street determined positions side crosswalk area 
watch cars crosswalk task agent needs able see entire crosswalk area street crosswalk time order sure cars coming 
important entities view duration task need represented explicitly 
cross crosswalk clear task may useful representation curb side street side park agent servo 
task runs parallel keep dog close agent may divert attention dog longer able perceive curb limited field view argument 
agent need represent street information street needed tasks 
needs represented get agent street crosswalk associated curb opposite side agent 
may ball play fetch dog need representation long dog fetches time 
throw ball open area assumes ball agent ball throwing effector get ball dog returns puts 
dog presumably carries ball mouth knowing dog position sufficient find ball get ball dog returns 
dog fetches ball agent need concerned ball lands thrown play fetch dog subtasks need store information ball 
agent walk dog task ball launching effector say carrying ball representation useful store ball known fixed locations launcher thrown 
agent need represent open area dog go get ball 
ball thrown agent need know information area fact new open area selected loop fetch task information stored particular open area useful long 
designer consider rate representation verification 
agent uses positions entities effector control agent needs verify positions rate close possible rate effector control 
rate needed changes important environmental entities detected responded quickly practical 
consider dog position mentioned information known entity associated role called dog 
agent executing street task example pull leash strength proportional distance entities associated dog street representations entities far apart 
keep dog moving forward involve monitoring dog position pulling leash dog front agent 
effectiveness agent leash control depends effective monitoring dog position 
positions entities associated corner park feedback effector control loops information verified rate loops issue effector commands 
verification ball position done position fixed locations thrown transitions states take place known times occur agent actions 
agent computational perceptual resources verify information representations rate effector control verification design done 
agents limited perceptual field regardless computational resources verify information stored representations perceive relevant entities 
designer trade offs timeliness formation cost shifting perceptual resources different areas environment 
walk dog corner subtask parallel activities 
recall agent walking corner keep dog street side flowers 
agent switch verifying position entities associated corner dog street flowers 
position corner street flowers change respect agent due agent motion agent estimate locations proprioceptive sensors 
reasonable algorithm update position flowers dog right side agent street dog left side 
obviously dog monitored cases 
bindings street flowers change agent moves necessary monitor associated entity position dog opposite side sidewalk entity currently bound role unimportant time dog crosses 
agent periodically check position relative corner 
done opportunistically dog walks front agent dog corner field view accuracy proprioceptive sensors dead reckoning known inaccurate cross street task agent trying bind car large object moving crosswalk 
suitable length time car bound agent trying bind moving street 
agent representation curb side street corner side crosswalk trade monitoring dog watching servo point cross street 
agent just move forward street width watch dog 
walk dog park trade verifying information dog park dog corner walk dog corner 
agent update park position opportunistically dead reckoning inaccurate 
play fetch dog agent need monitor position ball dog retrieve 
fact agent may monitor dog going come back ball 
case agent just needs perform search local area determine dog returned 
representation rationale task roles variables associated bound entities world variables bound values program 
roles useful save association recompute needed 
saving association refers having internal representation data structure stores information entity bound task role 
representation powerful tool agent designer share data tasks provide perceptual continuity time distance 
examine sharing roles tasks multiple tasks roles associated object sense share single role binding maintaining binding 
role sharing principle reason having explicit representation role 
discuss advantages disadvantages representation detail 
creation maintenance role entity bindings large part computational load sensor effector control component agent architecture recall discussion pa systems section 
designer reduce load advantage multiple tasks binding subtask need go binding process 
parallel subtasks emergent behavior scheme effect entity 
pour cup coffee task requires pot aligned cup tilted correct angle 
tilting aligning tasks occur parallel refers pot 
task role entity bindings shared sequential tasks 
pour cup agent grasp coffee pot handle remove pot machine alignment pouring task 
pot role bound object task sense 
task binding binding subsequent tasks 
caution reader thesis uses consistent names roles shared tasks 
words tasks share role role name task 
designer abstraction see multiple tasks roles filled entity tasks share binding 
imagine skills pour cup coffee agent designed different teams 
skill removes vessel coffee coffee machine represents coffee container role named pot skill vessel cup represents coffee container role named designer sure pot associated object 
exam 
note implicit roles need taken account coding agent various behaviors 
implicitly represented roles agent decide actions 
task calculate information entity fulfilling implicit role just won store 
ple imagine pour cup coffee agent designers borrowing skill previously created agent poured glass juice 
juice pouring agent skill called pour pitcher glass pitcher glass roles 
pour cup coffee agent designers skill sharing binding pot role remove machine pitcher role pour pitcher glass decision information particular entity important task obviously depends needs task 
walk dog example positions entities important agent actions proximity various objects close dog street 
close dog car coming 
fact argue position fundamental piece data needs stored kept date represented entity domains interest thesis 
stated section agents designed methodology meant act dynamic domains current sensor data relevant previous sensor data 
tasks addressed thesis involve robots navigating reacting changes environment 
order determine environment agent needs know look position direct perceptual resources properties determined 
say tasks may need data entities 
example drive store task task specification agent stopped traffic light monitor color signal 
agent brake effector control process may monitor color object associated traffic signal role release brakes turns green 
designer decided information object associated role 
analogous software reuse 
needed task role representation considered 
role representation benefits 
representing task role allows agent deal limited field view 
limited field view argument representation says important entities outside agent sensory field task represented agent doesn just forget 
example walk dog agent vision system limited field view perceive roses street simultaneously 
representing position flowers street matter agent looking react stored data dog suddenly bolts 
note information task needs know entity stored entity representation 
traffic signal representation drive store agent just store signal position agent find agent looks away waiting red light change radio station 
signal color may stored turns green agent releases brake longer concerned signal 
advantage representation occurs role shared 
role sharing comes different forms 
multiple tasks act respect entity representation allows tasks share role data structure cost creation maintenance 
form occurs dependent roles identified section 
form role sharing refers sharing information entity bound role effects information agent entities bound roles 
representation useful tasks manipulate data structures dependent roles reflect new information roles representation minimum communication tasks 
roles represented time task wants information entity bound dependent role gather data tasks roles task role depends 
depending architecture communication expensive 
roles represent properties environment roles depend 
example bowl apples role may store fact entity associated apple role inside entity associated bowl role apple bowl roles just store positions entities 
dependent roles represented properties expensive compute agent able store result time 
designer think representing task roles beneficial 
costs associated representing representing 
issues heart questions information bound entity represented information verified 
proponents reactive approach argue world best model needs stored internally 
information determined consulting world necessary 
implicit argument relevant entities kept sensor range true particular task designer may consider representing task roles 
computing piece information current sensor data requires continued allocation perceptual computational resources 
information stored representation information agent access associated entity viewable expensive maintenance 
agent strike balance amount information stored rate verified agent finite computational power 
way deciding task roles caused designer focus agent tasks currently important selection entity information stored verified serves focus tasks 
designer note agent capabilities obviate need representation role 
example dog walked walk dog task gps transmitter collar agent gps receiver dog need representation effectively sensor range 
deciding information needs verified task dependent 
time usefulness trade high rate maintenance high usefulness data computational load 
recall rate maintenance refers piece information verified 
higher rate maintenance piece data useful data expensive terms perceptual computational resources 
note maintenance need periodic 
information may sufficient verify agent schedule computation jobs 
traditional reactive systems place emphasis usefulness information pay maximum computational price 
methodology advocates examining agent task capabilities determine acceptable rates maintenance 
fact exists possibility certain pieces data verified current sensory view 
trade complex decision 
entities associated represented task roles agent perceptual field rate verification presents computational cost 
entity move perceptual field motion agent agent direct perception system different location order verify information entity 
means important entities may longer view information maintained computational cost 
maintenance arbitrarily complicated possibly involving planning 
going downtown verify grocery store extreme example 
designer create maintenance scheme procedure keeping representation verified required rates balances task needs date information computational cost limited sensory horizons areas perceivable sensor time 
factors important representation maintenance opportunism effector vs non effector control 
opportunism refers agent happening get entities associated multiple task roles perceptual field simultaneously 
agent designed take advantage dog walks front dog walking agent agent see corner dog view 
representations updated time 
effector vs non effector control refers piece information stored role role task directly control effectors purpose 
reel leash near flowers task uses position dog flowers directly compute commands leash effector hard pull direction 
pieces information agent may compute entities associated task roles may effector control tasks 
deciding pot coffee determine pour cup coffee agent proceed pouring action directly influence motion agent effector 
sort non effector control data typically need verified effector control data agent designer bias maintenance process agent time spent verifying effector control data 
majority agent maintenance computation devoted effector control data role representations leaf tasks store non effector control information 
tasks non effector control data excess baggage maintenance slow task operation 
order understand consider information stored role representation need verified point 
doesn information unaffected dynamic nature environment benefit explicitly representing 
agent designer design knowledge agent tasks implicit role 
role data needs verified rate verification determines usefulness role information task effector control tasks expend effort maintaining non effector control information 
obvious representation deleted task completes providing represented role shared task 
representation longer useful agent maintain deleting representations reduces agent maintenance 
role shared tasks designer may want agent delete role representation sharing tasks executed closely time 
required recreate re bind representation maintain representation tasks sense delete representation 
representation summary designer decide task roles explicitly represented agent control program 
main reasons explicit representation provide information important entities outside agent current perceptual field share data 
address domain characteristics see sections provides symbolic model tasks help control agent provides means deal large scale space 
argued piece information stored role representation position associated entity reason direct agent perception system entity determine information 
takes advantage domain characteristic agent coarsely estimate positions 
designer decide appropriate representation maintenance scheme 
balance usefulness stored information currently relevant entities amount computation involved establishing information 

perception information agent extract environment recognize entities bound current task roles 
agent perceptual capabilities form baseline identify environment 
capabilities task dependent information encoded perceptual descriptions task roles associated recognition processes 
term primitive recognizable pr denote entity set entities agent match directly perceptual description 
directly means object recognition agent perceptual capabilities combinations relationships separately recognized entities 
duration various role entity bindings effect perception system 
level detail resolution required information representation 
resolution refers precision data stored representation 
example task perception simplicity exposition specified dog walking agent perceptual capabilities directly identify entities fulfill task roles see task specification 
dog ball corner park flowers cars directly recognized agent perception system prs 
street relationship 
see keep dog task accomplished keeping dog away closest curb identified agent sidewalk edge detector 
flowers come types roses see agent able recognize 
watch flowers task involve looking roses looking back roses perception system need handle multiple perceptual descriptions role 
tempting say open area throw ball open area recognized lack entities agent wishes keep dog away flowers cars 
negative recognition processes problematic agent finds object conflicts open area description may entities 
agent want throw ball open pit just flowers cars 
negative processes similar prolog negation failure model agent determine known objects area area determined open 
kinds prob lems perception systems autonomous agents seek eliminate 
agent perceptual capabilities allow identify necessary entities environment means agent capabilities deficient best designer aware issue 
designer examine duration role entity bindings roles involved 
clearly dog role longest binding duration length task 
corner park remain bound length walk dog corner walk dog subtasks 
street flowers bindings change agent moves street 
crosswalk subtasks cross street remains bound duration tasks ball subtasks play fetch dog 
designer take advantage fact dog binding lasts long dog position speed perceptual computation determines position 
refers processing limited portion input image entity known position 
dog correspond dog agent need look large area potential dogs initial binding 
true corner park 
fact environment dynamic entities kept view simultaneously may cause strategy modified slightly 
agent looks away position entity time may examine larger entire portion perceptual stream returns view entity estimate entity position may incorrect expanded search may necessary 
street flowers roles foveated roles potentially rebound flowers parts street agent dog move 
crosswalk cross street task remains bound entity curb entirety task foveated tracked 
ball need foveated agent continually track position position stored launcher thrown 
designer address level detail needed representation information 
task roles agent needs know position associated entity 
role landmark corner park crosswalk accuracy position value accuracy position stored roles leash control dog street flowers 
starting landmark general distance direction useful 
agent dead position landmark meaning accuracy position estimate decrease 
coarse metrics effective domain mentioned section provided agent periodically verifies estimates vision system navigate landmarks 
dog moves accord street flowers bound different entities time estimating positions proprioceptive sensors risky 
course agent just say dog view corner corner location needs verified agent believes estimate corner position longer trusted understanding limits dead reckoning capabilities 
lastly mentioned ball position stored states fairly course level detail 
level acceptable agent simple ball launching system 
perception rationale step seeks impart structure agent perception system agent task capabilities 
ultimately agent perception system charged creation maintenance bindings task roles entities environment 
computational demands maintaining task role information dynamic environment means designer carefully structure perception system efficient 
step process consider task specification agent capabilities determine information agent extract perceptual stream recognize entities bound task roles 
ways topdown bottom process creating task decomposition 
roles perception come top descriptions particular objects fulfill agent capabilities detect description 
words walk dog agent associate dog role mailbox just easily detect mailbox 
hand perception roles car watch cars crosswalk thought bottom manner 
capability agent combined find cars 
agent motion detector reasonable identify cars bumper detector parked non dangerous cars 
iteration task decomposition role selection steps may necessary entities possible fulfill role detectable agent 
ultimately agent identify objects act tasks agent capabilities insufficient 
example task capabilities determine perceptual data recognition process role consider mole agent task specification 
agent ability detect localize motion determine color 
agent identify mole brown object game surface 
alternatively mole fast moving object game area 
task specifies game contains perceptual description suffice motion computation proceed rate pop 
note case mole pr 
designer may need recognition processes detect entity bound role variety reasons 
task roles filled single objects bowl apples role fulfilled bowl apples correct spatial relationship 
designer thought combinations relationships objects fulfill roles identifying dependent roles section 
example consider agent task specification task pick covered pot stove 
agent may specialized pot lid detector identify vessel cover single object pr 
hand agent identify pot lid separate prs lid identified pot lid 
agent determine position pot handles pick task agent identify pot location handles handle position necessary information task effector control 
times multiple perceptual routines needed perception objects particularly compound objects objects consisting individually identified entities situation dependent 
consider lamp 
task play mole game mole pops set holes agent hit goes environment game surface holes brown hole agent mallet effector hit perception system detect motion color task specification 
mole agent may able identify individually lamp socket relationship perceived overhead underneath perspective 
similarly penny top empire state building appear small perceived ground seen 
important issue objects change perceptual characteristics assembled 
knife wooden knife set holder appearance separate knife put holder knife handle visible 
sugar cube dropped cup water looses cube shape 
course categories perceptual difficulties different 
problems result fact objects look different different states 
different state may result object different location penny different spatial configuration light bulb partially occluded knife physically altered sugar cube 
effect agent may need multiple perceptual descriptions object recognize object different situations 
designer decided entities associated task roles recognized necessary optimizations considering effects role entity binding duration required precision stored information 
optimizations vital operate effectively dynamic environment 
examine duration role entity binding agent needs monitor entity bound task role long period time may advantageous foveate entity detect changes entity properties needed tasks 
agents task pick covered pot stove environment stove pots picked handles lid agent grasping effectors vision system task specification 
pick covered pot means tracking entity position 
reducing area perceptual field searched decreases time needed determine needed entity information 
increases potential update rate entity representation tracking means entity move faster relative agent agent loose 
role bound different entities duration task foveation may useful agent need examine larger portion perceptual field entities bound task role 
example suppose play mole task consists single subtask hit mole 
mole role rebound variety different game 
limiting mole search process single mole hole allow agent hit get low score 
may cases agent currently bound entity examines larger portion perceptual field entities bound task role 
instance agent may implement hit mole current mole monitoring hole 
long mole agent continue hit action particular mole 
time agent processing current visual field bound mole role current mole hit hole 
determining binding duration long depends execution time various tasks 
long binding durations arise different situations 
single task long execution time binds role stays bound entity large portion task duration 
second way role long binding duration shorter sequential tasks share role expect bound entity 
course long execution time large portion ill defined basically role bound agent need look appropriate entities bind role foveation target save processing time 
question section addresses fact tasks need precise information entities bound roles tasks 
information determined multiple sensors 
example position object determined vision sonar 
sensors provide coarse data data analyze 
sensors precise larger perceptual field 
sensors detect certain environmental properties 
sonar provides positional information data typical robot sonar system coarser visual data 
typically covers larger perceptual field 
proprioceptive sensors provide small amount information size perceptual field concern 
designer needs examine precision requirements create representation maintenance scheme 
designer determine different sensors determine information develop strategy allocating sensor resources 
walk dog example agent combination proprioceptive sensors vision maintain representation 
done agent visual resource acquire task relevant entities time lower accuracy sustained entity view manageable 
answers question designer decision required rate maintenance see section define basic classes role maintenance requirements 
shows space role maintenance requirements divided quadrants precision maintenance frequency 
exactly designer decides constitutes high low precision maintenance frequency depends agent task relative needs various tasks agent perform 
placing needs particular role classes help designer create appropriate representation maintenance scheme agent 
additionally quadrant divided classes design decisions discussed apply finer divisions 
quadrants follows 
quadrant contains roles associated information needs verified frequently information precise roles put constraints agent maintenance scheme require largest amount time high accuracy sensors 
example dog walk dog needs camera trained possible position needs verified frequently camera agent precise position determining sensor 
quadrant represents roles need verified require precision 
information accurate 
agent perform worse inaccurate information correct information 
issue information 
position specified small region agent localize entity 
frequency maintenance high low required precision high low 
categories role maintenance requirements information contain 
hopefully agent just precise sensor handle roles precise sensors tied maintaining roles quadrant 
example agent chapter avoids obstacles sonar 
sonar provides coarse position estimates obstacles compared visual estimate position agent destination provided agent camera avoidance task need precise information anyway tries circumvent obstacles squeeze spaces 
roles quadrant need updated infrequently need contain precise information 
roles ones depend roles hold abstraction information dependent contain 
example pot role pour cup coffee task needs store pot position task amount coffee pot 
amount coffee precise tell cup poured need checked new cup 
roles category vie time precise sensors roles quadrant 
designer create scheme quadrant role data occasionally computed bulk time spent determining quadrant role data 
quadrant contains roles need updated frequently need contain precise information 
may tasks roles fitting category designer advised consider roles really need explicit representation 
roles category may contain information needed scheduling planning system information may need determined may need held representation action oriented portion agent architecture 
example role stores answer question raining quadrant agent believes rain showers quickly data need frequent updates true false time agent concerned hard raining precision important 
stored representation type information sent planning system stored scope 
computational dimension representation maintenance computing arbitrary information take arbitrary amounts time 
agent wants verify complex property entity high rate high precision computational power designer little help 
brings question effector vs non effector control information section 
computational difficulty determining role information effect categories roles 
roles quadrants effected computation slowed rate agent resources available verify data 
roles quadrant store information expensive compute updated infrequently agent need schedule computation interfere maintenance 
roles quadrant problematic maintenance computation needs done environment loss cycles role updates causes agent events 
anytime algorithms determining required properties environment allow designer trade offs precision computation time 
amount time available allocated roles information desired precision relative roles 
course scheduling anytime computation np complete issue addressed thesis 
addition compositions system components different anytime algorithms guarantee system behaves anytime algorithm 
perception summary general designer want roles leaf tasks task decomposition fulfilled prs easily maintained rates commensurate effector control loops implement tasks 
may cause designer iterate deciding entities fulfill task role entities prs 
step designer decide agent perceptual capabilities recognize entities fulfill various task roles 
represented roles leaf tasks decomposition hierarchy important entities bound roles prs representations maintained effectively 
duration role entity bindings allow perception system foveate area bound entity decrease processing time 
level detail required particular data allows agent allocate resources needed 
designer may go back previous step methodology task decomposition selection task roles try redesign current representations maintained required precisions rates 
considerations meant address domain characteristic see section characteristic places demands agent computational power ability react 

communication information important inter task relationships 
words data computed task needed 
section roles shared tasks identified role information clearly exchanged tasks 
point important think data information stored role representation section tasks may need exchange 
results actions previous tasks progress tasks system examples 
example task communication walk dog task kinds information communicated tasks domain 
information environment roles store mentioned various descriptions tasks 
tasks obviously communicate position information entities associated roles 
communication takes place parallel executing tasks base actions information subtasks walk dog corner walk dog sequential tasks depicted 
subtask walk dog corner executing maintains position stored corner 
task complete information communicated cross street help establish initial position crosswalk 
cross crosswalk reports final position crosswalk stored crosswalk cross street completion information move walk dog park 
determine agent trajectory park 
dog maintained tasks time completes executing role information provides task position continue monitoring dog 
tasks communicate perceptual descriptions binding information entities bound bound roles 
domain roles bound entity perceptual descriptions entity built tasks 
perceptual information communicated 
consider flowers role 
watch flowers bind flowers role flowers sight percep tual description flowers communicated reel leash near flowers 
useful shown farther back road roses dog leash near 
watch cars crosswalk task needs communicate fact car role bound object trying time 
triggers cross crosswalk clear 
example suppose agent programmed descriptions dogs walked 
walk dog task pass description current dog subtasks turn pass description leaf tasks 
binding dog dog created subsequent tasks perceptual description maintain dog position agent may examine smaller portion sensory stream 
addition passing information entities bound task roles tasks tasks exchange notion confidence information 
example keep dog street task observing dog confidence position stored representation high 
may allow watch flowers walk corner tasks redirect agent vision system try verify flowers corner roles 
confidence function time agent acquired role entity vision system provides means implementing representation update algorithm discussed section 
tasks communicate data indicate task action result 
agent tasks just need report success failure task sequence needs decide failure 
specified happens task fails dog tired task failure test means continue playing fetch 
imagine agent sophisticated abilities deal failure 
action results determine task execute 
example agent walk dog corner dog break free run away 
agent continue street try get dog back 
note position corner sufficient determine success failure corner task 
agent reached corner longer dog 
progress reports communicated item represents task estimate proceeding goal 
form communication occurs tasks executing parallel 
example avoiding mailbox route corner see accomplished walk corner task 
agent process avoiding obstacle task notifies keep dog street street view watch flowers flowers vice versa depending direction avoidance 
walk dog corner walk dog park tell keep dog moving forward avoiding obstacles dog forced obstacle 
communication rationale purpose step help designer structure task role representation 
information communicated tasks part role representation entities bound role actions taken entities 
intimate relationship actions entities actions take place objects world arbitrary points space 
course humans capable actions seemingly relation objects world grasp air hardly sort actions allow robots useful 
actions sense effect physical world roles action specific descriptions physical world stance somewhat succeeding chapters situations agent sensors detect needed entity 
examining types entity information tasks exchange support actions designer determine data needs role representation designer determine structure role examining communicated tasks 
obviously information entity associated role questions section communicated tasks need know accomplish action 
addition principle classes role information tasks may need communicate 
perceptual descriptions actions confidence progress 
classes role information summarized follows 
perceptual descriptions routines associated recognition processes examine sensory stream entities possess described characteristics 
entities fulfill role 
descriptions exchanged parent child tasks 
tasks particularly leaf tasks reusable allowing successfully operate number different entities bound role 
pour cup coffee agent needs separate skills manipulate tea cups operate cup role bound 
parent task typically information decide entity environment acted child task create appro 
admittedly engineering issue 
information communicated tasks role information efficient add information role representation strictly relevant role actions taken role 
example action requests results progress information internal state process executing action information entity world 
roles exist support execution acting processes leap say roles carry information need communicated tasks 
priate perceptual description communicate child 
child task bind role leaf task create new description appropriate child task 
consider pick covered pot agent task specification 
pick covered pot task pass perceptual description pot subtasks grasp pot task may break pot description pr descriptions handles passed grasp pot handles leaf task 
necessarily set entities match perceptual description child task may report information actual bound entity back parent 
example pour cup coffee agent may report cup role bound mug tea cup parent task determine coffee pot type vessel 
walk dog agent reel leash near flowers watch flowers communicate actual binding flowers role roses determine amount leash dog 
actions role information action performed results action 
role representation may may contain action performed portion action information depending implementation particular agent 
example agent may possess skill capable performing multiple actions roles passed 
agent grasping system able hold cup handle drink cup wash cup base invert 
agents multi purpose skills may need action information role representation 
skills require form parameterization agent current state see chapters examples 
action parameterization complex especially coordinating multiple effectors 
example agent arms snow may require separate parameters actions executed arm effector snow thrown left right 
action role representation contain results action just performed task determine outcome previous task 
may possible task determine results previous actions examining state world examining entity data stored roles results action dependent context executed may adequately captured role representation 
example agent tried open door failed door locked may want report fact tasks observing environment tasks determine action failed door closed 
may helpful action result stored role representation information determined inspecting environment prevents tasks having execute elaborate perceptual routines infer information known acting task 
addition ll discuss section doing lot inference hurt responsiveness certain tasks 
confidence denotes agent belief information stored role representation useful 
confidence valuable action helps determine allocate perceptual resources verify information low confidence select courses action operate entity confidence 
confidence defined number ways 
role associated entity agent field view designer may decrease confidence entity move proprioceptive sensors typically accurate direct perception 
confidence expressed measure entity matches role perceptual description 
example drive store agent may role particular street left turn 
agent approaches street may far away street sign 
agent confidence upcoming street sign correct street 
confidence just role bound case agent bound street sign role may sign agent really wanted 
chapters see examples confidence implemented agents different capabilities 
progress measure task proceeding 
progress tasks monitor communicating task 
tasks may adjust actions progress tasks 
example drive store agent may subtask handles navigation watches store 
navigation process general idea far store store actual position report progress store monitoring task 
monitoring task devote increasing time looking store agent draws closer 
course possible designer create tasks communicate information identified necessary task inter relationship 
information extraneous internal state task 
data task internal computations important elements agent environment stored task role representations 
internal data communicated tasks provides semantic information environment 
significant inference translation machinery built interpret internal state data task 
argue groups tasks communicate express important information environment actions role representations communicate common role structure 
creating role structures agent various tasks designer take account dependent roles identified section 
roles contain information depends information stored roles 
role information communicated tasks dependent roles part agent inter task communication 
means representation structures contain information form task dependent roles interpret order correctly update roles 
task communication appropriate role structures means establishing epistemological links dependent representations 
communication summary section discussed information communicated tasks 
tasks operate roles communicating information entities bound roles specifically represented roles unrepresented roles needed outside task 
leads proposal representation channel tasks communicate agent architectures representation communication 
section outlined structure role representation 
roles basic components call index property identify action confidence progress 
components summarized table 
point worth emphasizing index identify independent 
single entity play roles identify component index component change single role fulfilled entities index component remain fixed identify component changed 
example pour cup coffee agent throw away cup 
pour cup coffee task cup associated role cup 
throw trash away task cup associated trash 
example occurs drive store task different signs get assigned street sign role read street signs task 
table representation component summary component name component contents index task dependent label indicates representation role current task role name 
property information bound entity stored representation small amount identify perceptual description detect entity associated role sensory stream 
identify may contain perceptual data initial role entity binding information maintain binding 
action action agent wishes take respect entity bound role 
contains results action role action completes additional parameters needed action property component 
confidence measure agent belief information stored role representation correct measure usefulness 
progress denotes current ongoing action entity associated role proceeding 
representations walk dog agent component called component stores position bound entity 
term property different tasks especially different levels decomposition hierarchy may store different information representations 
role structure addresses domain characteristics 
roles designed carry information current task maintainable dynamic environment 
roles communication architectural components hold quantitative data environment agent sensor horizon 

architecture agent tasks laid architecture 
designer create architecture uses manipulates roles discussed previous sections 
example task architecture thesis targets multi layered architectures see section walk dog tasks divided layers 
tasks partitioned effectively representations designed far 
means tasks control effectors bind roles prs placed responsive layer pa layer 
includes leaf tasks figures 
tasks pa layer pa layer tight perception action loops keep representations bound prs date 
tasks may may pa layer 
tasks pa layer needs handle reduce agent reaction time 
tasks better second layer architecture activate pa layer tasks needed 
architecture rationale previous steps methodology guided designer choosing rep resent trade offs associated representation 
purpose thesis guide design representation architecture 
agents need architectures section discusses impact representation may structure agent architecture 
issue fundamental representation architecture design cycle time 
cycle time time task perceive environment including representation maintenance select action execute 
executing action necessarily mean running completion issuing effector commands move task goal current environment 
time perception action loop task choose new effector commands may continue previous action may start new 
representation designed maintained rate effective particular task representation 
impact architecture task executed architectural component rapid cycle time maintain task representation rates required tasks 
thesis assumes designer layered architecture architectures map nicely role hierarchies tend arise dependent roles represent portions environment different abstractions 
means role dependent roles layer role task higher layer 
property stored role typically expensive compute slow cycle time lower layer 
tasks require high rates representation maintenance executed pa layer tempered computational requirement maintenance 
tasks get slower maintenance probably executed layers architecture complex task pa lay er able execute layer slow ruin responsiveness tasks 
division tasks layers depend number engineering issues latency bandwidth inter task communication capabilities layers target architecture amount task inference computational power required 
communication issue effected representation 
tasks execute parallel share role communicate role information layer architecture intra layer communication generally higher bandwidth lower latency 
tasks different levels hierarchy communicate information roles different levels 
example suppose role depends role role tasks different layers architecture 
necessarily communication part maintenance role communication represents link roles 
designer want consider frequency communication placing tasks architecture way 
discusses methods automatically updating role role role updated scheme involves communication 
designer needs consider role information exchanged particular maintenance scheme 
roles tasks different levels decomposition different layers architecture lower layers architecture maintain important details needed effector control higher layers maintain data needs updated frequently 
architecture summary step agent designer try structure tasks decomposition hierarchy layers agent architecture 
step divide agent tasks pa layer non pa layer tasks 
pa layer tasks executed component agent architecture responsive events dynamic environment appropriately maintain tasks representation 
non pa layer tasks may divided layers number characteristics 
final structure non pa portion architecture determined implementation concerns latency bandwidth inter task communication computational power required 
methodology concerned design representation systems design agent architecture 
agent needs architecture step approaches question architecture design perspective representation effect 
final structure architecture engineering issue contribution 

post methodology completing methodology questions designer 
point designer layered system agent capabilities task decomposition 
designer know roles exist agent tasks entities agent environment fulfill roles 
knowing role entity bindings shared long bindings help designer decide roles need representation agent architecture 
answering questions information agent store maintain representations help structure agent perceptual system 
understanding information shared communicated tasks help determine flow information system 
flow information nature tasks designer partition sets executed different layers agent architecture 
point designer implement agent architecture effectively manipulate system representation designed 
agent perception abilities maintain information stored role representations agent architecture means exchanging task role binding information tasks different layers 

methodology summary section repeats important aspects methodology 
methodology meant answer questions agent representation sections directly address issues parenthesis answers questions sections may depend answers questions previous sections 
represented see section 
representation structured see section 
representation maintained see sections 
design answer questions answering questions methodology repeated 
agent primitive skills 
tasks decomposed sequential subtasks 
decomposed parallel subtasks 
task roles 
entities fulfill roles 
role bindings shared tasks 
information entity bound task role needed task 
roles useful develop explicit representation 
task role information verified 
information agent extract environment recognize entities bound current task roles 
duration various role entity bindings effect perception system 
level detail resolution required information representation 
information important inter task relationships 
agent tasks laid architecture 
final role structure developed methodology repeated table see section culmination arguments 
role structure addresses domain characteristics laid section roles designed carry information current task maintainable dynamic environment section table representation component summary component name component contents index task dependent label indicates representation role current task role name 
property information bound entity stored representation small amount representations walk dog agent component called component stores position bound entity 
term property different tasks especially different levels decomposition hierarchy may store different information representations 
identify perceptual description detect entity associated role sensory stream 
identify may contain perceptual data initial role entity binding information maintain binding 
action action agent wishes take respect entity bound role 
contains results action role action completes additional parameters needed action property component 
confidence measure agent belief information stored role representation correct measure usefulness 
progress denotes current ongoing action entity associated role proceeding 
specialized needs particular tasks section communication architectural components sections designed hold quantitative data section environment agent sensor horizon section 
chapter design methodology autonomous agent representation systems specialized tasks capabilities agent 
methodology series questions guide designer creating representation systems efficient effective dynamic domains 
agent designed design methodology laid chapter bruce 
bruce task play hide seek laboratory human controlled opponent 
shows bruce shows vehicles play time 
human hides vehicle game area see 
bruce search game area opponent attempt touch tag sight 
bruce spotted opponent human may drive away bruce 
bruce looses opponent chase examine nearby objects see opponent hiding 
bruce tag opponent wins game 
bruce built uva board 
possess 
bruce opponents chapter applying methodology bruce ought wrong people looking 
mark twain dependent drive wheels fairly coarse shaft encoders single color camera pan tilt platform bump capable detecting impact front left right sides 
onboard processing done pair motorola mc hc 
bruce radio modem communicate host workstation sun sparc processing done 
bruce video transmitter broadcasts images camera datacube mv image processing 
section examine bruce software architecture developed methodology thesis 
shows plan search game environment bruce execute 
numbers indicate steps plan solid line representing path follow 
dashed lines indicate direction bruce turn camera look opponent 
bruce field view shown near completion step 
shaded shapes denote objects game zone 
methodology steps answering questions design follow plan play hide seek emerges 

task decomposition agent primitive skills 
designer see capabilities combined black box skills bottom portion de box 
search plan home composition process 
bruce basic skills navigation location control camera pan tilt mount 
agent navigates location combining motor perceptual capabilities 
servo ing position location specific perceptual characteristics detected camera bruce move environment 
varying characteristics agent move variety static objects chase opponent 
tasks decomposed sequential subtasks 
decomposed parallel subtasks 
mentioned previously playing hide seek consists searching opponent chasing opponent tag possibly performing search nearby objects bruce looses opponent chase 
tasks shown subtasks play hide seek task control flow order execute shown 
note arrows denote flow control dashed arrows indicating control flow parent child tasks 
order search agent needs go landmarks looking opponent avoiding obstacles 
order view entire game area bruce need point camera certain areas environment need navigate 
search task search look drive watch turn backto occluder tag opponent play seek 
hide seek task decomposition move watch look consists navigation task move landmark obstacle detection task camera control task look region task monitors opponent watch opponent operating parallel 
shown subtasks opponent task 
tasks shown stacked ovals meaning look play seek search search move watch look look drive watch turn back watch watch 
hide seek task flow diagrams tag opponent operate parallel 
control flow arrows parent task show executing time move landmark watch opponent transfer control back parent execution tasks 
occurs bruce reaches landmark moving detects opponent 
opponent detected bruce chasing 
situation control flows search opponent task chase opponent task chase opponent task tag opponent task 
tag opponent task simply visual bruce opponent bruce bump detects impact opponent close bruce believes impacted opponent 
opponent escapes chased bruce look object vicinity bruce lost visual contact 
process handled look occluder task sequential subtasks shown right 
control flow shows sets parallel subtasks check opponent hiding nearby 
watch opponent task runs parallel task bruce switches chase opponent task opponent detected point 
looking objects bruce select object near opponent known position possibly occluding view opponent opponent hiding 
handled choose occluder task 
bruce drive relative starting location 
due mechanics bruce drive system going object involves moving rear drive wheels past object turning back face 
sequence performed drive past occluder turn back occluder tasks 
note watch opponent subtasks transfer control back look occluder tasks subtasks transfer control subtask sequence 
tasks sequential steps looking object watch occluder indicates different branch decomposition chase opponent take 

identify task roles task roles 
search opponent task roles opponent landmark region represent aspects environment important searching game area 
subtasks deal complexity navigation 
move task landmark obstacle roles directs agent influenced position goal landmark obstacles 
detect obstacles task obstacle role 
watch opponent opponent role associate vehicle bruce tag look region region role corresponding area game environment bruce look 
chase opponent tag opponent tasks opponent role tasks concerned driving opponent 
various subtasks look occluder choose occluder drive past occluder turn back occluder occluder role 
drive past occluder task role called intermediate target mentioned task name 
role associated object bruce estimate position relative occluding object see 
shows task decomposition diagram annotated task roles 
roles shown bold occur task name callout boxes 
entities fulfill roles 
roles search portion hide game landmark opponent region obstacle 
landmark role played various times various objects agent search route see 
opponent role played bruce opponent dump truck game 
true opponent role chase opponent subtask 
region role filled portion game area bruce needs look 
fact role better described neck angle specific features environment 
obstacle role filled object direct path bruce current navigation goal 
look occluder portion game occluder intermediate target roles filled object correct position 
occluder object approximately azimuth closer known position opponent intermediate target associated object side occluder away occluder plus bruce length 
allows motor control system move landmark task search roles opponent landmark region look choose occluder drive watch opponent turn back occluder chase opponent play seek 
hide seek task roles move watch opponent look region detect obstacles tag opponent roles landmark obstacle roles occluder roles occluder opponent re servo bruce intermediate target 
time passed occluding object reaches intermediate target 

representation task roles role bindings shared tasks 
bruce task simple 
landmark region opponent roles shared search opponent child tasks move landmark look region watch opponent respectively 
obstacle role detect obstacles task shared move landmark task task calculates move agent wheels landmark obstacle roles 
opponent role shared watch opponent chase opponent tag opponent look occluder tasks 
see watch opponent tasks decomposition hierarchy transition parent task transitions chase opponent task 
opponent binding shared bruce chases detected vehicle 
occluder role shared subtasks look occluder task choose occluder drive past occluder turn back occluder information entity bound task role needed task 
domain agent navigate environment searching opponent 
tasks move landmark detect obstacles look region tag opponent occluder turn back occluder need positions entities associated roles control agent effectors 
watch opponent choose occluder determine initial positions objects associated roles pass data tasks 
important information entities associated task roles domain position 
chose store positions ego centric polar coordinates cause agent capabilities position estimates relative current location accurate position estimates relative external frame 
words position computed information gathered sensors mounted agent turned agent centric position simple transform shifting current camera pan angle translating sensor position center agent body 
positions converted coordinate frames maintaining positions frames requires special sensors knowledge positions multiple landmarks triangulate 
bruce able see landmarks encoders error prone successful ego centric system 
roles useful develop explicit representation 
landmark opponent occluder roles benefit explicit representation bruce may take action respect outside field view 
move landmark task may landmark outside current field view representation role allow bruce moving 
task benefits role representation opponent may drive outside bruce field view chase bruce may able reacquire opponent turning direction seen 
object bound occluder role necessarily go outside bruce view look occluder task specifically drive occluder 
occluder role needs representation bruce execute turn back occluder task occluding object visible completing drive past occluder task see 
intermediate target role need representation shown played object sight agent 
obstacle avoidance en route cause intermediate target fall outside bruce field view representation role useful 
region role interesting object environment agent bind role described head angle pan camera search opponent 
head angle just parameter look action role needs representation 
opted represent role order uniform communication structure parent tasks children see section discussion communication interface 
representation obstacle role interesting issue causes iteration representation perception steps methodology 
bruce vision system mis identifies obstacles false positives 
obstacle role representation may take longer agent realize binding incorrect take stateless system 
classic argument representation put forward brooks opponent goal obstacle agent occluder field view 
obstacle avoidance look occluder intermediate tar 
stateless system store information re evaluate environment wishes act 
means forget previous erroneous percepts minimum possible time 
system state representation may continue decisions previously determined incorrect information 
argues obstacles representation misidentified may cause bruce avoid empty space 
due limited ability camera pan obstacles go outside bruce field view shown step 
obstacle representation bruce invariably hit obstacles flank camera past drive wheels 
argues representation local space 
designer choose representation obstacle role try improve perception choose role representation try improve navigation control algorithm avoid obstacles outside field view 
bruce representation compromise 
obstacles detected certain distance away bound obstacle role bruce navigation system take position account cycle pa loop 
allows bruce somewhat fooled far away false obstacles 
obstacles close bruce bound obstacle role represented pass outside camera field view 
clearly multiple obstacle roles bruce avoiding obstacle see obstacle blocks new path 
bruce simple visual avoidance algorithm avoid obstacles try move goal 
part thinking designing bruce obstacle avoidance routine stateless system capable handling avoidance 
representation needed remember obstacles passed outside field view 
thesis design representation systems significant effort spent designing routine avoid multiple obstacles 
obstacle role bound bruce avoid obstacles role unbound 
task role information verified 
positions entities associated roles control bruce effectors wheels camera platform verified rate effector control loop 
role maintenance scheme simple 
agent needs know position landmark occluder depending current task plus obstacle order navigate 
attempt detect opponent times 
pass active task effector control loop agent verify position entities associated current task roles attempt bind opponent role 

perception information extracted environment recognize entities bound current task roles 
bruce perception system consists single color camera signal transmitted board receiver processed combination datacube mv image processor sun sparc 
hardware supports primitive visual operations speeds high support bruce task edge detection color histogramming 
bruce visual identification routines straightforward availability operations 
bruce finds ground non ground boundary shown 
large vertical discontinuities line may represent boundaries objects note sprite 
object identification accomplished comparing color histogram pixels pairs discontinuities stored histograms various objects 
comparing truck histogram histogram pixels discontinuity pair discontinuity pair bruce determine pair delineates truck pair 
designed bruce necessary histograms recognize landmarks appear search path opponent chase 
obstacles detected objects pair discontinuities closer bruce current goal direct path goal see appendix section navigation system works 
bruce able determine positions entities associated task roles 
ground plane constraint states ground flat horizontal plane objects world rest ground 
constraint allows bruce calculate distance object smallest distance bottom image points object discontinuity boundaries 
known camera geometry relate distance bottom image depth 
bruce computes azimuth object position image camera known angular field view pan angle 
polar coordinates azimuth depth ego centric meaning agent coordinate pair discontinuity pair 
image opponent tem origin 
bruce tasks consist moving objects world search chase works fine leaf tasks 
main search task convert landmark coordinates stored bruce game area map egocentric coordinates navigation vice versa 
discuss appendix duration various role entity bindings effect perception system 
binding duration roles bruce tasks determined 
particular designer interested roles long binding durations 
words roles stay associated object long periods time bound different objects infrequently relative task execution time 
single definition time long time relative agent perceptual capabilities binding changed execution time agent tasks 
general ways role long binding duration 
single task role remain bound entity duration execution long time 
bruce landmark region intermediate target roles move landmark look region drive past occluder tasks respectively 
roles remain bound single object duration task uses 
second means having long binding duration sequential tasks share role expect bound object 
opponent occluder roles shared multiple sequential tasks tasks expect role bound entity 
role domain short binding duration long obstacle role 
cycle bruce perception action loop detect obstacles task bind role object obstacle bruce current destination object object obstacle time 
catch long binding duration obstacle goes outside field view front mounted camera hit bruce body rear mounted wheels 
obstacle close edge field view role remain bound bruce remembers location past 
binding duration information structure perception system 
bruce visual processing divided classes location tracking 
location process role initially bound entity environment 
tracking processes information entity bound task role maintained 
roles remain bound entity duration task bound opponent occluder roles remain bound multiple tasks 
means bruce save significant amount visual processing regions space occupied entities bound task roles 
case means limiting visual processing particular region image 
principle location tracking processes completely different mechanisms identifying objects image 
presumably location process slower accurate tracking process tracking process context previous position assistance 
bruce uses exact visual operations edge detection color histogramming location tracking 
tracking faster discontinuity boundary pairs far known position object matched object stored histogram 
means fewer objects need analyzed computation proceed faster 
difficulty process scheme associated object moves tracking fovea 
words happens associated object moves faster expected agent moves slower goes field view 
bruce needs means identifying tracking process failing failed activate location process 
simple thresholding amount match stored histogram histograms objects detected suffices purpose 
histogram matching process modified version swain ballard terzopoulos 
produces percentage match value equal number pixels matching color histograms divided total number pixels see section appendix details 
score low bruce disable tracking process location process start look occluder task 
level detail resolution required information representation 
question answered primary subtasks play hide seek 
search opponent task information position various landmarks obstacles regions point opponent 
effector control want accurate possible 
means bruce estimating dead reckoning positions little possible implying pointing visual resource objects possible 
obstacle avoidance impossible keep obstacle destination agent body current heading view time 
bruce looking objects effecting navigation possible understanding trade offs long important object seen see discussion confidence section 
chase opponent task similar opponent position effector control accurate possible 
means bruce keep camera trained opponent possible 
look occluder task different needs occluder roles 
intermediate target object selected spatial relationship occluding object 
bruce physical layout front camera rear wheels means successful navigating point fairly straight front point object maneuver 
point moving object object typically seen camera estimated position object inaccurate 
bruce selects intermediate target navigates certain distance correct position relative occluder execute turn back occluder subtask 
bruce afford reduce accuracy estimate occluder position concern intermediate destination object specifically chosen purpose getting bruce certain position relative occluder 
needs accurate knowledge occluder position turn view area remember really interested finding occluder opponent 

communication information important inter task relationships 
play hide seek task divided groups communicating subtasks 
examining group discover role information communicated tasks 
search opponent task moves bruce game environment attempting find opponent 
task opponent landmark region roles communicates watch opponent move landmark look region subtasks respectively 
search opponent task gives move landmark task perceptual description landmark bind landmark role maneuver agent associated object 
gives watch opponent subtask description opponent opponent role task bound detected trigger switch chase opponent task 
look region subtask receives description position region look hopes watch opponent task bind opponent role agent looking 
search opponent task communicate perceptual data subtasks various landmarks regions bruce needs concerned task 
words move landmark task include hard coded perceptual information agent route plan dictate landmarks agent move 
having search opponent task pass role information subtasks subtasks reused execute leg search route having different leaf task landmark region 
fact agent play hide seek game different opponents see watch opponent task parameterized opponent perceptual description 
parent task know opponent search communicate subtask 
important kind data communicated search opponent subtasks action input output 
input means parameters task needs perform action output means results actions 
move landmark moves agent certain tolerance landmark 
tolerance determined search opponent insure bruce stops correct position perform look region example 
move landmark reports reached specified landmark supplies landmark current ego centric position 
allows search determine agent location map environment decide ego centric position landmark visited 
note landmark current position computed information task needs know entity associated role section action result just boolean value action completed successfully action failed position communicated 
watch opponent look region tasks receive configuration information perform actions task role communicates success failure parent task watch opponent signals success failure binding binding opponent role 
note detect obstacles communicate parent task 
part search task abstracted away search opponent task 
communicate move landmark task binding obstacle role 
role landmark determine effector commands sent wheels landmark 
examine inter task communication chase opponent task 
chase opponent task consists single subtask tag opponent 
tasks communicate perceptual description opponent opponent tagged result chase action 
addition tag opponent task communicate information decide control transfer look occluder task 
call information confidence represents agent belief stored position opponent correct 
long binding opponent op ponent adequately maintained tracking function finding opponent camera images confidence stored opponent representation remain high 
opponent slips outside field view occluding object opponent confidence decrease time chase opponent task transfers control look occluder 
look occluder task subtasks communicate similar perception action information 
choose occluder subtask job select object potentially occluding opponent opponent known position 
occluder role bound choose occluder task successfully completes perceptual description bound object passed parent look occluder task distributed task children 
drive past occluder turn back inform parent task completed respective missions getting tolerance object associated intermediate target facing occluder 
fact tasks communicate information parent task task sequence really decision results implementation control flow see section explanation 

architecture agent tasks laid architecture 
issue designer tackle determining tasks rapid perception action cycles bind roles prs see section require inference 
tasks executed agent pa layer 
typically processes control sensor effector 
table shows tasks sensor processing effector control 
leaf tasks hide seek decomposition control effectors shown number wheel camera mount controlling tasks table 
watch opponent detect obstacles control sensors need pa layer tasks representations pa layer tasks 
opponent obstacle prs tasks share roles expect maintained effector control rates opponent detect obstacles need pa layer 
tasks decomposition tree belong layers architecture 
search opponent task uses map game environment direct pa layer subtasks 
map global coordinate system different egocentric system store positions pa layer tasks 
search opponent uses different representation 
representation need updated place search opponent task layer architecture call task executor layer te 
place look occluder task layer sequence subtasks drive agent occluder 
control flow shown 
control flows parent subtask 
choose te charge activating deactivating processes pa layer markers 
reduces amount control flow pa layer need concerned 
similarly chase opponent task exists mainly allow switch table task controlling capabilities task name sensor effector controlled move landmark wheels drive past occluder wheels turn back occluder wheels tag opponent wheels look region camera mount choose occluder camera mount watch opponent opponent detection detect obstacles obstacle detection phases hide seek task searching chasing take place te 
shown search opponent transitions chase opponent chase opponent activates tag opponent pa layer task 
watch opponent directly transfer control tag opponent prefer control flow te 
bruce need planner play hide seek domain search plan execute play hide seek task root decomposition tree separate task implementation 
complex version game imagined play hide seek actual implementation third layer architecture 
suppose bruce chasing opponent longer locate 
point bruce continue current search pattern route planner compute new search route current location 
seek route planning task passed search plan search opponent 
new plan needed control transfer back play hide seek new plan generated 
task placed new layer architecture requires inference te layer tasks 
fact task requires full inference planning engine te layer tasks merely set context pa layer execute pre defined plans 
te tasks need inference capabilities preserve cycle time route planning task different layer architecture 

bruce implementation section describes result design process carried previous sections 
section details answers methodology questions combined 
generated search route bruce follow game layout shown 
form working autonomous agent 
remainder section organized follows 
describe agent pa layer representation operation pa layer main loop including marker maintenance 
describe actual pa layer behaviors achieve agent goals 
lastly discuss representation inter layer task communication 
bruce representation describe structures represent task roles pa layer 
representations called markers agre chapman 
information communicated tasks section marker components communicated information outlined section progress 
dependency list 
table summarizes contained various marker components dependency list 
summaries explained greater detail discuss marker maintenance general operation pa layer main loop 
table components bruce markers component name component contents index role name combination action see select current action pa layer action table 
property ego centric polar coordinates associated object identify divided locate track subcomponents 
color histogram object role bound amount match threshold declare match successful 
histograms match thresholds typically different region searched appropriate object different see 
bruce pa layer operates tight perception action loop 
pa layer uses representation representation maintenance part loop 
order understand maintenance algorithm pa layer loop introduce concept instantiated vs uninstantiated markers 
simply instantiated marker pa layer selected entity environment associate marker marker identify component 
uninstantiated marker marker associated entity 
uninstantiated marker reflects higher layer expectations world pa layer confirm expectations instantiating binding marker object 
example bruce completed step search plan see object field view 
landmark invocation move landmark task step te action index determine action take action table 
contains action result component store data parent task outcome particular action 
note component null indicating action take marker 
happens marker represents object part action indicated action component marker see dependency list 
confidence contains flag set associated object detected current image counter images passed finding associated object 
contains instantiated flag indicating marker currently associated object world 
dependency list list markers pa layer needed complete action specified action component 
tasks multiple roles executed 
marker action component contains action completes task task roles represented marker markers dependency list 
example obstacle markers placed dependency list landmark marker move landmark task 
table components bruce markers component name component contents layer search opponent task create uninstantiated landmark marker appropriate identify component 
move landmark task immediately detect object landmark marker contains ego centric position 
bruce move expected position comes view start running marker locate routine try detect object 
locate routine finds appropriate object associated marker marker said instantiated 
pa layer main loop purpose pa layer perception action loop select appropriate actions agent 
layers influence pa layer decision ultimately pa layer controls agent effectors 
pa layer actions closely coupled current perceptions 
bruce pa layer representation action selected function current perceptions information stored markers 
main loop proceeds follows 
executes maintenance algorithm instantiated markers tries instantiate markers remain uninstantiated 
pa layer examines action component marker executes specified action 
explain steps detail 
pa loop step update markers step verifies positions stored property component markers consistent positions associated objects world 
positions updated hypothesize test algorithm 
new computed 
recall section decided call component property position appropriate different agents may store different data representations 
object regions segmented section 
new positions objects associated markers hypothesized transforming positions stored markers wheel encoder values read update 
instantiated marker position falls agent current field view marker track routine analyze objects detected 
results track routine distance object marker stored position create ordered list detected objects likelihood associated marker 
instantiated markers run track routines object creates ordered list markers likelihood object associated marker differences hypothesized marker position detected object position 
ordered lists markers objects objects markers passed stable marriage algorithm determines marker object correspondences 
object selected marker correspondent position object stored marker property field flag mention confidence component table set 
object selected marker correspondent hypothesized position new stored position 
pa loop step instantiate markers instantiated markers updated uninstantiated markers matched objects associated instantiated markers 
transformed positions step agent proceeds similar matching process results markers locate functions track functions 
system biased markers instantiated object allowed correspond marker 
words instantiated markers get matched objects instantiated marker matched object supposed match uninstantiated marker 
bias allowed object associated instantiated marker presumably tracked time object associated uninstantiated marker expectations higher layers 
foveal image region searched track function contains matching object object corresponds instantiated marker uninstantiated marker 
perceptual context previously executions pa loop lead track function consider image region uninstantiated marker grounded perception 
bruce values perception memory expectations 
pa loop step select execute action updating markers pa layer looks list markers see action components actions 
searches list order executes non null action component finds 
action component specifies action done respect object associated marker 
pa layer access action database indexed action component index component 
actions database consists tasks executed parallel implementation parallel 
task implementation leaf tasks decomposition implemented behaviors skills called pa processes 
pa processes information marker containing action possibly information markers marker dependency list 
tasks started action component single marker 
table shows map ping leaf tasks marker action index components 
section discusses representation activates pa processes representation 
goto action landmark marker begins move landmark detect obstacles processes 
processes share landmark marker obstacle marker created order move bruce specific landmark 
bruce navigation system complex just processes described fully appendix details unimportant discussion 
look region chase opponent turn back occluder implemented single pa process activated various marker actions indicated table 
implementation processes unimportant effects amply described previous sections 
drive past occluder activated goto action intermediate destination marker 
marker comes te see section position goto action parameter occluder position 
parameter goto action re table mapping tasks activating marker components task name action index component activating marker move landmark goto landmark marker detect obstacles goto marker index look region lookat region marker watch opponent uninstantiated opponent marker tag opponent chase opponent marker choose occluder uninstantiated occluder marker turn back occluder occluder marker drive past occluder goto intermediate destination marker call parameters stored marker action component indicate close bruce needs get destination 
parameter position occluder marker close intermediate destination sure bruce turn see area occluder 
goto action pa processes implement goto navigate bruce position stored marker 
general need separate pa processes task example move landmark drive past occluder implemented ones 
watch opponent choose occluder tasks need implementing pa processes re handled step pa layer main loop 
occluder marker special locate routine allows bound object near position stored opponent opponent locate routine histogram truck car opponent 
parent tasks te monitor markers instantiated 
inter layer communication section describes markers communicate tasks te layer 
pa layer action completes pa processes associated action deactivated marker action component initiated processes passed te 
say merely indicate marker deleted pa layer te alerted look marker contents 
te response information reads markers usually create new markers pass pa layer 
action components markers cause pa layer new actions 
te layer may choose delete old marker pa layer completed task 
example landmark marker goto action completed deleted opponent marker instantiated 
goto lookat action completes meaning landmark reached region looked marker action result component set complete marker passed search opponent task te layer 
landmark region position relative agent current step search plan te process generates landmark region marker passes pa layer 
opponent marker instantiated agent executing tag opponent pa process opponent marker confidence assessed count number frames correspondent image 
number grows large tag opponent pa process exits placing target lost result code action result slot marker passes marker te chase opponent task 
task transfers control look occluder task 
look occluder task generates occluder marker passed pa marker instantiated te creates intermediate destination marker goto action 
begins drive occluder task 
task completes te places action occluder marker 
occluder marker deleted pa layer instantiation maintained drive occluder 
turn back occluder uses occluder position turn back face object 
opponent marker instantiated point executing task transfer control chase opponent task 
spot developed core technology projects texas robotics automation center houston tx shown 
represents building block number applications motivate describing spot context applications 
spot task robotic waiter 
imagined scenario spot cocktail party serving attendees 
waiter robot just get certain distance person served person take 
spot chapter applying methodology spot takes limits vision limits world 
arthur robot wish 
multiple people party spot keep circulating moving guests offering food 
seconds spot check new patron 
spot real world interface mobile base directed perception pan tilt camera platform mounted top 
cameras mounted platform grey scale cameras central color camera 
onboard pentium processor controls agent drive system wheels encoders pan tilt platform performing color image processing 
pentium mmx machine provides stereo imaging grey scale cameras 
addition robot agent architecture available targeted architecture 

task decomposition agent primitive skills 
order determine agent primitive skills need examine capabilities closely 
base supplied control software allow programmer set forward rotation speeds wheel base 
encoder values forward rotational movement accessible 
second pan tilt camera mount axes controlled positional control 
movements interrupted complete velocity control achieved setting axis velocity sending axis position limit direction 
stereo vision system available design process track objects dimensions virtual fovea known proximity spaces 
system receive requests start tracking objects positions current camera view outputs current positions tracked objects camera view 
positions relative center baseline cameras body robot 
proximity space system output object space area determine space lost target tracking 
built search behavior allows empty proximity spaces try reacquire targets randomly moving sphere target known location 
spot color vision system detect skin hues image 
spot provides examples capabilities build primitive skills 
agent combine wheel base motor encoder control navigate location 
second pan tilt mount referred head smoothly track targets rapidly redirect agent attention cameras 
agent monitor location entities proximity spaces detect patrons skin tone system 
tasks decomposed sequential subtasks 
decomposed parallel subtasks 
part spot task identify potential patrons humans maneuver 
follow track time 
move patrons try serve 
time return patrons served see want 
due fact spot able keep patrons served view time remember positions previously served patrons return 
task decomposition diagram shown task flow diagram shown 
serve patrons knows people served directs switch patron change agent attention 
occurs look patron moves camera pan tilt mount view requested patron identifies patron image 
attend patron moves agent certain distance patron tracking 
move patron accomplishes locomotion watch patron handles tracking 
serve patrons attend move switch patron look watch patron 
serve patrons task decomposition attend switch patron attend move watch patron switch patron look 
serve patrons task flow serve patrons 
identify task roles task roles 
task spot domain patron role person attended attended 
serve patrons task multiple patron roles directs subtasks switch agent attention associated patrons 
shows decomposition diagram task roles bold 
entities fulfill roles 
patrons domain humans 
serve patrons task initial idea people served located patron roles tasks filled humans locations 

representation task roles role bindings shared tasks 
tasks patron roles tasks designed operate human switch patron begins patron role tasks serve patrons effect patron 
patron role shared tasks 
serve patrons task multiple patron roles bound different patrons switch tasks decomposition 
serve patrons attend patron move patron switch patron look patron watch patron 
serve patrons task roles information entity bound task role needed task 
order move patrons agent needs know positions environment 
bruce position piece information needs computed entity associated task role 
spot stores coordinates tuple distance agent depth azimuth elevation angle 
roles useful develop explicit representation 
patron roles serve patrons task need representation associated humans view time 
likewise patron role switch patron lookat patron tasks needs representation patron agent wants switch attention may outside current field view 
patron role attend patron subtasks interesting case agent capabilities effect answer 
mentioned section agent proximity space vision system track entities associated roles 
proximity space fovea covering certain region space 
remembering fovea position essential perceptual computations performed data region 
information require representation patron roles data structures foveal positions stored 
stated section proximity space system tracks objects state needs stored internally 
vision system agent capability designer require role representation just store perceptual data 
tasks decomposition share patron role attend patron subtasks tasks representation role 
recall proximity space system outputs positions tracked objects camera image remember positions outside field view 
associated patron view attend patron task role represented representation shared serve patrons store position allows serve patrons switch patron get patron back view restart attend patron 
task role information verified 
bruce roles attend patron switch patron subtasks effector control verified rate effector control loop 
patron roles serve patrons task verified effector control rates associated humans probably view 
necessary patrons attended time 
spot needs verify positions patrons move far saw 
general spot check previous patron depends factors total number patrons served time persons expected stand group circulate 
spot task second time window attending patron part task specification 

perception information extracted environment recognize entities bound current task roles 
spot different visual systems disposal 
proximity space system 
system rapidly tracks contents small spherical volumes agent environment 
volumes contain texture patterns correlated stereo temporal image pairs 
recall proximity space system black box allows spot estimate position objects associated task roles placing proximity spaces reading positions proximity spaces track objects time 
interface proximity space system described section places constraints spot design 
need initialize proximity spaces 
system told start tracking object certain location agent determine location 
second agent architecture activate deactivate proximity spaces field view moves contain contain object tracked 
proximity space system reports locations head centric coordinates agent convert coordinates ego centric coordinates uses 
known field view cameras agent deactivate space ego centric position current field view 
agent architecture controls head tracking object agent move head point cameras location proximity space 
unanswered question proximity spaces get initially placed objects 
fact skill proximity space system requires skill initialize proximity spaces anticipated effects representation 
spot initializes proximity spaces color vision system 
recall spot single color camera find humans objects associated patron roles examining image red hues associated skin tones 
areas image respond skin tone filter matched constraint model human head arm positions 
successful match means human detected proximity space initialized location 
single color camera spot accurately derive dimensional position human 
spot search correct depth initialize proximity space 
conceptually color vision system produces vector color camera center head detected human head facial texture works proximity spaces 
human point vector 
proximity space system slides proximity space vector lands feature detected color vision system 
slide means keeping proximity space coordinates fixed slowly increasing depth coordinate distance agent proximity space 
lands refers proximity space detecting pattern track tracking process proximity space begins tracking finds texture match left right images believes volume occupied object 
proximity space system communicate fact particular space begun tracking agent architecture 
comprehensive description initialization process 
note humans prs agent capabilities needed maintain information proximity space system track fast effector control color vision system initialize proximity spaces 
duration various role entity bindings effect perception system 
duration patron role entity bindings domain length execution spot application 
human bound patron role agent maintain binding length party 
bruce long binding duration allows 
strictly speaking proximity space system black box knowledge inner workings initializing proximity space human head know heads trackable system technique 
proximity space system powerful capability designer provides benefits agent architecture 

additional constraint design agent head control initializing position space agent move head proximity space system moving new sphere space trying determine object depth agent 
head cameras move proximity space object triggered color vision system 
spot proximity space system tracking capability 
spot foveate entity proximity space active proximity spaces form foci attention agent 
long binding duration problems accurately maintaining collection patron roles 
patrons view time possibility patron move place agent saw agent attending 
general problem limited visual resource 
spot designed domain knowledge people parties stand groups don move 
provided interval times agent attempts view patron sufficiently small patron move known location 
moved somewhat proximity space system built search behavior may able find 
level detail resolution required information representation 
attend patron task requires position estimated position human patron operate 
task uses information control effectors keeping track dynamic moving targets requires accurate information available data proximity space system encoders 
switch patron task benefit accurate patron position estimate redirect agent cameras proximity space system reacquire patron 
patron visible time position patron role switch patron allowed accurate encoder 

communication information important inter task relationships 
order answer question review task flow depicted 
serve patrons task collection patron representations 
passes switch patron redirects agent attention human associated role 
control passes attend patron subtasks cause agent perform normal tracking spot uses attention 
point serve patrons patron task current patron select new patron 
serve patrons passes new patron role switch patron cycle repeats 
clearly information moved tasks includes position patrons 
tasks share patron roles exchange position patrons 
domain patrons humans identified skin tone detection tracked proximity spaces manner 
means perceptual information needs communicated tasks position perceivable dynamically changing data distinguishes entities domain 
proximity space system designer information needed track held tasks tasks exchange information initialize proximity space locations 
imagine complex domain particular patrons need attended distinguish clothing 
perceptual description clothing passed serve patrons switch patron allow initialize proximity space location attend patron 
imagine attend patron periodically checking proximity space perceptual cues verify space tracking correct entity 
piece information communicated tasks confidence agent position stored role representations 
confidence time agent associated proximity space view tracking proximity space system says proximity space lost target implying space view 
agent confidence role low agent seen associated patron long switch patron directed bring patron view 
role proximity space lost associated entity watch patron move patron controlling effectors space location 
proximity space system tries reacquire target attend patron subtasks just wait 
switch patron located human color vision system process searching proximity space serve patrons ask switch patron try acquire new target 
depending distance human agent proximity space initialization take seconds agent confidence role high time 
fact communicated serve patrons keep attentive focus human initialization complete 

architecture agent tasks laid architecture 
step identify pa layer tasks 
leaf tasks pa layer tasks control agent effectors bind patron roles prs 
attend patron switch pa layer tasks merely activate subtasks pass role receive serve patrons 
domain described specifies means selecting patrons agent confidence positions 
means serve patrons pa layer task chooses patron role send tasks significant inference just time patron seen 
spot tasks placed pa layer need multi layered architecture 
architecture target architecture robot rap layer see section 

spot implementation section describes pa layer representation results decisions previous sections 
discuss operation agent architecture show representation integral part 
spot uses architecture adopt conventions referring pa layer skill layer tasks execute skills 
spot representation agent tasks skill layer various patron roles 
patron role associated marker data structure similar bruce 
data structure contains index property identify action confidence components 
contents marker components summarized table 
table components spot markers component name component contents index task dependent identifier associated object role current task 
spot relatively simple domain set patron 
property dimensional ego centric position associated patron 
skill layer main loop skill layer main loop begins updating markers 
positions markers transformed encoder values read time loop 
markers positions inside field view position proximity space stored property component 
proximity spaces markers indicate associated entity view activated entities gone view deactivated 
confidence timers markers positions outside field view start continue counting timers markers positions identify locate routine handles skin tone model matching id marker proximity space proximity space system spot reads data proximity space system network form pairs 
coordinates proximity space placed property component correct marker id action requests activation skills possible values activates move patron watch patron lookat activates switch patron confidence instantiation state possible values instantiated marker associated object proximity space presumably tracking object uninstantiated marker associated object agent running marker locate routine partially instantiated object detected marker locate routine proximity space searching generated vector object timer counts time proximity space field view reaches seconds switch patron try reacquire marker bit holding proximity space system tracking target successfully recall part proximity space system output table components spot markers component name component contents inside field view reset highest value 
uninstantiated marker associated entity view locate routine run 
candidate location detected marker proximity space moved vector generated locate routine 
instantiation state marker set partially instantiated keep skill redirecting cameras 
proximity space lands target longer reports occupancy lost threshold marker fully instantiated 
proximity space reaches agent maximum depth failure reported agent architecture marker remains uninstantiated 
pa layer skills data stored markers drives skill layer agent architecture 
original skill layer responds skill activation deactivation requests rap layer 
modified skill layer main loop handle role representation spot markers maintained normal operation skill layer begins running active skills 
spot active skills called goto 
operation skills driven property confidence values markers 
goto controls agent wheels keep spot fixed distance human attending marker action 
run goto skill assesses humans associated patron markers spot attend markers confidence components 
way goto performs function serve patrons task 
marker human attended marker currently tracked goto skill skill new patron marker action compo nent lookat 
current marker partially instantiated state goto skill set marker action component lookat marker fully instantiated proximity space moved maximum depth proximity space system reports trackable texture 
handles look patron watch patron tasks 
marker lookat action redirect agent view marker position 
track location proximity space associated marker action 
marker position brought view lookat action sets marker action component 
final question skill layer execution begins 
rap layer activate goto skills place patron markers skill layer 
demonstration application spot begins rap system communicating skill layer passing patron markers estimates positions people 
markers lookat action allowing skill layer execute agent task 
summary spot architecture operates manipulating markers 
skills accomplish agent task communicating shared representation 
important characteristic spot representation virtue communication medium able integrate multiple sensory systems existing agent architecture 
marcus agent designed build structures blocks scattered lab 
navigate collect blocks move specific site assemble 
marcus plans build structures chapter designed context building arch 
marcus augmented nomadic technologies model robot see 
possesses wheel drive base encoders independently base rotatable turret ring sonar sensors 
color camera pan tilt mechanism mounted top deck 
computation performed onboard pentium pro system running linux 
marcus routines perform basic image processing operations 
marcus arch lab chapter applying methodology marcus confuse motion action 
ben franklin edge detection blob coloring image regions specific rgb values 
results image processing displayed user laptop carried top deck network connection internal computer 
marcus environment computer vision laboratory olsson hall university virginia nearby hallway 
various colored blocks placed environment map positions available marcus 
assembly site specified map 
map shown 
arrows represent approximate paths marcus travel building arch numbers represent order paths followed 
marcus starting position assembly site represented various blocks represented colored rectangles 

marcus environment portion olsson hall hallway furniture assembly site door door starting position spanning block fastener block hallway 
task decomposition agent primitive skills 
marcus executes plan build variety primitive skills 
marcus control camera mount pan tilt position approximately hemisphere front camera 
marcus independently rotatable wheel base turret decouple hemisphere direction motion mount rotated changing positions pan tilt axis move camera see 
marcus possesses skills navigate location implicitly orienting base possibly turret rotate base turret face location camera mount point wheel forward direction 
speech synthesizer give directions human assistant 
marcus grasping effector discussion operations require effector picking things putting things performed author 
addition area top deck designated toolbelt 
carry move camera view objects placed 
monitor sonars reading current range data 
typically thought skill agent possesses assembly planner planner generates assembly instructions structures agent build 
remainder design process involved creation agent execute plans 
tasks decomposed sequential subtasks 
decomposed parallel subtasks 
order analyze marcus task examine plan marcus executes build arch 
task decomposition diagrams figures show top level steps arch building plan 
steps 
thesis concerned planning creation planners 
planning capabilities marcus limited planner outputs single plan build arch 
decomposed collections subtasks shown figures 
notation top level plan step task indicates contains subtask decomposition details section 
notice number plan step tasks subtask decomposition tasks trying accomplish nearly goals 
task flow diagrams tasks appendix figures 
remainder section describes task decompositions task flows 
arch building plan figures start design process decomposition flow pre defined 
table provides high level summary tasks marcus perform build arch 
location column refers marcus indicated travel path number shown 
show tasks marcus needs location multiple table rows location 
table marcus top level decomposition summary location task performed start go purple block path search base block yellow green go base block path pick base block search fastener block go fastener block path put fastener block toolbelt search assembly site path doesn typically move get put base block go top block path plan linear series steps flow diagrams 
interesting decisions designed plan known capabilities marcus 
ex pick top block go assembly site path stack top block base block go fastener block near door path turn view door go door path search block stack hallway go block stack path pick stack go door back lab path search stack previously built assembly site go stack path determine orientation pose stack determine agent relative position put stack hallway position relative stack site search spanning block go spanning block path pick spanning block search fastener near door go fastener near door path turn face stacks assembly site go assembly site path determine pose stack built assembly site determine agent position position second stack span stack second stack spanning block table marcus top level decomposition summary location task performed ample marcus gets base block path moving purple block path 
base block visible marcus starting point easier navigate furniture block waypoint obstacle avoidance get goal agent see 
similar manner going door leads hallway going back assembly site getting spanning block marcus instructed go fastener block near doorway 
due detectability landmarks cases 
marcus perceptual capabilities easier get final destination moving easily detectable red fastener block looking nearby area door stack blocks try detect final destination far away 
final point marcus picks fastener block path needs build stack assembly site 
part definition marcus domain stacks assembled held fastener 
plan steps table decomposed subtasks shown figures 
plan steps represent actions different parts environment describe decomposition plan steps general terms sections discuss subtasks specific context executed 
plan steps broadly classified categories locomotion manipulation building dealing doors 
tasks categories described tables 
search base block go block go block pick block search go put toolbelt go block pick block go site stack top base block go rotate go stack go stack pick go door 
top level task decomposition marcus search block pick block search go rotate go stack go stack determine stacks pose put stack relative stack go search rotate span item spanner find item find topblock item find topblock item span topblock spanner move topblock topblock view watch spanner cross topblock topblock find base stack item item move item view watch item 
locomotion building task decompositions marcus pick pickup effector move view watch put put move view watch put toolbelt pick move view watch check item put item relative item put determine move view calculate 
manipulation task decompositions marcus align hall door watch baseboard alignment center move equidistant walls rotate item turn item find watch door hall necessary align turret go door door move rotate view door find door door rotate table locomotion task descriptions task name description go destination moves agent specific destination 
consists parallel subtasks navigate destination moves agent wheels destination look destination turns camera face destination avoid obstacles navigation control steer objects blocking agent straight line path destination rotate destination turns agent wheel base turret face particular location consists subtask turn destination rotates agent body face destination search item find item detected marcus estimated 
consists sequential subtasks turn destination rotates agent face position item look item moves camera fixed positions relative agent turret see item detected table manipulation task descriptions task name task description pick item picks item agent carry 
consists subtask followed parallel subtasks move item view moves agent position item viewed means backing 
needed marcus manipulate objects needs visually determine manipulations completed 
pick effector asks human assistant pick item draws mark agent laptop screen indicate item watch item pick monitors item removed view 
situated task see section removal item view assumed due item having picked 
note decomposition pick item tasks moveto item view variants tasks necessary marcus single camera determine distances non stereo cues 
case constraints bruce 
important see put item puts held item certain location 
consists subtask followed parallel subtasks move view moves agent position location item put viewed put effector asks human assistant put item draw mark agent laptop screen indicate desired position human watch item put monitors item appear view specified position put item toolbelt picks item places agent top deck location designated toolbelt 
consists subtask parallel subtasks subtask move item view pick item pick effector asks human assistant put item toolbelt position robot top deck draws mark agent laptop screen indicate item watch item pick pick item check toolbelt item watch item pick determines item removed view task looks toolbelt position see item placed put item relative item places object position specified coordinate system object 
determines position put item function position item uses put item accomplish 
determine determines orientation object relative agent 
consists sequential subtasks move item view pick item calculate item pose determines orientation item relative canonical orientation table manipulation task descriptions task name task description item meets floor point image determine distance item marcus thinks 
may necessitate moving wheels possibly backing 
table building task descriptions task name task description stack item item create towers blocks 
consists subtask followed parallel subtasks move item view pick item stack effector asks human assistant put item top item draws mark agent laptop screen indicate item watch item item detects item placed top item span item item spanner places object tops objects 
consists sequential subtasks find base item determines position base item find topblock item determines position block top construction item find base item determines position base item find topblock item determines position block top construction item span topblock topblock spanner see span topblock spanner note subtask span item item spanner consists subtask followed parallel subtasks move topblock topblock view moves position topblock topblock seen camera image spanning effector ask human place spanning block topblock topblock watch spanner cross topblock topblock detects spanning block adjacent span item item spanner complicated tasks marcus perform 
stage involves finding appropriate parts item item spanned 
marcus domain item item constructions blocks parts interested finding top blocks item 
task defines spanning crossing top blocks third construction called spanner 
order find top blocks marcus executes task find base item item similarly find base item find topblock item 
reader confused names find base item find topblock item 
constitutes base top block specific kind structure consideration names imply blocks necessarily lowest highest blocks structure 
marcus spans structures towers establishing position tower base allows accurate positioning camera find top due constraint 
structure collection blocks placed side side top structure whichever block connected spanner base block aided determining block top 
table door task descriptions task name task description find go moves agent lab hallway 
consists sequential subtask move door determines door view moves agent 
control transfers rotate view door 
rotate view door changes agent view rotating body set positions door estimated position 
transfers control back move door rotating 
possible orientations tried task transfers control back find go door reporting failure 
move door note subtask find go door consists subtask followed parallel subtasks find door searches image door 
control transfers subtasks goes rotate view door track baseboard monitors door position hallway baseboard see section move door drive agent door rotate view door note subtask find go door consists single subtask rotate destination discussed table find go door moves agent hallway lab 
consists sequential subtasks align hallway rotates agent camera wheels facing wall door go center hallway moves forward backward agent middle hallway facing wall rotate base hall door turns wheel base turret camera mounted perpendicular wall agent facing direction door find hall door moves agent hall door scanning wall door frame align base turret moves wheel base point door frame go hall door moves agent door final class tasks deals moving doors marcus domain 
aspects decompositions tasks initially thought necessary 
fact separate tasks needed move agent door align hallway note subtask find go hall door consists parallel subtasks rotate hall door turns agent direction wall door watch baseboard alignment detects hallway baseboard horizontal image meaning agent roughly facing straight wall center hallway note subtask find go hall door consists single subtask move equidistant walls uses agent sonar determine position wall front agent moves positions roughly equidistant rotate base door note subtask find go hall door consists single subtask rotate base item turns agent wheel base align item turning turret task subtask called turn base item handles moving find hall door note subtask find go hall door consists parallel subtasks followed single subtask watch hall door monitors wall door frame move hall door moves agent hall door estimated position 
attempts keep agent certain distance wall help see door open hall door necessary checks door closed asks human assistant open 
monitors door opened 
go hall door note subtask find go hall door consists single subtask move door move door find door table door task descriptions task name task description different sides anticipated 
issue situated routines specifically situated perception 
door appears different different sides factors agent having detect door closer range hallway lab unpredictable nature visible open door hallway opposed lab 
details door detection provided section 
important point intuitively similar tasks executed different situations need take account advantage situations different task decompositions 
second unanticipated aspect door task decompositions find door task 
agent alternates trying detect move door rotating new position change agent view door 
strategy thought necessary door detection routines created see section 

identify task roles task roles 
marcus arch building task complex tasks previous agents task roles complex 
roles entities effect agent actions task 
usual task role diagrams appear appendix figures section discuss reasoning 
remainder section describes roles tasks figures roles plan step tasks 
general reason particular task roles definition roles see section belief actions take place objects see section 
words task roles objects associated roles entities effect outcome task 
example go destination task fig ure maneuvers agent specific location environment 
destination role location destination determines goal point agent 
likewise destination role navigate destination look destination subtasks tasks handle wheel camera control move look destination respectively 
avoid obstacles subtask obstacle destination roles obstacles effect agent movement destination 
task designated handle steering obstacle position destination 
similar logic role effects actions taken task applies roles marcus tasks reiterate argument 
discuss tasks roles obvious task name interesting relationships roles roles roles parent task 
roles obvious name task 
example find topblock item find topblock item tasks topblock topblock item item roles base role 
base determine look topblock kind structure item associated 
example effector tasks pick put spanning stack tasks ask human assistance perform various jobs need know various portions environment refer request 
pickup effector task item role item pick item task know item ask human example pick purple block draw mark appropriate point image laptop screen 
put tasks put item put item relative item roles denote position item placed 
ll see shortly tasks need role receive instructions plan steps share subtasks 
vein align hallway task hall door role rotate hall door subtask needs told direction hall door information ultimately comes plan step task 
tasks move agent doors go hall door move find door move door destination roles mentioned task name 
task concerned moving agent door specific destination 
case find door task bind destination role object move door operate 
important aspect roles marcus tasks certain roles dependent roles 
important notice instances actions effect entity associated role effect entity associated dependent roles 
means agent receives information entity may need change information entities reflect 
example find base item item subtasks span item item spanner base item item roles 
interesting aspect base sub component item item 
words item associated stack blocks base associated block bottom 
item associated single block base just block 
similarly topblock topblock roles item find topblock item associated different sub components item item topmost block 
epistemological link tween roles happens bottom top block structure effects structure blocks connected 
role dependencies exist subtasks find go hall door task 
dependency exists hallway role center hallway task front wall back wall roles move equidistant walls subtask 
front wall back wall sub components hallway walls define hallway 
similar dependency exists baseboard role watch baseboard alignment hallway role parent task align hallway 
angle baseboard tells agent hallway alignment relative agent 
dependencies represent sort link roles exists item base 
information front wall baseboard effects information hallway 
dependency hall door role roles find hall door subtask see appendix 
due marcus perceptual capabilities discussed section 
put item relative item role computed configuration information plan step put item relation item item role 
means dependent item 
effects just empty spot assembly site information effect item 
creates situation roles mutually dependent 
dependent item item dependent 
final interesting issue roles tasks roles tasks 
important domain knowledge place roles 
example put item toolbelt task toolbelt role 
toolbelt special exists agent person location known 
put item toolbelt task put item location just pre defined toolbelt 
single toolbelt need know information object world dynamic toolbelt properties maintain contents 
task toolbelt role toolbelt effects task 
toolbelt merely represents piece domain knowledge encoded task 
similarly align base turret task find go hall door task roles 
task wheel base turret wheels pointing direction camera 
roles aspects environment influence current task task requires knowledge agent body sensed roles required 
point roles tasks plan step tasks figures explained 
roles plan steps straight forward shown figures appendix reason tasks roles reason roles tasks figures roles roles entities environment tasks designed effect 
entities fulfill roles 
answer question strongly impacts plan steps figures 
roles tasks bound specific objects environment order correctly execute plan 
example block role go block task step plan filled purple block 
correct execution plan requires role bound specific object perceptual routine written recognize object recognize set objects 
size set depends perceptual routine environment 
important remember possible marcus bind role incorrect object object environment correctly fill role 
recovery errors arbitrarily difficult depending far agent gets error begins effect plan execution 
document address error recovery design representation systems 
path 
remainder section divided parts 
part provides table describes objects meant fulfill roles plan steps 
table refers path numbers environment diagram 
second part discusses objects fill roles plan implementation tasks figures 
section looks roles tasks light agent capabilities provides insight effect roles plan step tasks may design implementing tasks 
table entities environment fulfill roles plan step tasks plan step task name role bold entity fulfills role go block purple block path search base block block path see go base block previous pick base block previous search fastener red block path go fastener previous put fastener toolbelt previous search assembly site position path put base block block picked path assembly site role position path go top block purple block path pick top block previous go assembly site base block assembly site stack top block base block stack created referred stack assembly site stack assembly site top block purple block path base block yellow block assembly site go fastener red block path rotate door door path goes roles plan step tasks filled specific objects environment 
exception base block role starting second step plan 
role bound yellow green block map indicates yellow block path marcus door previous search stack purple green block stack path go stack previous pick stack previous go hall door door path goes search stack stack assembly site go stack previous determine stacks pose previous put stack relative stack stack stack picked hallway stack previous search spanning block green block path go spanning block previous pick spanning block previous search fastener red block path go fastener previous rotate stack stack assembly site go stack previous determine stacks pose previous span stack stack spanning block stack previous stack second stack assembly site spanning block green block path table entities environment fulfill roles plan step tasks plan step task name role bold entity fulfills role mation 
knows base block get 
section discusses perception base blocks detail 
looked roles marcus plan steps examine entities play roles tasks implement steps 
roles parent tasks figures root node decomposition typically filled object environment section discusses specific objects selected 
example destination go destination entity agent needs move 
reason roles tasks filled objects tasks meant executed times various plan steps different situations properly 
exceptions door hall door door tasks filled doors 
entities fulfill roles tasks level abstraction root tasks 
example obstacle role avoid obstacles subtask go destination task filled object blocking agent path destination 
span item item spanner task base topblock topblock roles meant filled lowest block stack highest block stack highest block stack respectively 
find go hall door task number additional roles need bound 
subtasks hallway roles played hallway olsson hall 
baseboard role watch baseboard alignment subtask bound baseboard strip olsson hall hallways portion hallway nearest agent side hall hall door 
front wall back wall roles equidistant walls subtask played entities reflect agent front rear sonar presumably walls hallway 
destination role go hall door move door subtasks played point door frame case door frame 
move door destination role played baseboard strip door hallway 
similarly baseboard role track baseboard played portion baseboard visible door 
destination find door played position side door passed move door maintains position baseboard 
observations roles leaf tasks marcus decomposition figures entities fulfill roles depend agent capabilities 
marcus manipulate blocks example item role pick effector subtask pick item filled single block 
true item roles leaf subtasks manipulation tasks pick item put item put item toolbelt putdown item relative item determine item pose 
roles building tasks figures filled single blocks 
base topblock topblock roles span item item spanner subtasks obviously meant bound particular blocks extent structures bound item item roles 
spanner spanning effector played single block task uses marcus manipulation capabilities 
similarly item role stack effector subtask stack item item manipulated agent 
marcus manipulator fact human decision somewhat arbitrary 
allows illustration hierarchical representation separate information data pertinent known different components agent architecture 
effector played block 
parent tasks leaf tasks restrictions roles 
example marcus needs able pick stacks blocks item role pick capable bound stack blocks 
section discusses item role bound different entities parent child tasks 
marcus domain shows entities fulfill roles influence design tasks 
plan steps tasks meant implemented tasks figures reused plan designer want implementing tasks general possible 
means able operate roles bound different entities various situations 
designer may domain constraints know possible entities task asked bind role 
knowledge designer apply situated skills 
trade efficiency situated skills inflexibility novel situations 
marcus sorts trade offs implementation tasks figures 
example go destination task flexible operate entity bound destination role 
find go hall door task flexible operate properly hall door role bound door olsson hall 

representation role bindings shared tasks 
examine roles shared tasks role sharing primary motivation developing representation role discussed section 
common forms role sharing marcus task sharing roles plan step tasks locomotion building manipulation door tasks figures 
sharing specific plan created general tasks agent execute 
type sharing arch building plan summarized table appendix example go block go block tasks block base block roles respectively 
tasks implemented go destination task having destination role associated object block base block role 
key understanding form role sharing marcus task realize previous agents marcus actual plan shown task decomposition figures 
bruce example follow route plan changing bindings destination role move destination task task decomposition applies plans execute 
complexity structures marcus skills allow assemble impractical create task decomposition encompasses possible plans 
means needs standard way specific manipulations denoted plan case arch building plan implementing marcus general purpose assembly skills 
done mapping roles plan step tasks roles tasks figures 
example go block task implemented go destination task having block role destination role go destination task refer object 
various forms role sharing exist tasks decompositions figures 
consider go destination task decomposition 
observe tasks destination roles 
means destination shared role tasks need bound entity 
important classes role sharing exhibited 
sharing parallel subtasks 
subtasks benefit role sharing having maintain independent copies role information 
second parent child role sharing go destination shares destination children 
benefit information stored parent task abstracted role child task 
words roles parent child tasks bound object different information entity bound role may computed task 
parent task may wish provide child task portion information knows entity order simplify computation done child 
clear examples discussed 
consider role sharing tasks 
search item task notice search item look item item roles 
role shared task turn destination task 
recall names roles need tasks share role 
destination role turn destination played entity playing item role turn destination rotate agent entity camera far observe 
reader may question task called turn item answer task designed subtask rotate destination 
see tasks destination roles share 
fact destination tasks name inconsistent cases 
tasks mentioned far exhibit parent child form role sharing mentioned 
form role sharing occurs tasks figures 
sense parent task accomplished subtasks acting respect entity playing role parent task 
noted understood roles parent task shared subset children 
interested readers easily see sharing task role diagrams appendix figures similar names parent child tasks indicate shared roles 
reader may noted parent child role sharing similar plan step implementor task role sharing 
block go block bound object destination go destination bound object destination navigate destination 
important issue tasks may retain different information entity associated shared role binding 
important form role sharing observed center hallway subtask find go hall door task 
task hallway role subtask front wall back wall roles 
hallway role combination roles move equidistant walls subtask 
position entities playing front wall back wall roles combine form agent notion position hallway relative agent 
hallway role store hallway position abstraction information subtask roles 
form role sharing multiple roles possibly multiple tasks shared single role task occurs roles dependent roles discussed previous question 
role combines data roles view entities associated roles 
degenerate case number roles combine role equivalent parent child form role sharing 
different information different abstraction contained role 
example item pick item task may bound construction blocks item subtasks bound single block agent maneuver respect order view impending pick 
agent capabilities force item role subtasks associated single block designer information pick item item role determine block structure bind item role 
roles shared way need representation representations linked information bound entities captured representations see section 
remainder answer question concentrates shared roles parent task 
span item item spanner task subtasks containing base topblock topblock roles 
base role occurs find base item find base item tasks bound different entities case 
base remains bound long establish position topblock topblock 
base shared find base item find topblock find base item 
topblock topblock roles bound entities find topblock tasks span topblock topblock task blocks spanned roles shared 
put item relative item task interesting role item subtasks 
entity playing item role establish role 
role needed put item subtask item 
hall door role find go hall door task appears subtasks 
tasks attempt bind role move agent respect role associated entity 
tasks need hall door associated entity role shared 
subtasks align hallway center hallway concerned agent position relative hallway hallway roles share 
interesting hallway role appear shared task subtasks 
hallway role align hallway defined terms baseboard role watch baseboard alignment 
hallway role meant played hallway building visual feature recognized task baseboard 
marcus aligns hallway turning baseboard appears horizontal camera image 
information current angle baseboard determine information current alignment hallway 
purposes task hallway baseboard form shared role 
hallway role hallway actual combination front wall back wall roles subtask discussed 
final example role sharing find go door task 
subtasks move door destination role representing location agent consider door 
find door determines location detecting door determining position 
tasks share destination role 
baseboard role track baseboard subtask associated recognizable feature position determined 
find door binds destination baseboard seen door tracked 
means baseboard destination bound entity shared go door subtasks 
likewise rotate destination subtask rotate door shares binds destination role entity door role form shared role 
door object agent wants facing natu rally destination agent rotation 
summary seen types role sharing 
sequential parallel tasks roles bound entities 
second occurs information entities bound roles tasks effect entity bound role task 
occurs roles parent task subtasks parent holding view entity bound role hallway defined sonar readings front back walls 
information entity bound task role needed task 
question examines information entities bound task roles needed tasks 
information role sharing determine role explicitly represented agent architecture 
vast majority tasks position associated entity needed 
discussed chapters previous agents position needed determine information entity needed direct perception system 
exception align hallway subtask find go hall door 
task needed orientation hallway relative agent 
position hallway relative agent important fact subsequent center hallway task deal agent position 
interesting tasks determine item pose put item relative item 
require position pose entities associated roles 
determine item pose uses position item determine pose put item relative item uses pose calculate 
tasks require positions entities bound roles positions may different forms 
discussed chapters previous agents section accurate maintain positions objects ego centric coordinates 
tasks figures ego centric positions control effectors 
agent effectors fairly centered body cylinder origin ego centric system coordinates natural way control 
agent raw sensor data easier convert ego centric coordinates non ego centric coordinates information environment needed estimate ego centric coordinates non egocentric coordinates require external points triangulate 
contrast roles plan steps specify positions entities associated non ego centric coordinates 
entities involved plan perceivable agent starting position agent needs position data source plan routes 
positions encoded map relative map coordinate frame 
map contain ego centric positions objects agent known starting position orientation maintaining positions accurately arch building task extremely error prone marcus able see objects time positions dead reckoned 
effective map coordinate system fixed origin transform coordinates ego centric coordinates new objects pertinent agent task 
marcus mechanism doing discussed section appendix roles useful develop explicit representation 
answers previous questions help determine roles explicitly represented 
look roles tasks figures 
roles tasks need representation entity associated role field view 
roles destination go destination item role search item destination rotate destination hall door go hall door door find go door 
recall destination turn destination subtask played entity plays item search item representation virtue fact item represented 
important reason represent roles due role sharing 
shared roles representation ways 
multiple tasks take advantage binding maintenance role sharing physical data structure 
means task needs binding maintenance just read shared data structure 
second representation shared roles assist inter task communication 
discussed detail section having explicit representation allows tasks communicate information entity environment 
roles span item item spanner task representation shared subtasks parent task 
example topblock topblock roles bound different tasks passed span topblock topblock spanner task shares subtasks item item roles similarly shared parent tasks bind topblock roles 
spanner represented shared different tasks different levels decomposition 
base find base item shared find topblock item find base item find topblock item 
somewhat artifact decomposition imagine find topblock item task internally computed base position determine topblock position base computation invisible outside task 
task decomposition created role needed representation dependency base item item means representation base useful place pass information portion item item find topblock tasks 
item item roles stack item item represented due fact shared subtasks parent task 
argument applies item role pick item put item toolbelt determine item pose item roles put item 
item roles put item relative item represented facilitate communication child subtask remember item maps item child 
item role necessarily need representation needed compute position 
may useful represent item passed task plan step 
marcus represents item 
hall door role find go hall door represented typically outside field view task fact extensively shared subtasks motivates representation remember maps item role rotate base item door role move find go door task door role shared subtasks role needs representation 
destination role door task representation forms shared role destination find door position initialized baseboard track baseboard position maintained 
roles marcus tasks appear need representation 
represented various reasons 
destination role move door subtask find go hall door may need representation played entity visible door agent moves room 
destination representation shared go hall door task determines destination position hall door 
destination just point space goes types entities associated roles section agent needs dead state needed hold far agent moved 
done agent sure visible door easier just dead room 
door role need representation move door task task door sensor range 
agent sense necessary information door edges door frame sonar 
information maneuver agent door difficult maintain door position azimuth information provided sonar fairly coarse 
agent really concerned getting destination point need try maintain door representation 
door role task associated environmental feature effects task execution represented task 
interesting door represented maps hall door represented 
contradictory remember agent need information hall door destination hall door conceptually maps door designer need communicate information hall door task needed 
case representation remaining roles find go hall door subtasks hallway baseboard front wall back wall clear cut 
hallway role common different subtasks really exchange information hallway 
subtask concerned orientation agent agent position 
aspects hallway sensed complete tasks different subtask sensory data contribute 
hallway role probably require representation 
note contradictory previous discussion hallway role shared role case arguments representation particular role 
case hallway representation data associated roles subtasks needed outside subtasks placing form hallway role unnecessary 
baseboard watch baseboard alignment subtask align hallway probably need representation 
aligning hallway agent turns hall door baseboard appears horizontal image 
position hall door controls marcus rotation base board needed tell 
highlights possible iteration perception representation steps methodology 
marcus run perceptual routine detect baseboard determine angle 
uses situated routine just determines baseboard horizontal image 
words baseboard horizontal marcus detect 
role shared required role information available agent sensors detecting baseboard ok previous orientations baseboard helpful determined baseboard represented 
baseboard perception changed calculate rate change baseboard angle estimate current angle image 
mean having detect baseboard variety angles 
provide insurance sensor errors cause marcus horizontal state 
allow turn back require representation store previous role information 
environmental context task brown strip featureless white wall perceptual errors rare overhead representing baseboard necessary 
similarly front wall back wall roles move equidistant walls task need representation shared required information entities bound roles gathered agent sensors 
agent determine current positions walls sonar 
representation obstacle role avoid obstacles subtask straightforward 
argument obstacle representation bruce representation prolong time recover false obstacle identification 
argument representation inevitably obstacles pass outside sensory field agent clear 
representation allow agent remember obstacle fully move 
marcus advantage bruce sonar ring increasing sensory field 
difficult distinguish destination obstacle sonar vision having memory previous obstacle destination positions help distinguish 
marcus capabilities provide limited representation obstacle 
marcus need maintain information particular obstacle continually rebind role entity currently obstacle 
may object may new doesn matter long obstacle 
role bound marcus subsequently tries fails detect obstacles immediately forget entity bound obstacle start going back destination 
continue obstacle avoiding course short period time order get past obstacle outside sonar sweep path goal 
time interval marcus forget current association obstacle object unbind role 
marcus position obstacle role bound determine motor commands get 
need maintain information obstacle chooses avoidance course follows independent data specific obstacle 
marcus discontinued association obstacle previously associated object object obstacle marcus bind obstacle role object start process 
roles plan step tasks figures 
argue roles 
may appear outside agent angular sensor range agent sensory view 
may true marcus sonars 
uses front sonars simple obstacle avoidance algorithm purpose thesis develop sophisticated motor control strategies 
possible improvement just sonars front agent monitor heading sonars facing direction destination tell agent cleared obstacle 
problem marcus encoders high rotational error compared straight line dead reckoning performance 
turning avoid obstacle especially close requires rapid turning goal angular position quickly incorrect 
angular position determines sonar appropriate serious problem 
fact causes problem trying reacquire destination marcus camera 
discuss problem section 
plan steps represented 
shown previously role plan step tasks maps role tasks implement step 
roles represented reasonable represent roles plan steps order facilitate communication plan step tasks tasks figures 
point argument return issue section 
information verified 
roles locomotion building manipulation door tasks role information effector control needs verified rate effector control loop 
discuss section situations entity bound task role complex perception system maintain role information effector control rates 
case entities bound plan step roles 
section show requirements agent task lead representation design addresses problem 

perception information extracted environment recognize entities bound current task roles 
marcus perceptual needs divided detection blocks detection doors 
discussing perception doors complex caused iterations back task decomposition question 
door detector situated skill uses marcus edge detection capability detects patterns edges correspond doors olsson hall 
images generated find go door task moves marcus lab hallway 
show marcus edge detection colored blob finding capabilities find doors 
shows edge image overlaid graphics initial door location process 
shows tracking involved moving door frame 
detecting door inside room opposed hallway performed follows 
hough transform performed search nearly horizontal lines lower half image 
line meant edge carpet door frame visible door open closed door closed line formed bottom door 
line shown lower red horizontal lines 
note lines drawn entire image display purposes represent length actual detected edge 
lines obscure white edge pixels drawn 
lower line second hough transform searches image area line second nearly horizontal line 
line baseboard opposite side hallway door visible door open 
serves detect door open closed 
may simple means determining door open fairly effective door closed forms fairly featureless surface edges rarely 
door location tracking 
door open contrast brown baseboard white hallway walls forms strong edge rarely missed 
example situated routine see section 
horizontal lines established hough transforms search vertical edges left right half image 
detected edges shown vertical red lines 
edges represent edges door frame 
intersections vertical lines lower horizontal line denoted green marks near points determine distance direction edges door frame 
marcus determines distance intersections large fit 
door 
verify edge pattern door marcus performs search vertical lines higher horizontal line brown baseboard white wall 
uses technique detect adjacency color blocks discussed 
note previously marcus just looking edges concerned color 
area searched shown thin red box portion higher horizontal line 
small green red rectangles region represent regions analyzed colors brown white 
performed find door subtask find go hall door 
task detected baseboard bind destination role shares move door 
role bound point far away baseboard azimuth midway intersection points 
door detected perception roles task change information agent needs changes 
move door subtask drives agent position stored destination 
subtask sonar sensors slightly left right agent forward direction steer agent away door frame edges moves forward 
assuming roughly front door go door task begins order detect door see technique allow wiggle 
interesting point subtask detects door visually move door subtask detects door sonar 
shared role meaning form sensor fusion going role information computed tasks 
fact shared roles supposed represented role information doesn computed task uses role 
turns door detected find door visually perceptible move door task sonar duration time important agent passes doorway 
agent detect door sonar necessary door representation move door task 
importance initial task decompositions move door subtask determine destination shared door role 
move door update door role position better find door role bind destination share move door door baseboard detected track baseboard subtask maintain position baseboard move door servo position 
remember move door destination shared track baseboard 
somewhat arbitrary choice find door skill bind destination role role 
move door just easily compute destination position door role access door role 
baseboard 
tracking baseboard simplified version detecting shown 
hough transform area known location baseboard making baseboard representation ability store information detect candidate edges 
edges brown white adjacency check performed pass position update destination 
marcus determine distance baseboard baseboard runs floor determine azimuth baseboard runs entire width door 
baseboard effectively 
update azimuth destination marcus dead original value set find door subtask 
reasonable limited range orientations marcus successfully navigating door dead reckoning errors compensated search item task detect agent destination hallway 
limits placed allowable angles horizontal vertical lines door detection limit number potential doors considered 
means depending agent orientation door frame find go door task begins executing door may skewed image recognized 
unanticipated fact caused iteration back task decomposition step methodology resulted addition rotate view door subtask 
task rotates agent different orientations assumption find go door task executed door nearby find door fails detect probably due agent orientation 

reader note constitutes form foveation 
detecting door hallway requires different set situated perceptual routines 
main difference inside room baseboard seen hallway open door 
looking room hallway discernible feature visible 
issue distance agent door find go door room side task executed larger possible hallway side find go hall door task due width hallway 
hallway door takes larger portion image distortion camera wide angle lens factor 
fish eye distortion causes straight door frame edges appear curved far center image 
fact width door means possible view left right door frame edges vertical lines image distances marcus hallway 
conceptually simple solution problem search image appropriate curves 
computationally complex simple line finding agent moving hall due move hall door subtask performing computation 
means perceptual routine fast allow image curves pass processed 
solution adopted introduce additional roles task 
left edge right edge roles hold positions straight lines detected near center camera image appear vertical 
potential edge say left edge detected line bound right edge 
distance left edge right edge tolerance door hall door role bound position inbetween 
candidate right edge new left edge search continues 
marcus capabilities determine task roles representation 
needs representation detectable curved right edge detected 
recall door move door need representation task concerned destination role 
task decomposition see point task destination role matter marcus need track hall door representation left right door edges need maintained 
hall door role bound agent needs able determine door closed 
baseboard purpose visible inside rooms fact form visual clutter usually visible 
door open image area door frame edges usually full edges various objects visible inside room 
door closed flat surface shows edges surface wood grain problem 
number edge pixels left right door edge locations certain threshold door considered open 
address perception important class objects marcus domain blocks 
entities bound roles arch building task blocks constructions blocks 
blocks domain come different colors 
marcus capabilities band filter input camera image range particular rgb values color blob color resulting binary image 
order recognize constructions blocks stacks marcus detect blobs appropriate color verify appear appropriately adjacent image 
testing boundaries appropriately colored blobs see adjacent pixels 
perceptually interesting role base block role filled green yellow block 
marcus needs run perceptual routines blocks trying initially locate base block 
entity detected role bound color selected entity need tracked 
tasks require complex perception effects answers questions methodology 
example marcus capabilities allow pose determine pose stacks blocks 
stack blocks top red fastener block 
visible amounts blocks agent determine orientation stack compared canonical expected orientation see appendix 
initially thought item role bound block construction pose perception computation works stacks 
perceptual important class roles bound constructions blocks 
perceptual routines recognize arbitrary constructions blocks arbitrarily complex agent may able recognize construction viewpoints due object range partial component occlusion 
means difficult impossible recognize arbitrary constructions blocks effector control rates 
construction bound role task controls effectors leaf task agent perform task effectively 
marcus needs operate collections blocks arch building task needs bind constructions roles tasks 
furthermore needs able recognize spatial relationships blocks define particular constructions exist 
example needs able tell blocks stacked stacks block 
words marcus needs pick block stack maintain position block stack effector control loop wants verify stack remains stack 
question balance needs 
marcus perception system structured provide timely role information action bound entity current position maintain required role information entity structure 
answer lies fact role information needed effector control loop 
performing action construction blocks generally involve effectors contacting portion construct surface 
exactly effectors perform action depend action type construction 
marcus deals mainly stacks blocks blocks domain snap vertically 
means example marcus wants pick stack blocks lift bottom block stack rest blocks move 
marcus wanted move row blocks move individually interconnect horizontally 
perception system designed knowledge actions agent take 
consider go destination task 
leaf subtasks navigate destination look destination share destination role parent task need information destination effector control rates 
destination come plan step go stack occurs example destination bound construction 
points division perceptual responsibility 
complex perception divided routines run effector control rates routines 
agent routines generate information needed effector control effector control rates 
order meet requirement agent single routine determines needed information entity bound role 
problem information needed effector control typically computed 
fact stated section information related effector control computed effector control loop slows pa layer stance bit cases agent sufficient computational power handle additional perceptual pa layer 
executing leaf task uses information individual components composite object agent perceptual routines determine just position components needed control task effector 
agent periodically verify spatial relationship components construction exists 
information gathered perceptual routines stored task role 
go stack example agent needs move position bottom block rests floor marcus uses constraint bruce uses relate height image distance agent 
blocks stack ground positions incorrectly estimated 
marcus update position bottom block effector control loop verify stacked relationship blocks go action 
locomotion manipulation tasks function similarly 
leaf tasks roles bound individual blocks roles parent tasks bound constructions 
means marcus blob coloring routines individual blocks prs leaf tasks adjacency detection routines multiple blob colorings detect block constructions 
building tasks stack item item span item item spanner interesting create constructions blocks 
tasks bind item item roles block structures subtasks bind roles blocks determine stacking spanning action complete 
example span item item spanner task subtasks determine topblock topblock individual blocks spanning block cross principle spanner composite object spanner role leaf tasks bound portion spanner going contact 
splitting perception process portions inside effector control loop important issue view dependent perception 
simply means different entities look different different perspectives 
general problem vision dissertation develop novel vision techniques solve 
addressed design agents 
assume agent capabilities allow handle problem domain prs 
job agent designer assist agent recognizing composite objects 
general parts construct may partially fully occluded 
certain spatial relationships may detectable certain distance 
marcus needs multiple perceptual routines recognize different constructions different situations strategy apply 
knowing perceptual routine apply complicated question agent need guess position orientation 
tasks go destination parent task determined role bound composite object portion object bound leaf task roles action 
span item item spanner separate subtasks 
decision somewhat arbitrary go destination decomposition contain separate subtasks 
task determine topblock different constructions camera movement required tasks deal construction movement requires effector action needs done leaf task handle effectors 
object select routine 
problem marcus domain detect adjacencies constructs distance 
means wants stack blocks may guess far block part stack prepared search 
strategy marcus uses select perceptual routines capabilities 
marcus separate perceptual routines individual blocks stacks spans blocks various color combinations 
routine uses depends task role 
marcus needs basic recognition tasks recognize individual blocks recognize constructions blocks recognize component blocks part constructions 
task may different discussed section 
task role bound pr type routine 
task role bound construction marcus routine second type 
role shared task needs maintain information individual component structure perceptual routine third type required 
marcus may alternate routines second third types depending estimated perspective object 
order understand perspective select routine understand details marcus detects constructs 
marcus determines spatial relationships technique operators called 
technique provides means detecting color adjacency image need precise description boundary colored objects 
dumbbell rectangular regions separated variable distance 
marcus arch building task sufficient regions separated direction image coordinates 
detecting adjacency involves making coarse esti mate boundary location usually just horizontal line placing regions fall opposite sides 
regions analyzed 
top region contains pixels top block color bottom region contains pixels bottom block color dumbbell votes blocks top 
regions contain pixels appropriate color different vertical distance regions tried 
vote relationship marcus decides exists 
appendix provides details technique 
marcus simple blob coloring identify single blocks dumbbell technique identify constructions blocks 
needs recognize block part structure needs determine block structure monitor block blob coloring note blob coloring doesn verify block construction periodic verification fact necessary 
details various perceptual routines swapped appropriate situation saved section 
having understanding marcus perceptual capabilities address perspective issue 
marcus perceive individual blocks angles distances maximum primitive 
constructions blocks problem spatial relationships may perceptible certain distance 
marcus handle issue stacks blocks 
estimates stack far away normal dumbbell recognition different routine recognize just block 
routine yield position candidate stacks objects part desired stack 
routine different addition monitoring position detected block routine look block 
marcus move closer detected block see block visible top stack detected 
happens perceptual routines changed normal stack block routines 
marcus gets close block block top agent difficult situation 
possibly block part desired stack just come just singleton block 
general purpose solution problem 
marcus search local area candidate stacks block thought top indicating stack come undone 
summary seen marcus perceptual routines various task roles 
section roles marcus task decomposition shown shared roles 
fact roles representation reason 
section seen perceptual routines structured determine information entity bound shared role tasks role need different information entity 
section see information determined different perceptual routines propagated tasks effects task views entity associated role 
duration various role entity bindings effect perception system 
entities remain bound roles length associated task 
marcus separate locating tracking functions entities 
possesses routines colors recognize 
routines essentially restrictive objects accept matches assumes reasonably accurate estimate position determined 
location tracking composite objects trade exists 
designer decide amount computation tracking amount locating verifying composite object retains correct structure 
tracking individual parts effector control rates parts tracked computational resources consumed main perception action loop 
periodic verification relationships construct easier having positions parts 
means agent needs expend effort running locate routines parts 
structures marcus domain computational power available parts tracked action loop 
imagine complex structure exist 
domain structures complex shapes large numbers parts 
agent continually track parts interacts 
example pick object parts agent places hands tracked 
parts serve seed points pieces construction 
issue arises despite earlier claims information needed effector control position components fact components relationship maintained effector control rates marcus afford 
marcus compound object perception routines form colors 
routines technique described earlier 
functions just bounding boxes blobs correct colors determine blobs adjacent 
method accurate faster 
question pieces structure tracked effector control loop just single task role entire construct 
words role object separate roles parts 
just entire object fill roles tasks 
answer capabilities agent allow act respect single blocks constructions blocks 
means portion marcus architecture translate plan step effects structure blocks effector commands manipulate single blocks 
marcus picks stack blocks lifting bottom block 
pick stack task changed pickup block task fulfill pick stack goal 
addition separation constructions components allow agent deal different perspectives relationships discernible discussed 
structure recognized single monolithic routine effector control loop different routines possible perspective 
having perception routines individual components marcus derive information environment desired relationships components verified 
level detail resolution required information representation 
roles effector control marcus needs highest accuracy available case comes vision 
discussed entities bound role perceived accurately coarser sonar door door skill obstacle avoid obstacles 

communication information important inter task relationships 
seen important classes information important relationship tasks communicated tasks 
information entity bound role tasks decided section 
represented roles marcus task information associated entity position 
tasks exchange information variety reasons 
parent task passes information child tasks way representing expectations entity 
child tasks presumably try acquire entity agent sensors 
times parent task pass positional information portion entity bound role child task 
occurs child task need information stored parent task role data entirety structure child operate piece 
sequential tasks may exchange positional information entity task bound role task shares role 
emergent behavior schemes parallel tasks exchange positional information control different sensors effectors take action respect entity 
second kind communicated information mentioned perceptual information 
typically task pass perceptual information entity task order task bind maintain shared role 
example search base block tells search item base blocks yellow green 
search item binds role block color reports results back tasks sharing role need track color 
task role filled structure pass perceptual information portion task 
kind exchanged information previously hinted action input output 
bruce action input refers parameters needed action 
example executing go destination task agent needs know close get object depend action comes 
agent wants pick object get effector range object merely convenient target servo agent may need get close 
marcus actions require parameters multiple parallel actions taken different parts compound object recall show example section 
action output refers results actions 
child tasks report outcome parent task decides meaning result agent current context 
example find go door task find door find door reports fact move door 
move door necessarily interpret meaning door 
may rotate view door change agent perspective cause door finding failure 
perspective changes door move door report find go door door 
type information communicated tasks progress information 
progress different results actions represents ongoing action advancing 
progress tasks wishing monitor task proceeding 
tasks interpret progress information information know 
example parent task may notice child task making adequate progress execution favor task 
alternately tasks change operation task doing 
marcus uses progress information go destination task denote process avoiding obstacle opposed heading straight destination 
problem turning avoid obstacles destination goes outside field view 
means position dead reckoned 
marcus encoders high rotational error dead reckoned positions highly inaccurate marcus rotating estimate destination position drifts 
obstacle avoided marcus faces position believes destination may able match task role object viewable actual estimated positions differ 
usually occurs marcus turn sharply avoid close obstacle 
informing task maintains destination obstacle avoided allows task accept larger discrepancies detected estimated position doing correspondence destination role 
marcus exchanges form confidence information tasks 
domain confidence fairly simple respect composite objects 
confidence entity bound task role correct binary 
object acceptable identify routine agent binds role 
role bound agent confidence operate entity 
role bound agent confidence detected entity 
compound objects complication need separate objects components perception action loop 
marcus may tracking individual components stack drift apart time 
cue periodically verify component relationship confidence information 
relationship components verified confidence relationship high 
time decay reaches threshold marcus verifies relationship 
cause task communicate low confidence leaf task handle verification running locate routine 
marcus perception routines verify stack relationship effector control rates confidence roles relationship remain high 
seen information exchanged tasks entities bound task roles 
exactly expecting roles place 
tasks share roles mutually concerned entity environment logically communicate information entity 
discuss roles connected epistemological link 
certain information marcus domain maintained effector control rates may multiple data structures holding information entity 
example pose information returned determine item pose maintained position information 
merely stored tasks agent moves location pose determined 
multiple roles subtasks linked single role parent task 
example base topblock roles linked item span item item spanner task 
base topblock roles need store positions blocks item stores relationship 
removing unnecessary detail consideration perception action components architecture major motivation concept task role see sections 
agent needs operate multi part structures tasks decomposition need know entirety structure effective 
links representations created communication parent task children 
child task needs report role information parent parent needs function synthesize data possibly multiple roles representation entity 
case representation stores pose entity function fairly trivial just store action result subtask representation 
representation arch arch marcus building position stored representation determined positions components 
function positions various pieces single arch position 
marcus arch position defined half way positions stacks spanned 
stacks multi part entity 
agent needs detect component arch function arch position agent knowledge arch structures initial estimate component position subsequently perceptually grounded 
key feature functions defined kind structure role represents 
functions arches different functions stacks 
architecture agent tasks laid architecture 
step defining architecture divide agent tasks pa layer non pa layer tasks 
leaf tasks figures pa layer tasks bind roles prs perform actions controlling agent effectors 
tasks short cycle time effector starts moving rapid perception cycle needed control properly 
words agent starts moving matter critical safety responsive time 
implies representation tasks maintained pa layer cycle time 
top task figures pa layer tasks partly roles bound composite objects may expensive maintain pa layer rates 
stacks marcus maintain position relationships components tasks pa layer 
place pa layer effect single blocks allowed pa layer capabilities 
span item item spanner task pa layer task reason item item composite objects topblock spanner subtask pa layer 
leaf task roles bound prs preceding tasks 
task control effectors leaf share roles children complete action 
find go hall door task immediate children pa layer tasks 
align hallway center hallway tasks pa layer tasks hallway pr representation appropriately maintained 
rotate base hall door interesting 
uses rotate base item task normally non pa layer task item bound compound object 
rotate base item time arch building task 
possible place restriction entities bound item place pa layer 
chosen rotate base item fit pattern similar tasks outside pa layer 
rotate base item non pa layer task parent task rotate base hall door non pa layer task 
find hall door pa layer task hall door pr find hall door uses 
reader may recall hall door identified left right edges door frame separate objects 
may hall door pr left right edge representations outside find door task 
hall door representation bound point left right edges updated perceptually just bound 
hall door functionally pr representation parts identified maintained effector control rates 
subtasks manipulate effectors 
align base turret pa layer task roles controls wheel turret effectors 
go hall door pa layer task hall door pr passed move door 
find go door task move door rotate subtasks pa layer tasks door pr immediate children handle effectors 
rotate view door uses rotate destination pa layer task 
marcus implementation level subtasks door tasks figures non pa layer tasks 
keep ideal limiting goes pa layer tasks need high bandwidth connections sensors effectors 
level subtasks door tasks sequentially executed tasks tasks accomplish goals 
cases decisions context best stored pa layer representation 
example find go door task remembers different viewing angles tried recognize door 
plan step tasks pa layer tasks 
bind roles non prs access information pa layer tasks maps environment 
pa layer tasks local space coordinates control effectors coordinates agent maps converted 
question division non pa layer tasks 
issue tied knowledge available particular task 
knowledge task brings bear problem processing time requires 
plan step tasks example ability results receive children determine agent step 
possess context interpret result codes agent actions able initiate replanning access planning engine non pa layer tasks find go hall door simple sequencers child tasks 
follow predefined pattern tasks relieve pa layer having decide action results means agent current state action comes 
non pa layer tasks divided different layers containing plan steps containing rest non pa layer tasks 
division allows layer hold data need pa layer continual maintenance hold planning engine possibly information 
division assuming agent pa layer task usually selected inference 
words sequencer maps action result codes tasks 
purpose keeping planner far action selection process lessen temptation heavy weight processing necessary sequencer decide action 

implementation implementation marcus representation system architecture follow design decisions previous sections 
need multiple representations represented task role shared tasks different layers 
needs usable pa layer non pa layer infor 
previously stated marcus planner 
pre generated plan 
thesis design construction planners pseudo planner acceptable reasonable planner interface agent designed consideration planning component possibly long slow process 
mation associated entity stored maintained pa layer 
structure representation tasks layer similar information representations carry fits categories specified section 
difference portion environment layers consider determining values representation components layers consider objects consider parts 
remainder section provide details representations marcus architecture perform tasks building arch 
discuss representations kept date state world 
marcus uses forms representation pa layer tasks non pa layer tasks 
call pa layer representations markers previous agents 
divide non pa layer portion architecture task executor te planner 
te representations called protomarkers planner representation subject thesis 
table summarizes components marker data structure 
marcus markers similar markers bruce spot similar information communicated tasks 
table components marcus markers component name component contents index role name combination action component determine agent act respect object associated marker 
property ego centric polar coordinates associated object 
pa layer main loop marcus pa loop performs basic functions pa loops agents maintaining representation selecting actions similar structure 
pa layer attempts update property components instantiated markers running identify routines track routine case 
pa layer tries identify routines locate track initially bind marker object maintain property component 
routines manipulated te situation 
contains processed flag decide marker identify routines needs run see 
action agent respect object associated marker 
action pointer function te parameterizes 
component stores result code action completed 
confidence consists instantiated flag indicating marker associated object environment 
progress contains code indicating action taken associated object progressing 
simply ok action going plan 
dependency list list markers needed complete action specified action component update marker 
example marcus capable perceptually maintaining information stacked relationship entities pa layer capabilities sensible entities separate representations 
determining blocks stacked requires determining positions blocks single perceptual routine update property component multiple markers 
markers blocks stack perceptual routines update positions stack markers 
marker routine runs handle updates markers identify routines markers skipped cycle pa loop 
table components marcus markers component name component contents instantiate uninstantiated markers locate routines 
action selected performed 
remainder section discusses difference steps executed marcus executed bruce 
pa loop step update markers portion loop proceeds similar manner marker maintenance bruce markers track routines detect correspondents multiple markers 
happens pa layer verifies relationship entities determined positions update 
marker identify routine markers update dependency list 
markers set processed flags identify routines run execution loop 
difference bruce creates problem trying update instantiate markers 
bruce single means image segmentation segments image analyzed identify routines 
routines considered image regions regions ranked matched marker 
reasonable stable marriage algorithm insured markers matched image region presumably object 
marcus perceptual routines handles segmentation difficult guarantee multiple identify routines detecting appropriate objects overlapping image regions 
solving problem involve keeping track image regions associated markers 
means describing regions include area really part object computationally expensive marcus blob coloring routines main segmentation method bounding box retained blob 
empirically determined marcus need address problem important entities rarely look colors easily distinguishable overlap image previous position resolve marker matched region 
pa loop step instantiate markers marker instantiation similar bruce 
correspondent marker position stored property field instantiated flag set 
multiple markers instantiated finding correspondent 
track routine marker locate routine instantiate markers marker dependency list 
locate routines instantiate markers dependency list trying detect group components spatial relationship associate component marker 
correspondent dependent marker relationship verified 
discussed section may possible detect relationships necessary find multiple correspondents perspectives insisting locate routine instantiate dependent markers may restrictive 
marcus deals problem placing locate routine markers believes position required relationship visible 
example distant stack wishes go put single block locate routine bottom block marker top block marker block colors green yellow detects block color top block color associated instantiated marker 
bottom block marker instantiated perspective pr top block marker instantiates signals te see discussion monitor functions te 
te change locate track functions markers 
routines update instantiate components agent perspective possible 
pa loop step select execute action marcus pa loop selects action agent perform manner similar bruce 
multiple markers values action components order markers added pa layer determines order actions performed 
pa layer behaviors actions specified action components markers collection parallel tasks called pa processes actual execution pseudo parallel 
processes map readily leaf tasks decomposition 
implementation processes described appendix important effects amply described previous sections 
remainder section just lists cases pa processes task correspond exact layout leaf tasks figures 
go destination task combines navigate destination tasks pa process process needs control agent wheels 
process looks obstacles detected obstacle role bound avoids moves destination 
common pattern combine move view effector watch tasks single pa process 
depend task 
example stack item item item stack item item 
move view watch tasks generally concerned object part 
tasks looking conditions indicating human performed action trying position agent observe conditions occur 
flow indicated flow diagrams appendix operations go continually agent adjust position view environment changes ruin old view 
example marcus looking see item gets put top item item moves marcus needs adjust view observe item properly 
combination subtasks occurs stack item item span topblock topblock pick item put item put item toolbelt tasks 
similar combination occurs move item view calculate subtasks determine item pose 
leaf task combinations occur find go hall door task 
subtasks align hallway combined single pa process senses baseboard horizontal sends rotation command base 
base stopped pa process completes 
watch hall door open hall door necessary subtasks find hall door combined pa process 
process checks hall door role bound looks see door open asking human assistance 
role bound process continues monitoring wall trying bind role 
final question reader may track baseboard behavior move door 
baseboard role roles automatically maintained part main pa layer loop section need separate maintenance behaviors 
done tracking baseboard fit usual interface track routines 
track routines normally produce coordinates candidate correspondents marker matched 
mentioned section difficult estimate azimuth baseboard matter task execution 
track baseboard just updates baseboard dead reckoned part normal representation maintenance 
task executor tasks te layer different pa layer tasks restrictions cycle time 
different representation structures component names similar pa representations 
te uses structures called protomarkers summarized table 
table components marcus protomarkers component name component contents index index component consists unique identifier protomarker 
plan steps defined refer particular objects index associated protomarkers 
plan step causes protomarker created see protomarker unique index plan steps refer associated object 
property property component divided fields called prop 
component contains position associated object 
ego centric coordinates relative object environment 
marcus uses assembly site relative coordinates coordinates relative position object placed arch assembly site 
prop component stores information determined pa layer maintained pa layer main loop 
marcus stores pose objects 
reader note action component representations agents 
marcus need protomarker component processed te main loop decide action take associated object 
information held current plan step 
simple planning layer architecture place information protomarkers passed te marcus implemented 
layout tasks te discussed section need discussion task 
span item item spanner task find base find topblock tasks pa processes leaf tasks span topblock spanner 
span item item spanner span topblock identify component protomarker charge handling identify routines dependent markers see dependency list 
contains information relationship components protomarker associated object manipulate dependent marker identify routines different perspectives situations 
confidence protomarker confidence component contains bit decide spatial relationships object components 
protomarker associated object goes outside field view bit set time agent wishes act object relationship specified identify component verified 
agent periodically verifies associated object structure 
newly created protomarkers zero confidence markers instantiated 
dependency list component holds list markers associated protomarker 
marker represents parts object represented protomarker 
single marker protomarker dependency list 
ll see plan steps refer protomarkers tasks effect simple objects create protomarkers marker 
table components marcus protomarkers component name component contents topblock spanner te 
interesting span item task sequences number tasks pa processes te layer task 
architecture te tasks nested te tasks execute te tasks pa processes permitted activate pa processes 
pa process perform action binding shared role causes pa process take action te start pa process executing monitoring cues produced pa process 
protects responsiveness pa layer allowing process execute layer explicit request te 
te main loop task executors main loop consists steps check monitors handle completed actions determine action 
explain steps separately 
check monitors monitors small pieces code examine te protomarkers determine specific environmental conditions occurred 
monitors implement behaviors discussed design marcus 
monitor specifies firing condition condition occurs 
firing condition state protomarker associated markers 
pass main loop te check see conditions exist 
monitor function executed removed current monitors list 
principle monitors monitoring task checking progress component protomarker markers see action proceeding wait ing component objects certain positions 
marcus uses monitor functions jobs monitor condition instantiation markers 
monitors provide mechanism handling switching marker identify routines agent perspective changes 
recall agent far away stack wants associate protomarker te creates marker bottom block single block identify routines 
second marker top block created routine locate routine 
monitor set watch instantiation second marker 
happen bottom block marker instantiated top block marker locate routine suitable block bottom 
monitor function switches identify routines markers monitor function protomarker appropriate locate track functions new perspective 
stacks marcus domain functions 
functions depend finding correspondents markers opposed previous function allowed marker bottom block updated independent 
second monitor functions span item item spanner task 
start task agent find topblock construct ones spanning action observed 
agent looks bottom block sets monitor function keeps count number times agent run topblock marker locate function failed find 
monitor function executes marker instantiated frame count exceeds certain threshold 
marker instantiated monitor function merely exits removed monitor list 
frame count exceeded te deter mines stack longer place 
monitor function places stack action bottom block marker uninstantiated topblock marker dependency list 
cause stack re created 
te continue spanning action 
monitor functions instantiation base block markers 
general role played objects possible single locate function detect times designer collection separate functions job 
case marcus 
marker associated yellow green block 
functions developed anyway easiest way instantiate marker yellow green block particular location put different uninstantiated markers pa layer 
base block protomarker created te uninstantiated markers dependency list 
function function 
coordinates property components 
agent tries instantiate base block protomarker markers placed pa layer monitor fire instantiated placed monitor list 
monitor function remove uninstantiated marker pa layer subsequent protomarker effect single remaining marker 
protomarker store color detected base prop field property component thought marker correct identify routines information te planner 
handle completed actions monitor functions checked run te checks see actions markers associated protomarkers completed 
pa layer passed marker te te search protomarkers find contains marker 
marcus checks action just completed plan step plan step completion function 
completion function similar monitor function fires associated plan step finished 
function runs alters state protomarker referenced completed plan step 
marcus uses completion functions set position portion protomarker property component usually put item task 
case origin assembly site coordinate system set stack built site set 
blocks added assembly site relative positions calculated position original stack ego centric coordinates marker new blocks 
running completion functions te modification representations action completed return code placed marker action slot 
te check middle sequence actions part single plan step 
completion example rotate task different meanings executed part rotate stack task go door task 
table appendix provides list te operations various possible pa layer actions complete 
marcus deletes markers necessary 
marker completed delete action removed pa layer actual memory freed point 
code ran marcus bug forgot check action just completed pa layer action particular step plan 
plan steps required multiple pa layer actions completion functions functions run action completed 
bug effect marcus plan steps triggered bug completion functions 
description marcus 
marcus removes marker markers protomarkers 
part step te main loop delete markers dependency list marker completed action 
done markers support completed action longer needed needed action added 
problem markers dependency list perceptual dependency relationship markers verified pa layer 
removed dependency list 
marcus knows marker index values indicate perceptually dependent markers topblock fastener removed 
determine execute action completed actions dealt te pa layer execute new actions 
step plan see index protomarker indices set protomarkers associated entities involved step 
te protomarker index create new needed object 
markers appropriate action components created new protomarkers needed protomarker doesn necessary markers dependency list 
example plan step execute pick stack task stack certain global coordinate may create new stack protomarker 
markers created protomarker 
property components initialized global local conversion appendix marker bottom block item marker pick item action 
marker topblock marker markers identify routines assuming agent right perspective observe stack pick 
possible protomarker markers dependency list created way 
markers removed pa layer actions complete delete marker plan step 
idea marker null action component consumes resources exists pa layer pa layer maintaining marker property component 
efficient plans arch building plan remove markers pa layer associated objects acted agent near 
protomarkers contain markers usually deleted te especially agent need deal associated entity 
protomarkers consume computational power data maintained te act associated object 
allowing protomarker remain markers deleted allows agent remember certain environmental data low cost 
markers recreated object associated protomarker acted 
important issue recreating marker may difficult highly error prone estimate associated object ego centric position correctly object marker remained pa layer maintained 
trade exists difficulty re establishing object position computational resources designer planner willing allocate maintaining position 
markers created appropriate values placed action components passed pa layer 
new markers instantiated pa layer te knows spatial relationship specified protomarker exists locate routines check 
protomarker markers protomarker confidence bit set te verify protomarker relationship markers seeing instantiate 
specified relationship verified successfully te initiate new action changing action component pre existing markers 
table appendix summarizes te begins new plan steps recall subsequent pa layer actions part plan step initiated te described table appendix 
relationship markers protomarker te execute action rebuild structure stack item item span item item spanner 
plan step structure structure plan steps marcus plan shown table 
table plan step components component name component contents action task te execute 
note action pa layer te task root nodes decomposition diagrams figures 
protomarker tags specifies index fields protomarkers involved task 
specified implementation maximum needed marcus tasks 
protomarker specified index created exist 
id identify functions entities associated step protomarkers 
example id indicates stack block color block color red id means protomarker associated single red block 
field new protomarkers created 
position position entity associate protomarker specified map coordinates 
summary marcus architecture divided layers planner task executor perception action layer 
planner pa layer interface te 
planner communicates plans linear series plan step structures te te causes pa layer execute plan sending various markers 
markers markers return pa layer actions complete 
te interprets results sends markers pa layer manipulates components existing markers 
te discovers planner plan gone send protomarkers planner give information environment replan plan steps refer protomarkers te translate representation representation pa layer plan steps carried 
protomarkers group sets markers plan step simply refer collection components 
te responsible distributing planner desired action components object 
allows planner take view environment reduces planning search space 
time te reduces pa layer burden keeping active markers parameters parameters task 
data radius goto destination actions close agent consider action complete 
completion function function run plan step completes 

marcus planner handle replanning agent similar planner te interface 
table plan step components component name component contents minimum 
words pa layer expends computational resources maintain marker memory doing action marker object 
assumption marker pa layer important current task soon important maintained accuracy property field crucial 
allows designer overload pa layer markers causing maintained effectively 
te handles notion current task passing pa layer just markers needed express task done 
pa layer create additional markers obstacle markers example automatically deleted pa layer action caused created completed 
markers created te passed back just passed te responsible deleting 
allows te tradeoffs computational load pa layer accuracy information stored markers available agent 
protomarkers store information extracted environment agent sensor effector actions maintained pa layer 
spatial relationships difficult maintain effector control rates kept te periodically verified changing instantiation status identify routines associated markers 
order evaluate usefulness representation system define representation system effective 
methodology thesis idea task oriented design control loops closely couple sensors effectors necessary achieve task goals 
computational demands loops lead designs task roles task roles point designer entities environment important task agent built spend time computation 
agent representation store information entities associated task roles doing efficient effective task representation 
specify criterion influence system representation agent task performance judged requirements similar desired properties 

requirements 
architectural components representation able find necessary information search manageable combinatorics manageable dependent component cycle time defined section 

representation aid designer creating tasks manage agent limited computational resources 
representation systems designed different trade offs accuracy information contain cost maintaining information 
chapter evaluation 
george eliot 
representation aid designer creating tasks manage agent limited perceptual resources 
representation assist tasks handling perceptual problems limited field view occlusion 
argue system representation meet requirements meeting grounds reject system 
important thesis addresses design representation systems physical robots dynamic domains 
robots typically receive sensor input person perspective domains occlusion 
system representation augment perceivable world helping agent remember important currently perceivable information 
recall limited field view argument representation section 
course apply representation systems layers directly connected sensors pa layers 
layers notion occlusion limited field view 
observed pa layer grounds representation higher layers 
similar place constraints computation done pa layer 
critical importance agents multi tiered architectures pa layer handles agent interaction world 
agent ability react ability adjust actions changes environment depends pa layer ability devote computational power perception action 
pa layer efficient resources asked perform computation useful current task 
means searches unpredictable length representation 

term field view non visual sensors perceptual field accurate 
extended inferencing allowed data stored representation form directly usable tasks access 
specific information needed entities associated task roles considered methodology section 
course reducing search space task may mean increasing search space cases representation direct task requiring faster perception action cycle 
says representation designed understanding trade offs precision information stored representation closely corresponds current state world amount computation required maintain information 
trade offs combination importance information ongoing task time required compute information 
representations pa layer generally sensor effector control require frequent verification 
representations layers usually verified data crucial moment moment action data stored pa layer maintenance rate pa layer representation represent significant computational burden agent 
system representation meet 
system met myopic loose track important entities went outside field view occluded 
system meeting represent primitive see section bog computational load maintaining complex representation 
system meeting designed operate properly allows designer time consuming search processes pa layer hampering efficiency 
additional requirements belief representation forms appropriate medium communication layers agent architecture see section 
strictly requirements representation system communication protocol provide additional benefits met 
designer develops representation system communication agent architecture designer need create separate communication system 

representation system facilitate communication layers architecture 
words tasks know interpret representation communication protocol necessary exchanging representation 

representation system facilitate communication layers architecture 
methodology task subtask decomposition provides natural linkage roles parent child tasks 
tasks placed different layers architecture designer exploit link inter layer communication 
says communication tasks layer agent architecture facilitated representation 
note requirement restricts processes communicating internal state 
internal state data process place representation fit representation components 
process context interpret internal state processes need told interpret information 
restricting information communicated designer forced carefully consider information really needs shared 
says representation assist communication tasks different layers 
example layer may hold information needed agent cur rent effector control 
information stored representation layer passed lower layer crucial 
alternatively changes representation entity layer interpreted layer effect representation entity way marcus determines positions composite objects individual block positions see section 
addition higher layers communicate beliefs environment lower layers ground beliefs perception 
communication placing removing representation entity layer memory simple way 
systems representation developed methodology chapter meet requirements representation agents developed chapters meet 
met representing data needed tasks see section 
information environment ignored 
representing data search space reduced 
crucial thing representation contains information form car parked opposed map representation agent search car determine position parking place 
search reduced designer limiting number representation elements exist time see sections discussions having roles deleting representations tasks 
particularly important pa layer maintenance process suitably fast 
deciding roles tasks need representation designer seeks limit number elements active time example marcus uses markers time 
dependency component markers proto markers serves lessen search information pointing elements contain information needed task indicated marker action component 
methodology helps designers meet task role hierarchy results task decomposition see section 
agent need compute number environmental properties execution tasks 
tasks computational load required continuously verify properties reduce agent ability react acceptable levels 
natural epistemological link roles different tasks provides means dividing storage properties agent needs know entity 
needed effector control stored representation leaf tasks properties stored representations higher tasks 
updating properties periodically computation needed information feasible 
example marcus updates positions individual blocks pa layer needed effector control verifies protomarker relationships blocks going effect associated object 
link roles different tasks represents constraint information stored role 
example position stack determines position component blocks position blocks determines position stack 
cases properties stored non pa layer representations simple functions properties stored component representations 
may simplify processing additional perceptual computations necessary determine properties 
addition perception portion methodology section addresses directly addressing amount perceptual computation agent needs maintain representation 
considering binding duration level detail designer looks ability agent context maintaining representation 
context mean previous properties entities bound representation help compute current properties 
designer domain knowledge task constraints simplify update process tasks exhibit situated activity section 
spot marker confidence timer values section maintenance representation marcus door detection routines section examples 
methodology asks designer consider level detail required representation assist designer creating appropriate maintenance scheme 
considering maximum amount precision feasible designer develop efficient allocation computational perceptual resources 
designer precise expensive sensors needed develop control strategies direct agent sensors portion environment current important information determined 
methodology encourages effective field view paradigm help designers meet see section 
designing agents remember important entities outside perceptual field designer allows agent act information store context assist entity expense initial identification 
pa layers agents described chapters meet exchanging information pa processes markers see sections 
means communication similar blackboard system pa processes knowledge sources compute information entities information posted knowledge sources 
pa processes post markers important results ones concerning task roles available pa processes 
agents meet having higher layers command lower layers simply placing appropriate expectations representation uninstantiated markers see sections 
example marcus places markers pa layer action components markers triggers sensor effector actions 

evaluation design methodologies section analyze current design methodologies fail produce representation systems meeting requirements specified 
doing consider methodologies design agent execute task marcus executes 
methodologies discussed strictly representation design methodologies certain amount interpretation deciding effect representation 
bad designer free different design techniques time free shoot foot 
subsumption methodology subsumption methodology needs discussed briefly provide form representation 
design agents perform marcus task serious environment blocks needed perceivable 
means subsumption system turn acquire step marcus plan purple block reached perceptual cue tell marcus turn block 
violation 
architecture methodology examine part architecture 
design methodology concentrates decomposing task deciding resulting subtasks belong layers architecture 
architecture layers planner top pa layer called skill layer bottom sequencing layer rap system 
design methodology address issue representation cause problems 
problems stem representation sub systems architecture 
rap system uses lisp predicates fundamental representation element skill layer uses arbitrary data structures skills inputs outputs communication channels skills 
note interested bottom tiers planning scope thesis 
order see problems occur need create decomposition portion marcus arch building task 
consider goto destination task executed marcus put initial base block assembly site heading back previously seen purple block create stack 
task destination bound purple block decomposed destination look destination avoid obstacles 
tasks skills need function tight perception action loops control effectors agent moves world 
skill detect destination added process detects destination sensory stream 
goto destination task rap skills achieve activated rap systems parameterized destination location 
reader may question task decomposition different architecture tasks marcus capabilities 
avoid obstacles detect destination wrapped navigate destination affect ability meet requirements stated 
representation comes play know skills written purely reactive fashion see section 
methodology address representation designer create representations outlined section contained data 
representation elements developed designer turn structure representation developed section methodology thesis superior aids designer creating structures hoping occur chance 
representation elements data developed thesis reader referred section arguments representation ineffective 
suppose skills representation contained data markers marcus pa layer section 
skills map environment get assembly site purple block rap system need send name current destination 
skills represent properties world markers spatial configurations various blocks top 
violates discussed 
violated skill layer uses maps reduce search space considered skill layer action selection machinery 
violated skills look map form map takes order determine position purple block 
navigation skills just information purple block task determining information fall rap system planner 
line skills tighter pa cycles raps 
violated representation stored properties objects configurations blocks needed skill layer tasks 
violated stated skills search unnecessary data objects properties 
fact data stored skill representation need meaning skills compute information current sensor values get rap systems violates 
violated representation information updated continue useful 
methodology provides guidance respect representation maintenance temptation update effector control rate maximum rate required skill 
may cause precision computation trade poorly 
representation violate designer poor trade permitting go destination skills get bogged verifying information germane task 
skill representation contains data representation developed thesis representation violates 
means skill representations designed thesis methodology methodology design agent skill pa layer 
uses multiple representation systems rap layer representation different skill layer 
rap layer representation strongly specified skill layer 
fundamental element lisp clause 
block block purple block 
type representation violates lack structure means deictic 
unification determine facts stored rap memory 
place information particular entity stored look takes unknown amount time 
addition violated difficulty removing facts rap memory 
rap memory contains time stamped predicates increase rap system search time removed form garbage collection computationally expensive require unknown time 
methodology designer finds roles agent tasks 
data contained representation roles known important role task task easy find remove data longer necessary 
methodology thesis avoids problems advocating creation deictic representation important task dependent objects layers agent architecture 
methodology places restrictions skill layer wrong restrictions rap layer representation designs methodology produce efficient effective systems representation 
pure architecture pure architecture subsumption architecture traditional subsumption architectures system representation structures authors call markers 
main contribution design representation architecture representation coordinate communicate behaviors 
pure design methodology address important issues decide represent structure representation devise scheme effective representation maintenance 
suppose marcus designed ideas pure architecture 
markers able represent multiple points environment specify relationship trajectory markers pure unblock task 
similar protomarkers information kept pa layer 
arch marker contained positions blocks stacks spanning block 
agent tried maintain information arch marker effector control rates violate mechanism trade offs accuracy computation 
pure system provide means controlling marker updates gaze behavior 
marker position close fovea pure robot stereo system agent tries update marker 
controlling gaze appropriately designer implement maintenance scheme prioritizes information 
putting mechanism gaze behavior hides crucial aspects data contained markers usefulness piece information 
different tasks require different precision information 
hierarchical representation created methodology clear priority placed precision piece information 
determines rate piece information needs maintained 
placing different information different layers representation hierarchy designer tailor maintenance scheme needs layer representation 
gaze behavior hand completely hides importance information encodes terms agent looking 
harder change information priority level change priority level main tained 
providing hierarchical representation system represent different data different levels providing confidence component representation clear data important priority updated 
problem pure architecture arises fact architecture single layer 
default behavior active behavior control transferred behavior behavior environmental conditions 
similar pengi discussed chapter suffers scaling problem 
complex task agent complete aspects environment registered determine switch behaviors 
pa layer eventually violates agent may search representation current task task 
representation provides easy means saving information agent wants store afford maintain verify part current task 
protomarkers kept layer architecture allow marcus pa layer remove elements representation needed current task retain information create required 
designs cause agent serendipitous updates marcus sees structure protomarker markers pa layer time update performed methodology easier designers create representation systems agents complex tasks complex environments designer decide looking data may useful 
soar architecture soar architecture extended interact world 
particular soar control autonomous robots 
design methodology advocated soar cast agent task environment form usable soar production system 
layers soar architecture representation divided short long term memory 
short long term memory violate 
short term memory collection attribute value pairs deictic 
memory structures drawbacks see section described rap system memory 
long term memory contains productions soar planning learning processes 
planning learning scope long term memory type memory am concerned 
productions stored long term memory store data possible results actions assist determining possible world states 
means extra data sort order determine current world state violating 
violated soar address maintenance representation 
soar designed general symbolic ai architecture uses database facts assumed correct environment 
attribute value pairs short term memory assumed delivered interface sensors notion feedback unit 
sensors method generating attribute value pairs soar engine needs soar tell interface look important current task 
guidance distribute computational perception resources maintain information efficiently 
section methodology addresses concerns detail 

evaluation design way evaluate methodology look effect design process 
methodology meant provide context agent designers 
guiding designers questions methodology puts designer right frame mind create efficient effective representation systems agent perception action component 
chapters provide evidence kinds workable designs emerge designs carried context 
examine methodology directs designer consider design issues represent structure representation maintain representation 
recall question set answer section 
methodology instructs designer consider objects important agent tasks 
done task role concept important objects agent needs act respect basis thinking systems achieve agent goals 
having designer consider importance role task methodology encourages agent designs agent considers small subset environment executing task 
encourages design situated behaviors limits scope entities represented agent 
final decision representation roles trade offs representing role discussed section computational expense verification vs penalty selecting action stale information 
asking questions specific data needed tasks section data communicated tasks section methodology points designer structure role representation 
types information typically important tasks handling perception action discussed section 
important directly addressing information contained roles designer kept representing arbitrary amounts data 
important efficiency finished agent saves time design process simplifying design maintenance scheme 
methodology addresses design agent representation maintenance scheme section 
developing strategy assure stored information todate difficult considering trade offs methodology important 
maintenance usually computationally intense methodology suggests optimizations consider designing maintenance process section 
considering optimizations greatly help designer discover computational savings necessary agent operate fast perceive important changes environment 
design process discussed chapters show methodology provides setting designer craft solutions basic design issues section 
example bruce designer task role concept decide represented 
words bruce represent landmark search route move landmark task task requires information landmark time 
leads bruce inter level control structure information layout entire environment stored layer architecture portions information passed pa layer needed 
methodology helps creating structure marcus representation having designer consider information communicated tasks particularly epis links roles 
having designer consider relationship abstractions block structures different tasks helps determine information needs computed task order keep representations consistent state world 
considering links helps develop maintenance communication systems tasks maintain representation communicate information tasks help maintain representations tasks 
methodology assists design schemes maintain representation keeping consistent dynamic world 
example spot perception system designed understanding spot capabilities stereo vision limited field view 
designer knows spot keep track multiple objects field view designer knows spot focus attention periodically shifted different objects 
considering spot task confidence component representation created trigger shift camera view 

summary section evaluated design methodology ways 
comparison agent design methodologies 
evaluated design methodologies respect task performed marcus 
failed meet requirements representation systems set forth section 
analyses extend cover current architectures design methodologies fail address design representation systems 
architecture uses arbitrary data structures lisp predicates represen tation 
architecture uses risk similar problems 
includes layered architectures atlantis rcs tca 
pure architecture uses structured representation called markers limit number markers system information contain 
lack information hierarchy leaves open potential bog system unnecessary details 
similar systems pengi sonja brill agent similar problems complex tasks 
soar architecture memory systems meet representation criterion 
short term memory consists attribute value pairs problems lisp predicate memory 
long term memory contains productions predict outcomes actions represent agent environment 
second way methodology evaluated analyzing effect design process 
methodology put designer right context create effective efficient systems representation 
analyzed questions methodology provide guidance discussing trade offs involved determining answers questions 
thesis presents methodology designing autonomous mobile robots 
main contribution methodology design representation efficiently effectively agent architecture 
robots methodology appropriate expected operate dynamic uncertain physical domains 
order efficient effective domains robot control close coupling sensors effectors constrains design representation 
efficacy validity methodology documented agent designs successfully carried operating implementations 
key feature agents action oriented portion architectures system representation 
representation allows components architecture efficient effective meeting goals 

action selection redux debate representation action oriented portion architecture particularly perception action layer shifted away argument perception action layers stateless reactive systems debate form effective representation 
researchers agre chapman kuniyoshi brill demonstrate agent successful simple pa layer representation systems 
common feature chapter re part solution re part 
steven wright works representation moment moment effector control 
current sensor values particular state agent representation simple transform determines behavior engage 
moves previous examining issues effect representation action selection represent maintain representation organize representation effectively agent architecture 
address issues turn sections 

fundamental representation design fundamental question design representation system represented 
order coherent design process perception action systems task oriented approach 
major implication task oriented approach concept task roles aspects environment influence agent behavior particular task 
roles focus methodology developing representations efficient effective agent tasks 
intertwined issue roles task questions entity entities environment fulfill roles 
possible properties entities stored representation 
obvious means deciding represent base data needed particular task obvious basis agent computational ability verify data stored representation required dynamic environment 
call verification process maintenance 
computational complexity general maintenance reason representation agents proposed place representation just took time update dynamic domains 
methodology calls designer consider structured way task requirements possible trade offs associated verifying representation 
notion entity fulfills role depends abstraction task views environment 
methodology encourages designer create role hierarchies roles hierarchy represent different abstractions objects world decomposing agent task designer just decompose goals aspects environment need manipulated accomplish goals 
designer consider data environment needs stored role representation 
role hierarchies layered nature agent architecture allow properties different levels usefulness represented 
data tasks sensor effector control loops determine moment moment actions 
data helps determine multiple tasks active typically accessed sensor effector control data 
piece information higher maintenance cost agent willing pay 
role hierarchies allow designs different information entities represented different layers architecture 
methodology causes designer consider quickly task requires agent respond changes world role hierarchies allow designer create maintenance scheme layer hierarchy conforms requirements 
major benefit role hierarchies allow information spread layers architecture 
typically information represented particular layer longer tasks layer take sorting 
information relatively inexpensive maintain pertinent layer current task slows layer cycle time tasks waste time examining information determine relevant 
role hierarchy allows information stored outside layer reduce layer responsiveness 
agent storing information passed back layer layer tasks need 

representation maintenance representation maintenance fundamental representation methodology examines process maintenance efficient 
having representation action oriented portion architecture means maintaining 
data merely stored useless dynamic environment 
necessity maintenance key efficient representation limiting maintained 
methodology advocates reducing time required maintain task roles limiting amount information represented agent 
done limiting number size data structures representation 
methodology encourages number structures limited role concept 
designer seeks determine minimal set aspects environment determine agent action task 
truly minimal set roles required fewer entities represented faster maintenance process faster pa layer cycle time 
methodology designer consider information stored representation order limit size structure 
position necessary data property component 
amount information representation data structure presents trade number data structures 
information data agent selecting actions expensive maintain 
course having data selecting action burden means process takes longer 
general designer want represent properties entities bound roles possible 
decisions usefulness importance information action selection process maintenance cost including required accuracy cost shifting perceptual computational resources determine information needed 
methodology encourages efficiency maintenance process having designer consider situated ness see section computationally simplify identification entities associated roles 
example marcus detect doors vertical edges see section door detection routines expected olsson hall 
designer selected roles entities fulfill task methodology suggests methods optimizing process representation maintenance 
principle situated activity applied differentiating initially binding entity representation maintaining binding see section 
example robot designs different methods track objects associated roles initially locate objects 
allows tracking routines context established locating routines 
example section spot fact locate routine places proximity space human tracking done proximity spaces knowing tracking just follow texture 
optimization considering level detail needed particular representation 
possible task operate maximum possi ble precision information designer consider allocating perceptual computational resources 
fact limited perceptual fields agent means tasks may able perceive important entities times sensors 
methodology encourages designer choose entities monitor agent sensor capabilities precision entity information required tasks likelihood information stored entity stale monitored 
representation hierarchies developed design methodology allow designer control representation maintenance 
hierarchies possibility properties stored level hierarchy computed aggregation properties representations lower level 
position stored marcus arch representation aggregation positions blocks arch 
technique useful similar properties different tasks properties different levels abstraction marcus ego centric vs relative coordinates section 
aggregation possible separate perceptual computation determine properties non pa layer tasks necessary automatic maintenance non pa layer representation possible propagating results pa layer maintenance non pa layers 
dis aggregation refers domain knowledge decompose entity components allows task express domain knowledge task form default values 
example marcus designed knowledge stack blocks top big blocks estimate positions component blocks position stack 
benefit role hierarchies representation maintenance layers architecture typically designed update representation rate 
representation maintained part task main loop presumed representation pertinent current task removed layer memory 
representation maintained task main loop maintained representation requires frequent updates maintained properly 
single maintenance rate level means information entities computationally expensive determine impedes responsiveness entire layer 
methodology encourages role hierarchies means storing information layer maintained appropriate frequency 

representation organization methodology assists designer structuring agent representation tasks access information need access information needed 
part may obvious trivial value information rarely cut dry involves trade offs discussed 
designer encouraged examine role sharing build semantic links representation different layers 
design allows agent tasks communicate efficient channel 
includes inter intra layer communication 
consider intra layer communication 
tasks layer process representations form representation forms efficient communication medium tasks understand structure contains information needed tasks see section 
semantic links role representation different layers allows inter layer communication 
communication takes form hierarchical control lower layers higher layers 
communication occurs layer sets context passing selected information task hierarchy control agent treats important acts 
having designer consider semantic links roles methodology designer discovering information representation layer converted information needed tasks lower layer 
information placed higher layer lower layer representation controlling actions lower layer 

surprises having methodology design robots aspects design process surprise important keep mind 
surprising aspect general engineering concerns appear worthwhile separate perception action 
engineering practice divide robot design problem separate components connect 
particularly tempting create perception system needs agent actions 
words tempted create perception system generates information environment placed database separate action system read decide 
rationale separation perception system know action system current activity 
separation simplifies communication means perception system try generate information agent needs tasks time 
difficulty perception system know information needed generate possible information action system needs available 
means perception system inefficient bogged depending information trying generate 
methodology tries steer designer away examining task roles objects fulfill required information objects representation roles addressing perception 
intention designer information available task organization designer perception system strictly task oriented 
generating required information objects associated roles current task perception system sufficiently efficient effective rapidly changing environments 
surprising fact representation perception action component agent architecture fairly independent architecture 
words design representation unaffected choice agent architecture 
say methodology explicitly refers form agent architecture representations designed course thesis designed assuming layered architecture 
layered architecture assumption leads immediately hierarchical systems representation discussed thesis complex object properties expensive maintain stored higher layers simpler compute properties possibly computed agent primitive capabilities stored lower layers 
layered architecture assumption required 
methodology urges designer segregate properties represented difficulty maintenance include simple compute properties perception action component agent 
sensor ef control process bog representation maintenance processing 
point layered architectures literature representation design methodology depend definition layer 
late design process designer choose computational unit architecture calls layer execute tasks depend unit ability maintain representation task 
representation designed needs task architecture 

contributions thesis contributes field autonomous robot software design describing task oriented design methodology agents operating dynamic environments require tight sensor effector control loops 
specific contributions thesis 
thesis presents design methodology representation systems action oriented portion agent architecture 
specifically design methodology presents trade offs precision benefit maintenance cost 
assists designer considering hierarchies representation order determine appropriate allocation computational perceptual resources 
encourages representation communication behaviors role sharing 
encourages representation communication control layers agent architecture 
quasi architecture independent today architectures agent perception action layer 

thesis presents physically implemented agents performing different tasks validation agents designed methodology implemented operate effectively dynamic environment 
thesis design methodology creating systems representation perception action component agent architecture efficient effective dynamic environments 
validity efficacy methodology shown design multiple physically implemented agents 
argue chapter methodology superior methodologies area representation design methodology seen complementary autonomous robot architectures robot development languages environments 
designers working constraints current architectures successful incorporate efficient effective representation contend adhering methodology thesis establish context creation representation possible 

bruce implementation section provides details bruce software described abstractly chapter 
particular address navigation obstacle avoidance system color histogram matching perception system task executor role interpreting search plan doing local global coordinate system conversions 
navigation system goto action bruce places action component landmark markers part search opponent task navigate bruce game environment 
action consists pa processes called move landmark detect obstacles look landmark find path execute pseudo parallel 
processes implement move landmark detect obstacles tasks shown decomposition diagram section 
pa processes shown leaf tasks decomposition design time anticipated navigation system take form 
actual implementation move landmark roles landmark intermediate destination 
detect obstacles obstacle role look landmark shares landmark role move landmark 
find path landmark intermediate appendix robot implementations value bound variable willard van quine destination obstacle roles 
shared move landmark detect obstacles 
roles represented markers facilitate inter process communication 
operation pa processes follows 
move landmark controls agent wheels servo position stored landmark marker intermediate destination marker instantiated 
processes servoing intermediate destination marker decreases marker confidence value 
value drops certain threshold marker deleted 
detect obstacles process checks objects marker maintenance routine section 
objects goal closer bruce goal path bruce width centered goal azimuth declared obstacle see discussion projecting agent path image find obstacles 
obstacle marker created position set closest point obstacle object bruce 
look landmark pa process turns agent camera look landmark position long possible 
bruce pan tilt camera mount pan view approximately degree field front agent possible view goal particularly avoid obstacles 
find path pa process obstacle marker created detect obstacles 
obstacle marker causes process create intermediate destination marker path free obstacles see 
move landmark task move destination time start going landmark 
point object new obstacle detect ob flag 
obstacle marker created detect obstacles analyzed find path determine needs move persistent representation 
mentioned section obstacles represented near edge field view soon 
obstacle close bottom edge image obstacle marker preserved deleted 
find path chooses path agent follow goal obstacles 
paths represented creating intermediate destination marker agent new destination move landmark behavior path intermediate destination position chosen performing image scan nearby area 
obstacle marker created find path computes images taken separate pan angles representing sweep front agent 
agent estimate distance objects free space point 
agent chooses azimuth intermediate destination marker goal azimuth azimuth represented obstacles deleted amount free space currently available azimuth 
chosen direction closest goal run obstacles certain amount free space 
intermediate destination agent real goal necessary agent reach location merely head direction 
radius stored marker suitable large value 
move landmark delete marker time agent start heading goal landmark 
perception system bruce ability distinguish landmarks opponent color histogram intersection 
histogram models landmark opponent captured stored locate track functions various identify components te place marker 
models matched histograms area pairs discontinuities 
area bounded left right discontinuities top lowest closest image bottom point left right edges 
top top image 
pixel hashed bit value highest order bits red green blue image bands 
degree match histogram model measured formula swain ballard iterative scaling technique terzopoulos shown idea scale model taken size current region frequently 
results histogram intersection scale model model histogram created object close camera model rarely gets scaled match value high results start decrease 
final match value region parameters rank objects markers marker maintenance scheme section 
worth noting segmentation identification techniques min buckets scale model sum min intersect bruce sufficient task environment fairly problematic 
believe causes 
buckets histogram hashing function uniformly distributed 
camera laboratory floor considerably darker height people stand sit 
meant colors tended dark spectrum highest order bit particular color band seldom color fairly saturated white 
lead fewer buckets important histogram objects seemingly different colors moderately distinguishable 
addition camera automatic gain control probably damping bright colors necessary floor dark bruce distinguish 
bad segmentation discontinuities corresponding real boundaries objects led histograms incorrect regions matched model histogram segmented background human 
depressed intersection match scores 
task executor bruce pa layer architecture adapted perform tasks merely adding pa processes identify routines 
te flexible 
bruce route planner search route encoded te 
encoded series local coordinates visit 
term local coordinates route plan expressed series steps assumptions agent state previous step completes 
example step encoded just com step garbage radius mm 
te assumes bruce particular point certain stage plan completes 
point varies step plan local space coordinate point respect point 
te adjust azimuth landmark azimuth stored marker current landmark new landmark old landmark map value 
task executors agents example marcus face difficult problems local global coordinate conversion maps truly encoded global coordinate system 
systems robust error bruce 

marcus implementation section details marcus agent architecture 
discuss task executor converts global coordinates maps ego centric coordinates pa layer 
discuss marcus pose detection system te operations action pa layer 
local global coordinate conversion vice versa marcus converts map coordinates local space ego centric coordinates execution arch building task 
process takes known local space coordinates locates agent position map chapter 
position local space position object interest determined 
shows example 
grey agent dashed line heading 
agent maintains markers corresponding location place visited previous destination corresponding landmark current destination 
radii markers put marcus locations 
locations indicated block dots intersection points circles derived radii 
global coordinates marcus defines previous destination current destination 
solving equations determine coordinates intersection points coordinate system centered previous destination 
simple matter translate coordinate system map origin 
circles intersect intersection equation fail 
allow slightly larger smaller attempt get intersection 
perturbed general dead reckoned comes visual data correct question intersection points marcus true location 
rx ry current destination previous destination destination 
local global coordinate conversion markers dx dy point called rx ry 
marcus uses domain assumptions resolve issue 
particular uses markers coordinate 
markers shown 
bruce marcus defines positive counter clockwise direction negative clockwise direction 
point closer axis axis abs abs marcus intersection point lower value 
axis point higher value lower value 
closer axis marcus point greater value 
closer axis marcus point lower coordinate intersection point 
difficult values exact yield outcome previous destination directly agent close assumed case 
means agent direct line rx ry calculated point line intersects circle radius centered 
marcus knows location global coordinates calculate local space position marker destination 
coordinates destination map expressed previous destination coordinates dx dy azimuth cosine rule tri dx rx dy ry angle vertices dx dy rx ry 
marcus calculated position new marker stores coordinate current destination task executor 
allows treat point time adjust map coordinates points relative 
reason just circle intersection equations simpler circles centered origin 
chose method coordinate system conversion opposed triangulation methods allows different rx ry points simpler methods 
domain assumptions allow marcus disambiguate location navigation system tends follow fairly direct path goal 
means rarely possible location rx ry arrive values mean marcus took circuitous route 
possible due obstacle avoidance example cost keeping third marker date high 
especially true considering situation markers previous destinations expensive maintain inaccurate dead reckoned 
pose detection marcus determines pose block stack visibility stack components 
implemented pose detection routine requires blocks 
base block said footprint size top block said footprint size final top block size 
shows views example stack 
visibility various blocks stack marcus determines viewing zones relative stack overhead view shows different zones 
zones differentiated relative size position widths bounding boxes blobs associated different blocks 
solid black lines separate major zones define red block bounding box falls yellow box width 
dotted lines define additional view front view top view 
example stack views back view zone zone zone zone zone zone zone zone zone zone 
zones determine item pose sitions areas relationship coordinates bounding boxes appear differently 
perceptual conditions determining zone agent means zone summarized table 
notation min stands screen coordinate left edge purple block bounding box max bottom edge yellow block bounding box 
left means red block bounding box occupies left portion area yellow block bounding box width 
visibility criteria determine empirically 
angle returned pose detector defines zone canonical orientation block stack 
position degrees 
pose detection routine distinguish stack fixed position agent different locations agent fixed position stack rotated axis 
words pose detector determine local orientation stack respect agent agent position global coordinates 
agent uses stack pose determine orientation local assembly site coordinate system 
plan care orientation construction global coordinates ambiguity problem 
construction needs certain position global coordinates agent translate local assembly site coordinates stored stack representation global coordinates map 
case marcus assumption pose stack 
assume changes pose due position stack stack rotation 
marcus system converting local global coordinates uses determine position map 
assumes change stack pose due rotation stack axis entities marcus domain moved users marcus back turned 
detecting adjacency marcus detects color adjacency technique called 
dumbbell consists square images regions separated certain distance line segment 
shown dumbbell ends shown black rectangles connected black line 
line segment determines kind adjacency dumb table summary pose zones major zone pose zone condition angle right width right midpoint width max max max max occluded portion visible min min min min left width left midpoint width abs xmin xmax min right width min right left left right width min left width middle left right midpoint width max right width max left width bells detect 
example vertical segment checks stacked relationship block top 
horizontal segment detect relationship blocks side side 
general line described means slope intercept marcus implements horizontal vertical lines uses vertical lines arch building task 
detecting adjacency begins blob coloring input image colors call color color marcus wants check adjacency 
example marcus wants look yellow block particular adjacency green block find green yellow blobs 
placed various locations search region 
dumbbell placed fixed point location determined line segment 
pixels dumbbell color color dumbbell votes adjacency 
marcus pixels correct color pixels 
dumbbell votes relationship dumbbell tried moving left right coordinate search region 
dumbbell vote adjacency different measures taken 

example adjacency measurements dumbbell separation altered 
shown maximum separation 
possible separations tried dumbbell vote adjacency fixed dumbbell moved 
dumbbell moves left right search region 
search pattern adjacency dumbbell starts coordinate 
useful looking vertical adjacencies common marcus task 
search region dumbbell analysis carried defined bounding rectangles colored blobs 
region extends larger left bounding box edges smaller right bounding box edges 
runs smaller bottom box top box 
dashed lines illustrate minimal bounding box region 
region extended top bottom left right size dumbbell pixels 
adjacency routine compares number positive voting total number attempted dumbbell positions 
certain percentage voted relationship marcus believes exists 
vote adjacency blocks called stacked 
vote adjacency blocks considered separate 
handling completed actions marcus task executor table summarizes happens pa layer completes action passes marker te 
current plan step result completed action te modify state state protomarker associated returned marker possibly protomarkers markers 
note completed actions treated differently depending te involved sequencing set pa layer actions single plan step 
columns midst parenthesis indicate completed actions handled ongoing sequence 
stated completion result action success universal code action completed expected 
ordering table order completed action result code examined 
table te handles completed pa layer actions completed pa layer action te response align hallway midst go hall door change marker action component hallway 
center hallway midst go hall door create destination marker middle hallway side marcus door put rotate base item action put door marker dependency list 
rotate base item midst go hall door change marker action component door 
find hall door midst find hall door marker destination marker door marker destination marker associated position inside detected door dependency list 
put align base turret action inside door destination marker delete marker completed action 
update current previous destinations local conversion described section 
current destination inside destination marker previous destination door marker 
align base turret midst go hall door change marker action component hall door go hall door midst go hall door action complete 
increment plan step counter move plan step 
delete marker midst find hall door delete marker 
handled separately completed actions find go diverted separate handler 
move door result door midst find go door create new destination marker new position place rotate item action 
new positions progressively larger angular offsets door original position alternating directions 
rotate view door implemented 
rotate item midst find door set door marker action find door delete destination marker 
agent look door hopefully image better aligned 
move door result success midst find go door action completed marcus hallway 
adjust current previous destinations local global conversion 
current destination destination marker hallway estimated baseboard position previous position door marker 
increment plan step counter 
delete marker midst find door see delete marker midst find hall door delete marker midst plan step remove marker proto marker dependency list 
protomarker marker multiple markers deleted don increment plan step counter comes back completed delete action 
search item midst item spanner change marker action component lookat item gets centered view add monitor wait topblock marker stack get instantiated 
table te handles completed pa layer actions completed pa layer action te response item stack just re stacked topblock marker instantiated monitor function just fired meaning topblock marker instantiated 
place search item action base marker protomarker specified plan step representing item 
item stack just re stacked topblock marker instantiated monitor function just fired meaning topblock marker instantiated 
put topblock marker spanner marker topblock marker dependency list put span topblock topblock action action component 
put item midst put put item relative result cant find view agent rotate view 
happens move view task account azimuth point trying view simply figures image coordinate far bottom image backs marcus 
compensated putting rotate action marker 
rotate item midst put put item relative put put item action marker 
table te handles completed pa layer actions completed pa layer action te response stack item midst span item marker index topblock protomarker marker index indicating item stack item midst span item marker index topblock protomarker marker index indicating item put item midst put put item relative result success marker protomarker represents stack sure markers pa layer correct identify routines associated objects seen camera 
set markers protomarker uninstantiated increment plan step counter 
delete marker order deletion completing current plan step marker deleting step 
look dependency list protomarker delete marker 
don increment plan step order doesn represent step 
put item toolbelt set position property component protomarker toolbelt increment plan step pick item set position property component protomarker hand increment plan step 
go destination set previous destination marker 
increment plan step counter 
stack item item midst determine item pose marcus just completed needed determine item pose find stack expected 
create marker fastener block doesn exist place determine item pose action 
place markers top bottom blocks dependency list 
markers protomarker dependency list 
table te handles completed pa layer actions completed pa layer action te response te starts new plan step table shows actions te takes various plan steps 
doing actions step te main loop creates protomarkers markers including global local coordinate conversion step needed 
markers created added pa layer 
note markers created stack bottom marker placed dependency list marker actions placed specified 
stack item item set index marker item topblock set property position bottom block 
set identify routines item item markers appropriate locate track routines 
set index protomarkers item item stack place markers dependency list 
delete protomarker single multi part entity associated stack protomarker 
increment plan step counter 
rotate item increment plan step counter 
determine item pose store result code prop field property component protomarker 
pose returned action stored prop data known associated object maintained pa layer stored 
increment plan step counter 
actions result success increment plan step counter 
action unhandled abort program halt agent 
table te handles completed pa layer actions completed pa layer action te response table te actions starting new plan step plan step wants action executed te actions add create marker agent location initialize previous destination global local converter 
delete protomarker deletes specified protomarker te 
markers deleted previous steps 
go destination destination entity location map current destination previous destination newly created destination marker current destination 
refer moving local global origin 
marker created start te step correct ego centric position go destination action component 
find go door place find door action door marker 
protomarker needs door marker dependency list 
rotate item place rotate item action protomarker marker marker index item 
search item protomarker represents stack change bottom block marker locate routine top block marker locate routine 
set monitor watch top block marker instantiation 
put search item action bottom block marker stacks single block marker protomarker represent stack 
set marker index item 
pick item associated object view verify relationship specified protomarker 
relationship set action detected component marker recreate relationship 
stacks bottom block marker get stack item item action 
protomarker relationship verified set appropriate block marker action pick item bottom block stacks just block singletons 
put item toolbelt protomarker stack verify blocks stacked 
place put toolbelt action appropriate marker 
put item find protomarker 
marker create local conversion agent location position object specified plan 
add marker appropriate object marker dependency list set marker action putdown item 
add marker pa layer 
put item relative find protomarker item calculate position item location relative offset specified plan step 
convert local space coordinate create marker 
remainder put item 
action initialize local global conversion system 
add action initializes previous destination initializes current destination 
creates new marker position marker step protomarker 
delete marker put delete marker action markers step protomarker dependency list 
stack item item find protomarkers item item fastener block 
agent needs fastener hand toolbelt stacking action pa layer look know stack built properly set identify routines markers item item put dependency lists 
place item action item marker 
note possible action taken block structure marcus implemented stacking singleton blocks 
table te actions starting new plan step plan step wants action executed te actions find go determine side hallway door left right relative agent 
agent position position door map 
set door protomarker marker action align hallway 
determine item pose find protomarkers bottom top blocks verify relationship exists remember action works stacks 
stack fastener marker put determine item pose action create marker place action 
span item item find protomarkers item item create markers necessary 
base marker item uninstantiated put search item action 
base marker item uninstantiated put search item 
instantiated topblock markers instantiated put spanner marker dependency list put span item item spanner action spanner marker 
note implementation allow spanner compound object 
say add say action protomarker marker string speak specified plan step parameter 
step just say plan completed successfully plan execution 
table te actions starting new plan step plan step wants action executed te actions 
marcus task flow diagrams section presents task flow diagrams task decomposition shown chapter figures 
double arrows see show continuation control flow sub diagram 
flow diagram assembly plan shown chapter figures shown tasks simply execute sequentially alphabetic order 
appendix marcus task figures go look navigate search turn look rotate turn stack item item move item view watch 
marcus task flow diagram span item spanner find item find topblock item find topblock item span topblock topblock spanner move topblock topblock view watch cross topblock topblock find item span topblock topblock spanner pick pickup effector move view watch pick 
marcus task flow diagram put put move view watch put item relative item put put toolbelt pick move view watch check item determine move view calculate 
marcus task flow diagram find hall door align center move walls rotate hall door rotate item turn item find watch door move door open hall necessary go door move align watch alignment hall door center rotate rotate item find align turret go door 
marcus task flow diagram find door move rotate door find door door rotate move rotate door 
marcus task flow diagram 
marcus task role diagrams search base block go block go base block pick base block search fastener go fastener put toolbelt go top block pick top block go assembly site stack top base block go fastener rotate door go door stack go stack pick stack go hall door 
top level task roles marcus roles base block assembly site roles item item search spanning block go spanning block pick spanning block search fastener go fastener rotate stack go stack determine stack pose span stack stack spanning block search stack go stack determine stack pose put stack relative stack 
top level task roles marcus continued go destination avoid obstacles look destination search item navigate destination turn destination look item rotate destination turn destination span item item spanner find item find topblock item find topblock item span topblock topblock spanner move topblock topblock view watch spanner cross topblock topblock find base item stack item item move item view watch item roles item item roles topblock topblock spanner roles item base topblock roles item base topblock roles obstacle destination pick item pickup effector move item view watch put put move view watch put item toolbelt pick move item view watch check item put item relative item put determine move item view calculate roles item roles item roles item roles item roles item roles item item find go hall door align rotate hall door watch baseboard alignment center hallway move equidistant walls rotate hall door rotate item turn item find hall door watch door move hall door open hall necessary align turret go door move find door move door rotate door find door move rotate destination track baseboard 
door task roles marcus roles front wall back wall roles door destination roles door destination roles hallway hall door roles door destination roles hall door destination roles hall door left edge right edge 
marcus role mappings table summarizes mappings roles steps marcus assembly plan roles tasks implement 
table role mappings plan step implemented plan step role mapped role go block go destination block destination search base block search item base block item go base block go destination base block destination pick base block pick item base block item search fastener search item fastener item go fastener go destination fastener destination put fastener toolbelt put item toolbelt fastener item search search item assembly site item put base block put item base block item assembly site go top block go destination top block destination pick top block pick item top block item go assembly site go destination assembly site destination stack top block block stack item item top block item base block item go fastener go destination fastener destination rotate door rotate destination door destination go door find go door door search stack search item stack item go stack go destination stack destination pick stack pick item stack item go hall door find go door hall door hall door search stack search item stack item go stack go destination stack destination determine stack pose determine item pose stack item put stack relative stack put item relative stack item stack item search search item spanning block item go spanning block go destination spanning block destination pick pick item spanning block item search fastener search item fastener item go fastener go destination fastener destination rotate stack rotate destination stack destination go stack go destination stack destination determine stack pose determine item pose stack item span stack span item item spanner stack item stack item spanning block spanner table role mappings plan step implemented plan step role mapped role appendix contains list constraints walk dog task chapter 
constraints appear chapter particularly task specification 
repeated convenience 

walk dog task constraints 
agent environment consists intersecting roads crosswalk park dog moving cars mailbox sidewalk roses ball leash 

cars street moving 

dog walked distinct dogs may environment move 

dog leash 

agent walk dog park route specified sidewalk right side street crosswalk park 

dog kept street crossing crosswalk 

dog agent avoid cars street 

dog kept flowers roses 

dog kept sidewalk 

agent control dog position leash agent pick dog carry park 

agent play fetch dog reaching park 

agent ball play fetch 

dog retrieve ball thrown 

agent playing fetch dog appears tired 
appendix task constraints agre chapman 
plans 
robotics autonomous systems 
agre chapman 
pengi implementation theory activity 
aaai 
albus 
nist real time control architecture rcs approach intelligent systems research 
journal experimental theoretical artificial intelligence 
aloimonos 
active vision 
international journal computer vision 
arkin balch 
aura principles practices review 
journal experimental theoretical artificial intelligence 
attneave 
visual world head 
american journal psychology 
ballard rao 
deictic codes embodiment cognition 
behavior brain sciences 
ballard 
animate vision 
artificial intelligence 
ballard brown 
computer vision 
prentice hall 
englewood cliffs nj 
bonasso firby gat kortenkamp miller slack 
experiences architecture intelligent reactive agents 
journal experimental theoretical artificial intelligence 
booch 
object oriented design applications 
benjamin cummings publishing redwood city ca 
borenstein koren 
vector field histogram fast obstacle avoidance mobile robots 
ieee transactions robotics automation 
brill wasson ferrer martin 
effective field view paradigm adding representation reactive system 
journal engineering applications artificial intelligence 
brill 
representation local space perception action systems behaving appropriately difficult situations 
ph dissertation 
department computer science 
university virginia 
brooks 
intelligence representation 
artificial intelligence 
brooks 
elephants don play chess 
robotics autonomous systems 
brooks 
robust layered control system mobile robot 
ieee journal robotics automation ra 
bryson 
hierarchy sequence vs full parallelism action selection 
submitted cognitive science 
chapman 
intermediate vision architecture implementation 
cognitive science 
chapman 
planning conjunctive goals 
artificial intelligence 
cohen voss 
comprehensive study object triangulation 
proceedings spie mobile robots vii vol 

connell 
sss hybrid architecture applied robot navigation 
ieee international conference robotics automation 
dennis 
data flow supercomputers 
ieee computer 
duda hart 
hough transformation detect lines curves pictures 
communications acm 
feldman 
frames suffice provisional model vision space 
behavioral brain sciences 
ferguson 
touring machines architecture dynamic rational mobile agents 
ph dissertation 
computer science department 
university cambridge 
firby 
adaptive execution complex dynamic worlds 
ph dissertation 
computer science department 
yale university 
firby 
investigation reactive planning complex domains 
aaai 
gat 
integrated planning reacting heterogeneous asynchronous architecture controlling real world robots 
aaai 
gat 
alfa language programming reactive robotic control systems 
ieee international conference robotics automation 
guiard 
asymmetry bimanual skills 
manual asymmetries motor performance 
elliot roy eds 
crc press 
boca raton fl 
horswill 
visual architecture cognitive architectures 
journal exper theoretical artificial intelligence 
horswill 
real time control attention behavior logical framework 
international conference autonomous agents 
horswill 
polly vision artificial agent 
aaai 
horswill 
specialization perceptual processes 
ph dissertation 
department electrical engineering computer science 
massachusetts institute technology 
huber 
object tracking stereo vision 
aiaa nasa conference intelligent robots factory service space 
huber kortenkamp 
stereo vision pursue moving agents mobile robot 
ieee conference robotics automation 
jones flynn 
mobile robots inspiration implementation peters wellesley ma 

today tomorrow man 
artificial intelligence 
knuth 
marriages 
les presses de universit de 
kak 
fast vision guided mobile robot navigation model reasoning prediction uncertainties 
cvgip image understanding 
kuipers byun 
robot exploration mapping strategy semantic hierarchy spatial representation 
robotics autonomous systems 
kuipers levitt 
navigation mapping large scale space 
ai magazine 
kuipers 
modeling spatial knowledge 
cognitive science 
kuniyoshi ishii 
vision behaviors multi robot cooperation 
iros 
laird yager 
soar integration external interaction planning learning soar 
robotics autonomous systems 
lesser erman 
retrospective view hearsay ii architecture 
ijcai 
maes 
situated agents goals 
robotics autonomous systems 
marr 
vision 
freeman 
san francisco ca 
mataric 
integration representation goal driven behavior robots 
ieee transactions robotics automation 
mccarthy hayes 
philosophical problems standpoint artificial intelligence 
readings artificial intelligence 
tioga palo alto ca 
mcdermott reactive plan language 
research report yaleu dcs rr 
yale university 

miller 
spatial representation system mobile robots 
ieee international conference robotics automation 
moravec 
robot spatial perception stereoscopic vision evidence grids 
cmu technical report cmu ri tr 
moravec elfes 
high resolution maps wide angle sonar 
ieee international conference robotics automation 
musliner durfee shin 
circa cooperative intelligent real time control architecture 
ieee transactions systems man cybernetics 

consistency maintenance concurrent representations 
ph dissertation 
department computer science 
university virginia 
nilsson 
shakey robot 
technical note 
sri international 
menlo park california 
noreils chatila 
plan execution monitoring control architecture mobile robots 
ieee trans 
robotics automation 
parnas 
criteria decomposing systems modules 
communications acm 
seifert opportunistic planning reminded pending goals 
cognitive psychology 
pearson huffman willis laird jones 
symbolic solution intelligent real time control 
robotics autonomous systems 
pylyshyn storm 
tracking multiple independent targets evidence parallel tracking mechanism 
spatial vision 
rich knight 
artificial intelligence 
mcgraw hill 
new york ny 
kuniyoshi 
architecture vision purposive behaviors 
iros 
sacerdoti 
planning hierarchy abstraction spaces 
artificial intelligence 
scheifler gettys 
window system 
acm transactions graphics 
sethi ravi 

programming languages 
addison wesley 
reading ma 
simmons 
architecture coordinating planning sensing action 
proceedings workshop innovative approaches planning scheduling control 
slack 
sequencing formally defined reactions robotic activity integrating raps 
proceedings spie conference sensor fusion 
spector hendler 
planning reacting levels representation 
international journal intelligent cooperative information systems 
swain ballard 
color indexing 
international journal computer vision 
terzopoulos 
animat vision active vision artificial animals 
iccv 
tracz 
program salesman software reuse 
addison wesley 
reading ma 
tsotsos 
intelligence scaling problem 
artificial intelligence 
ullman 
visual routines 
cognition 
wasson kortenkamp huber 
integrating active perception autonomous robot architecture 
robotics automation 
wasson martin 
multi tiered representation autonomous agents 
spie symposium intelligent systems advanced manufacturing 
wasson huber kortenkamp behavior visual architecture autonomous robots 

cvpr workshop perception mobile agents 
wasson kortenkamp huber 
integrating active perception autonomous robot architecture 
nd international conference autonomous agents 
wasson ferrer martin reynolds 
consistency maintenance autonomous agent representations 
technical report cs 
computer science department 
university virginia 
wasson ferrer martin 
systems perception action effective representation 
flairs 
wasson ferrer martin 
perception action effective representation multi layered systems 
gi vi 
wirth 
program development stepwise refinement 
communications acm 

visual tracking attention perceptual organization 
cognitive psychology 
zelkowitz shaw gannon 
principles software engineering design 
prentice hall 
englewood cliffs nj 
zilberstein russell 
optimal composition real time systems 
artificial intelligence 
