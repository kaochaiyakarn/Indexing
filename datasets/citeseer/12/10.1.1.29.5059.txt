relevant analysis natural deduction submitted degree doctor philosophy queen mary westfield college university london april relevant analysis natural deduction linear relevant logics studied widely mathematical philosophical computational logic 
describe logical framework rlf defining natural deduction presentations logics 
rlf consists language manner similar harper honsell plotkin lf representation mechanism language rlf ll calculus representation mechanism judgements types developed relevant logics 
ll calculus type theory order dependent type theory kinds dependent function spaces linear intuitionistic 
study natural deduction presentation type theory establish required proof theoretic meta theory 
rlf framework conservative extension lf 
show rlf uniformly encodes fragments intuitionistic linear logic curry calculus ml 
describe curry howard de bruijn correspondence ll calculus structural fragment hearn pym logic bi bunched implications 
show categorical semantics ll calculus kripke resource models monoid indexed set kripke functors 
indexing monoid seen providing account resource consumption 
models seen indexed formulation categorical models read bunches 
study version ll calculus prove cut elimination theorem 
submitted degree doctor philosophy queen mary westfield college university london april supervisor david pym learned help support great importance 
members supervisory committee edmund robinson hodges regard 
pablo adam paul levy david advice suggestions support 
supported epsrc research studentship stages department computer science 
eu types working group provided funds attend types france types germany 
diagrams drawn paul taylor diagram proof tree packages 
contents ll calculus rlf logical framework 
motivation 
ll calculus 
context joining 
multiple occurrences 
variable sharing 
definitional equality 
basic properties ll calculus 
conversion 
related systems 
conservativity 
example encodings 
ill 
ml 
calculus 
summary 
propositions types correspondence 
logic bi 
fragment logic bi 
correspondence 
correspondences 
summary 
kripke resource semantics 
ll calculus 
syntactic presentation 
internal logic 
algebraic presentation 
kripke resource models ll calculus 
kripke resource ll structure 
kripke resource ll model 
soundness completeness 
class set theoretic models 
summary 
ll calculus 
ll calculus 
soundness completeness 
cut elimination 
summary 
bibliography list tables fragment ill 
ll calculus 
ll calculus continued 
context joining 
parallel nested reduction 
fragment ill 
valid proof expressions ill 
left rules 
chapter chapter introduce notion relevant logical frameworks study proof theory internal logic categorical model theory type theoretic language framework introducing subsequent chapters thesis 
starting point thesis study logical framework particular class logics linear relevant logics 
general theory logics main motivations 
firstly desire study common core logics 
secondly provide single meta language capable representing class logics implemented machine 
implementation meta language automatically provides implementations class logics hhp 
logical framework study meta language ll calculus order dependent type theory kinds dependent function spaces linear intuitionistic 
thesis concentrates semantics proof model theoretic type theory 
explain word relevant title thesis 
read rea term relevant family logics weaker structural properties intuitionistic classical logic 
restrict merely logics contraction weakening 
refer related appropriate places text 
chapter 
ll calculus rlf logical framework consider situation ambient universe uses meta language reason compute possibly formal system 
examples general situation abound 
example mathematics uses logic reason group theory 
example heart logical frameworks informatics uses low level language implement class high level languages exploiting computational characteristics low level language correct compilation high level languages low level language execute high level languages 
logical frameworks formal meta logics provide languages describing logics manner suitable mechanical implementation 
lf logical framework hhp pym provides meta theory suitable logics structural strength minimal propositional logic 
wish study logical framework describing relevant logics 
class logics interesting philosophical logical computer science point view 
order describe logical framework 
characterize class object logics represented 
give meta logic language meta logical status vis vis class object logics 
characterize representation mechanism object logics 
prescription conveniently summarized slogan framework language representation representation mechanism judgements types originates development kant notion judgement ml 
methodology judgements judgements represented type proofs 
logical system represented signature assigns kinds types finite set constants represent syntax judgements rule schemes 
representation theorems relate consequence object logic consequence encoded logic certain class uniform representations hst identified considering surjective encodings consequences object logic consequences meta logic judgements meta logic corresponding judgements object logic 
judgement types methodology property encoded systems inherit structural properties meta logic 
reason lf language lp calculus admits weakening contraction uniformly encode linear relevant logics 
limitation overcome ways 
way add equations signature constrain judgement ex post facto 
method adopted avron encoding linear calculus lf linearity constraint enforced introducing extraneous language axiomatize concept strictness domain theory 
way overcome limitation weaken framework working weaker framework language 
approach natural brings fact structural strength framework effectively reflects structural strength class object logics encodes 
order represent reason object logic particular strength endow framework appropriate level structure 
second method seen application physicist john baez calls microcosm principle bd 
seek language weakening contraction forced 
motivate connectives language considering natural deduction form rules relevant logics 
specific example chapter consider natural deduction rules omega connectives linear logic sole judgement concerned proo proposition delta delta delta proo delta delta delta proo omega omega proo delta delta delta omega proo delta delta delta proo omega proo delta delta delta proo delta delta delta proo proo delta delta delta proo proo table fragment ill order distinguish encoding elimination rules need kinds conjunctions additive multiplicative 
need connective represent inference object logic 
representation rules constants chapter 
signature ill follows tensor pf proo ffi proo ffi proo omega tensor pf proo omega ffi proo ffi proo ffi proo ffi proo pf proo proo ffi proo pf proo ffi proo type propositions constructors omega type ffi ffi fact omega connective needed part meta language curried away ffi connective represents inference 
quantification intuitionistic 
logics describe resource conscious situations dynamic semantics ml need linear quantification 
analysis undertaken generally considering prawitz pra general form schematic elimination rules relevant point view 
resulting meta language ll calculus connectives additive conjunction quantifiers linear intuitionistic implications arising non dependent versions quantifiers 
ll calculus order dependent type theory intuitionistic linear dependent function spaces 
basic judgement type theory term type context signature definition relies crucially notions joining maintenance contexts 
particular full dependency set notion sharing deals formedness linear dependent types 
rules function spaces linear lx intuitionistic lx just notation px follows lx lx mll lx lx preview rules introduces key characteristic type theory building context linear intuitionistic variables 
particular zone stoup separating linear intuitionistic parts context 
judgement decidable 
proof statement involves proving strong normalization essential meta theoretic properties 
chapter motivate rlf logical framework give natural deduction presentation language ll calculus 
establish required proof theoretic meta theory language 
show rlf conservative extension lf rlf uniformly encodes lf encodes 
object logic encodings characteristics ll calculus 
large part chapter appeared ip ss dj pym 
relevant analysis natural deduction 
journal logic computation 
brief concerning choice methodology logical frameworks 
earlier mentioned logic language mathematics purpose thesis develop type theoretic logical framework representing certain classes formal systems 
logicist intention claim 
consider linguistic algebraic frameworks 
important stress methodology type theoretic logical frameworks evidenced lf hhp earlier automath db 
adopt principle weakness require mechanism binding minimal decidable meta language 
add strength meta language interesting study weak situations 
propositions types correspondence ll calculus type theory motivated consideration inter alia linear logic 
structurally closer bi logic bunched implications 
linear logic begins removing structural rules querying consequences conjunction decomposes additive conjunction multiplicative conjunction omega bi contrast begins decomposing implication directly terms conjunction 
bi kinds function spaces linear intuitionistic correspondingly kinds quantifiers linear new intuitionistic 
proof theoretically arise extra structure context 
distinct context formation operators admits structural rules weakening contraction doesn 
scheme contexts lists trees internal nodes labelled 
rules implications follows chapter 
similar pair rules quantifiers bi bunched structure variable context determines type quantifier linear intuitionistic formed abstraction 
eliminating connectives premiss contexts combined regard type linear intuitionistic connective 
conceptual similarity ll calculus arises contexts seen extended ways ll calculus bi subject restrictions bi working fragment original logic exactly allows show curry howard de bruijn correspondence ll calculus bi 
statement result proof chapter 
bi probably folklore relevant logic decent proof theory semantics computational interpretation dun rea op 
kripke resource models chapter study categorical semantics type theory 
nature class models motivated considering notion resource primitive informatics 
resource space time seen monoidal structure sense identify elements including null combinations resources 
consider comparison resources sense better sense able prove facts 
resource semantics elegantly explains difference linear intuitionistic connectives action computation linear connectives seen consume resources 
delta resource monoid addition partial ordering elements give simplified version forcing relation internal logic type theory 
delta 
resource semantics combines generalizes kripke semantics intuitionistic logic proposition interpreted set poset urquhart semantics relevant logic proposition interpreted set monoid kri 
semantics ll calculus kripke resource models set kripke functors 
kripke functor roughly speaking indexed category extra structure 
items extra structure worth mentioning 
base indexed category monoidal structures 
allows model kinds context extension syntax interpreted jgk omega jak interpreted jgk theta jak 
second item existence natural isomorphism allows formation function spaces 
necessary model linear dependent function space 
intuitionistic dependent function space defined natural isomorphism equivalent usual characterization function space right adjoint weakening 
include example kripke resource models 
term model constructed syntax type theory 
main purpose construction show henkin style completeness theorem 
second model set theoretic built spirit cartmell streicher contextual category families sets car str interesting 
model constructs kinds indexed products set op small monoidal category 
usual cartesian product described cartmell instance 
second restriction day tensor product day 
kripke resource models especially set theoretic model seen indexed formulation categorical models read bunches 
ll calculus presentation ll calculus chapter linearized natural deduction system 
chapter version natural deduction system mle ml elimination rules non dependent versions replaced rules introduce connectives context left hand side sequent 
consider linear case 
mle rule natural deduction system follows lx mn context formed sharing sensitive join premiss contexts sequent calculus system rule replaced ll rule ll yn chapter 
new fv jc 
ll rule obvious candidate mle 
consider rule intuitionistically extends similar analysis applies ml rule 
completeness sequent calculus version ll calculus respect natural deduction version depends crucially presence cut rules admissible taken explicitly sequent calculus system 
working normal forms proofs prove cut elimination theorem 
chapter allow study proof search type theory uniformly encoded object logics rlf logical framework 
chapter ll calculus rlf logical framework linear relevant logics studied widely mathematical avr gir mey sh philosophical ab dun rea computational abr hm mtv ph logic 
study logical framework rlf defining natural deduction presentations logics 
rlf consists language manner similar lf hhp pym representation mechanism 
language rlf ll calculus system order linear dependent function types uses function describe degree sharing variables functions arguments 
representation mechanism judgements types developed linear relevant logics 
motivate ll calculus considering form relevant natural deduction 
specify ll calculus family order dependent type theories linear intuitionistic function spaces discussing briefly possible intermediate systems 
framework rlf conservative extension lf notion conservative extension takes account representation mechanism type theory 
reported builds ideas pym pym 
recall word relevant read description family logics weaker structural properties intuitionistic classical logic merely contraction weakening 
read taxonomy place linear logic rlf common lf able define hilbert type systems scope 
chapter 
ll calculus rlf logical framework exponentials lowest point lattice word informally technical sense logics 
follow taxonomy obtain lattice logical frameworks weakest rlf type theory weakening contraction 
emphasize ll calculus lies properly world relevant logics type theory contexts dependently typed notion read bunches rea 
framework rlf provides relevant analysis natural deduction just lf provides intuitionistic analysis natural deduction 
study variety distributivity laws usually considered relevant contexts rea 
investigation fit framework possibly variations ll calculus quite straightforwardly 
chapter organized follows 
section motivate ll calculus context logical framework considering form relevant natural deduction 
formally define type theory summarize meta theory section concluding section comparison related 
section show rlf conservative extension lf 
section illustrate example encodings rlf framework 
object logics consider fragment propositional intuitionistic linear logic dynamic semantics ml relevant calculus 
motivation logical frameworks formal meta logics inter alia provide languages describing logics manner suitable mechanical implementation 
lf logical framework hhp pym provides metatheory suitable logics structural strength minimal propositional logic 
wish study logical framework describing relevant logics 
order describe logical framework 
characterize class object logics represented 
give meta logic language meta logical status vis vis class object logics 
characterize representation mechanism object logics 
prescription conveniently summarized slogan framework language representation literature terms sub structural weak way 

motivation components entirely independent pym 
point interdependencies section 
representation mechanism judgements types originates ml development kant kan notion judgement 
higher order judgements hypothetical general correspond ordinary dependent function spaces respectively 
methodology judgements types judgements represented type proofs 
logical system represented signature assigns kinds types finite set constants represent syntax judgements rule schemes 
object logic rules proofs seen proofs general judgements cm representation theorems relate consequence object logic consequence encoded logic ob ject gamma consequence encoding meta gamma consequence set variables occur judgements proof object term corresponds corresponds place holder encoding meta logic term corresponding encoding sequel consider complete apparatus judged object logics 
example encodings section pathological sense require judgement 
example encoding fragment intuitionistic linear logic requires judgement proo contrast general multi judgement representation techniques 
conjecture studies applied general case defer development occasion 
certain class uniform representations identified considering surjective encodings consequences object logic consequences meta logic hst 
judgements meta logic corresponding judgements object logic 
judgement types methodology property encoded systems inherit structural properties meta logic 
reason lf language lp calculus admits weakening contraction uniformly encode linear relevant logics 
specification hst stronger requiring uniformity presentations logic 
concerns scope 
chapter 
ll calculus rlf logical framework illustrate point suppose ill uniform encoding intuitionistic linear logic lf ill image object consequence ill 
ill provable gq ill 
uniformity image object logic consequence ill implies weakening linear logic contradiction 
seek language weakening contraction forced 
motivate connectives language considering natural deduction form rules weak logics 
general way considering prawitz general form schematic introductions relevant point view 
prawitz pra gives intuitionistic logic 
schematic rule ary sentential operator represented rule form 
rule bound assumptions shown elide sake readability 
delta delta delta 
delta delta delta delta delta delta rule fs gs hs formulae constructed usual way 
inference infers formula premisses may bind assumptions form occur premiss assumptions multi sets keeping structural rule exchange 
require discharge compulsory 
case natural deduction presentation intuitionistic linear logic instance require ff fg example rule ff ff yg annotate schema indicate method encoding 
type propositions linear universal quantifier intuitionistic universal quantifier 
quantify linear proposition lf intuitionistic proposition pg lg lf range linear intuitionistic quantifications 
inference binding assumptions premiss inference formula premisses represented ffi 
motivation lf delta delta delta ffi 
delta delta delta ffi 
delta delta delta 
ffi ffi premisses combined multiplicatively additively depending contexts disjoint 
distinguish combinations conjunctions multiplicative omega tensor additive force structural rules 
traditional relevance logics multiplicative referred intentional additive extensional 
meta syntax omega mindful relationship operators 
full expressivity recovered introducing modality 
bang language 
premiss allows depart relevant inference choose number times 
meta logic schematic rule represented constant type lf lh ffi ffi lh represents iterated general encoding formula seen connectives omega occur negatively 
tensor case allows curry away omega modulo permutation premisses 
example type able replace occurrence omega lh ffi omega ffi ffi ffi lh ffi ffi ffi ffi consider currying away non dependent version additive function space 
language kinds dependent function space interesting scope current study 
chapter 
ll calculus rlf logical framework recapitulate exactly logical constants framework undertake additive conjunction quantify non dependent form represent implication represent dereliction relevant inference 
able formulate precise idea regarding completeness set pg respect sentential operators explicit schematic rules pra sh 
similar analysis undertaken corresponding elimination rule 
analysis allows degrees freedom 
structural level types 
section main intention motivate language structural rules weakening contraction forced able uniformly encode linear logic 
language range relevant logics rea includes instance anderson relevance logic ab 
choosing different language particular structural distributivity properties allow uniformly encode class logics 
family relevant logics determined choices interesting representational perspective pursue thesis 
second orthogonal degree freedom concentrate sequel concerns corresponding range structural choices level terms opposed types 
considering aspect logical point view consider multiple occurrences proof 
degree proof shared propositions structural property determines curry howard de bruijn correspondence type theory functions arguments share variables corresponding degree 
language motivated section develop sequel type theory curry howard de bruijn correspondence structural fragment bi logic bunched implications 
details correspondence chapter 
ll calculus ll calculus order dependent type theory intuitionistic linear function types 
calculus deriving typing judgements 
entities ll calculus objects types families types kinds 
objects denoted classified types 
families types denoted may thought functions map objects types 
kinds denoted classify families 
particular kind type 
ll calculus classifies types 
denote entities 
assume disjoint countably infinite sets meta variables range set variables range set object level constants range set type level constants 
syntax ll calculus grammar kinds type lx lx types lx lx lx lx am ob jects lx lx mn hm ni write range linear intuitionistic variable declarations 
bind variable object lx inhabitant linear dependent function type lx object lx inhabitant type lx amounts martin lof style px notion linear free bound variables substitution may defined accordingly bie 
free write lx lx respectively 
basic study include units added type theory little difficulty 
define notion linear occurrence extending general idea occurrence calculus bar note definitions may possible 
definition linear occurrence 
linearly occurs 
linearly occurs linearly occurs ly ly uv 
linearly occurs linearly occurs hm ni 
linearly occurs linearly occurs 
linearly occurs linearly occurs definition extended inhabited type kind 
definition linear occurrence variable linearly occurs expression linearly occurs 
chapter 
ll calculus rlf logical framework definitions linear girard sense ben bar 
quite natural bunches setting 
hearn pym instance examples bi terms chapter show ll calculus propositions correspondence non trivial fragment bi linear variables appear op 
example linear variable occurs terms cx bx assuming lx bx assuming ly cx cx cx assuming type 
sequel refer informally concept linearity constraint 
essentially means linear variables declared context production consumption contract 
depart usual resource conscious logics idea formulae produced antecedent consumed succedent 
judgement cx cx linear consumed type declared consumed succedent valid 
ll calculus signatures keep track types kinds assigned constants 
contexts keep track types linear intuitionistic assigned variables 
syntax signatures contexts grammar signatures hi contexts hi signatures contexts consist finite sequences declarations 
dependency aspect type theory requires bases linearly ordered bar page 
assume usual extraction functions dom ran related lists 
define functions extract just linear intuitionistic exponential parts context lin hi hi exp hi hi lin lin exp exp lin lin exp exp ll calculus formal system deriving judgements 
ll calculus sig valid signature context valid context kind valid kind kind type write kind abuse notation write indicate derivability ll calculus case said valid signature context definition type theory depends crucially notions 
joining contexts form third undertaken order declarations type variables linear versus intuitionistic respected 
idea linear variable occurrences allows form contexts form type constant signature 
contexts repeated distinct declarations variable possible 
joining contexts certain occurrences linear variables shared function argument identified 
sharing implemented function 
notions explicated appropriate points sequel 
rules deriving judgements tables 
save space place side conditions premisses 
rules conveniently separated linear intuitionistic set relating directly intuitionistic lp calculus 
signature formation rules enforce intuitionistic behaviour allowing constant intuitionistic type extend signature 
context formation rules allow types assigned variables 
distinguish extending context linear intuitionistic variables 
context formation rules introduce particular characteristics type theory 
joining premiss contexts multiplicative rules 
join respect ordering premiss contexts concept linear versus intuitionistic variables 
method join denoted defined section 
chapter 
ll calculus rlf logical framework valid signatures hi sig sig kind sk 
sig sig type sa 
sig valid contexts sig hi context context type dom ga context context type dom ga context valid kinds context kax type kind kind kli lx kind type kind lin lin kli kind kind kl lx kind table ll calculus order motivate second characteristic type theory consider simple apparently innocuous derivation 
example type type note argument type cx dependent linear free 
delta delta delta cx type cx cx cx lz cx cx delta delta delta cx type cx cx cx cx cx problem excess linear xs appear combined context application step 
step types match literally 
problem arises equal 
solution recognize xs distinct occurrences variable occurring argument type cx allow degree freedom sharing occurrences 
necessary formally define binding strategy multiple occurrences 
ll calculus valid families types context ac type ali lx type type type lin lin ali type type lx type alli lx lx lx nk ale bn lx lx lx bn type type type kind valid objects context mc type mvar type mvar 
lx lx lx nk mle mn mll lx lx lx ml mn hm ni type table ll calculus continued chapter 
ll calculus rlf logical framework section 
sharing aspect implemented function defined section 
implication solution repeated declarations variable allowed contexts 
reason usual side condition dom absent rules valid contexts course don allow variable inhabit distinct types 
kli ali pair rules form linear function spaces 
pair fv constructs linear dependent function spaces 
second rule pair constructs ordinary linear function spaces 
side conditions rules joins premiss contexts second necessary book keeping occurrences linear variables identified current binding strategy 
side conditions ale mle rules similar nature 
function selects critical linear occurrences 
occurrences removed give context 
seen side conditions type theoretically propositions types correspondence logically natural 
essential difference linear intuitionistic function spaces observed considering mle ml rules 
context argument entirely intuitionistic allows function times likes 
example sub section example derivation involve sharing 
type type ly dy construct hi context ly dy type ex dx lx ex lx dx type lx ex dx lx ex ez ez dz maintains linear occurrence variable context joining method joining contexts ternary relation read contexts joined form context 
proof search context split contexts 
rule defining states empty context formed joining empty contexts 
second third rules comply linearity constraint 
ll calculus imply linear variables exactly rule takes account structural properties intuitionistic variables 
search intuitionistic variable sent ways context split 
join hi hi hi join join join 
table context joining context joining relation respect ordering contexts linearity constraint defined binding strategy section 
context context context vice versa split 
studying distribution laws relevant contexts context joining relation need take regard context equalities 
brief relation regard logic programming 
noted proof search basis logic programming relation read split 
implementation ll calculus logic programming language calculate splittings techniques similar lolli hm interesting consider approaches remained unevaluated long possible search 
approach resemble matrix methods wal 
multiple occurrences consider multiple occurrences idea proposition types reading 
understood uses proof proposition opposed seen distinct proofs proposition 
idea seen presence binding strategy define internalization conversion allows degree freedom structural level terms opposed types useful dealing variable sharing section 
chapter 
ll calculus rlf logical framework section define left free occurrence corresponding binding strategy 
sequel noting generalized 
definition left linear occurrence defined follows provided 
denote atoms constants variables say distinct 
constant variable constant variable cases trivial lm fg distinct lm fxg abstraction adopt usual technique capture avoiding substitution case occurrence bound 
induction binds occurrence left convert lz continue 
give cases binder ones exactly similar 
lm ly lm lm distinct lm lx lm lz new application left occurrence vm failing case constant variable straight forward lm lm distinct lm xm fxg need check free lm vm lm lm pairing deal additive cases disjoint union left occurrence components pair lm hm ni lm lm lm lm lm lm lm define left occurrence context declaration similarly right occurrence declaration 
binding strategy formalizes concept linearity constraint 
ll calculus definition left binding assume right occurrence context 
binds 
left occurrence ran declaration 
unbound left linear occurrences linearity constraint intuitionistic variables right occurrence context binds unbound xs type declaration occurrences rules deriving judgements read strategy place 
example rule binds left occurrence 
similarly admissible cut rule term cuts left occurrence context corresponding intuitionistic rules binds occurrences cuts occurrences context sequel left binding cutting strategy discussed 
general strategy binding th variable left cutting th variable left 
variable sharing variable sharing central notion allows linear dependency set 
fact notion implicit definition linear occurrence 
ll calculus uses function implements degree sharing variables functions arguments 
define considering situation contexts form bx 
case declarations identified form bx 
definition function defined binary multiplicative ale mle cut rules lz nk ale mle un delta delta delta nk cut 
chapter 
ll calculus rlf logical framework occurring construct right left follows fg lin lin fx lin lin right ii right ii second clause definition stated follows right occurrence clause needed form consistent type theory allows formation sufficiently complex dependent types 
mean types lx lx gamma abstracting types depend previously abstracted variables 
binary rules variables occur order establish formedness types premiss contexts premisses occur order establish formedness types 
possible variables occurring premisses play role logical structure proof variables duplicated 
requirements regulated absence sharing variables clause applies obtain useful linear dependent type theory linear dependent function space dependency abstracting previously abstracted variables 
example type theory encode dynamic semantics ml section 
definition consider example 
example suppose type type construct type type cx type cx cx cx lz cx cx type type cx type cx cx cx cx cx formally defined recursively structure read right left 
adopt informal notation ease expression 

ll calculus denotes context join get side condition interesting 
premiss contexts joined get cx 
removes extra occurrence restores linearity constraint 
similar situation arises cut cx cx cx cx cx cx function required vacuous certain restrictions ll calculus type theory considered 
instance restrict type formation entirely intuitionistic type judgements form type recover fp fragment cervesato pfenning 
type theory cp 
fragment include unit stating subject reduction property section 
simple dependency case restricted type theory useful encode fragment intuitionistic linear logic section 
definitional equality definitional equality relation consider conversion terms levels 
definitional equality relation terms respective level defined symmetric transitive closure parallel nested reduction relation defined table 
note rules substitution performed bound occurrences transitive closure denoted 
conversion sufficient current purposes foresee little difficulty lp calculus coq sal strengthening definitional equality relationship rule 
section 
basic properties ll calculus section study basic properties ll calculus 
proof techniques new adapted harper hhp setting 
minor points note regarding proofs meta theory 
point note 
ll calculus conservative extension lp calculus number cases deal proofs structural induction greater 
concentrate fragment chapter 
ll calculus rlf logical framework 
re 
ml lx lx 
kl lx lx 
mapp mn 
lx lx 
mb lx 
lx lx 
hm ni hm 
am 
mp 
ab lx 
mp hm ni 

mp hm ni table parallel nested reduction type theory fragment dealt quite similarly 
show representative interesting cases 
reason large number cases linear dependent aspect type theory 
instance consider judgement obtained application binary rule 
linearity constraint allows linearly occur types declared linearly occur linearly occur types declared linearly occur sharing occurred assumed sent separate premiss contexts 
sharing complicates analysis argument fairly routine inductive 
consider characteristic properties reduction relation 
desirable technical properties proving major results 
show substitution conserved reduction 
lemma 
proof induction length proof representative cases 

ll calculus take ly inferred ml 
form ly ly ly induction hypothesis twice get rule 
ml allows infer ly ly ly 
ly 
mn sub cases consider 

inferred 
mapp 
form mn induction hypothesis twice get rule mapp allows infer 
mn 


inferred mb 
form ly 
induction hypothesis twice get rule 
mb allows infer ly 
ly 

chapter 
ll calculus rlf logical framework proof parallel reduction relation adaption combinatorial proof ste traces back tait martin lof ml 
combinatorial approach works reduction relation kinds types objects defined levels terms 
lemma pi exists proof induction sum lengths proofs take lx lx psi gamma gamma gamma lx lx 
psi 
lx induction hypothesis twice exists exists result follows 
ml take mn cases consider depending derived 
mapp 
mb 

derived 
mapp 
mn psi gamma gamma gamma 
psi 
induction hypothesis twice exists exists result follows 
mapp take 
ll calculus 
derived 
mb 
lx psi gamma gamma gamma 
psi 
induction hypothesis twice exists exists lemma result follows diagram 

follows 
mapp 
mb 
lx psi gamma gamma gamma lx 
psi 
lx lx derived 
ml 
induction hypothesis twice exists st exists lemma 
mb lx result follows diagram 
hm ni hm ni psi gamma gamma gamma hm hm 
psi 
hm induction hypothesis twice exists exists result follows 
take hm chapter 
ll calculus rlf logical framework 
psi gamma gamma gamma 
psi 
induction hypothesis exists st result follows 
mp take third property church rosser follows 
lemma cr property exists proof induction number steps 
base case just diamond property confluence 
inductive step assume hypothesis gamma steps 












complete case fill bottom right rectangle 
consider admissibility structural rules 
lemma useful proving 
analyses type assignment abstraction obtained 
specific part specialized linearity case barendregt generation lemma pure type systems pts bar 
lemma inversion lx lx 
ll calculus proof consider derivation lx lx conversion rules change term lx follow branch derivation term lx introduced time 
done abstraction rule 
abstraction rule lx lx lx statement lemma follows inspection abstraction 
theorem lemma allow weakening contraction intuitionistic parts recall earlier comments section regarding consideration particular language allows admit certain structural rules 
theorem details ll calculus 
comment form admissible structural rules 
exchange contraction rules inherited dependent linear type theory respectively 
rule weakening requires context proving typedness entirely intuitionistic 
rule dereliction requires free variables linear type 
cut comes forms cutting linear variable cutting exponential 
rules read current binding strategy 
extra side conditions exchange enforce context formedness accordance left binding strategy 
theorem structural structural rules admissible 
exchange provided fv fv type 
weakening type 
dereliction free variables 
contraction 
cut sub proof nk 
cut 
chapter 
ll calculus rlf logical framework proof induction structure proof premisses 
representative cases 
admissibility weakening mc context construct context type ga context mc side condition ga application 
mvar type 
induction hypothesis type construct type mvar exchange step possible depend particular initial judgement type correct 
ly ly induction hypothesis construct ly ly exchange step possible dependent particular judgement type variable dependent 
mle mn ly 
induction hypothesis twice ly 
ll calculus sensitive join sensitive join mle construct ly mn nk 
admissibility dereliction mvar type 
case free variables just mvar 
get suppose fv 
intuitionistic type done 
consider step introduced replace application mvar mvar ly ly sub cases depending linear variables consumed 

fv 
linear occurrence exchange puts judgement form apply induction hypothesis 
get 
apply exchange get ly ly 
fv 
case argued similarly 
admissibility contraction mc suppose context context validity judgement constructed series applications ga context type ay context general join 
clause join contexts premiss apply ac rule 
weakenings exchanges necessary allow construct chapter 
ll calculus rlf logical framework context equivalent required result 
suppose lz lz bc case proceed need assumptions regarding kinds example consider intuitionistic variable occur type linearly occur lx type linearly occur type really lx type lastly previous cases occur 
argument applies case basically consider theta sub cases generated intuitionistic variables ranging minimum type type maximum type type 
consider cases 

suppose exponential variables 
modulo rule applied mle 
second argument premiss derived mvar lz type premisses derivation form induction hypothesis applied 
induction hypothesis twice definition substitution rules mvar ale allows reconstruct derivation type required result 

sub case argued similarly 
omit details 

ll calculus admissibility cut mvar type 
show 
follows assumption nk side condition needed remove excess occurrences type mle mn ly 
sub cases consider depending shared variable regulated 
non sharing case proof proceeds context sent 
suppose case similar 
induction hypothesis get ly mle construct mn 
elided details substitution 

sharing case sent branches 
argument proceeds induction hypothesis branch 
consider standard type theoretic properties concluding strong normalization decidability 
part lemma states judgement general form context valid 
usual way stating judgement context 
ll calculus weaker intuitionistic type theories state constituent parts context valid contexts join form context contrast result harper lemma 
second part lemma states valid contexts allowed constructed 
lemma subderivation property 
context delta delta delta context contexts join respect sharing form context 
context type proof induction structure proof premisses 
chapter 
ll calculus rlf logical framework 
representative cases 
mc context 
mvar type 
ga get hi context type context required judgement 
lx lx ab induction hypothesis get delta delta delta context delta delta delta context 
th judgement formed application ga rule context type context nk 
induction hypothesis context delta delta delta ym context joining form context 
mle mn lx ab nk 
induction hypothesis twice context context joining form joining form 
context formation rules consider 
ga context context type 
second premisses provides required judgement 
ga similar ga case 
context context type 
second premisses provides required judgement 
lemma says inhabited term kind type 
explicit cut 
rules inductive cases 
lemma subderivation property ii 
kind 

ll calculus 
type 
proof induction structure proof premisses 
representative cases part lemma 
mc context unfold context forming derivation context root arrive judgement sig sig unfold signature forming derivation arrive sig type sig delta delta delta delta sk sa 
sig required result 
mvar immediate type 
lx lx induction hypothesis type 
ali construct type lx type mle mn lx ab nk 
induction hypothesis lx type inversion obtain type premiss 
cut rule construct type type nk 
clear chapter 
ll calculus rlf logical framework natural algorithm type checking proceeds calculating type term comparing type assigned type 
approach relies unicity types kinds property type system 
lemma useful proving unicity 
lemma unicity domains lx lx jv proof confluence exists lx lx possible form lx implies claim 
bar unicity types proved relying pts single sorted functional 
ll calculus single sorted type kind 
argument unicity relies characteristic properties reduction relation 
lemma unicity types kinds ut jv proof induction structure proof premisses 
representative cases fragment 
mc suppose context constant 
mvar suppose type 
immediate 
suppose lx lx ab lx lx ab gx respectively 
induction hypothesis get rule 
applied times necessary gives required result 
mle suppose mn mn lx ab lx sensitive join induction hypothesis twice get lx lx unicity domains get knew lemma gives required result 
suppose hm ni hm ni induction hypothesis twice get rule 
times necessary gives required result 

ll calculus unicity types kinds cr property allow derivation lemma extended unicity domains lx inhabits lx proof cr determines definitional equality term lx ut type lx sufficient allow infer result 
definition linear occurrence motivated desire type theory subject reduction property 
important linear variables lost reduction 
pause consider problem proceeding show property 
consider instance application delta delta delta lx delta delta delta lx suppose type function reduction leaves hanging 
supposed lx provable 
inversion provable 
definition linear occurrence reasons 
fv true case general simple types may sufficiently complex 
fv consumed type function lx lx 
application form lx linear occurrence follows situation simple loss occurrence variable succedent arise type theory 
subject reduction property proved step reduction relation basic type theory 
checked define relation 
lemma subject reduction proof simultaneous induction structure proof premisses 
main cases step typing derivation rule mle ml reduction step rule 
mb 
consider cases 
suppose lx lx chapter 
ll calculus rlf logical framework arises lx lx nk 
lemma lemma jc rule cut rule construct nk 
type theory extended unit stated subject reduction property 
reason illustrated derivation assume type delta delta delta context 
lx 
delta delta delta lx reduction left hanging 
conjecture extended type theory weaker form subject reduction conjecture arises consideration cut elimination linear type theory presence 
point reduction example effects terms proofs properly considered inference rule type theory 
reduction sequences type theory terminate theorem strong normalization valid terms strongly normalizing 
kind strongly normalizing 
strongly normalizing 
proof idea variation argument harper hhp define faithful dependency linearity translation kinds type families set simple types constructed theta base type type families 
ll calculus objects set untyped terms set constants fp js sg 
denote type assignment curry products infinite set rules 
definition translation simple types type lx lx lx am theta jaj bj jaj lx jbj bj ly lx jbj jaj fv ja bj jaj theta jbj jcj jxj mj ly lx jmj jaj fv nij jp mj jmj translation embeds ll calculus curry typable terms untyped calculus structure preserving way 
dependency aspect lost instance forgetting variable term lx linear aspect lost translating linear intuitionistic variables exactly manner 
chapter 
ll calculus rlf logical framework refer troelstra schwichtenberg technique strong normalization translation ts 
technique extending conversion section 
note minor technicalities translation 
translation ju 
translation signature context obvious hi hi 
binding strategy utilized give occurrences unique names 
lemmata show translation sufficiently faithful 
abuse notation somewhat take symbols mean similar relations calculus 
lemma 



proof induction structure proofs 
lemma follows fact defined symmetric transitive closure 
representative cases 
re immediately 
lx lx induction hypothesis twice 
lx ih theta lx 
lx lx induction hypothesis twice 
lx ih lx 
ll calculus 
am induction hypothesis twice 
am ih 
ab lx induction hypothesis twice 
lx lx ih lx lx 
induction hypothesis twice 
theta theta ih theta lemma 
jm jmj jnj 

jb jbj jnj 
proof induction structure respectively 
representative cases 
ly ly subs lz ly jm ja lz ly jmj jnj jaj jnj ih theta lz ly jmj jnj jaj jnj subs lz ly jmj jaj jnj subs mj jnj chapter 
ll calculus rlf logical framework pq pq jp subs jp jjq jpj jnj jqj jnj ih theta jnj subs jnj hp qi hp qi ij subs jq ji jnj jqj jnj ih theta jnj subs qij jnj lemma shows consistency translation 
lemma 
jaj 

jmj 
proof induction structure proof premisses 
illustrate argument representative cases 
mc context trivial formed type 
lx lx induction hypothesis jmj lx jmj ly lx jmj jaj mj lx 

ll calculus mle mn lx nk 
induction hypothesis twice jmj jnj construct jmj jmj jmj jnj jnj jnj app double line indicates series applications indicated rule 
weakenings introduce left right proofs respectively 
exchanges contractions eliminate duplicate intuitionistic original type theory variables 
necessary get premisses elimination rule additive form 
proof tree required 
type dependency simply typed calculus 
hm ni induction hypothesis twice jmj jnj rule theta gives theta nij 
extra combinatorial complexity ll calculus terms owing possibility reductions type labels lost translation 
lemma 
jaj ja 
jmj jm chapter 
ll calculus rlf logical framework transitive closure untyped calculus 
proof induction proof non trivial cases arise rule applied rules rules 
case example lx nj lx jmj jnj jmj jnj jm lemma 
second case lemma suffices result 
give proof strong normalization 
suppose infinite reduction ll calculus 
translated reduction simply typed calculus 
translation faithful reduction simply typed calculus infinite 
simply typed calculus pairing known strongly normalizing gan 
infinite reduction ll calculus 
arises corollary theorem 
theorem decidability assertions ll calculus decidable 
proof argument lp calculus 
observe firstly complexity proof judgement determined proofs strictly smaller measure secondly form judgement completely determines proof 
main method underlying argument involves replacing conversion rules better behaved normal order reduction strategy 
conversion extend definitional equality ll calculus conversion show decidability holds resulting type theory 
recall decidability relies strong normalization church rosser 
previous proof strong normalization modular retained 
church rosser holds typed terms 
lp calculus case establishing church rosser involves complicated argument assuming strengthening order prove substantial amount metatheory church rosser typed terms shown hhp sal 
case exploit lp calculus result show church rosser ll calculus 
technique inspired 
ll calculus method prove strong normalization define faithful consistent translation ll calculus lp calculus reflect reduction lp calculus back reduction ll calculus 
minor technical issue translation translation additive conjunction lp calculus connective 
added lp calculus obvious way effecting meta theoretic properties 
shall call resulting system lp calculus 
translation properties able show church rosser conversion 
argument follows 
suppose contradiction non confluent term ll calculus 
translation take term lp calculus 
translation sound non confluent lp calculus term 
reduction lp calculus known confluent coq sal 
conclude term ll calculus 
may possible give direct proof decidability ll calculus extended conversion 
done sal implementation harper el hhp proof idea strengthening trivially holds linear parts context 
argument complicated relies equivalence different type theories van vd 
translation argument adequate purposes 
related systems section briefly compare ll calculus appropriate fragments linear type theories 
abramsky abr benton ben linear type theories types correspondence propositional ill concern predicate ill consider linear version barendregt cube displayed called standard orientation 
abramsky benton type theories correspond 
nodes type theory corresponds lp node 
difference abramsky benton studies motivation study ll calculus language logical framework 
comparison cervesato pfenning cp appropriate case 
claims inspired study origins pym 
description llf framework lacks account notion representation 
type theory fragment ll calculus lacking inter alia linear dependent function types 
precise chapter 
ll calculus rlf logical framework fp fragment 
recovered restricting type formation intuitionistic consequence vacuous 
noted restricted type theory section 
key point comparisons follows 
construction linear dependent function space necessitates investigation various structural properties 
explicated technical device multiple occurrences 
concern non dependent 
intuitionistic dependent function spaces analyses 
conservativity section show rlf conservative extension lf 
need translation lp ll calculi 
reminiscent translation il ill maps gir 
definition gammaq lp ll define translation signatures contexts 
clauses capture intuitionistic linear distinction languages image intuitionistic type 
hi ps uq psq pg aq succedent typing judgement gammaq defined induction structure 
give cases typed objects cases similar 
pc aq px bq lx lx px aq bq abstraction clause deals fact binding negative occurrence variable 
argument capture property conservative extension level type theory level framework 
need consider arbitrary object logic translation definition lf encoding signature conservativity level type theory immediate consequence definition 

example encodings definition rlf encoding signature standard judgements types encodings 
lemma conservativity object logic 
uniform encoding lf 
provable consequence lp uniform encoding ll proof define follows pe pe pe pe proof realizers proposition assumption see immediately diagram 
lp gammaq ll commutes 
show uniform encoding 
proof induction structure 
interesting case weakening 
suppose lp lp translating consequence ll calculus gives ll weakened get ll definition gammaq image lp assumption uniform encoding lp image object consequence 
example encodings section illustrate encodings rlf 
intention bring essential characteristics ll calculus language weak structural properties linear dependent function space variable sharing allow encodings undertaken uniformly chapter 
ll calculus rlf logical framework judgements types mechanism 
object logic syntax inference rules considered consumable resources encoded intuitionistic constants signature 
state representation theorems encodings undertake 
order need notion canonical essentially long bh normal form 
definitions lemmata needed characterization canonical forms ll calculus similar lp calculus omit presentation 
say function compositional bijection simply means bijection commutes substitution 
ill encoding omega fragment propositional intuitionistic linear logic ill 
ill object logic slightly detail 
encoding restricted type theory type formation entirely intuitionistic discussed type theory section previously 
restriction picks system cervesato pfenning cp 
natural deduction style rules logic table taken troelstra tro 
lower case greek letters range propositions ill object logic 
rest sub section 
delta delta delta delta delta delta tensor omega delta delta delta omega delta delta delta tensor delta delta delta delta delta delta delta delta delta table fragment ill signature ill begins declarations type type represent syntactic categories individuals propositions ill formula constructors declared constants signature ill omega ffi ffi ffi ffi 
example encodings terms formulae encoded function maps terms formulae free variables terms type ill omega omega basic judgement judgement formula proof ill proo represented declaring constant proo type signature 
proof formula represented term type proo 
multiplicative operator ffi represent inference object logic 
curried version meta logical multiplicative conjunction combine representation premisses omega rules represented declarations signature ill tensor lf proo ffi proo ffi proo omega tensor lf proo omega ffi proo ffi proo ffi proo ffi proo need distinguished additive operator represent additive rules 
alternative additive function space investigation scope current study 
recall sub section 
lf proo proo ffi proo lf proo ffi proo valid proofs ill labelled trees constraint assumption packets contain exactly proposition packets uniquely labelled bie 
valid proof respect proof context denoted assertion finite set variables order logic list uniquely labelled assumptions fx fv dom treatment ill quantifiers rlf essentially lf 
rules proving assertions form table 
encoding function defined encode proofs ill omega cases instance follows usual linearity level propositions types set variables implicitly ed 
chapter 
ll calculus rlf logical framework hyp tensor omega omega tensor table valid proof expressions ill tensor tensor tensor tensor lx proo lx proo proof context fx fx mapped proo proo 
encoding basically illustrates propositions types correspondence af omega ill expect strong representation theorem 
theorem representation ill encoding functions compositional bijections 
ill formula 
ill ill 
ill ill mp proo ill proof object mp canonical object ll calculus 
proof encoding functions clearly injective 
surjectivity established 
example encodings defining decoding functions left inverse omega omega tensor tensor tensor lx proo lx proo tensor decoding functions total defined follows definition canonical forms signature 
induction formulae proof expressions respectively get similar induction get encoding commutes substitution 
encoding extended deal omega phi fragment propositional ill representation ill units forces design type theory 
meta logical required directly represent object logic linearity constraints type theory mean encoding ill valid ll calculus judgement 
case similar 
ml second encoding programming language ml extended mlr reworking example cervesato pfenning cer cp 
reworking exploit available cervesato pfenning 
consequently full ll calculus type theory action non trivial 
basic mlr logic judgement form mlr gamma 
means program evaluated store continuation leaves answer store expression pair signature begins declarations store type cont type instr type ans type represent syntactic categories store continuations expressions answers 
chapter 
ll calculus rlf logical framework evaluation represented declaration ev cont ffi instr ffi answer ffi type really interested rule evaluating re assignment 
stated follows mlr ffl gamma 
mlr gamma 
ffl mlr unit expression 
ml memory modelled set cell expression pairs 
pair represented linear hypothesis type contains holds lvalue cell rvalue expression 
cell type exp type contains cell ffi exp ffi type rule re assignment evaluation encoded follows ev lc cell lv exp contains ffi ev ffl ffi lv exp contains ffi ev assignment instruction shown usual infix form reasons readability 
rule encoded fashion linear property memory formalized quantifier 
illustrate idea soon 
re working mlr example state referring cp 
theorem representation mlr encoding functions compositional bijections 
stores shape hc hc continuations instructions answers closed possible occurrences free cells mlr gamma 
cell cell contains pm contains vm mlr mp ev proof object mlr mp canonical object ll calculus 

example encodings property desirable show mlr logic type preservation context store mlr gamma 
valid instruction type valid continuation type valid store valid answer type main difference reworking example proof type preservation ev rule prev encoded 
prev lc cell lv exp contains contains ffi ev ffl ffi ffi prev type prev proofs type preservation cells evaluations respectively 
note types linear free variables 
type theory employed encoding involve notion sharing 
cells quantified intuitionistically cp linearly 
case sub proof prev type prev consist instance 
allow admit garbage cell expression pairs occupying memory space 
linear quantification gives better representation memory management 
encoding realizes intuition making general statements linear variables quantifier 
encoded version mlr type preservation stated shown cp 
omit details 
calculus example equational theory type theory similar church calculus abstraction allowed abstracted variable free body function 
full expressiveness ll calculus type theory crucial notion variable sharing 
allows quantifier capture traditional notion relevance 
contrast encoding calculus avron relevance constraint enforced introducing extraneous language axiomatize relevance domain theory 
signature begins declaration type represent syntactic category terms 
constants represent object logic abstraction application operations equality judgement chapter 
ll calculus rlf logical framework 
ffi ffi app ffi ffi ffi ffi type axioms rules equational theory relevant calculus encoded follows lx lx ly ffi lx ly lz ffi ffi lx lx ly ly ffi ffi app app lx ly app xy constant declarations encode reflexivity symmetry transitivity properties object logic judgement 
constant declaration encodes rule congruence respect application 
constant declaration encodes application 
definition means lx quantifies occurrences body 
ill example encoding illustrating propositions types correspondence 
allows state stronger representation theorem avron 
theorem representation encoding functions compositional bijections 
fv 
mp proof object mp canonical object ll calculus 
summary chapter studied logical framework rlf uniformly encoding natural deduction presentations weak logics 
studied proof theoretic meta theory language rlf ll calculus detail 
lines includes undertaking object logic encodings rlf 
extend study barendregt 
summary cube type theories bar hyper cube intuitionistic relevant cubes diagonal edges determined translation form considered definition 
chapter propositions types correspondence conceptual similarity ll calculus type theory logic bi particularly way function spaces formed 
chapter set types correspondence type theory structural fragment logic 
follow barendregt bar treatment propositions types correspondence set predicate logic lp type theory 
chapter organized follows 
section give pym hearn presentation logic bi 
section motivate state certain restrictions bi 
fragment logic correspondence set done section 
section discuss correspondences relevant logics 
logic bi give presentation pym hearn logic bi bunched implications op 
ll calculus propositions types correspondence structural say means section fragment bi 
original logic reasons 
firstly reasons completeness interest 
secondly order clarify exact nature restriction ll calculus correspondence 
bi restricts structural rules intuitionistic logic decomposing implication multiplicative additive parts 
implications linear intuitionistic 
logic bi arise extra structure called bunches read rea context 
girard linear logic restricted modality ed formulae may weakened contracted 
contrast bi context formation operators admits structural rules weakening contraction doesn 
scheme contexts lists trees nodes labelled leaf formation determines kind function space formed 
variable context bunch obtain kinds universal quantifiers new new give pym hearn presentation bi 
restrict attention new subset connectives primary concern analysis relevant natural deduction 
bi quite full set connectives including disjunctions existential quantifiers 
language logic bi defined structure 
definition slight generalization van dalen vd barendregt bar 
definition structure tuple consisting non empty sets called sorts relations typed functions constants 
barendregt works exclusively example structure ha ci sets theta 
generally arbitrary structure easy see language logic particular deal pre defined relations functions 
language logic begins giving names component structure 
omit formality confusing sort relation function constant symbols language components structure 
say relation language symbol language relation structure logic defined term signature predicate signature essentially set functions including ary functions constants set relations respectively components particular structure working 
chapter 
propositions types correspondence range set sorted variables 
set bi terms term inductive definition variables predefined functions language set term extended terms appropriate sorts 
denote set atomic propositional letters range set bi formulae form inductive definition atoms multiplicative implication new multiplicative quanti additive con junction additive implication additive quanti terms relations language set form extended terms appropriate sorts 
bunches variables propositions inductive definition variable assumption multiplicative unit additive unit multiplicative combination additive combination propositional assumption multiplicative unit additive unit multiplicative combination additive combination main point regarding bunches behaves additively admits weakening contraction behaves multiplicatively 
bunches structured trees nodes labelled leaves labelled propositions 
write refer subtree 
logic bi replaced write gamma denote bunch hole 
write denote isomorphism leaf re labelling 
require commutative monoids 
isomorphism commutative monoid equations form coherence equivalence bunches 
main judgement bi read proposition variable context propositional context respect term signature propositional signature 
auxiliary judgements establish formedness terms propositions 
judgements read term type variable context respect term signature prop read formed proposition variable context respect term signature propositional signature 
omit rules judgements largely exclusively take care combining contexts apparent grammar terms formulae 
axiom rule symmetric relation axiom records 
form rule necessary maintenance bunched structure variable context 
familiar axiom side condition prop immediately derivable application substitution cut terms 
definition judgement defined rules identity axiom prop prop axiom substitution axiom denotes abuse notation write just axiom pick arbitrary bunches 
chapter 
propositions types correspondence multiplicatives prop new new new new additives original rule admits weakening contraction take simpler familiar rule definition 
actual equivalence systems delicate issue 
version bi linear admits weakening contraction 
define affine version bi weakening permitted 
concern weakest linear system 
interesting reading sharing interpretation kinds function spaces quantifiers hearn pym op pym 
domains interpretation syntactic control interference idealized algol rey rey type procedure share store arguments type procedure 
alternatively context seen partitioning store separate components context allows shared store 
domain interpretation proof search basis logic programming clausal hereditary harrop fragment bi 
resolution program clause new creates local answer substitution atom particular subsequent proof search goal depend answer substitution 
compared usual resolution program clause creates global answer substitutions 

fragment logic bi kinds function spaces quantifiers allow reason sharing interference imperative logic programming languages 
reader referred papers pym hearn complete discussion logic 
fragment logic bi point note logic type theory parameterized signature set constants closed type 
easily see translate signatures 
main consideration determining correspondence ll calculus bi relate respective contexts 
obvious step undertake structure type theory logic arises contexts 
original presentation bi contexts trees internal nodes labelled 
type theory hand context extended ways basic idea correspondence consider informal sense intuitionistic extension linear extension ll calculus bi quite full story bi allows arbitrary context combination just context extension 
idea see context singular proposition packing restriction bi internal logic ll calculus type theory brings internal logic closer linear logic 
packing currying allows show correspondence derivations proofs 
consider issue discuss soundness 
points consider 
due restricted nature order logic term variables separated propositional variables multiple occurrences requirement function logical issues 
formedness types issue consideration rule indicates consider simplest situation corresponding proof type theory 
suppose type type construct chapter 
propositions types correspondence delta delta delta fx yy type mvar fx yy fx yy delta delta delta fx type mvar fx fx mle fx yy fx zw yy presence proof realizers means variables corresponding logic needed 
exercise illustrates difference predicate logic corresponding dependent type theory formedness side condition logic judgement included proof type theoretic judgement 
second point consider rules function spaces ll calculus correspond exactly rules implication universal quantification formation bi 
additive intuitionistic elimination rules impose restriction context minor premiss entirely extended denote context 
line argument take substitution rules cutting linear proposition cutting intuitionistic proposition 
sequel notation identify type linear intuitionistic variable 
identify linear leaf bunch identify intuitionistic leaf bunch 
formally say ffl ffl 
slightly better means pattern matching linear leaf equivalent coherence isomorphism formal description 
ready restricted logic 
definition formula judgement defined rules 
identity axiom prop prop axiom axiom axiom 
fragment logic bi multiplicatives prop new new new new additives formalize concept deduction fragment bi 
allow show precise correspondence formulae types terms proofs 
proof expressions logic grammar lax limp limp lall lall ranges countably infinite set occurrence markers 
idea label discharged occurrence uniquely occurrence marker 
proof expressions directly related barendregt derivation combinators bar hearn pym proof objects op 
instance proof expression corresponds barendregt combinator hearn pym abstraction operator 
judgement read derivation respect context 
rules valid proof expressions 
chapter 
propositions types correspondence definition bi derivations defined follows identities prop prop axiom lax prop prop axiom axiom axiom multiplicatives limp prop limp new lall new new new lall additives proof rules subject side conditions previous stated logical rules 

correspondence correspondence section set correspondence bi ll calculus 
basic idea follows terms logic correspond elements type theory formulae logic correspond types type theory deduction formula logic corresponds element type corresponding type theory 
define functions logic ype theory type theory logic 
functions fact inverses 
give translations need say components particular structure working dealt type theory 
barendregt method define called canonical context corresponding particular structure 
instance ha ci canonical context type type type type 
logic type theory distinguish signature context place declarations corresponding components structure constants signature 
translations logic signature type theory signature easy see 
define translations terms formulae derivations bi elements types terms ll calculus context 
enable show soundness 
consider translation contexts 
quite crucial matter done loosely barendregt treatment intuitionistic logic bar 
translation allows see certain way second sub bunch series propositional extensions 
definition ffl ffl bunch 
function defined induction structure bunches follows hi hi new variables 
chapter 
propositions types correspondence translation bunches forces consider particular fragment bi 
fragment bunch replaced bunch omega omega substituted omega similarly bunch replaced bunch substituted 
corresponding fragment type theory working doesn omega omega curry omega away need 
idea inside proof soundness 
finer translation contexts thought relying dereliction possible leave occasion 
context translation explicitly 
definition function defined terms formulae derivations bi follows 

term context denoted translation denoted inductively defined follows hi language functions extend translation obvious way 
formula context denoted translation denoted inductively defined follows new gamma fx cg lx gamma fx cg lx language relations extend translation obvious way 
note case translation stated 
correspondence 
derivation context denoted gp translation denoted inductively defined follows gp lax limp gamma fx lx limp lall gamma fx cg lx lall ht gamma fx lx gamma fx cg lx join translations gp gp 
specific form context cases 
lemma intuitionistic elimination cases translation minor premiss entirely intuitionistic 
proof form rules dictates context minor premiss entirely formed 
translation bunch definition entirely intuitionistic 
effect structural rules argued similar basis 
lemma says translation terms formulae sound 
terms correspond elements formulae correspond types 
lemma 

prop type 
chapter 
propositions types correspondence proof induction structure respectively 

constant variable cases dealt straight mc mvar rules 
inductive hypothesis functions mle rule 

predicates language treated base cases ale construct types 
inductive cases consider just linear ones 
induction hypothesis twice type type 
just ali get type required translation new induction hypothesis type 
ali get lx type required translation new intuitionistic cases dealt similarly 
theorem relates derivations bi proofs ll calculus 
theorem soundness gp 
proof induction structure derivation hypothesis 
lax convenient usual form axiom obtained application substitution 
lemma know type declarations free variables mvar get required translation lax similar previous case omitted 
limp limp induction hypothesis gp 
application get gp lx required 
limp limp induction hypothesis twice gp gp 
application mle possibly weakening get gp 
required 

correspondence lall lall new induction hypothesis gp 
application get gp lx lx required 
lall lall new induction hypothesis twice gp lx mle possibly weakening get 
required 
induction hypothesis twice gp gp 
recall gp gp get gp ht required 
induction hypothesis gp 
get gp required 
induction hypothesis gp 
application mll get gp lx required 
induction hypothesis twice gp 
weaken judgements get gp 
application ml gives 
required 
lall induction hypothesis gp 
application mll get gp lx lx required 
lall induction hypothesis twice gp lx chapter 
propositions types correspondence weaken judgements get gp lx 
application ml gives gf 
required 
give translation type theory logic 
basically technique done reverse 
consider signature ll calculus construct structure language 
give mappings elements types elements types ll calculus terms formulae deductions bi 
define translation type theory logic 
ll calculus contexts translated follows hi translated singleton contexts translated contexts translated translation inductively definition function defined elements types terms ll calculus follows 

element assumptions denoted translation denoted inductively defined follows hi signature contained functions extend translation obvious way 
type assumptions denoted translation denoted inductively defined follows hi lx gamma new lx gamma 
correspondence note case additive conjunction stated 
note language relations translation terms translation extended obvious way 
derivation proof context denoted translation denoted inductively defined follows lax lx gamma limp mn limp lx lx gamma lall mt lall hm ni lx gamma mn lx lx gamma lall mt note translation identities applications really need realizers indicate kind identity application realized 
usually clear context shall formal 
lemma says elements terms types formulae 
completeness arguments requires type theoretic judgement resemble logic judgement types depend terms way 
lemma 
just list variable declarations 
type form list variable declarations followed list type declarations prop 
chapter 
propositions types correspondence proof induction structure respectively 

base cases constant variable 
cases term virtue declared signature sort symbol structure 
inductive hypothesis application rules functions declared signature 

base case constant type case translated sort signature 
consider just inductive case 
suppose lx type type 
induction hypothesis prop 
new get new prop 
inductive cases done similarly 
theorem relates realizers ll calculus proof expressions bi 
theorem completeness form list variable declarations followed list type declarations 
proof induction proof hypothesis 
mvar suppose implies dom fv 
lemma know form construct lax bi version ll calculus context 
mvar 
case done similarly omit details 
suppose lx induction hypothesis 
get limp required 
mle suppose mn contextsensitive join induction hypothesis twice 
get limp required 

correspondence suppose lx lx induction hypothesis 
new get lall new required 
mle suppose mt new context sensitive join induction hypothesis twice new new get limp required structural equivalence 
suppose hm ni induction hypothesis twice 
get required 
suppose induction hypothesis 
get required 
mll suppose lx induction hypothesis 

get required 
ml suppose mn contextsensitive join induction hypothesis twice 

get required 
chapter 
propositions types correspondence mll suppose lx lx induction hypothesis 
get required 
ml suppose mt contextsensitive join induction hypothesis twice get required 
far set maps logic type theory 
theorem shows maps inverses 
theorem correspondence 

proof 
induction structure lax suppose lax calculate lax lax definition dealt similarly omit details 
limp suppose limp calculate limp lx gp gamma fx fg limp definition limp ih 
correspondence limp suppose limp giving calculation brief note regarding translation contexts 
premisses judgement limp xp xp dp dp induction premisses translated ll calculus judgements gp gp 
contexts gp gp share intuitionistic variables arise variables bi context 
order type theory join necessary weaken appropriate intuitionistic variables contexts gp gp join contracts copy away leaves context correct bi translation 
subject explanation applies cases proof limp gp limp definition limp ih lall suppose lall new calculate lall lx gp gamma fx cg lall definition lall ih lall suppose lall 
calculate lall gp lall definition lall ih calculation done subject explanation regarding calculation 
suppose calculate chapter 
propositions types correspondence ht gp ih suppose calculate gp ih suppose calculate lx gp gamma fx fg definition ih suppose giving calculation brief note regarding translation contexts 
premisses judgement xp pi induction premisses translated ll calculus judgements gp 
contexts gp share intuitionistic variables arise variables bi context 
order type theory join necessary weaken appropriate intuitionistic variables contexts gp join contracts copy away leaves context correct bi translation 
subject explanation limp definition limp ih 
correspondence suppose calculate lx gp gamma fx cg definition ih suppose 
calculate gp definition ih calculation done subject explanation regarding 
calculation 

induction structure 
mvar suppose calculate lax mvar 
done similarly omit details 
suppose lx calculate lx limp xm dm gamma lx definition lx ih fact leaf bunch 
mle suppose mn give calculation worth making little note regarding correctness translation context 
judgement mn holds join induction premiss judgements translated chapter 
propositions types correspondence 
application gives judgement 
contexts share intuitionistic variables 
necessary weaken order get translation correct 
subject explanation calculate mn limp definition definition mn ih suppose lx lx calculate lx lall xm gamma lx definition lx ih fact leaf bunch 
mle suppose mt 
calculate mt lall definition definition mt ih calculation done subject explanation regarding calculation 
suppose hm ni calculate hm ni definition ht definition hm ni ih suppose calculate definition definition ih 
correspondence mll suppose lx calculate lx xm dm gamma lx definition lx ih fact leaf bunch 
ml suppose mn give calculation worth making little note regarding correctness translation context 
judgement mn holds join induction premiss judgements translated 
application 
gives judgement 
contexts share intuitionistic variables 
necessary weaken order get translation correct 
subject explanation calculate mn definition definition mn ih mll suppose lx lx calculate lx xm gamma lx definition lx ih fact leaf bunch 
mle suppose mt 
calculate mt definition definition mt ih calculation done subject explanation regarding 
calculation 
chapter 
propositions types correspondence correspondences description correspondence intuitionistic logic simply typed calculus howard 
howard refers tait toone correspondence cut elimination logic normalization term calculus 
independently de bruijn interpreted propositions types proofs terms encoding classical mathematics part automath project 
propositions types correspondence referred curry howard de bruijn correspondence 
commented approach follows barendregt correspondence lp lp calculus order minimal dependent type theory pred order minimal predicate logic shown bar 
barendregt deals minimal predicate logic 
correspondences mention deal propositional part correspondence 
barendregt refers thesis proposition types embedding extended entire cube 
shows completeness fails node cube 
barendregt completeness theorem refers fujita tf show correspondence higher order predicate logic type theory fujita type theory subsystem cc 
abramsky abr benton ben barber bar show propositions types correspondence intuitionistic linear logic 
techniques generally follows define propositional logic decorate terms type theory 
approach follows barendregt define separate systems show correspondence 
gabbay de show curry howard correspondence family propositional resource logics 
natural deduction style logic type theory defined firstly constraining axioms allowed system secondly imposing abstraction discipline basically meta logical side condition 
rule 
instance linear logic defined combinators reflexivity left transitivity prefixing right transitivity permutation abstraction allowed long variables bound opposed bound action 
relevance logic defined adding combinator distribution set abstraction allowed long non vacuous 
independently wansing wan covers subject gabbay de 
wans 
summary ing logic hilbert style analysis spirit howard covers correspondence cut elimination normalization 
wansing minimal lambek style categorical logic calculus abstractions left right presents methods extend system consideration family sub structural logics included propositional il 
course main difference treatments content logic consider controls quite different manner say linear logic 
hearn pym point op bi folklore relevant logic 
appears explicitly written studied 
summary chapter set curry howard de bruijn correspondence ll calculus structural fragment logic bi 
key characteristic allowing correspondence able extend type theory logic context distinct ways 
chapter kripke resource semantics internal logic ll calculus corresponds certain way detailed previous chapter fragment logic bi 
key characteristic bi extra structure context specifically kinds context extension operations allows formation kinds function spaces 
understood categorically single category kinds monoidal structure 
understood model theoretically unique combination familiar ideas kripke style world semantics urquhart style resource semantics 
chapter internal logic semantics motivate indexed categorical semantics type theory 
categorical semantics ll calculus kripke resource model monoid indexed set kripke functors fj op cat rg 
indexing monoid seen providing account resource consumption 
main component kripke functor indexed category op cat base kinds monoidal structure 
extra structure indexed category includes natural isomorphism allows formation function spaces 
model seen providing indexed view appropriate notion dependency read bunches rea 
chapter organized follows 
summarize presentation type theory syntactic algebraic forms 
motivate categorical semantics type theory 
form main technical part chapter 
ll calculus completeness theorem 
construct example kripke resource models 
term model construction mainly prove completeness 
second example model construction fam category families sets interpreted set presheaf set op small monoidal category 
gives structure define kinds indexed products 
ll calculus briefly remind reader syntactic presentation internal logic ll calculus 
sequel shall refer natural deduction presentation ll calculus system syntactic presentation ll calculus order dependent type theory kinds function spaces linear intuitionistic 
calculus deriving type judgements main term type context signature definition type theory depends crucially notions joining maintenance contexts 
notion context joining implemented ternary relation read join form 
notion sharing deals wellformedness types binary multiplicative rules utilizes notion multiple occurrences implemented function 
notions allow formation full linear dependent types 
chapter gave natural deduction presentation type theory proved church rosser strong normalization decidability judgement internal logic internal logic type theory corresponds structural fragment logic bi bunched implications 
main judgement bi read proposition variable context propositional context respect term signature propositional signature 
controlled distinct context forming operators admits weakening contraction 
structure context bunches allows formation kinds functions quantifiers linear ones intuitionistic ones 
chapter 
kripke resource semantics logic bi discussed chapter propositions types correspondence shown ll calculus structural fragment 
start section discussing kripke resource semantics bi utilizing semantics mathematical structure needed semantics type theory 
algebraic presentation preparation presentation categorical semantics ll calculus general particular completeness argument give algebraic presentation ll calculus type theory 
idea consider provably formed syntactic object modulo definitional equality 
ju denote abh equivalence class expressions ll calculus tend omit gamma brackets confusion arise 
definition signature 
base category contexts realizations defined follows ffl objects contexts proves context ffl arrows realizations hm gamma 
proves gamma identities hx gamma 
write identity arrow composition substitution 
hm gamma 
hn gamma 
hn gamma 
proposition category 
proof am objects hm gamma 
hn gamma 
hp gamma 

ll calculus arrows 
check identity morphism hn hn hy hm composition associative hn hp hp hp judgements type context object definition seen index type term depend variables declared seen internal logic judgement index formalize algebraic presentation syntax base strict indexed category follows 
definition inductively define strict indexed category base category op cat cat category small categories functors follows ffl category defined follows objects types proves type morphisms object 
classifying category theorem follows amounts assertion proves composition substitution 
chapter 
kripke resource semantics ffl functor def def 
working cat raise doubts completeness particular presence identity arrows linear case 
note arrow gamma 
term model considers identical context judgement valid amount weakening variables declared defined arrows order achieve completeness needed worked weaker setting presheaf op set rd 
relation type theory category defined definitions theorem states term category defines proved theorem classifying category signature abh normal form 
ffl proves context object ffl proves type object ffl objects 
proves gamma hm gamma 
arrow ffl proves hi arrow 
proof induction forward direction structure proofs backward direction complexity expressions 
arguments straight forward omit details 
kripke resource models ll calculus kripke resource ll structure motivate mathematical structure model ll calculus considering informally models internal logic 
fact structure motivate quite modular 
kripke resource models ll calculus sub structure model intuitionistic pg fragment ll calculus lp calculus 
key issue syntax concerns existing linear intuitionistic function spaces quantifiers 
distinction explained resource semantics 
notion resource time space primitive informatics 
essential aspects resource include ability identify elements including null element resource combinations 
resource monoid 
imagine notion comparison resources indicating resource better may prove propositions 
similar ideas seen post hoc relevant logic literature 
resource semantics elegantly explains difference linear intuitionistic connectives action computation linear connectives seen consume resources 
consider informally internal logic judgement delta kripke resource monoid 
simplified version forcing relation implications defined follows 
delta 
similar pair clauses defines forcing relation bi quantifiers need environment appropriate bunch variables world jxk interpretation bunch variables set op 
dn 
jxk 
new dn 
delta op set domain individuals gamma gamma cartesian pairing gamma gamma pairing operation defined day tensor product construction set op resource semantics seen combine kripke semantics intuitionistic logic urquhart semantics relevant logic 
details op 
suppose category propositions interpreted 
index ways purposes interpreting type theory 
index kripke world structure functor category strength model chapter 
kripke resource semantics fragment internal logic correspond kripke style models intuitionistic logic 
second index resource monoid structure obtain indexed set kripke functors fj rg 
separation worlds resources considered structure emphasizes sort phase shift gir hm 
briefly reconsider choice section 
consider model propositions explicate structure basic judgement internal logic proposition context context reading judgement natural see index propositional judgement reading extended type theory basic judgement seen index depends meaning 
led technology indexed category theory ps 
specifically case type theory judgement modelled arrow jmk jak fibre jgk strict indexed category op cat 
technique modelling typing judgement cartmell car pitts pit authors dimensional structure relies properties certain classes maps model intuitionistic fragment ll calculus 
formally equivalent indexed approach appealing main reason provides technical separation conceptually separate issues 
instance logical level base fibres deal respectively terms propositions 
cost bureaucracy issues non indexed approach 
need base category account structural features type theory internal logic 
recall proof theoretically function spaces quantifiers arise extra structure viz 
types context extension operators context 
model context category kinds structure 
leads 
kripke resource models ll calculus definition 
definition doubly monoidal category doubly monoidal category category equipped monoidal structures omega theta 
definition requires comments 
firstly requirement bifunctors omega theta symmetrical contexts objects intended model ordered lists 
secondly symbol theta context extension operators suggests theta cartesian product 
case fj rg model internal logic dependencies variable context fj rg model type theory dependencies case property object extended theta projection map theta second projection map theta may correspond formed type 
interaction projection maps stated requiring pullback theta theta theta pullback indicates cartesian case interpret realizations tuples 
suppose arrow fibre exists unique arrow gamma 
theta pullback cover case monoidal extension 
require existence unique arrow omega omega mi gamma 
omega tuples omega doubly monoidal category exponentials alternatively equipped monoidal closed structures theta omega called doubly closed category dcc hearn pym op 
provide class models bi function spaces modelled doubly monoidal category requiring extra structure fibres model function space 
models intuitionistic linear logic barber plotkin dill bar deal kinds context extensions 
technique pair chapter 
kripke resource semantics categories monoidal cartesian monoidal adjunction 
forces separation linear intuitionistic parts context useful modelling dependency 
specifically suppose wanted model bx 
barber plotkin scheme interpreted cartesian category bx monoidal 
bx valid object monoidal category needs type order formed 
consider function spaces modelled 
intuitionistic case weakening functor right adjoint pd satisfies beck chevalley condition 
fact amounts existence natural isomorphism cur hom thetaa hom pd absence weakening linear context extension operator means model way 
structure displayed suggests way proceed 
sufficient require existence natural isomorphism ld hom hom lx indexed category 
ffl range omega theta range 
couple remarks need isomorphism 
firstly refers hom sets fibre source 
restriction avoids need establish foundedness arbitrary object ffl suffices model judgement arrow jmk jak fibre jgk examples provided term set theoretic models 
second wish extended context defined indexed functor 
reason seen observing form forcing clause application bi 
remarks isomorphism allows formation function spaces 
additive conjunction modelled requiring category products 
completes motivation categorical semantics ll calculus internal logic 
summarize structure model ll calculus indexed set functors fj op cat rg 
resource indexing structure sufficient model linear intuitionistic function spaces 
approach modular 
kripke resource models ll calculus provide categorical semantics intuitionistic fragment ll calculus lp calculus 
basically single functor op cat category cartesian structure theta 
led definition 
remind reader notational conventions 
ffl range linear omega intuitionistic theta context extensions gi range linear omega gi intuitionistic theta gi tuples syntax range linear intuitionistic declarations 
definition hr commutative monoid resources 
kripke resource ll structure indexed set functors fj op cat rg hw poset op op cw small doubly monoidal category cat category small categories functors 
terminal object preserved nose cw 
cw object ffl cw cartesian extension canonical projections theta canonical pullbacks theta theta theta pullback indicates cartesian case interpret realizations tuples 
particular exists unique arrow theta cw cover case monoidal extension 
require exist unique omega omega mi omega tuples omega extensions canonical second projection fibre ffl maps required satisfy strictness conditions ffl ffl ffl ffl cw ffl chapter 
kripke resource semantics 
natural isomorphism ld hom hom lx extended context defined indexed functor 
natural isomorphism required satisfy beck chevalley condition cw ffl ld ffl id 
category cartesian products 
purpose current study modelling type theory structures consider arrows type fibre suffice 
conclude section showing kind conservativity result 
embed kripke resource ll structure fj rg kripke lp structure show function space ld ll structure case pd lp structure case 
expected lp structure just sub structure ll structure model intuitionistic fragment ll calculus 
recall kripke lp structure functor op cat category equipped just modified cartesian closed structure plus usual coherence conditions pym 
lemma natural isomorphism cur hom hom pd cur gamma kripke lp structure just ld natural isomorphism theta case kripke resource ll structure 
proof fix 
define translation ll structure lp structure 
informally translation seen follows ffl ffl 
theta theta 
kripke resource models ll calculus primed components originals objects ll structures theta pg operators translated lp structures theta pg operators add theta lp structure obvious way respectively 
similar translation done morphisms 
key point action forget linear intuitionistic context extension operator difference translating context extension operator theta 
show natural isomorphisms start natural isomorphism ld compute hom lx hom cur hom theta translation premiss ld natural isomorphism 
projection theta exists syntactically lemma seen translation ll calculus lp calculus reverse definition 
semantically seen categorical setting 
statement lemma large category objects structures able construct arrow ll structure lp structure 
kripke resource ll model kripke resource model kripke resource structure points interpret constants ll calculus terms defined context formally kripke resource model components kripke resource structure operations interpretation function functors satisfaction relation 
structure components defined due inter dependences simultaneously induction raw syntax 
explains long complex formal definition model 
ignoring inter dependencies moment explain purpose component model 
kripke resource structure provides domain type theory interpreted 
operations provide points interpret constants signature 
second interpretation gammak partial function mapping raw necessary formed contexts objects types raw contexts objects category chapter 
kripke resource semantics indexed interpretation terms raw contexts arrows category indexed interpretation types terms interpreted bh equivalence 
fourth functors maintain formedness contexts regard joining sharing 
model needs constrained multiple occurrences variables context get interpretation 
fifth satisfaction relation worlds sequents axiomatizing desired properties model 
stronger logics intuitionistic logic definition model sufficient derive properties satisfaction relation 
van dalen description kripke model intuitionistic logic done way instance vd 
case definition directly 
remarks model definition immediately presentation 
restrict discussion semantics type fragment 
treatment fragment undertaken analogously sense fragment logical structure fragment 
interpret kind type require existence chosen object call fibre 
object obey equations preserved nose behave quantification 
details treatment fragment case contextual categories streicher thesis str 
analogous development setting similar omit details 
definition ll calculus signature 
kripke resource ll model tuple op cat rg gammak join share fj op cat rg kripke resource ll structure operations gammak interpretation raw syntax ll calculus components op cat join share functors satisfaction relation worlds sequents defined simultaneous induction raw structure syntax follows 
kripke resource ll structure operations corresponding constant lx am type fk operation op op jm object jxk 
kripke resource models ll calculus jxk share join jg share join jg fk corresponding constant lx am am arrow op gamma 
jak am 
interpretation gammak gamma satisfies jg ak jgk omega ja jg ak jgk theta ja jg hm gamma 
dk jgk jm gamma 
jdk jgk share join jg share join jg jg jhi jgk cm op jm jm ng jgk jgk share join jg share join jg jg jgk ja jb extended context defined indexed model jgk ja jb ja ja theta jb jhi jgk jc op jx jg ak jgk ja jm jgk jm jmn jgk jn gamma jgk ja jm jx jdk jxk share jx chapter 
kripke resource semantics ni jn jp jm 
interpretation undefined 

exists bifunctor join purpose join objects extend object second discarding duplicate cartesian objects 
definition join objects follows jd ak jdk omega jx ak ak jdk jdk omega jx ak ak jd ak jdk theta jx ak definition join morphisms similar 
easy see jxk jdk exists functor share purpose share regulate sharing multiple occurrences object 
definition share objects follows share share jxk jfk jxk jd jfk jdk ak jd ii jxk definition share morphisms similar 
purpose share ensure joined objects morphisms formed 
join share cut interpretations result object different indexed model argument object 
necessary defining interpretation function application 
satisfaction model relation worlds sequents hold 
kripke resource models ll calculus dom jg ak defined lx mn jxk jdk jxk share jx lx mn jxk dk require conditions 
syntactic monotonicity jxk defined jx defined subterms summands condition needed various inductive arguments 
automatic interpretation defined raw objects 
accessibility functor domain op jgk cw jgk cw arrow exists functor cw jxk jxk recall ranges contexts types terms jgk jgk jgk jgk context jgk undefined 
concludes definition kripke resource ll model 
remarks concerning definition order 
type theory structural freedom level terms logically allows existence multiple occurrences proof 
operating representation judgements occurrence object base resulting representation form valid terms types representations 
sharing requirement regulated existence functor share defined follows 
second accessibility condition simplest regarding model theoretic notion relativization interpreting constructs world reasoning point view 
definition model sequel accessibility relation chapter 
kripke resource semantics take equates contexts worlds 
syntactic term seen weak sense rigid designator interpretation different worlds semantic object 
example suppose proves jm defined soundness case jm defined equal jm sense syntactic term designates objects jm notions partiality model 
technically interpretation function partial defined raw objects syntax 
partiality plays roles 
firstly dependent typing partiality bootstrap definition 
secondly kripke semantic partiality information world structure goes objects defined interpretations 
refer streicher str pym pym mitchell moggi mm comments regarding matters 
check functoriality join share 
lemma join share functors 
proof 
action join morphisms defined follows jg omega xk jgk omega jxk omega xk jgk jgk omega jxk theta xk jg theta xk jgk theta jxk jg jgk jg need show join preserves identities composition 
induction structure objects 
base cases units 
case monoidal structures sufficient infer result 
inductive cases consider 
omega case compute omega defn join ei omega ih omega ei defn join 
kripke resource models ll calculus second inductive case omega done similarly 
third inductive case theta theta case compute theta defn join theta ih thetaa defn join show join preserves composition second place proof similar 
assume compute theta theta defn join structure theta theta theta theta theta gi 
need show share preserves identities composition 
induction structure objects 
case hi immediate definition share 
non hi bx case compute follows share di ii share di ii ih share proof composition case assume share share compute share func join share share appropriate side conditions 
chapter 
kripke resource semantics consider various model theoretic properties satisfaction relation 
lemma monotonicity signature rg gammak join share model 

proof induction syntax accessibility jxk defined ranges case definition lemma forcing global sections rg gammak join share kripke resource model 
jgk defined ja defined jm defined jgk jm gamma 
ja arrow jgk 
proof induction structure 
direction require model points get arrow 
direction immediate definition direction second projection map fibre context gives required arrow 
direction immediate definition lx lx direction induction hypothesis jg ak jm gamma 
jb arrow jg ak 
natural isomorphism get arrow jgk jl gamma 
jgk 
direction suppose exists arrow jgk jl gamma 
jgk 
follows immediately existence arrow jdk jn gamma 
ja 
kripke resource models ll calculus implies existence arrow jxk jmn gamma 
jb jx jdk jxk definition gives lx lx lx lx direction induction hypothesis jg ak jm gamma 
jb arrow jg ak 
natural isomorphism get arrow jgk jl gamma 
jgk 
direction suppose exists arrow jgk jl gamma 
jgk 
follows immediately existence arrow dk jn gamma 
ja implies existence arrow jxk jmn gamma 
jb jxk dk definition gives lx lx direction induction hypothesis twice arrows jgk jp gamma 
ja jgk jp gamma 
jb chapter 
kripke resource semantics jgk 
recall construct products 
arrow jgk gamma 
ja jgk 
direction induction hypothesis twice 
definition gives 
substitution lemma cases substituting linear variable substituting intuitionistic 
lemma substitutivity signature rg gammak join share model 

jd defined jx jd jxk share jx 
jd defined jxk gk jd proof induction structure syntax functoriality models 

linear case quite interesting shows essential model components 
omit parameters interpretation simplicity seen induction ought 
basic argument structure model construct square cw share share omega jak share ffl share jd share omega jak ffl jd 
soundness completeness share share share hh share hh share jd jd induction arrow fibre share omega jak 
functorial structure model arrow hh share jd hh share jd jv fibre object share ffl share jdk omega jgk jd 
argument intuitionistic case similar linear pullback condition extend context jak 
soundness completeness lemma context type interpretations signature rg gammak join share kripke resource ll model 

proves context jgk defined jgk ob 
proves type ja defined ja ob jgk 
proof follows definition 
proofs done induction structure proofs system inter dependencies done simultaneously proof theorem 
theorem soundness signature rg gammak join share kripke resource model world model 
proves jgk defined ja defined jm defined 
chapter 
kripke resource semantics proof induction structure proofs proof soundness done simultaneously proof lemma 
mc suppose proves lx am definition fj rg points interpret lx am jc op applications natural isomorphism op am op gamma 
ja am observed jc type checks 
induction gk defined 
lx am follows 
mvar suppose proves type 
induction jg ak defined 
definition jx jg ak correct type 
shown jg ak jx gamma 
ja follows 
mvar 
case done similarly mvar 
suppose proves type 
induction jg ak defined ja defined 
definition jx jg ak correct type 
shown jg ak jx gamma 
ja follows 
suppose proves lx lx induction jb defined 
jg ak jm gamma 
jb natural isomorphism jgk ja get jgk jl gamma 
obtain lx lx 

soundness completeness mle suppose proves mn lx nk 
induction hypothesis twice lx jgk jm gamma 
jdk jn gamma 
ja assume monotonicity definition satisfaction mn jx jdk jxk share jx jxk jmn gamma 
jb check interpretation model 
definition jmn defined equal monotonicity jgk jn jgk ja jm defined 
need check types 
jm jgk gamma 
applying natural isomorphism jgk ja gives jgk ja jm jg ak gamma 
jb functor jgk jn performs required substitution 
action join share gives jxk 
mll case done similarly 
suppose proves lx lx induction jb defined 
jg ak jm gamma 
jb natural isomorphism jgk get jgk jl gamma 
obtain lx lx 
chapter 
kripke resource semantics ml case done similarly mle 
suppose proves mn lx nk 
induction hypothesis twice lx jgk jm gamma 
dk jn gamma 
ja assume monotonicity definition satisfaction mn jxk share join dk jmn gamma 
jb check interpretation model 
definition jmn defined equal monotonicity jgk jn jgk ja jm jxk share dk 
need check types 
jm jgk gamma 
applying natural isomorphism jgk gives jgk jm jg ak gamma 
jb functor jgk jn performs required substitution 
action join share gives jxk 
suppose proves hm ni proves proves induction hypothesis twice jgk jm gamma 
ja 
soundness completeness jgk jn gamma 
jb category model products 
property jgk construct jgk ni gamma 
hm ni follows 
suppose proves proves induction hypothesis jgk jm gamma 
definition satisfaction allows construct jgk jp gamma 
ja ig follows 
convenient working fragment type theory observe bh equalities generated rule lx nk rule lx ly lx fv 
application natural isomorphism lemma allows show bh jmk turn consider completeness 
appropriate definition validity chapter 
kripke resource semantics definition validity ll valid respect models rg gammak join share worlds jgk ja jm defined 
components term model defined category contexts realizations defined previously 
proposition doubly monoidal category 
proof context extension operators taken extension extension units context extension operator require rules taken syntax type theory context context context equivalences respectively units extension extension define hi allowing continue hi general unit 
definition category full sub category defined follows ffl objects hi object object exists arrow mi theta theta object 
ffl morphisms arrows just considered 
lemma tuple consisting set objects context joining operation gamma gamma gamma unit context hi defines commutative monoid 
proof ease argument adopt notation gd denote join contexts show hi behaves sided identity 
immediate due coherence equivalences contexts 

soundness completeness show joining relation associative valid contexts dq gd dq dq dq gd gd gd 
proof associativity induction length context dq 
base case dq hi 
definition joining relation implies hi dq hi 
argument know hi hi 
definition construct gd equal hi 
inductive cases consider join join join 
rules 
dq join 
assumption splits splits induction hypothesis join form gd gd join form gd join gd join form gd gd cases argued similarly omit details 
lastly show commutativity joining relation 
proof induction length context base case hi proof immediate 
inductive cases consider join join join 
rules 
suppose 
induction hypothesis 
application join gives 
cases argued similarly omit details 
joining associative informally say join form 
talk way joining need confusion 
note logics intuitionistic logic bi include conjunctions disjunctions develop notion prime theory 
prime theories exactly structure required semantic clauses connectives prove completeness 
construction prime theories necessary minimal cases lp ll calculi function spaces connectives 
ll calculus additive conjunction term model inherits structure syntax push definitions 
lemma model existence kripke ll model gammak gamma join share world chapter 
kripke resource semantics proof construct model syntax ll calculus 
kripke ll structure defined follows 
category worlds taken 
base category product ob 
indexing monoid context joining relation gamma gamma gamma defined lemma 
functor indexed element ob defined follows ob jects types proves type arrows arrows nk nk 
easy see functor 
suppose identities corresponding functor cat id id identity composition induction hypothesis twice gamma 
gamma 

just compose functors cat give required answer 
check kripke structure 

terminal object taken unit additive context 
choose proof theory judgement proves exists fibre 
contains free variables preserved nose 
extensions omega theta context extension rules type theory 
projection map intuitionistically extended context defined defined weakening admissible syntax 
map hg ai term projection map need check appropriate square pullback 
bm contexts ht morphism 
need show 
soundness completeness ht bm context ha hb morphisms bm equal terms type define mediating arrow ha type checks 
need show ht hx ha ht ht ht need show unique 
suppose hb chapter 
kripke resource semantics mediating arrow 
ht get equations hx hb ht ht ht hb equations hb ha ht hb hb ha lastly need check strictness conditions 
contexts morphisms prove type 
ffl xi ffl hai ai ht hs ai hb ci ht hs ai hb ci hs ci hs ci hs ci 
soundness completeness equation assume proves type proves type 

natural abstraction application rules type theory lx lx recall ranges linear intuitionistic declarations 
need check meet beck chevalley condition lx lx lx lx lx lx lx lx lx lx lx lx 
products rules 
model defined follows 
kripke ll structure defined 
operations model constants declared signature interpretation gammak gamma gamma obvious term type interpreted class terms definitionally equivalent term type appropriate component 
functors join share defined joining relation gamma gamma gamma respectively 
satisfaction relation provability type theory 
defined sharing sensitive join check relation satisfies inductive clauses satisfaction relation 
immediate operations 
context induction structure proofs hypotheses chapter 
kripke resource semantics 
lx implies mn nk holds direction mle application cut 
intuitionistic case similar 
immediate rules 
conditions models met follows 
monotonicity met fact terms defined 
constructed accordance proof rules 
valid term constructed valid sub terms 
accessibility provided nature 
theorem sharing sensitive join finish proof model existence 
assume premiss initial node hi model constructed syntax required property 
theorem completeness proof theorem soundness shows forward direction 
assume apply lemma 
class set theoretic models describe class concrete kripke resource models ll structure fj op cat rg bifam ctx op set small monoidal category ctx small settheoretic category contexts 
model construction category families sets exploits day tensor product construction day define linear dependent function space 
start describing indexed category families sets fam ctx op cat 
base ctx small set theoretic category defined inductively follows 
objects ctx called 
class set theoretic models contexts denotations sets arrows ctx called realizations set theoretic functions 
ob ctx fam fy dg 
fibre described discrete category objects ys arrows maps corresponding identity functions id fyg fyg considered singleton set 
arrow ctx fam fam fam re indexes set fy dg set viewing set cat object set seen object discrete category cat 
category families sets just considered presheaf fam ctx op set indexed category adopt view sequel 
explicate structure ctx describing fam contextual category car 
definition streicher str 
contextual category fam length denotation den fam set described follows 
unique context length den 
context length den set family sets indexed elements den theta context length den theta fhx yi den objects contextual category fam morphisms simply functions den den 
codomain denotation set allows definition extensional context extension theta 
set structure define intensional context extension omega 
obvious candidate tuple construction really just special kinds cartesian product inherits theta structural properties 
may dom structure define product 
order able define theta omega denote fam set presheaf set op monoidal category 
emphasize general monoidal category going describe class settheoretic models 
simplicity take op partially ordered commutative monoid delta 
cartesian structure presheaf gives theta context extension restriction day tensor product day gives omega context extension 
chapter 
kripke resource semantics note restriction day tensor product consider merely consider set theoretic characterization day tensor product tuples hx tuples consider element family sets quite concrete spirit cartmell streicher models considered general construction fibred day product 
contextual setting definition 
contextual category bifam length denotation den bifam set described follows 
context length den 
context length den gamma gamma 
context length den set family sets indexed elements den theta context length den theta fhx yi den omega context length den omega fhx den theta theta omega omega extension defined ends 
characterization day tensor product tuples restriction account dependency triples hx 
objects bifam morphisms functions den den 
bifam fam parametrized objects interpreted set interpreted set consider bifam indexed setting 
earlier argument relating indexed contextual presentations families sets bifam seen functor category bifam ctx op set 
quite presheaf setting require 
calculate 
class set theoretic models ctx op set ctx op theta set theta ctx op set ctx op set restores indexed setting reiterates idea fam 
lastly say components concrete model 
define delta define quotient relation delta necessary separation worlds resources cf 
bi semantics op 
allows define bifam delta 
maintains required properties monotonicity internal logic forcing relation 
easy check bifam delta simulate 
check bifam ctx op set kripke resource ll structure define kripke resource ll model 
lemma bifam ctx op set kripke resource ll structure 
proof recall view set cat 
points refers definition 
terminal object fibre taken point set 
indexed variables preserved nose 
ob ctx set indexed bifam context extensions theta omega second projection simply element hood set projection defined object theta hx yi projection defined object omega elements denotation omega consist pairs 
pullback need checked similar calculations term model omit 
natural isomorphism defined type context extension follows 
omega extension set indexed denotation omega write bd omega define curry omega bifam defined bifam omega bifam bifam bifam omega chapter 
kripke resource semantics theta extension set indexed denotation theta write bd thetaa define curry thetaa bifam defined fg bifam bifam bifam bifam inverse functor just application defined follows 
omega case bifam bifam uncurry theta case bifam bifam uncurry need check curry uncurry isomorphisms 
need check beck chevalley condition 
fairly simple calculations abstraction application substitution set just additional resource parametrization omit 
comment description function space corresponds indexed version day function space 
require natural isomorphism lemma described adjoints omega theta set 
product objects theta fibre taken cartesian product corresponding singleton sets fmg theta fng 
lemma bifam extended kripke resource ll model 
proof bifam defined follows bifam family indexed sets bifam functor arises due combination functoriality presheaf ctx op set 
definition model requires structure points interpret constants signature 
arbitrary signature interpret constants variables functors const set set respectively 
interpretation function gammak bifam parametrized worlds resources interpretation contexts defined idea construction category ctx 
summary 
jg ak bifam jgk bifam omega ja bifam 
jg ak bifam jgk bifam theta ja bifam interpretation functions defined curry functor interpretation defined product set 
interpretation function defined simultaneously instances functors join share ctx 
definition similar joining relation gamma gamma gamma sharing function term model omit details 
satisfaction relation ctx op set clauses reflecting properties example model 
lx ffl implies delta omega 
px implies theta 

conditions model met due definition interpretation function 
concludes definition example model 
simpler unspecified arbitrary signature 
consider signature encoded judgements imperative programming language chapter operations fibre conjecture bifam provides basis model imperative programming language 
particular think bifam model behaviour store quite finely 
basis conjecture lies uses internal logic reason local global issues state ful programming 
instance hearn nice example treating context extension operators different kinds storage allocators 
summary chapter began primitive notion resource bi analysis 
generalized type theoretic presentation defined notion kripke resource models 
monoid indexed set kripke functors indexing monoid seen chapter 
kripke resource semantics providing account resource consumption 
showed models sound complete ll calculus 
discussed interesting concrete kripke resource model constructed families sets 
chapter ll calculus ll calculus order linear dependent type theory parameterized function implements sharing 
type theory defined system linearized natural deduction 
chapter gentzen style sequent calculus ll calculus prove cut elimination theorem 
main difference natural deduction system referred system gentzen style sequent calculus referred system elimination rules replaced left rules introduce connective left hand side sequent 
systems equivalent provided system includes structural rule cut 
simple example consider natural deduction presentation propositional linear logic rules gentzen style sequent calculus rule replaced cut rule chapter 
ll calculus included sequent calculus 
predicate type theory basically follows pattern side conditions relating capture avoiding substitution definitional equality 
chapter follow technique pym pym intuitionistic lp calculus 
form left rules sequel 
lp calculus left rule formulated follows pl pz yn side conditions new 
intuitionistic lp calculus structural rules weakening contraction admissible 
consequence left rule expressed follows contraction principal formula pz pl side conditions fv 
rule advantage sub formula property yields resolution backchaining rule providing suitable basis logic programming pw obviously weaker gentzen systems considered sequel formulations pl pl equivalent 
rules consider analogues formulation mindful disadvantages 
premiss pz due fact cut elimination relates normalized proofs cut free proofs sequent calculus 
consequence cut elimination obtains normal forms 
expand 
ll calculus section system presentation ll calculus sequent calculus elimination rules system replaced left rules 
function spaces deal dependent cases omit treatment simpler non dependent ones 
case additive conjunction fairly standard 
elimination rule 
ll calculus replaced left rule omit treatment sequel refer girard lafont taylor glt troelstra schwichtenberg ts standard treatment 
combinatorics types declarations linear intuitionistic types dependent function spaces linear intuitionistic leads consider left rules dependent function spaces ll lz yn pl lz yn ll lz yn pl lz yn table left rules denotes side condition fv new jc nk couple comments regarding row column axes square 
firstly see row rules ll pl prior second row sense row get second row 
evidence point view seen nature proofs soundness completeness sequel 
seen observing intuitionistic variable relation occurrences replaced row prior second row refers part dereliction propositions types correspondence nature categorical models internal logic ll calculus 
second point second column rules pl pl intuitionistic minor premiss allows form intuitionistic function space 
chapter 
ll calculus reason premiss allowing abstracted variable function space intuitionistic variable 
cut rules linear intuitionistic variables included system cut cut 
denotes side condition nk theorem structural structural rules admissible 
exchange provided fv fv type 
weakening type 
dereliction free variables 
contraction 
proof induction structure proof premisses 
proof essentially system omit details 
soundness completeness section prove soundness completeness respect results crucially depend presence cut rules theorem soundness proves proves proof induction structure proofs cut rules admissible additional difficult cases left rules 
ll suppose rule applied ll delta delta delta delta delta delta ll lz yn 
soundness completeness side condition fv new nk 
induction hypothesis proves proves induction structure proof second obtain proves type apply mvar obtain proves lz apply mle proves proves obtain proves lz yn nk 
proves obtain lz yn nk cut rule 
argument summarized deduction ih delta delta delta lz type mvar lz lz ih delta delta delta mle lz yn ih delta delta delta cut lz yn side conditions denote ones argument 
pl suppose rule applied pl delta delta delta delta delta delta pl lz yn side condition fv new nk 
induction hypothesis proves proves induction structure proof second obtain proves type apply mvar 
obtain proves apply ml proves lz proves obtain proves yn nk 
note necessary weaken join chapter 
ll calculus properly 
proves obtain lz yn nk cut rule 
argument summarized deduction ih delta delta delta lz type mvar lz lz ih delta delta delta ml lz yn ih delta delta delta cut lz yn side conditions denote ones argument 
ll suppose rule applied ll delta delta delta delta delta delta pl lz yn side condition fv new nk 
induction hypothesis proves proves induction structure proof second obtain proves lz type apply mvar obtain proves lz apply mle proves lz proves obtain proves lz yn nk 
note necessary weaken join properly 
proves obtain yn nk cut 
rule admissibility dereliction necessary applicability cut 
argument summarized deduction ih delta delta delta lz type mvar lz lz ih delta delta delta mle lz yn lz yn ih delta delta delta cut 
yn 
soundness completeness side conditions mentioned argument 
pl case amounts pe case lp calculus 
suppose rule applied pl delta delta delta delta delta delta pl lz yn side condition fv new nk 
induction hypothesis proves proves induction structure proof second obtain proves type apply mvar 
obtain proves apply ml proves lz proves obtain proves yn nk 
note necessary weaken join properly 
proves obtain lz yn nk cut 
rule admissibility dereliction necessary applicability cut 
argument summarized deduction ih delta delta delta lz type mvar 
lz lz ih delta delta delta ml lz yn ih delta delta delta cut 
lz yn side conditions denote ones argument 
theorem completeness proves proves proof induction structure proofs system majority cases simple inductive arguments 
difficult ones dependent function space elimination rules mle ml consider 
chapter 
ll calculus mle suppose rule applied mle rule delta delta delta lx delta delta delta mle mn side condition nk 
induction hypothesis proves lx proves induction structure proofs assertions obtain proves type ae proves type ae apply mvar rule twice proves type obtain proves proves type obtain proves 
assertions application ll obtain proves fy lx yx fy sensitive join proves fy lx yx proves obtain df lx yn application cut rule df sensitive join fy assertion proves lx obtain mn application cut rule sensitive join df 
argument summarized proof ih delta delta delta lx ih delta delta delta ih delta delta delta type mvar ih delta delta delta type mvar ll fy lx yx cut df lx yn cut mn side conditions mentioned argument 
ml suppose rule applied ml rule delta delta delta lx delta delta delta ml mn 
cut elimination side condition nk 
induction hypothesis proves lx proves induction structure proofs assertions obtain proves type ae proves type ae apply variable rules 
proves type obtain proves mvar 
rule 
proves type obtain proves mvar rule 
assertions application ll obtain proves fy lx yx fy sensitive join proves fy lx yx proves obtain fy lx yn application cut rule 
assertion proves lx obtain mn application cut rule sensitive join fy argument summarized proof ih delta delta delta lx ih delta delta delta ih delta delta delta type mvar 
ih delta delta delta type mvar pl fy lx yx cut fy lx yn cut mn side conditions mentioned argument 
cut elimination section prove cut elimination theorem ll calculus 
ways go proving theorem style gentzen shown proves sequent cut rule proves style analogous prawitz shown normal forms provable provable gen pra 
pym pym shall undertake proof second style 
result obtains normal forms 
corresponds fact systems cut get completeness proofs proof system chapter 
ll calculus normal form get proof system cut 
pym notes relationship sequent calculus version lp calculus natural deduction version lp calculus directly analogous gentzen lj nj 
reminded girard moral normal cut free glt 
prove system sound complete respect cut elimination theorem follows corollary completeness part 
theorem soundness proves proves proof immediate consequence soundness respect proof completeness respect depends crucially simple technical device replacing mle ml rules system slightly weaker versions lx type mle mn lx type ml mn sensitive join rules weaker additional premiss 
relatively straightforward prove system obtained replacing mle ml rules system rules equivalent proof idea fact meta theory specifically lemma subderivation ii prove proves proves ae lemma equivalence proves proves proof proves proves immediate 
converse proceed induction structure proofs need consider mle ml rules 
suppose rule applied mle lx mn 
cut elimination induction proves lx induction structure proof assertion proves lx type inversion obtain type 
induction proves assume cut rule admissible proof essentially assertions obtain cut rule proves type sensitive join easy see ae obtain mn mle rule 
proof ml rule similar omit details 
proof completeness facilitated lemma 
lemma application normal form nf rule applied system proof mle ml non dependent versions form nm dom dom appropriate type 
proof induction structure proof mle case 
suppose mn lx usual application side conditions 
mn nf form lx form nm appropriate type 
sequel take denote constant variable 
proof completeness explain informally proof system mle ml step transformed proof system proof final judgement mn 
induction hypothesis extra premiss mle rule proves type 
declare variable type 
apply series left rules order gm nm nm gamma gamma 
minor premisses 
applications left rules effect firstly building declaration antecedent secondly building term type succedent 
specifically th application left rule builds variable type lx lx nm antecedent term form gamma succedent 
sharing sensitive joining contexts eventually leaves final context 
description basic underlying method pym pym 
say underlying chapter 
ll calculus described prescription preceded construction context gamma gamma type type described 
necessary form left rule adopted contraction principal formula takes place 
careful regarding context construction due action context splitting 
theorem completeness proves proves proof induction structure proof hypothesis 
main idea exploit structure nf type differences systems rules mle ml non dependent versions replaced corresponding left rules 
majority cases trivial inductive arguments omit difficult ones include 
mle suppose proves mn proves lx call subproof proves call sub proof usual application 
hypothesis mn nf lemma form nm type lx lx lx abstractions non dependent ones pym notation expressing dependent function spaces think easier reader keep fact back mind lx lx part proof denote substitution denote substitutions 
induction structure proof proves gamma shorter proofs part needed prove gamma induction hypothesis proves gamma nf 

cut elimination induction hypothesis making additional premiss mle rule proves type get proves 
induction hypothesis third time time proves judgements application ll rule obtain proves lx sensitive join induction hypothesis proves gm nm sm gamma left rules employ depends structure type obtain proves ym gamma sm gamma lx gamma proceed similarly gamma appropriate left rule applications obtain proves lx lx take step apply appropriate left rule proves obtained induction hypothesis obtain proves lx lx necessary derelict see context obtained required judgement 
non dependent version case proof done similarly 
omit details 
ml case done similarly mle 
mle case non dependent version ml details omit 
chapter 
ll calculus cut elimination follows 
corollary cut elimination suppose proves nf proves proof theorem proves proves lemma theorem nf proves summary earlier presentation ll calculus chapter linearized natural deduction form 
chapter original type theory replacing elimination rules left rules 
proved soundness completeness results theorem resulting sequent calculus system 
categorical semantics system remains subject investigation 
chapter begins investigation notion computation type theory 
proof search application cut elimination 
relate proof search ll calculus type theoretic meta language logical framework rlf proof search object logics uniformly encoded rlf 
chapter thesis study logical framework rlf defining natural deduction presentations linear relevant logics 
rlf consists language manner similar lf representation mechanism 
language rlf ll calculus representation mechanism judgements types developed relevant logics 
ll calculus order dependent type theory kinds dependent function spaces linear intuitionistic 
large portion thesis devoted studying semantics type theory 
gave natural deduction presentation ll calculus establishing required proof theoretic meta theory 
gave sequent calculus presentation type theory showed cut elimination 
internal logic type theory structural fragment bi logic bunched implications 
inspired resource semantics bi studied categorical model theory type theory 
interesting class kripke resource models construction set op small monoidal category 
avenues wish explore 
outline 
ll calculus rlf logical framework type theory studied interesting genesis 
arose analysis primarily intuitionistic linear logic structurally closer bi 
departure points ll calculus ill linear dependency 
approach chapter 
certain notion context joining restricting elimination way linear dependency set 
clear sophisticated context combination account typedness criteria 
noted concept bunches cube 
cube notions predicate polymorphic dependency 
lattice cubes particular structural properties 
interesting representational issues field seen programme van benthem notion logical pluralism investigating connections meta properties proof calculi structural properties systems deduction vb 
thesis began stating logical frameworks provide foundation development generic proof assistant went develop logical framework linear relevant logics 
practical piece development logical frameworks 
project involve issues representation man machine interface technology proof search 
particularly interesting issue relationship concerning cognitive gesture object logic proof step meta logic proof step 
implementation rlf contrasted lego really implementation language lf take issues representation seriously lp 
contrasted jape highly developed user interface weak logical representation foundation bs 
similar comments apply type theoretic proof assistants coq bbc alf syntactic calculators burstall bur 
development rlf explicates view logical framework architecture encoding object logic similar compiling language uniform representation theorem amounts providing proof correct implementation 
propositions types correspondence chapter presentation bi mainly purposes establishing de bruijn correspondence 
forced fragment bi fragment close linear logic fact 
precisely internal logic ll calculus relationship regard linear logic full bi left 
quite apart bi quite interesting computational interpretations includ ing connection syntactic control interference idealized algol rey rey 
investigate bi programming language 
kripke resource semantics chapter gave class models presheaves 
interesting investigate concrete models 
theses ambler studied sets sets quantales streicher studied sets realizability structures amb str 
interesting question ask account resources structures give fact question help clarifying notion resource 
account semantics gives syntax fairly static 
interesting investigate extent structures explain dynamic nature proof search 
instance realizers contain information constructed 
reminded proofs processes slogan 
start giving semantic account system 
leads consider semantics logical frameworks 
thesis begins studying semantics language rlf logical framework 
step give models judged object logics 
syntactically martin lof arities nps aczel frege structures acz developed relevant logics 
position study relation models rlf encoded judged object logics kripke resource models ll calculus give semantic account judgement method encoding 
aspects kripke resource models lead interesting programming concepts 
instance ask category arises considering omega theta monads 
interpret monads continuations computationally kinds continuations 
ll calculus chapter started investigate notion proof search basis logic programming ll calculus 
refinement ll calculus proceed lines pym wallen pw 
involves development resolution rules uniform proofs permutation theorems unification algorithms effective search strategies 
chapter 
pragmatically role quantifiers quite interesting understood module interfaces get kinds consult 
ask similarities kinds consult kinds storage allocation suggested hearn regions analysis bi 
theory meaning important consider philosophical ideas underlying technical presentation kripke resource semantics 
start considering kripke theory meaning intuitionistic logic go sketch idea resource conscious creative subject 
kripke semantics ideal mathematician creative subject constructing knowledge time 
initial time subject starts certain amount knowledge may nil 
extends state knowledge constructs new objects time 
subject engages research 
states knowledge form partial order 
subject certain choices activities order branching 
creative subject interpret logical connectives 
conjunction disjunction existential quantification straight forward ab known known ab known known known known 
implication presents problem oe known known 
solution interpret implication follows oe known stage stage known known 
universal quantification dealt similarly 
known state stage objects exist known 
accounts creative subject dummett dum van dalen vd 
criticism semantics captures certain aspect subjects behaviour temporal 
perfectly adequate traditional mathematical knowledge lemmata proven remain subject feels able 
doesn account concepts state mutate evolve time necessarily monotonic fashion 
idea refine kripke semantics providing dimension resource indexes creative subject 
example mechanical resource storage space memory holds current state computer 
amount storage space keeps amount state 
creative subject progress adjoin add chunks storage space 
sense knowledge resource 
general distinct categories 
knowledge increases monotonically time creative subject synthesize knowledge knowledge currently 
case resources 
creative subject create resources space 
re interesting link variable logics similar areas logical complexity space 
resources put constraint extent creative subject construct 
look back urquhart semantics relevant logic similar explanatory light 
semantics pieces information resources index computation 
pieces information distinguished facts 
canonical example resource conscious creative subject bottom execution linear logic program 
program executes time adds knowledge answer substitutions 
linear propositions consumed execution 
cost execution memory freed propositions till current point time 
bibliography ab ar anderson jd belnap 
entailment logic relevance necessity 
princeton university press 
abr abramsky 
computational interpretations linear logic 
theoretical computer science 
acz aczel 
frege structures notions proposition truth set 
barwise hj keisler kunen editors kleene symposium 
north holland 
agm abramsky gabbay tse maibaum editors 
oxford science publications 
von 
user guide alf 
available department computing science university goteborg chalmers 
avron honsell ia mason pollack 
typed lambda calculus implement formal systems machine 
journal automated reasoning 
avron honsell miculan 
encoding modal logics logical frameworks 
studia logica 
amb ambler 
order linear logic symmetric monoidal closed categories 
phd thesis edinburgh university 
available edinburgh university computer science department technical report ecs lfcs 
avr avron 
semantics proof theory linear logic 
theoretical computer science 
bar hp barendregt 
lambda calculus syntax semantics volume studies logic foundations mathematics 
north holland 
bar hp barendregt 
lambda calculi types pages 
volume abramsky agm 
bar barber 
linear type theories semantics action calculi 
phd thesis university edinburgh 
bbc barras cornes courant herbelin huet cm murthy parent paulin werner 
coq proof assistant manual version 
technical report inria 
bd baez dolan 
higher dimensional algebra iii categories algebra 
appear advances mathematics 
ben pn benton 
mixed linear non linear logic proofs terms models preliminary report 
technical report computer laboratory university cambridge 
bie gm bierman 
intuitionistic linear logic 
technical report university cambridge computer laboratory august 
bs 
roll jape logic 
available department computer science queen mary westfield college 
bur burstall 
teaching people write proofs tool 
cafeobj symposium japan 
car cartmell 
generalised algebraic theories contextual categories 
annals pure applied logic 
cer cervesato 
linear logical framework 
phd thesis universita di torino 
italian 
coq coquand 
algorithm testing conversion type theory 
huet plotkin hp pages 
cp cervesato pfenning 
linear logical framework 
clarke editor th lics new brunswick nj pages 
ieee computer society press 
bibliography day bj day 
closed categories functors 
mac lane editor reports midwest category seminar volume lecture notes mathematics pages 
springer verlag 
db ng de bruijn 
weaker frameworks 
huet plotkin hp pages 
dum dummett 
elements intuitionism 
clarendon press oxford 
dun jm dunn 
relevance logic entailment 
gabbay guenthner editors handbook philosophical logic volume iii chapter pages 
reidel 
gan ro gandy 
proofs strong normalization 
seldin hindley sh pages 
dm gabbay de 
extending curry howard interpretation linear relevant resource logics 
journal symbolic logic 
gen gentzen 
untersuchungen uber das 
mathematische zeitschrift 
translation gen 
gen gentzen 
collected papers gerhard gentzen 
north holland 
english translation edited introduced szabo 
jh geuvers 
logics type systems 
phd thesis katholieke universiteit nijmegen 
gir girard 
linear logic 
theoretical computer science 
glt girard lafont taylor 
proofs types volume cambridge tracts theoretical computer science 
cambridge university press 
hhp harper honsell plotkin 
framework defining logics 
journal association computing machinery january 
hm js hodas miller 
logic programming fragment intuitionistic linear logic 
information computation 
wa howard 
formula types notion construction 
seldin hindley sh chapter pages 
hp huet plotkin editors 
cambridge university press 
ja harland dj pym 
programming overview 
nivat editors algebraic methodology software technology volume lncs pages 
springer verlag 
hst harper sannella tarlecki 
structured theory representations logic representations 
annals pure applied logic 
ip ss dj pym 
relevant analysis natural deduction 
journal logic computation 
kan kant 
logik edited gb 
friedrich 
translation rs hartman schwarz dover publications 
kri kripke 
semantic analysis intuitionistic logic jn crossley mae dummett editors formal systems recursive functions pages 
northholland 
lp luo pollack 
lego proof development system user manual 
technical report ecs lfcs department computer science university edinburgh 
mey rk meyer 
relevant arithmetic 
polish academy sciences institute philosophy bulletin section logic 
ml martin lof 
intuitionistic theory types predicate part 
rose jc shepherdson editors logic colloquium volume studies logic foundations mathematics 
north holland 
ml martin lof 
meanings logical constants justifications logical laws 
nordic journal philosophical logic 
technical report di logica matematica dipartimento di matematica universita di siena 
bibliography mm jc mitchell moggi 
kripke style models typed lambda calculus 
annals pure applied logic 
mtv 
generating plans linear logic 
theoretical computer science 
nps nordstrom petersson jm smith 
programming martin type theory 
oxford 
pw hearn 
regions interpretation bi 
manuscript 
pw hearn 
resource interpretations bunched implications calculus 
girard editor proceedings typed lambda calculus applications aquila italy 
op pw hearn dj pym 
logic bunched implications 
appear bulletin symbolic logic 
ph dj pym ja harland 
uniform proof theoretic investigation linear logic programming 
journal logic computation 
pit pitts 
categorical logic 
abramsky agm 
pra prawitz 
natural deduction proof theoretic study 
almqvist wiksell 
pra prawitz 
proofs meaning completeness logical constants 
hintikka editors essays mathematical philosophical logic pages 
reidel 
ps pare schumacher 
families adjoint functor theorems 
pt johnstone editor indexed categories applications volume lecture notes mathematics 
springer verlag 
pw dj pym wallen 
proof search lp calculus 
huet plotkin hp pages 
pym dj pym 
proofs search computation general logic 
phd thesis university edinburgh 
available edinburgh university computer science department technical report ecs lfcs 
pym dj pym 
relevant analysis natural deduction 
lecture workshop eu basic research action logical frameworks design implementation experiment sweden may 
joint miller plotkin 
pym dj pym 
note proof theory lp calculus 
studia logica 
pym dj pym 
note representation semantics logical frameworks 
galmiche editor proceedings cade workshop proof search languages rutgers university new brunswick nj 
technical report department computer science queen mary westfield college university london 
pym dj pym 
functorial kripke models lp calculus 
lecture isaac newton institute mathematical sciences semantics programme workshop categories logic programming cambridge 
preparation 
pym dj pym 
logic programming bunched implications extended 
electronic notes theoretical computer science 
rd ritter de paiva 
new models intuitionistic linear logic 
manuscript 
rea read 
relevant logic philosophical examination inference 
basil blackwell 
rey jc reynolds 
syntactic control interference 
conference record fifth annual acm principles programming languages pages 
rey jc reynolds 
essence algol 
jw de bakker jc van vliet editors algorithmic languages 
north holland 
sal 
proof church rosser property edinburgh lf conversion 
lecture workshop logical frameworks france may 
bibliography sh jp seldin jr hindley editors 
curry essays combinatory logic lambda calculus formalism 
academic press 
sh schroeder heister 
generalized rules quantifiers completeness intuitionistic operators oe 
mm richter editor computation proof theory logic aachen volume lecture notes mathematics pages 
springer verlag 
sh schroeder heister 
structural frameworks substructural logics role elimination inferences 
huet plotkin hp pages 
ste 
combinators terms proof theory 
reidel 
str streicher 
correctness completeness categorical semantics calculus constructions 
phd thesis universitat passau 


edinburgh university press 
tf fujita 
adequacy representing higher order intuitionistic logic pure type system 
annals pure applied logic 
tro troelstra 
lectures linear logic 
csli 
ts troelstra schwichtenberg 
basic proof theory 
number cambridge tracts theoretical computer science 
cambridge university press 
urquhart 
semantics relevant logics 
journal symbolic logic march 
vb van benthem 
landscape deduction 
schroeder heister dosen editors sub structural logics 
oxford science publications 
vd van 
language theory automath 
phd thesis technical university eindhoven eindhoven netherlands 
vd van dalen 
logic structure 
springer verlag 
wal la wallen 
automated deduction non classical logics 
mit press 
wan wansing 
logic information structures 
number lecture notes artificial intelligence 
springer verlag 
