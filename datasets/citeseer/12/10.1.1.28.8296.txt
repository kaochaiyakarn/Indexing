appear proceedings fifth hawaii international conference system sciences january 
taxonomy software visualization price ian small ronald baecker dynamic graphics project computer systems research institute university toronto canada phone fax internet rmb dgp toronto edu software visualization interactive computer graphics typography graphic design animation cinematography enhance interface software engineer computer science student programs 
taxonomies software visualization proposed dimensions span space important distinctions systems 
attempt fill gap literature proposing novel systematic taxonomy areas making characteristic features software visualization technology 
taxonomy illustrated terms application systems historic importance technical interest 
scientific visualization researchers range scientific disciplines take advantage new hardware software technology display elucidate vast quantities incomprehensible data mccormick defanti brown rosenblum nielson 
data pictorial form scientists able brain ability analogies links visual image existing ideas links data appears columns numbers lines text 
scientific visualization system allows researcher discoveries possible provides powerful new interface data 
ironically field software engineering seen benefits scientific visualization revolution 
software engineers deal large amounts complex data computer programs rely interface remained essentially unchanged years 
programs edited sized overlapping windows large screen desktop author current address human cognition research laboratory open university milton keynes uk mk dq 
internet ba price vax acs open ac uk tions programs appear single colour single font text 
amount screen real estate increased fundamental interface vt style terminal 
programming language researchers trying design languages easier express understand programs restricted roman alphabet ascii character set elements difficult discriminate take limited advantage human visual perception system 
field computer software visualization sv similar goal handicapped restrictions facilitates human understanding effective computer programs relying typography graphic design animation cinematography interactive computer graphics 
importance visual representations understanding computer programs means new concept 
goldstein von neumann demonstrated usefulness flowcharts developed system draw automatically 
flowcharts serious limitations software engineers argue flowcharts significantly enhance understanding line systems 
researchers started address problem workstation technology common encouraging development broader range sv techniques 
ranged motion pictures sorting algorithms baecker fully interactive graphical representations data structures running live workstation brown sedgewick 
technology remains largely unused today software engineer 
common reason cited failure sv systems software engineering tools lack scalability 
systems fixed examples toy programs subsets language 
require extensive modification source code making inappropriate large software engineering projects 
display kind data level abstraction appropriate certain applications 
systems allow user navigate easily appear proceedings hicss page large information space software project provide detail suppression necessary grasp larger concepts 
believe failure technology transfer due part lack systematic organization researchers positioned systems 
characteristics software engineering tool useful optimal values characteristics vary depending situation 
previous taxonomies myers eisenstadt domingue rajan motta suggested handful criteria comparing sv systems 
sufficient general taxonomy detailed evaluate effectiveness breadth application particular system 
comprehensive set characteristics evaluating sv system 
argue characteristics span space important distinctions systems allow discover previous systems succeeded failed 
apply characteristics important sv systems illustrate taxonomy categorize different approaches 
conclude describing research agenda software visualization identifying important characteristics successful software engineering tool 
terminology calling software visualization called program visualization literature 
prefer term encompasses algorithms programs data suggests need deal systems consisting multiple programs 
program visualization visual programming programming example confused 
visual programming specification computer program graphics shu program visualization graphics enhance understanding program written 
programming example involves specifying program giving examples input output data having computer infer program myers 
certainly overlap areas program specified graphical examples kind visual programming graphical program specification improve understanding program degree 
focus sv tools visual programming systems 
software visualization systems illustrate taxonomy shall apply categories different sv systems 
chose systems historic importance illustrate diversity approaches 
systems include historically important sv systems completely span space taxonomy serve concrete points mapping taxonomy familiar examples 
major motion picture sorting sorting baecker produced university toronto 
minute colour educational film videotape uses animated computer graphics explain different sorting algorithms manipulate data 
movie begins showing algorithms manipulate handful data items ends race algorithms simultaneously sorting sets elements 
today teaching tool 
balsa brown sedgewick widely interactive sv system extensively brown university workstation project educational tool teaching introductory computer science courses 
interactive workstation system allows users watch graphical high level representation data structures running pascal program 
current statement executed highlighted source code data structure graphic reflects current contents data structure 
user start program time control program speed run program backwards 
animation achieved calls animation routines user inserted source code locations interesting events 
user write animation routines pascal 
version balsa ii brown supports colour rudimentary sound 
see program visualizer baecker marcus unix system typesetting programs written combines human factors research modern typography laser printing technology format programs automatically produce kind program book cross indices facilitate navigation source code 
bell laboratory movie stills bentley kernighan generate visualizations programs written language unix operating system 
user insert print statements source code movie language statements output appropriate points program 
display animation user run program collect output file 
movie language output program little language run movie interpreter 
results display animation program 
transparent prolog machine tpm developed open university eisenstadt 
systems visual appear proceedings hicss page logic language 
tpm prolog interpreter running workstation instrumented display automatically running trace program coarse grained fine grained views 
coarsegrained view shows final outcome attempted goals schematized tree node summarizing outcome call particular procedure 
fine grained view shows detailed execution history individual clauses augmented tree aorta diagrams 
tpm designed scale toy examples larger programs 
university toronto system baecker buchanan produces animations execution programs logo language 
done automatically user indicate aspects procedures data logo program see 
automatically produced default visualizations suitable augment portrayal writing additional code host logo language program animated need touched 
university washington program specially instrumented pascal compiler trained recognize certain patterns code data structure declarations henry whaley 
system automatically compile programs written subset pascal window system display high level graphical view certain data structures program runs 
currently recognizes generalized data structures graph linked list sorting algorithms 
taxonomy explained taxonomy propose characterizing program visualization systems divided major sections scope content form method interaction effectiveness 
major sections subdivided categories result called characteristics characterizes program visualization system particular way 
characteristic described briefly framework major sections 
scope general characteristics 

system example discussed visualization system example visualization 
visualization systems generate visualizations arbitrary programs particular class 
examples visualization hand coded demonstrations flexible visualizations particular algorithm system set programs 
examples fixed application may quite flexible type visualization produce entity visualize 
class program class program system designed visualize class characterized attributes source language operating system environment application 
systems designed class domain specific may programs class 

scalability restrictions working large programs datasets 
characterization merges design issues visualizations designed scale fundamental limitations system preset inherent limits size program visualized practical experience large program experience reported 
single category 
characterization important visual tools support toy systems primary criticism genre 

multiple programs system generate visualizations multiple programs simultaneously 
capability useful comparing execution speeds programs running race determining algorithm differs similar algorithm investigating particular algorithm flawed respect correct algorithm 
note modern windowing systems allow window visualization system run parallel approach considered satisfactory centralized control synchronization running visualizations 

concurrency system support visualization concurrent programs 
important issue concurrent applications special visualization needs require specialized support visualization system 

benign disruptive system visualize concurrent applications disrupt execution sequence program effect concurrent execution sequence 
disruptive behaviour desirable visualization system concurrent applications effect activating visualization system may change relative execution rates processes producing different result 
appear proceedings hicss page content gets visualized 

program algorithm visualization system designed produce algorithm program visualization 
differentiation subtle best described user perspective system designed educate user general algorithm falls class algorithm visualization 
system teaching user particular implementation algorithm program visualization 
signs line algorithm visualization program visualization crossed include displays program code listings opposed higherlevel code diagrams labelled displays values particular variables opposed generic data displays 
systems sufficiently flexible produce types visualization depending user desires specifies 

code visualization system performs program visualization visualize program code 
examples code visualization include pretty printed source code structured diagrams call trees 
nature underlying code may implicitly visualized way data evolves considered code visualization concrete visualization code statically execution required 

data visualization system performs program visualization visualize program data 
systems visualize data differ extent gracefully depict complex data structures 

compile run time data visualization depends gathered compile time run time 
general systems depend data gathered solely compile time limited visualizing program code data structures 
system produce visualization actual data values access run time information 
visualizations data gathered compile time generally animated relevant temporal axis change visualization 
visualizations generated data gathered run time produce complex displays variable space program rely animation intuitive mapping temporal aspects program execution presentation visualization 

fidelity completeness visual metaphors true complete behaviour eisenstadt underlying virtual machine 
systems designed software engineering may pose stronger demands pedagogical systems may wish take liberties order provide simpler easier understand visual explanations 
form elements visualization 

medium primary target medium visualization system 
systems designed medium run see designed medium easily produce visualizations workstations support news display postscript list primary target medium 
common choices include film videotape terminal workstation 

graphical elements graphical elements visualization produced system 
provides idea complexity visual primitives system graphical vocabulary 
vocabularies range simple ones feature combinations dots lines complex sets graphical elements include rectangles lines circles points may arbitrary attributes thickness fill pattern 
colour system colour visualizations 
colour convey great deal information imposing low cognitive load greatly underutilized sv systems 
brown hershberger note effective uses colour reveal algorithm state unite multiple views highlight areas interest emphasize patterns capture history 

animation system gathers run time data resulting visualization animated static 
obvious frequent animation program visualization systems capture convey temporal aspects program execution 
system animation novel ways 

multiple views system provide multiple synchronized views different parts software visualized 
appear proceedings hicss page include coarse grained fine grained views data structures graphical view changing program data corresponding view executing source code 

modalities graphical elements colour animation categorize purely visual aspects displays provided system modalities system 
modalities appeal senses sight hearing touch smell taste 
speech non speech audio appeal auditory senses visualization systems 
remaining senses researchers brooks currently working computer generated textures touched entertainment industry smell vehicles fisher 
method visualization specified 

specification style style visualization specification 
visualizations completely hand coded user writes special purpose programs visualize particular algorithm program produced modifying source code adding visualization code original program described writing additional visualization code operates harmony existing program require modifications original source code feedback obtained probes attached various points structures program produced completely automatically case system creates visualization purely analysis program requiring user intervention 

batch live visualization data gathered run time visualization produced batch job data recorded previous run produced live program executes 
visualization live user input result immediate change visualization 
visualization batch data extracted sort trace file user affect course execution program 

fixed customizable visualization generated completely fixed user customize means 
note able visualize different data sets implied live categorization qualify customizing visualization 
order customize visualization layout presentation visualization changeable explicit user instruction 

code familiarity visualization system completely automatic knowledge program code required visualization produced 
clearly completely automatic visualization requires prior knowledge part user main attractions approach 
visualization systems require modifications program source require user know program order produce visualization 
systems provide hooks users attach visualization code may require knowledge program user wishes best potential probes available 

invasive program source code modified order obtain visualization 
systems require encourage user write visualization code rely user place appropriate statements calling visualization modules program visualized 
systems depend interpreters allow catch flag events interest executing program 
systems instrument compiler automatically modify source code compiled systems considered invasive require user go modify source program rely compiler automatically 

customization language visualization customizable visualization specified 
systems support interactive manipulation visualization visualizations specified interactively direct manipulation 
systems require user program explicit visualization code rely procedural visualizations 
systems allow user describe desired visualization high level tools support declarative specification 
visualization systems easily support approaches different aspects complete visualization specification 

language visualization specified procedurally specification written programming language program visualized 
system seeks general application feature property system designed single programming environment requiring user learn new language significant win 
appear proceedings hicss page interaction interact control visualization 

navigation system support navigation visualization large program dataset 
carefully visualization designed situations visualization support large systems interface suffer scale program visualized increases 
eisenstadt 
suggest navigability may achieved changes resolution scale compression selectivity abstraction 

elision system support techniques eliding information suppressing detail display 
techniques useful information culling removal excess information relevant user line inquiry serves clutter display 
elision primary large problems entire dataset simultaneously displayed 

temporal control mapping visualization data gathered run time mapping program time visualization time 
visualization information gathered single point time program execution generates static visualization mapping static static system generates snapshot 
visualization generated animated mapping static dynamic know examples systems 
visualization gathers information span time program execution produces single visualization information mapping dynamic static visualization system generating trace 
visualization system maps dynamic dynamic uses information gathered period time program execution generate animation 
effectiveness visualization 

appropriateness clarity visualization communicate information software 
rapidly visual metaphors inspire understanding 
example visualizations systems provide defaults automatically generated presentations judged terms 
appropriateness clarity subjective measure may need validated experimentation marketplace 
declined subjective judgements having space full explanation see small baecker price preparation complete treatment 

experimental evaluation system subjected experimental evaluation 
see example baecker buxton case study field software psychology 

production system production significant period time 
includes consistent students course publication sale distribution 
analyzing systems taxonomy taxonomy provides meaningful way describing software visualization technology facilitate clear concise statement essential features similarities differences specific systems encourage development insights weaknesses existing technologies needs new technologies 
shall apply systems section suggest research agenda software visualization 
tables application taxonomy systems 
table entry appears missing refer back description taxonomy characteristic states conditions characteristic meaningful 
space constraints force oversimplification reader referred small baecker price preparation complete exposition 
see tables taxonomy illuminate clarify major roles distinctions systems 
sorting sorting demonstrates algorithm animation explain specific algorithms 
multiple program animation careful attention visual techniques data scalability effectively contrasts algorithms terms performance 
rudimentary colour sound add significantly comprehensibility presentation 
balsa begins sos left providing environment generating animations arbitrary pascal programs 
presentations appear workstation live customizable modifications additions host pascal program 
appear proceedings hicss page scope system example program class scalability multiple programs concurrency benign disruptive sos example specific sorting algorithms fixed algorithm set shows large data sets balsa ii system pascal built support large data sets see system limited preprocessor support support handles large programs system unix applications built support nominal disruptive tpm system prolog built support interpreter system logo built support interpreter system subset pascal limited algorithm set large program experience content program algorithm code data compile run time fidelity completeness sos algorithm run partial balsa ii run see program compile run tpm program run run program run partial form medium graphical elements colour animation multiple views modalities sos film rectangles lines dots sound balsa ii workstation graphic primitives text sound see multi font typeset text rules grey tone workstation graphic primitives text tpm workstation graphic primitives text workstation graphic primitives text workstation graphic primitives text appear proceedings hicss page method specification style batch live fixed custom 
code familiarity invasive customization language lang 
sos hand coded batch fixed balsa ii modified source visualization code live custom 
extensive procedural see automatic custom 
declarative modified source visualization code batch custom 
extensive procedural tpm automatic live custom 
interactive probes visualization code live custom 
minimal procedural automatic live fixed interaction navigation elision temporal control mapping effectiveness appropriateness clarity experimental evaluation production sos animation sos subjective balsa ii minimal animation balsa ii see see subjective snapshot trace animation tpm trace animation tpm subjective animation animation subjective see visualizing compiler illustrates different approach gathering information compile time enhanced source code 
form visualization may specified declarative language 
balsa movie stills produces program animation allows animation programs unix language 
balsa source augmented animation calls balsa results production intermediate file little language interpreted batch mode produce movie series printed snapshots 
transparent prolog machine demonstrates automatic software visualization applicability different style language logic language 
careful attention issues data scalability navigation allow system programs significant size 
illustrates probe method specifying visualizations 
users indicate aspects procedures data logo program see 
automatically produced default visualizations suitable customize portrayal writing additional logo code touching host program 
washington program automatic system 
fixed visualizations tailored specific problem domains produced incorporation knowledge base tailored domain 
research agenda systems illustrate positions dimensions program visualization design space closer examination reveals outstanding research issues need solved software visualization aid significantly practice software engineering 
largest failure date terms scope 
dealing primarily toy programs issues scalability remain solved 
known cases running comparing versions real programs 
concurrency scattered lacked unifying systematic framework demonstrated significantly large systems 
progress development methods intelligent presentation complex content myers eisenstadt display automatically lay appear proceedings hicss page appropriate diagrams complex data control structures 
date scratched surface terms form software visualizations 
systematically explored methods mapping attributes algorithms executing programs attributes colour hue saturation value 
appropriate sound area significant research potential see example 

anecdotes value listening program little systematic done 
methods specifying software visualizations far quite crude 
significant portions default visualization generated automatically 
visualization customization languages employ appropriate procedural specification direct manipulation programming example 
complex software visualizations large spatially temporally 
needs done methods interaction incorporate capabilities navigation elision detail suppression control mapping program time visualization time 
hundreds program algorithm visualization prototypes built years 
systematically evaluated ascertain effectiveness resulted systems saw regular products 
little principled analysis various methods visual representation presentation 
progress issues potential reward great 
obvious payoff field software engineering 
see conventional wisdom watch apologies magazine 
potential goes entire domain interactive systems users programmers interactive systems 
increasingly learning complex systems facilitated augmenting conventional textual graphic presentations animation baecker small baecker small mander video speech non speech audio gaver 
software visualization applied development self revealing technology aid explaining system behaviour users ranging novices experts 
gratefully acknowledge support laboratory natural sciences engineering research council canada information technology research centre ontario institute robotics intelligent systems canada apple computer human interface group advanced technology group xerox parc europarc digital equipment ibm canada lab centre advanced studies alias research 
indebted marc eisenstadt john domingue provided valuable comments draft 
jackson 
auralization parallel programs 
presentation chi 
baecker 

sorting sorting 
dynamic graphics project university toronto 
mm colour sound film videotape minutes acm siggraph distributed morgan kaufmann los altos ca 
baecker buchanan 
programmer interface visually enhanced animated programming environment 
proceedings hicss 
baecker buxton 
readings humancomputer interaction 
reading ma addison wesley 
baecker marcus 
human factors typography readable programs 
addison wesley 
baecker small 
animation interface 
art human computer interface design laurel ed reading ma addison wesley 
baecker small mander 
bringing icons life 
proceedings chi 
bentley kernighan 
system algorithm animation tutorial user manual 
computing science tech report bell labs january 
brooks 

university north carolina chapel hill research 
implementing interacting real time course acm siggraph 
brown 

exploring algorithms balsa ii 
ieee computer 
brown hershberger 
new techniques algorithm animation 
proceedings ieee workshop visual languages ieee computer society 
brown sedgewick 
system algorithm animation 
computer graphics 
eisenstadt 
transparent prolog machine tpm execution model graphical debugger logic programming 
journal logic programming 
eisenstadt domingue rajan motta 
visual knowledge engineering 
ieee transactions software engineering 

fisher 

virtual interface environments 
art human computer interface design laurel ed reading ma addison wesley 
goldstein von neumann 
planning coding problems electronic computing instrument 
reprinted von neumann collected works 
ed 
new york mcmillan 


program draw multi level flow charts 
proc 
western joint computer conf 
appear proceedings hicss page conventional wisdom software visualization software engineering old cw program visualization software engineers great idea quite measures expectations 
recipe new cw vastly improved 
characteristics conventional wisdom scalability real programmers real programs pv 
multiple programs versions possible everyday occurrence 
data visualization programs story data changes 
colour animation black white stills may pv needs serious bandwidth 
sound imagine music 

modified source really want line program 
live wants see yesterday news 
cnn 
customizable contractors get right time 
code familiarity know see point 
invasive real code re talking beware 
procedural customization real power pain 
language nice idea tends clash unrestricted program class 
interactive declarative customization old cw hard 
new cw way 
navigation elision real programs big easy get lost 
experimental evaluation production believe system going help henry whaley 
university washington illustrating compiler 
proceedings acm sigplan conference programming language design implementation 
mccormick defanti brown eds 

visualization scientific computing 
computer graphics 
special issue 
gaver 
talking listening computers 
art human computer interface design laurel ed reading ma addison wesley 
myers 

system displaying data structures 
computer graphics 
myers 

taxonomies visual programming program visualization 
journal visual languages computing 
rosenblum nielson eds 

visualization 
ieee computer graphics applications special issue 
shu 
visual programming 
new york van nostrand reinhold 
small baecker price preparation 
software visualization 
gopinath haberman iii myers 
audio aid program comprehension 
proceedings hicss 
