source level static branch prediction wong department computer science school computing national university singapore lower kent ridge road singapore tel fax email comp nus edu sg march ability predict directions branches especially conditional branches important problem modern computer architecture advanced compilers 
static dynamic techniques proposed 
today state art microprocessors form hardware support dynamic branch prediction 
static techniques hand widely studied belief give poorer results 
static branch predictions invaluable information static compiler optimization performance estimation 
propose performing static branch prediction source code level 
assumption source code contains information unavailable assembly machine code level may branch prediction 
empirical studies integer spec benchmarks indicate simple heuristics proposed ective practice 
branch prediction attempt directions branch instructions program 
particularly important problem computer architecture especially pipelined superscalar processors 
pipelined processor nal branch decision instruction passed number pipeline stages 
deep pipeline middle pipeline 
example dec alpha microprocessor integer branches nal resolution takes place th stage stage integer pipeline 
branch prediction incorrect instructions followed branch pipeline ushed cancelled undone 
situation worse superscalar processors typically today technology instructions issued single machine cycle 
example alpha instructions may ushed misprediction 
translates severe performance penalty 
reason processors today form dynamic hardware branch prediction facility 
investigate cacy branch prediction inferences done compile time inspection source code 
refered program branch prediction opposed pro le prediction 
previous approaches done mainly machine code level 
concerned conditional non loop branches conditional branches outside loops conditional branches loop excluding nal conditional branch back top loop 
believe loop branches ectively handled existing schemes 
contribution folded quantitative study source level program branch prediction programs spec spec benchmarks new set heuristics naming conventions proposed evaluated 
evidence shows set simple heuristics static branch prediction source code level achieve results 
section shall survey various existing methods proposals problem branch prediction 
section set source level program branch prediction heuristics proposed 
section outlines experimental setup study section reports results 
followed discussion 
previous works main families branch prediction strategies 
earliest approach isto prediction strategy hardware important example prediction strategy worked practice predicting backward branches branches instructions precede branch instructions program order taken backward branches taken forward ones 
schemes ective especially loops fair general conditional branches 
dynamic scheme performs branch prediction speci havior program execution 
assumption historical behavior branches serve predict branches 
proposals include branch history bits branch target bu er gshare predictor 
example dec alpha microprocessor bit history counter associated branch instruction instruction cache 
incremented taken branches decremented non taken ones 
counter value greater cause branch predicted taken vice versa 
branch nally resolved counter updated 
problem approaches signi cant amount required support 
furthermore extra hardware may lengthen critical path instruction processing 
approaches involve compiler done runtime 
undesirable advanced compilers especially attempt optimizations including form code motion scheduling global register allo cation inlining need branch prediction information achieve results see example lowney 
crisp compiler rst compiler perform static branch predic tion source code 
detected loop branches previously gathered data predicted direction branches comparison operator family strategies refered static reserve word compile link time branch prediction strategies refered semi static strategies 
types operand source programs 
case static branch prediction ball larus static branch prediction done executable codes studied 
static branch prediction analyzing syntax tree program described wagner 
approaches heuristics driven 
attempts improve performance heuristics studying corpus existing programs described calder neural networks employed 
ball larus extended wu larus dempster shafer theory evidence 
shown calder method susceptible di erences compilers architectures prior prediction object code 
works grunwald lindsay zorn propose static predictors aid dynamic predictors 
proposes set source code level heuristics static branch prediction 
heuristics described extensions earlier reported ones 
important innovation names macro function variable part heuristics 
entire prediction strictly program pro ling means di rectly 
speci cally analyzing source programs just macro expansion 
vulnerable uences architectures compilations 
source level branch prediction heuristics heuristics studied follows baseline 
heuristic branches assumed 
words branches predicted taken 
random 
branches chance predicted taken 
standard unix random number generator generation prediction probability 
precisely strategy trace scheduling compiler requires branch prediction compile time perform interprocedural code optimizations 
data ectiveness heuristic 
heuristic scoring system 
branches examined follows condition equality comparison score recorded branch 
rationale assuming uniform distribution data values probability oftwo equal low 
logical condition score recorded branch 
rationale satisfying predicates simultaneously generally harder satisfying just 
logical condition score recorded branch 
rationale relax constraints 
branch contains fprintf stderr score recorded statements 
rationale writing stderr gener ally production programs error reporting debugging purposes 
branch executed 
branch call functions word exit warn err part name score recorded 
rationale probably perform form error handling executed normal circumstances 
branch occurence return statement score recorded 
rationale bet entering procedure certain amount ofwork returning arm containing return resorted 
condition greater check variable expression string max occurs score recorded 
rationale check probably see certain limits exceeded time normal circumstances happen 
condition lesser check expression string min occurs score recorded 
rationale 
conditional branch branch positive score predicted taken 
study investigate di erent weights scores di erent rules 
take basic aim demonstrate heuristics practice 
branches inference random choice branch probability predicted taken 
heuristic sf 
heuristic extension heuristic 
table integer unix system functions values return error codes kept implicit assumption error 
functions participate conditional analysis performed see branch 
example fopen branch 
integer values kept table encoded form ranges 
example fopen system call value greater zero error value kept equal zero 
implementation technique extended handle simple propagations 
example able analyze file 
fopen 
redefinition null 
purpose def chains variables maintained 
heuristic sfm anumber system calls implemented macros expanded macro expansion inclusion system header les 
example getchar function 
heuristic extends heuristics sf inclusion macros consideration 
heuristics sf hand applied macro expansion 
reader may notice way doing perform heuristic sf processing prior macro expansion compiler 
done hope macro expansion may yield information 
dynamic prediction 
comparison purposes combined bimodal gshare predictor proposed mcfarling implemented 
implementation closely mirrors original proposal mcfarling tables entry bit saturating counters maintained see fig 

table bimodal predictor 
lowest bits line number statement index table 
original proposal lowest bits program counter pointing branch instruction 
aliasing expected scheme believe violates predictor workings serious way 
taken branch bit counter incremented 
decremented 
counter saturating incremented decremented 
value greater equivalent predicting branch vice versa 
second predictor gshare 
counter works way 
taken taken gr gshare xor line number pc predict taken combined dynamic branch predictor 
di erent way table indexed 
lowest bits special shift register gr register exclusive ed bits line number pc obtain index 
termed gshare mcfarling 
gr maintained follows branch taken bit shifted right register taken branch causes bit shifted 
main assumption scheme behaviour neighbouring branches correlated 
hashing past branches behaviour captured gr branch counters predecessor branching pattern 
third table indexed lowest bits line number checks particular bimodal gshare accurate past accurate 
reader note far elaborate scheme exist practice 
comparison example dec alpha scheme maintains bit local counter instructions instruction cache 
heuristics assumption programmers name variables pre way 
certainly possible violate assumption practice various software engineering reasons expect naming variables fairly pre bimodal predict 
initial results tests spec benchmark suite validate assumption 
experimental setup heuristics tested programs spec spec bench mark suites 
gnu version compiler extended purpose 
modi cations include macro preprocessor cccp extended insert markers macro sion sites 
markers maintain pointers away stage names macros prior expansion retrieved 
essentially pointers line indices simple ascii le containing sequential order names macros encountered processing le 
new pass follows immediately macro preprocessor added com piler 
actual branch prediction processing performed 
essentially strip version parser lex parse outputs augmented version macro preprocessed program 
main ad dition data structure captures prediction information 
data structure contains space allocated counters execution program capture runtime statistics 
original parser modi ed insert statistic gathering function calls certain locations code start branch conditional branch 
statistic gathering functions added main runtime library 
addition startup routine additional initializations mainly related patching pointers counters properly located runtime 
program lines total 
cond 
dyn 
pred 
perfect code executed wt 
ave static pred 
excl 
loops wt 
ave spec cint espresso li eqntott compress sc gcc spec cint go ksim gcc compress li ijpeg perl vortex ave benchmarks table characteristics benchmarks 
results section shall main results investigations cacy proposed heuristics 
benchmarks compiled modi ed compiler option compiler executed data set de ned spec 
outputs validated spec requirements 
benchmarks data set consists independent data sets runs 
furthermore length runs di er 
need introduce fair means reporting results 
program pj executing data set dk letn pj dk number times arm ith branch predicted taken heuristic taken 
similarly de ne pj dk pj dk pj dk ith branch number times arm taken arm predicted arm taken arm predicted arm predicted taken respectively heuristic brevity context clear shall drop pj dk portion formula 
total number branches covered heuristic program pj executing data set dk pj dk de ne accuracy heuristic program pj executing data set dk accuracy pj dk pj dk rate heuristic program pj executing data set dk de ned accuracy pj dk 
due fact spec benchmarks executed set data weighted average accuracy measure de ned follows weighted average accuracy pj pj dk pj dk pj dk table shows basic characteristics benchmarks study 
table reports weighted average dynamic predictor described section 
perfect static predictor statistics program pj executing data set dk obtained formula accuracy psp pj dk ip max truei pj dk falsei pj dk truei pj dk falsei pj dk truei pj dk falsei pj dk number times ith conditional program pj evaluated true false respectively executing data set dk 
perfect static predictor upper bound prediction strat egy 
dynamic predictors bounded 
contrary reported ball larus dynamic predictor performed consistently better perfect static predictor 
attribute better dynamic predictor experi ments 
average dynamic predictor better perfect static predictor 
stated earlier domain static dynamic predictors quite di erent 
argue potential static prediction strategies 
heuristic heuristic sf heuristic sfm program appl 
appl 
appl 
appl 
appl 
appl 
stat dyn stat dyn stat dyn spec cint espresso li eqntott compress sc gcc spec cint go ksim gcc compress li ijpeg perl vortex average table applicability heuristics percentages 
table shows applicability heuristics percentage non loop branches heuristic able perform prediction 
recall non loop conditionals itwas possible apply heuristic rule random predictions 
applicability measures percentage conditionals de nite predictions possible random predictions re sorted 
values static dynamic ratio 
static ratio percentage conditionals source code prediction possible 
dynamic ratio percentage executed branches prediction pos sible 
best average value achieved sfm 
compares favourably applicability corresponding spec integer code gure reported benchmarks reported ball larus non loop predictors 
baseline random heuristic heuristic sf heuristic sfm program accu 
accu 
accu 
accu 
accu 
accu 
ran ran ran cint espresso li eqntott compress sc gcc cint go ksim gcc compress li ijpeg perl vortex average table accuracy heuristics 
results various heuristics shown table 
set numbers heuristics 
rst set numbers accuracies heuristics computed branches prediction 
second set accuracies results random predictions branches heuristic able prediction 
cases proposed heuristics performed better baseline random method 
compared dynamic predictor best predictors sfm achieved average performance dynamic predictor 
important point note applicability dynamic predictor applied branches 
heuristic ave qual 
factor ave qual 
factor heur rand baseline random sf sfm dynamic table average quality factors heuristics 
table shows quality di erent heuristics means quality factor heuristic program pj de ned quality factor pj weighted average pj weighted average accuracy psp pj comparing results reported literature believe quality factor better means comparison 
benchmarks di erences data set directly comparison ratios meaningless 
table table may draw observations 
conditional branches symmetric 
static strategy predicting branches taken data suggest achieve accuracy average 
believe may artifact way particular programs written provide convincing proof predicting branch taken 

random strategy pursued lowney yields accuracy better expected accuracy due asymmetry branches 
small number branches tend ones executed time 
predictor happens predict correctly get higher score 

heuristic sf adds little performance heuristic reason seen follows 
take example fopen 
return value tested go branch return value zero indicates error 
error handling branch error handling reporting procedures fprintf stderr 
invoked 
tested heuristics ectiveness heuristic sf reduced 

heuristic sfm performs signi cantly better heuristic sf sc spread sheet program 
boundary spreadsheet de ned anumber macro variables pre xed max min readily heuristic sfm 

compared dynamic predictor espresso gives worst performance 
attribute mainly inlined procedures source code 
sure fragments generated tend terse names variables 
benchmark ignored suite spec spec sfm randomizing branches predictions achieved average accuracy dynamic predictor 
caveat dynamic predictor applicable branches 

best average quality factor sfm randomizing branches predictions better value reported ball larus integer spec benchmarks 

wagner reported static non loop branch predictor similar heuristic achieved rate times perfect static predictor quality factor 
sfm predictor quality factor higher 
addition qualitatively better previous works point ball larus prediction performed executable codes 
pre diction unavailable compiler level 
wagner non loop prediction derivative ball larus heuris tics done syntax tree level 
information available prior macro processing utilized 
showed help improve accuracy prediction number branches prediction performed 
discussion stressed proposed scheme meant replace runtime dynamic branch prediction 
aim get approximation branching behaviour compilation 
information useful ways 
examples 
trace selection 
trace scheduling compilers selection traces crucial performance 
proposed schemes aid selection process 

software data prefetching modern microprocessors started provide prefetching data cache 
aided branching probabilities compiler better evaluate data accesses basic block prefetching 

global register allocation 
global register allocation algorithms priority graph colouring approach heuristics weigh importance virtual registers contribute better performance get allocated physical registers 
availability branching information increase accuracy estimates 

code instrumentation 
new popular form code pro ling runtime infor mation gathering code rewriting witness code inserted strategic points target 
witnesses capture control ow program dur ing execution 
optimization inserting instrumentation code basic blocks possible insert witnesses frequently executed basic blocks reconstruct control ow 
proposal may able assist identifying frequently executed basic blocks 

assist hardware branch prediction 
may possible software hardware approach improve accuracy branch prediction run time 
remains subject research 
case seeing architectures recognize importance branch prediction possibility software branch prediction 
sparc version powerpc struction sets examples modern superscalar architectures branch instructions prediction bits 
described section implementation testbed ideas modi cation estimated gnu compiler production quality compiler 
advantage approach done early compilation process making branch prediction information available nearly passes back compiler 
possible information abovementioned areas 
required modi ed macro preprocessor basically notes macro expansion done names related expanded phrases additional pass parsing 
additional pass entire source code le scanned 
predictions intermediate le cleaned way actual parser accept input 
arrangements prediction information passed backend compiler 
degradation speed compilation measured observably negligible testbed 
approach taken quite closely coupled unix environment 
believe general approach adapted operating systems programming environments 
contribution show potentials source code level branch prediction 
proposed heuristics performing source level static branch pre diction evaluated performance large benchmarks 
number source level static branch prediction heuristics proposed studied empirical experi ments 
performing static branch prediction source code level advantage permitting inspection names assumption programmers employ names macros variables indicative uses named data 
branch pre diction performed front compiler assuming uses 
best heuristic sfm applicable time best case achieves accuracy dynamic predictor 
argue evidence simple heuristics branch predictions obtained compile time 
emphasized arguing static branch prediction replace dynamic ones 
believe heuristics proposed straightforward implement compiler helpful compilers optimization 
iwould anonymous referees useful comments 
bandyopadhyay murray 
compiling crisp microprocessor 
proc 
compcon spring 

ball larus 
optimally pro ling tracing programs 
acm trans 
prog 
lang 
systems 


ball larus 
branch prediction free 
proc 
sigplan conf 
prog 
lang 
design impl 

calder grunwald lindsay martin mozer zorn 
corpus static branch prediction 
proc 
sigplan conf 
prog 
lang 
design impl 

calder grunwald jones lindsay martin mozer zorn 
evidence static branch prediction machine learning 
acm trans 
prog 
lang 
systems 


chow hennessy 
priority coloring approach register allocation 
acm trans 
prog 
lang 
systems 



branch strategy taxonomy performance models 
ieee computer society press 
digital equipment 
digital semiconductor alpha microprocessor hardware manual 

branch folding crisp sor reducing branch delay proc symp 
computer arch 

fisher freudenberger 
predicting conditional branch directions previous runs program 
proc 
th asplos 

grunwald lindsay zorn 
static methods hybrid branch prediction 
proc 
int conf 
parallel architectures compilation techniques 
www cs colorado edu grunwald papers pact 
lee smith 
branch prediction strategies branch target bu er design 
ieee computer 


lowney freudenberger lichtenstein nix 
multi ow trace scheduling compiler 
supercomputing 



luk mowry 
compiler prefetching recursive data structures 
proc 
th asplos 

mcfarling 
combining branch predictors 
digital wrl technical note tn 
smith 
study branch prediction strategies 
proc 
th int symp 
computer architecture 

wall 
predicting program behavior real estimated pro les 
proc 
sigplan conf 
prog 
lang 
design impl 

wagner graham harrison 
accurate static estimators program optimization 
proc 
sigplan conf 
prog 
lang 
design impl 

weaver 
sparc architecture manual version 
prentice hall 
weiss smith 
power powerpc 
morgan kaufmann publishers wu larus 
static branch frequency program pro le anal ysis 
proc 
micro 


