hybrid shipping architectures survey ivan bowman university waterloo acm org february advances relational database systems include distributed systems choose execute portions query processing functionality server client sites 
symmetric problem received little attention partitioning client application functionality client server 
report presents survey literature related partitioning problems 
contents partitioning query execution centralized systems 
client server systems 
distributed systems 
client resources 
query shipping 
data shipping 
hybrid shipping 
summary 
partitioning client applications automatic partitioning 
user defined functions 
stored procedures 
code shipping 
summary 
optimizing distributed plans search space 
costing plans 
enumeration strategy 
optimizing expensive predicates 
summary 
mobile code automatic distributed partitioning 
languages 
past decades relational database management systems rdbmss widely adopted business users manage large amounts cor data 
adoption relational data model owes genesis fortunate convergence factors 
concurrency controls recovery mechanisms 

access plan optimizers 

efficient data processing algorithms 

client server computing paradigm 

massive vendor marketing sales efforts 
factors rdbms technology multi dollar industry areas model substantially improved 
particular fairly difficult write appli cations rdbms due impedance mismatch set relational model tuple time procedural languages write applications 
applications take best advantage global system resources 
clean separation system rela tional processor procedural application code convenient system architecture 
boundary components enforces partitioning may give best possible performance 
problem utilized resources exacerbated client server model procedural application code typically executes separate machine rdbms data stored 
pure implemen tation partitioning system able exploit client resources help compute answers relational queries server resources execute procedural application code 
address problems researchers proposed ideas better utilize client server resources 
hybrid shipping model allows relational processing system execute portions access plan client site 
user defined functions udfs proposed allow users extend rdbms procedural code execute server client 
code shipping solutions proposed allow optimizers choose best execution site client application code 
related area distributed systems research investigated mechanisms automatically partition applications optimize placement application code multiple sites 
interested comprehensive system achieves permits relational query processing performed client server sites 
automatically identifies fragments granularity basic blocks client application code may benefit executed server 
provides safe secure mechanism executing procedural client code database server 
optimizes code placement relational query processing operators procedural client application code fragments minimize response time resource consumption 
hypothesize model produce efficient access plans yield optimal client server resources 
execution model raises issues explored researchers 
presents survey literature relating issues places execution model context previous research 
remainder organized follows 
section describes proposed mechanisms partitioning query processing effort rdbms server client machines 
section discusses symmetric prob lem partitioning client application functionality client server machines 
section describes approaches optimizing queries distributed systems 
section describes approaches implementing mobile code 
fi nally section discusses topics fit suggests areas research 
partitioning query execution early database systems research concentrated single computer mod els advent cheap powerful workstations led systems exploit resources multiple computers 
orthogonal directions explored researchers client server systems execute client applications separate machine rdbms distributed database systems mul tiple server machines answer queries hybrid shipping approaches allow system execute portions relational access plan clients 
centralized systems mid research commercial prototypes rdbmss created evaluated prototypes implemented rdbms client application running single computer 
system developed group researchers ibm run ibm mainframes running vm operating system 
ingres developed concurrently university berkeley run pdp computers running unix 
systems implemented rdbms client applications residing single machine relational interface programs 
client server systems approach partitioning functionality multiple computer environ ment put client applications different computer rdbms 
hagmann ferrari performed performance study ingres suggested performance improved partitioning system user interface parser machine rest rdbms software machine 
general form partitioning approach client server model client machines running application software local rdbms related software submitting requests server ma chine running rdbms 
approach allows system scale easily client resources execute client applications 
approach benefits administration system server machines need backed administered client ma chines equipped user interface hardware server machines equipped large amounts memory large reliable secondary storage 
client server architecture generalized multi tier system computers organized layers layer acting client lower level server higher level 
general peer peer structures viewed client server computer possibly acting client server 
concreteness client server refer case computer fixed role client server 
today majority commercial rdbmss sybase ase ibm db oracle microsoft sql server variant client server architecture site fixed role client server 
distributed systems common multiple computers available site sense computer answer queries researchers considered different ways accomplish partitioning 
parti idea distributed rdbms multiple computers involved system providing local rdbms managing local data contributing global distributed rdbms 
distributed rdbms prototypes implemented late including sdd distributed ingres 
prototypes developed tech niques distributed query optimization execution distributed trans actions distributed data partitioning replication 
extent prototypes ahead time failed widely accepted number reasons including lack robust efficient net working protocols operating systems 
newer distributed database systems pop ular commercial systems offering form distributed query processing 
research prototypes provide dis tributed query execution including garlic disco mariposa 
client resources decisions designing client server distributed architecture partition query processing effort tween computers involved system 
traditional rdbmss execute query processing servers object oriented database manage ment systems considered performing query processing client site 
hybrid approach dynamically chooses combination alternatives proposed 
query shipping query shipping approach commonly commercial rdbmss 
approach ships sql queries client machines server 
server performs query processing effort answer returned form stream tuples 
limited form caching model answers previous queries stored client cache answer identical queries 
model completely preclude query processing occurring client site relational processing may embedded client applications procedural code 
example client applications compute selections aggregates joins customized procedural code 
approach data analysis programs retrieve bulk data server perform significant amount analysis data solely client machine 
data shipping contrast data shipping approach query processing server 
query processing done client machines 
data needed client query processing algorithms requested server 
data shipping approach better client resources query shipping substantially increase commu nication costs lead utilization server resources 
data shipping primarily objectstore 
key decision data shipping approaches unit transfer data common choices object servers returning individual objects server page servers returning disk pages server inter hybrid servers dynamically choosing better shipping policies 
object page server approaches preferable certain conditions 
hybrid approach maxi performance choose better pure schemes combination object page shipping 
hybrid shipping approach suggested franklin nsson hybrid shipping 
approach allows system choose perform query processing server portion processing client machine 
provided effective optimizer developed choose appropriate alternative approach ability perform pure shipping approaches better 
approach requires client computer con tains rudimentary query processing capabilities optimizer select plans supported client query processor 
hybrid ship ping allows system exploit client resources 
addition hybrid approach substantially reduce communication overheads data inflating operations performed client server 
hybrid shipping approach benefit client disk resources parallel server disk resources 
hybrid approach database products application systems sap research prototypes orion 
approach distributed wrapper heterogenous systems disco garlic mariposa 
project uses hybrid shipping requires aggregation duplicate elimination sorting done client output generation joins selections executed server client accessing cached results previous queries 
summary early systems centralized execution current dance relatively inexpensive computer hardware connected high speed networks led distributed systems preferred installations 
commercial rdbms systems predominantly offer pure client server systems employ query shipping approaches 
research prototypes simulation studies shown approaches lead utilization client resources 
flexible query execution policies recom partition data servers choose execute portions query access plans client computers 
approach provides system better scalability amount data clients increases 
approaches form part solution 
continue require client applications executed exclusively client computers 
section discuss proposals address limitation 
partitioning client applications hybrid shipping approach originally proposed franklin nsson considered partitioning query processing operators 
address ways partition procedural client application code client machines servers 
capability pro vided object server oodbms architectures allow methods executed server 
case selective methods approach reduce number objects intermediate results leading reduced execution communication costs 
automatic partitioning similar problem occurred early deciding parti tion functionality mainframe satellite programmable graphical terminals 
programmers decided functionality implemented satellite host implemented functional ity usually different programming languages environments 
groups researchers foley north carolina van dam michel brown approach undesirable characteristics 
programmer intuition place functionality wrong especially early design stages code partitioning decision usually 
static nature partitioning decision impossible re tune application effectively different loads different host satellite system different cost parameters 
approach required programmers fluent different programming environ ments 
combined problems designing distributed system host satellite system substantially difficult corresponding centralized system 
order address problems groups developed automatic par systems 
foley developed cages system compile time preprocessor distribute procedures pl programs host satellite system van dam michel developed system partition programs written algol systems relied run time statistics automati cally partition application procedures host satellite 
cages project considered moving global data simple form caching 
projects easier application programmers build efficient working systems able treat problem centralized able defer partitioning decisions run time statistics gathered 
user defined functions possible way partition client applications allow client program mers define functions operators subsequently executed server 
research examined ways client programmers define new data types new access methods informix data blades commercial systems support extension user defined functions 
user defined functions supported univer sal rdbms systems sybase ase informix db oracle 
example programmer wished retrieve list employees street address prime number implement function deploy server 
subsequent queries access function clause select appropriate employ ees 
user defined functions select list queries compute user defined aggregate functions 
users required decide functionality executed server implement functionality programming facilities rdbms 
developers commercial rdbmss wary allowing client pro include code server due issues safety security 
security refers threat user defined functions may maliciously read modify data access may pose denial service attacks 
security issues dealt commercial systems requiring privileged users able install new user defined functions 
safety issue refers problem bugs user defined functions may affect rdbms examples include causing crash server causing undetected corruption data 
commercial implementations user defined functions entirely satisfactory 
typically require proprietary interpreted language access proprietary api communicate rdbms 
order provide safety systems interpreted functions expense run time efficiency 
systems run native code server process leaves server open security safety holes 
alternative running native code process computer server employed cost run time efficiency 
java source language proposed alternative provide limited safety acceptable formance 
java promotes better portability access rdbms accomplished standardized api jdbc 
java udfs developed tested client machines deployed servers production 
java provides better support portability security safety comes cost execu tion efficiency 
efficiency addressed extent just time compilation 
part cost impedance mismatch java native language server 
jni interface limits efficiency udfs callbacks server 
approach providing safety software fault isolation provides safety native code 
wahbe lucco andersen tested approach postgres user extensible type system 
soft ware fault isolation approach provided significant performance improvements native operating system services hardware address spaces achieve safety 
server site user defined functions installed rdbms execute 
cases desirable expensive execute udf client site udf contains propri code application programmer wish available server 
mayr seshadri address concern providing optimization algorithm accounts cost executing udf client site allows concurrent execution minimize exposed network latency 
stored procedures udfs helpful improving execution speed individual queries provide general facility performing data tion 
stored procedures provided rdbmss mechanism client programmers group commonly operations execute efficiently server 
example common idiom programs guarded insert inserts tuple corresponding key exist generates error message formatted fields existing record 
stored procedures requires accesses rdbms find tuple exists perform insert 
stored procedure reduce single access 
general stored procedures arbitrarily complex 
fact execute arbitrary portions client application server providing form execution partitioning 
unfortunately mechanisms stored procedures cumbersome similar ways udfs 
language development environment stored procedures match environment client program partitioning decision early design process 
code shipping user defined function model commercial systems explored predator project consider moving functions server client model assumes partitioning done statically appli cation programmer 
requires administrator configure site desired functionality 
administration burden quite onerous number sites grows tens hundreds thousands quite achievable employee computer participating distributed system 
mocha project aims ease administrative burden ing code shipping middleware solution 
system allows access distributed group heterogenous servers wrapper architecture similar garlic 
garlic mocha wrappers called data access providers perform operations supported system 
functionality dap loaded dy system shipping appropriate java class files 
client programmers integrate custom operators framework likewise distributed system 
accomplished explicitly describing meta data operator xml 
mocha optimizes queries dynamic programming approach builds left deep processing trees 
mocha optimizes minimize com munication costs considering volume reduction factor 
summary relational database management systems allow client programmers de portions application server machine order improve performance 
mechanisms provided cumbersome 
usually require languages development environments typically require partitioning decisions com pile time 
mechanisms difficult usually attempted experienced programmers 
current systems rely trusting programmers implement secure safe extensions rdbms accept performance penalty interpret client extensions execute isolated process 
programming language java provided hope particular predator mocha research prototypes 
java udfs portable security safety guarantees java vm may acceptable rdbms implementors 
java come performance penalty com pared native code 
approach software fault isolation offers alternative providing safe native code low execution overhead 
existing approaches client program partitioning fairly require substantial effort knowledge part application programmer order achieve efficient robust implementation 
substantial room progress area 
optimizing distributed plans query optimizer component rdbms chooses access plan specifies operators execute query 
key components optimizer plan enumeration algorithm uses heuristics compare subset possible execution strategies cost function assigns cost metric access plan 
systems permit operators executed different sites system provide optimizer chooses site assignment order minimize cost function 
problem optimizing queries shown np hard 
result systems rely heuristics prune search space possible plans 
goal optimizer usually viewed finding best plan eliminating truly bad plans 
search space centralized system choices optimizer 
access path index selection 

join aggregation duplicate elimination algorithms 

join ordering 

placement expensive predicates 

intra query parallelism 
distributed systems decide server sites system 
addition decisions site selection 
choices join methods expanded distributed systems example semi joins may provide improved performance 
costing plans order compare plans optimizer needs assign cost function 
original distributed rdbms prototypes sdd distributed ingres cost function typically resource consumption distributed ingres allowed plans optimized response time 
communication costs assumed dominate local processing costs leading fairly simplistic cost models 
reasonably accurate cost models developed query pro cessing algorithms 
cost models depend parameters difficult estimate selectivity predicates 
particular join predicates sub queries correlated conjunctive predicates difficult estimate accurately 
contemporary optimizers statistics guess parameters 
unfortunately errors accumulate rapidly join degree queries 
researchers proposed query pro cessing engines periodically evaluate current plan believed optimal 
enumeration strategy system prototype dynamic programming optimizer discovered optimal left deep processing strategies 
strategies join ing tables discovered optimal join strategies tables 
enumeration technique proven successful emulated commercial rdbmss 
original algorithm enumerated left deep execution trees 
approach acceptable centralized systems distributed systems particularly benefit bushy trees place adjacent operators site 
modifications dynamic program ming approach allow bushy trees enumerated expense greater optimization cost 
serious criticism dynamic program ming algorithm fact uses exponential time space limits optimization algorithm joins fifteen quantifiers 
greedy algorithms heuristics prune search space tol erate higher join degrees cost possibly poorer access plans 
alternative branch bound style algorithms generate reasonable plans quite low memory consumption allowing optimization queries quantifiers 
optimizing expensive predicates traditional query optimizers primarily concerned choosing opti mal join ordering appropriate join methods 
user defined functions included optimization problem substantially harder 
estimation selectivity cost user defined functions non trivial reasonable guess may accomplished maintaining statistics previous executions 
researchers proposed placement expensive predicates udfs considered join enumeration algorithm 
approach effect substantially increasing cost enumeration 
hellerstein proposed predicate migration approach lead cost polynomial number udfs 
worst case pred migration requires exhaustive enumeration join space cost number joins query 
despite possibly high cost predicate migration guarantee optimality resulting access plan restriction linear cost function 
approach chaudhuri shim polynomial number user defined predicates needs exhaustively enumerate join strategies guarantees optimality resulting access plan 
predicate migration approach approach sensitive estimated selectivity user defined predicates 
poor plans may chosen estimates accurate 
expensive predicate placement algorithms originally designed context centralized system account possibility selecting execution site expensive predicates 
mayr pirahesh consider location user predicates extent client site udfs required located client site 
join enumeration algorithm exponential sum join degree query number udfs query 
cost enumeration worse optimizer considers best site execute udfs 
queries fairly udfs dynamic programming approach may reasonable 
queries contain tens udfs high join degree heuristic approach greedy algorithms randomized algorithms branch bound algorithms required dynamic programming able optimize queries reasonable amount time 
large queries example generated considering basic blocks client application candidates udfs existing join enumeration algorithms give reasonable results 
alternative approaches commodity flow networks may prove fruitful situations 
summary relational query optimizers heuristics cost estimates generate ac cess plans specify access methods base data join ordering methods placement expensive predicates 
distributed case optimizers choose execution site operations ac cess plan 
optimizers consider placement expensive predicates udfs join enumeration 
chaudhuri shim approach polynomial number udfs approach cover distributed case udfs executed client server spec ified optimizer 
case substantially expensive may rule traditional dynamic programming algorithms optimization 
mobile code problem executing client application code rdbms server viewed special case mobile code 
interest mobile code environments partially fueled internet java programming environment 
general problem writing distributed application tially harder writing equivalent centralized application 
waldo argue inherent problem distributed computing syntactic sugar 
caveat mind examine proposed systems attempt ease burden creating efficient robust distributed applications 
automatic distributed partitioning significant problem occurs writing distributed system decision partition functionality 
discussed section previous researchers programmer intuition wrong comes choosing partitioning 
researchers propose automated partitioning system examines system written single computer identifies portions distributed chooses partitioning profiling statistics 
system provided automated distributed partitioning algol programs host satellite computer 
procedures re partitioned run time measured statistics 
contrast cages allowed compile time partitioning pl procedures host satellite 
automatic partitioning offered nearness matrix provided aid program mer 
significant advantage cages system ability execute code host satellite concurrently albeit fairly constrained way 
performance study cages project applica tion efficiently partitioned procedures contained graphical display routines expensive computation 
granularity distribution procedures system able move computation host display routines satellite authors re wrote procedures allow partitioning 
cages considered partitioning order dozen modules 
large modern programs contain hundreds thousands procedures 
project implemented hunt able partition large applications containing hundreds com components distributed computers 
uses system monitoring gather statistics optimization step 
optimization performed classification phase clusters components similar access behaviour graph cutting algorithm commodity flow network 
system relies finding components effectively deployed 
studying system hunt severely constrained large number non components 
observations system cages system appears waldo warning particularly pertinent trivial generate robust efficient distributed system system intended centralized 
abacus project attempt distributed programs intended centralized 
provides primitives program mers write applications data intensive distributable components 
system monitors run time resource usage dynamically changes com ponent placement checkpoint restore methods explicitly coded programmer 
system manages adapt changing loads 
interesting feature rdbms standpoint partitioning done dynamically resistant bad initial access plans 
languages safe languages hold promise bugs program written safe language affect unrelated programs environment 
mobile code benefits languages help enforce security policies 
java popular language mobile code 
provides portability platform neutral byte code representation rich standardized class library 
security model java addresses security safety concerns related mobile code emergence just time compilers jits holds hope execution gap java systems level languages narrow 
java approach native code 
objective caml obliq safe tcl alternatives 
addition custom language technique software fault isolation incorporated compiler existing languages pascal 
approach inserts verification code possibly unsafe operations array accesses uses optimization techniques reduce overhead checks 
context rdbmss java mocha tor implement query operators client machines imple ment udfs execute server 
java expedient choice uses clear provides best level ab 
may case programming language primitives closely matched relational query processing provide better match 
customized approach require substantially implementation effort compared shelf language 
relational database management systems progressed point interested distributed systems multiple servers clients 
know best performance achieved consider exe relational query processing server client proposals optimizing plans systems ensuring appropriate operator code available 
know client applications benefit executing portions procedural code servers mechanisms user defined functions stored procedures 
significant lack research direction auto matically distributing portions procedural client application exe cution server machines 
facility needed difficult programmers implement partitioning due cumbersome server interfaces programmers sub optimal de easily corrected applications deployed 
order allow effective utilization client server resources research topics 
automatically detect sub procedural fragments client application may benefit executing server 

optimize placement large number udfs stored procedures client server 

execute client code server efficiently safely se 
answers questions surely help build efficient distributed database systems 
khalil amiri david petrou greg ganger garth gibson 
dynamic function placement data intensive cluster computing 
proceedings usenix annual technical conference june 
arnold gosling 
java programming language 
sun microsystems 
astrahan chamberlin gray griffiths king lorie mcjones mehl traiger wade watson 
system relational approach database management 
acm transactions database systems 
philip bernstein nathan goodman eugene wong christopher reeve james jr query processing system distributed databases sdd 
acm transactions database systems 
ivan bowman 
join enumeration memory constrained environment 
proc 
ieee conf 
data engineering 
surajit chaudhuri kyuseok shim 
optimization queries user defined predicates 
proc 
int conf 
vldb mumbai bombay india 
codd 
relational model data large shared data banks 
communications acm 
george copeland david maier 
making smalltalk database system 
beatrice editor sigmod proceedings annual meeting pages boston massachusetts june 
acm press 
david dewitt philippe david maier fernando lez 
study alternative workstation server architectures object oriented database systems 
dennis mcleod ron sacks davis hans rg schek editors proc 
int conf 
vldb pages brisbane australia august 
morgan kaufmann publishers 
epstein distributed query processing relational database system 
proc 
acm sigmod conference may 
michael franklin michael carey 
client server caching revisited 
tamer zsu dayal patrick valduriez editors distributed object management 
morgan kaufmann publ 
san mateo ca usa may 
international workshop distributed object management 
michael franklin bj rn th nsson donald kossmann 
performance tradeoffs client server query processing 
jagadish singh mumick editors proc 
acm sigmod conference pages montreal quebec canada june 
acm press 
michael godfrey tobias mayr praveen seshadri thorsten von eicken 
secure portable database extensibility 
laura haas editors proc 
acm sigmod conference pages seattle washington usa june 
acm press 
goetz graefe 
query evaluation techniques large databases 
acm computing surveys june 
laura haas donald edward wimmers jun yang 
optimizing queries diverse data sources 
proc 
int conf 
vldb athens greece 
robert brian hagmann domenico ferrari 
performance analysis backend database architectures 
acm transactions database systems march 
griffith jr configurable applications satellite graphics 
proceedings third annual conference computer graphics interactive techniques siggraph pages philadelphia pa july 
acm 
griffith jr james foley 
configurable applications satellite graphics cages 
proceedings second annual conference computer graphics interactive techniques siggraph pages bowling green ohio june 
acm 
joseph hellerstein michael franklin chandrasekaran deshpande kris hildrum sam madden raman shah 
adaptive query processing technology evolution 
ieee data engineering bulletin 
see telegraph cs berkeley edu 
joseph hellerstein michael stonebraker 
predicate migration optimizing queries expensive predicates 
proc 
acm sigmod conference pages washington dc 
galen hunt 
automatic distributed partitioning component applications 
phd thesis university rochester august 
available technical report tr 
galen hunt michael scott 
automatic distributed partitioning system 
proceedings third symposium operating system design implementation osdi pages new orleans la february 
usenix 
paul woelk won kim wan lee 
query processing distributed orion 
bancilhon editors advances database technology edbt pages venice italy march 
donald kossmann 
state art distributed query processing 
acm computing surveys 
appear 
donald kossmann michael franklin 
study query execution strategies client server database systems 
proc 
acm sigmod conference 
available university maryland technical report cs tr 
tobias mayr praveen seshadri 
client site query extensions 
alex christos faloutsos ghandeharizadeh editors proc 
acm sigmod conference pages philadephia pennsylvania usa june 
acm press 
janet michel andries van dam 
distributed processing host satellite graphics system 
proceedings third annual conference computer graphics interactive techniques siggraph pages philadelphia pa july 
acm 
manuel rodr guez mart nez nick roussopoulos 
automatic deployment application specific metadata code mocha 
proc 
th edbt conference konstanz germany march 
manuel rodr guez mart nez nick roussopoulos 
mocha self extensible database middleware system distributed data sources 
proc 
acm sigmod conference dallas texas usa may 
mary roth peter schwarz 
don scrap wrap 
wrapper architecture legacy data sources 
proc 
int conf 
vldb athens greece 
nick roussopoulos chen stephen kelley yannis papakonstantinou 
project views 
bulletin technical committee data engineering june 
griffith selinger astrahan chamberlin lorie price 
access path selection relational database management system 
proc 
acm sigmod conference 
avi silberschatz stan zdonik strategic directions database systems breaking box 
acm computing surveys 
stonebraker aoki devine litwin olson 
mariposa new architecture distributed data 
proc 
ieee conf 
data engineering pages houston tx 
michael stonebraker 
inclusion new types relational database systems 
proc 
ieee conf 
data engineering pages los ca february 
michael stonebraker paul aoki witold litwin avi pfeffer adam sah jeff carl staelin andrew yu 
mariposa wide area distributed database system 
vldb journal 
michael stonebraker joseph hellerstein editors 
readings database systems 
morgan kaufmann publishers san francisco ca 
michael stonebraker eugene wong peter kreps gerald held 
design implementation ingres 
acm transactions database systems 
tommy thorn 
programming languages mobile code 
acm computing surveys september 
anthony tomasic raschid patrick valduriez 
scaling access heterogeneous data sources disco 
ieee transactions knowledge data engineering september october 
andries van dam george richard harrington 
intelligent satellites interactive graphics 
proceedings ieee 
tamer zsu ronald 
adaptive hybrid server architecture client caching 
malcolm atkinson maria orlowska patrick valduriez stanley zdonik michael brodie editors proc 
int conf 
vldb pages edinburgh scotland uk september 
morgan kaufmann 
robert wahbe steven lucco thomas andersen susan graham 
efficient software fault isolation 
proceedings symposium operating system principles 
jim waldo geoff ann wollrath sam kendall 
note distributed computing 
technical report tr sun microsystems laboratories ca november 
williams daniels haas lapis lindsay ng obermarck selinger walker yost 
overview architecture 
technical report rj ibm research lab san jose ca 

