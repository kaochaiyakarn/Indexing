syntax de nition formalism sdf manual heering hendriks klint rekers june sdf formalism de nition syntax comparable bnf respects wider scope covers de nition lexical syntax 
design implementation tailored language designer wants develop new languages implement existing ones highly interactive manner 
emphasizes compactness syntax de nitions ering standard interface lexical context free syntax standard correspondence context free syntax powerful disambiguation list constructs ecient incremental implementation accepts arbitrary context free syntax de nitions 
sdf combined variety programming speci cation languages 
way obtain fully general user de nable syntax 
cr categories software engineering requirements speci cations languages 
software engineering programming environments programming languages formal de nitions theory syntax semantics programming languages processors 
mathematics subject classi cation software programming languages software compilers generators 
key words phrases lexical syntax context free syntax concrete syntax syntax ambiguous grammar grammar priorities user de nable syntax syntax de nition formalism scanner generation parser generation editor generation 
department software technology centre mathematics computer science box ab amsterdam netherlands current address software engineering research centre lange bk utrecht netherlands programming research group university amsterdam box db amsterdam netherlands current address university leiden department mathematics computer science box ra leiden netherlands note partial support received european communities esprit projects generation interactive programming environments project 
preface revised edition revision sdf manual originally published 
di ers original respects new prede ned sorts added ignore describing strings inside lexical tokens ignored see section reject forbidden combinations adjacent lexical tokens see section 
lexical disambiguation changed see section old prefer longest match rule replaced new prefer longest match sort rule 
prefer variables rule added 
new features context free syntax added injections see sections explicit naming functions syntax see section de nition priority ordering injection functions taken account see section 
general design considerations notations may improve readability programs formal speci cations considerably programming speci cation languages give user control syntax 
refer interested reader section manual brief survey development user de nable syntax 
issue general importance user de nable syntax sine qua non language de ning languages 
language de nition expressed meta language consist parts de nition concrete lexical context free syntax language de ned de nition static semantics de nition dynamic semantics 
project generation interactive programming environments constructing environment interactive development implementation languages context designed sdf handle syntax part language de nitions 
static dynamic semantics parts language de nitions concern manual coupling semantics syntax points syntax comes 
viewpoint concrete syntax natural describe coupling terms string text matching 
string pattern containing variables matched program text 
matching succeeds point text corresponding string values variables transmitted semantic rule attached pattern 
practice string matching gives rise ambiguities dicult control 
decided semantics coupled syntax means tree matching susceptible unintended ambiguities 
question arises parse tree syntax tree program text 
parse tree derivation showing text question derived start symbol grammar 
interior nodes non terminals grammar leaves lexical tokens keywords operator symbols identi ers making original text 
syntax tree contains essential information describing text interior nodes constructors called operators language direct descendants node operands 
leaves syntax tree identi ers integer constants main argument favor performing matching basis syntax trees parse trees may contain unnecessary nodes omitted syntax tree 
sdf supports patterns variables allowing declaration possibly nite number variables user de ned names variables section syntax de nition 
text containing variables text pattern corresponds syntax tree variables tree pattern open term 
actual matching uses syntax tree pattern 
texts variables may viewed incomplete variables playing role gaps lled 
emphasized coupling semantics syntax syntax tree matching preclude concrete syntax semantics parts language de nition 
fact favor doing 
price paid discrepancy text matching viewpoint strongly suggested concrete syntax syntax tree matching viewpoint intended 
minimize gap separating viewpoints sdf implicitly de nes standard translation context free syntax translation context free syntax sdf de nitions 
implies sdf expressive power instance syntax de nition formalism metal 
context free syntax de ned metal speci cation may di er important respects reproducible sdf 
example order arguments concrete forms function need metal 
reason believe uniform predictable relationship context free syntax distinct advantage 
required transformation syntax trees deeper form expressed programming speci cation language sdf embedded 
case algebraic speci cation formalism asf bhk chapter express static dynamic semantics languages 
environment syntax directed editor generated syntax part language de nition log dk koo second point syntax comes 
syntax directed movements text performed eciently basis corresponding syntax tree basis parse tree 
explained generally contains redundant nodes give rise void text movements may quite irritating 
hand text movements basis syntax unpredictable due xed correspondence context free syntax enforced sdf 
discuss modular sdf de nitions manual modularity important design issue outset 
particular putting sdf de nitions developed independently facilitated 
sdf language designer able borrow parts existing language de nitions undue diculty 
adopted viewpoint sdf allow de nition context free languages bnf permits implementation support feature reserve impose additional lr ll constraints 
advantage respect modularization 
full context free power available syntax de nitions longer brought acceptable unnatural form obeys restrictions imposed implementation 
turn means context free syntax may bear closer resemblance exactly sdf requires 
important question remains ambiguous syntax de nitions 
dicult problem solved sdf implications design 
usually ambiguous de nitions eliminated applying lr ll constraints just dismissed limiting language designer 
general case supported implementation ambiguous de nitions handled correctly sense parses ambiguous sentence returned freedom ambiguities longer guaranteed advance due fact longer decidable 
obviously unexpected ambiguities may cause fatal run time errors 
hand allowing syntactic ambiguities leaves room semantic disambiguation schemes similar ones people disambiguate sentences natural language 
semantic disambiguation falls outside scope sdf attempts alleviate problem syntactic disambiguation ering powerful priority construct 
solve problem unexpected syntactic ambiguities course 
helps language designer eliminate sources ambiguity aware 
syntactic disambiguation proceeds phases parse trees containing internal priority con icts rejected remaining parse trees compared multiset ordering derived priority rules sdf de nition 
rst phase handles ordinary arithmetical expressions instance second phase allows parses totally di erent compared 
power priority mechanism unambiguous sdf de nitions inherently ambiguous context free languages languages unambiguous context free grammar 
mean desired disambiguation obtained adding appropriate priorities ambiguous sdf de nition priorities 
availability separate disambiguation construct means disambiguation need expressed terms syntax rules 
result parse trees smaller closer syntax trees 
addition availability full context free syntax mentioned important reason xed correspondence context free syntax ered sdf turns satisfactory 
addition context free syntax lexical syntax de ned sdf 
lexical disambiguation controlled means priority mechanism available context free level primarily giving precedence longest lexemes literals occurring contextfree syntax 
remaining ambiguities passed context free level 
summary sdf allows de nition concrete syntax single framework 
design implementation tailored language designer wants develop new languages implement existing ones highly interactive manner 
emphasizes compactness syntax de nitions ering standard interface lexical contextfree syntax standard correspondence context free syntax powerful disambiguation list constructs ecient incremental implementation accepts arbitrary context free syntax de nitions 
combined variety programming speci cation languages 
way obtain fully general user de nable syntax 
rst example sdf de nition consists sections structure sorts names domains non terminals sections speci cation lexical syntax rules lexical syntax context free syntax rules concrete syntax priorities de nition priority relations rules contextfree syntax variables naming schemes variables introduce signi cant features sdf means example de ne lexical concrete syntax simple programming language see 
sorts section names declared 
names interpreted ways non terminals lexical context free grammar names domains construct syntax trees 
dual interpretation sorts achieve automatic mapping sentences syntax trees 
lexical syntax section de ne space tabulation newline character layout characters line 
addition form identi ers line numeric constants line de ned 
context free syntax section concrete syntax de ned concrete syntax obtained non terminal interpretation sorts reading rules right left ordinary grammar rules 
syntax obtained domain interpretation sorts reading rules left right de nitions typed constructor functions syntax trees 
sort names appearing function de nitions de ne types arguments result functions 
features illustrated context free syntax rules de ne lists separators line 
rules may bracket attribute 
rules grouping language constructs contribute syntax lines 
rules may various attributes de ning associativity properties lines 
allow de nition associative left right non associative operators 
priorities section priority relations rules contextfree syntax de ned associativity groups di erent operators 
shown operators higher priority operators 
variables section naming schemes variables 
variables ways examples add line numbers sdf de nitions ease text 
part sdf de nition proper 

sorts id nat program statement series exp 
lexical syntax 
layout 
id 
nat 
context free syntax 
program series program 
series series bracket 
statement series 
id exp statement 
exp series series statement 
exp series statement 
exp exp exp left 
exp exp exp non assoc 
exp exp exp left 
exp exp exp non assoc 
exp exp bracket 
id exp 
nat exp 
priorities 
left exp exp exp exp exp exp left exp exp exp exp exp exp 
variables 
exp exp 
series series simple programming language 
variables semantics de nitions added sdf de nition holes programs syntax directed editing 
organization manual chapters manual divided groups 
chapters introductory character main issues design sdf discussed basic concepts notations introduced 
second group chapters contains actual description sdf 
chapters devoted detailed description sections sdf de nition 
chapter contains summary de nitions 
group miscellaneous subjects addressed 
chapter show semantic rules attached sdf de nitions 
leads speci cation formalisms considerable syntactic freedom 
chapter techniques required implement sdf sketched 
discussion results obtained comparison related chapter 
appendices complete manual sdf de nitions sdf appendix berkeley pascal appendix 
preliminary de nitions chapter introduce basic notions de nition sdf regular grammars section context free grammars section signatures section 
section follows motivation de nitions section give overview sdf de nition show basic notions 
regular grammars regular expressions alphabet usual meaning asu 
regular expression associate language lexemes accepted 
empty string regular expression associated language 

regular expression associated language fag 

suppose regular expressions associated languages regular expression associated language lexemes 
regular expression associated language lexemes consisting concatenation parts rst part second part 
regular expression associated language lexemes consisting zero concatenations lexemes 
regular expression associated language parentheses may placed regular expression changing meaning 
extend de nition ways regular expression associated language lexemes consisting concatenations lexemes 
note 
parentheses may omitted priorities operators going high low priority concatenation 
addition concatenation operator left associative 
string constants abbreviate sequences concatenations single characters alphabet 
abbreviated 
lexical non terminal form regular expression see 
regular grammar de ned ordered list named regular expressions 
emphasize fact similar non terminals contextfree grammars call names regular expressions lexical non terminals occurrence lexical non terminal regular expression interpreted abbreviation regular expression associated earlier list 
general form regular grammar may occur provided language associated regular grammar union languages associated lexical non terminals identify lexical category lexemes call lexical non terminal lexeme pair lexical token 
context free grammars variant known bnf notation de ne grammars corresponding sdf de nitions 
terminals grammar literal strings appear grammar rules double quotes lexical non terminals 
lexemes strings character alphabet de ned separate regular grammar 
non terminals grammar written angle brackets 
may consist arbitrary symbols 
convention lexical non terminals sux lex 
grammar rule consists non terminal symbol list zero rule elements 
empty list rule elements denoted symbol 
rule element terminal non terminal sepg sep optional terminal 
denotes list zero repetitions non terminal separated sep sep brackets omitted rule element abbreviated chapter lexical non terminals sux var denote contributions variable declarations lexical grammar 
symbol abbreviate rules right hand side rhs rhs equivalent rhs rhs non terminal grammar acts start symbol 
parse tree combination regular grammar bnf grammar ordered labeled tree 
leaves tree literals grammar characters lexemes 
nodes labeled lexical non terminal non terminal list 
described detail de nition 
ordered labeled tree parse tree regular grammar bnf grammar root labeled lexical non terminal children labeled characters lexical alphabet characters form lexeme accepted regular expression associated regular grammar root labeled children cn roots labeled xn rule xn rule grammar parse trees literals root labeled sepg children cn sep empty children parse trees labeled sep empty zero odd odd numbered children parse trees root labeled children equal literal sep consider instance bnf grammar decl integer real regular grammar 
literals bnf grammar decl integer real 
lexical token 
non terminals parse tree sentence decl ab xyz real shown 
note lexeme represented decl real parse tree sentence decl ab xyz real 
sequence characters 
structure appearing rules de ning lost parse tree 
sequel add literals occurring bnf grammar regular grammar identify occurrence literal occurrence corresponding lexical non terminal see section 
signatures syntax corresponding sdf de nition described signature de nes set syntax trees known terms 
consists parts declarations sorts de ning basic domains trees 
declared sort basic sort sorts fs sepg fs sepg sep arbitrary identi er empty implicitly de ned list sorts denote lists respectively zero elements sort symbol sep part list constructor lists elements sort di erent separators distinct 
abbreviation denote 
strict non re exive partial order sorts de ning inclusion relations sorts subsorts 
partial order obtained transitive closure subsort declarations signature 
addition subsort relations hold automatically fs sepg fs sepg basic sorts occurrence fs sepg fs sepg implicitly declares sep constructor function lists elements sort fs sepg fs sepg basic sorts note relations hold automatically 
declarations functions de ning nodes tree giving function name number sort children arguments result sort 
result sort function basic sort 
argument sorts may list sorts 
functions arguments called constants attribute assoc denotes associative function may attached binary functions identical argument result sorts 
adopt convention names sorts functions separators signatures consist solely alphanumeric characters hyphens sort name surrounded double quotes 
signatures contain separate section declaration variables 
variables implicitly de ned denoted sort followed hyphen followed possibly quoted identi er nat denotes variable sort nat fid ids denotes variable sort fid 
note variables may range basic sorts list sorts 
trees constructed combining functions variables ways compatible de nition child node tree sort identical smaller appearing declaration function corresponding node 
exception general rule lists may contain list variables smaller list sort separators 
syntax tree term signature de ned inductively follows constant basic sort function arguments result sort term basic sort variable basic list sort term sort function arguments sorts basic sort result sort terms sort term basic sort sep basic sort sep separator empty term basic sort variable list sort fs sepg term list sort fs sepg variables sort fs sepg term list sort fs sepg 
note de nition associate smallest possible sort term 
consider example signature sorts id type decl nat exp arg list subsorts id functions id id integer type real type decl type id decl nat succ nat nat exp exp exp exp exp exp call id arg list exp basic sorts signature id type decl nat exp arg list 
partial order sorts de ned id nat included exp included arg list 
functions integer real decl succ call de ned type arguments result 
examples syntax trees signature shown graphically figures 
pre notation trees gures written succ succ decl real id decl real id call exp respectively nat succ nat succ nat id id decl type fid decl real id fid id id call exp fid variables appear examples variable sort nat nat id id id type type fid fid fid fid observe list sort fid appear explicitly signature example variables sort permitted 
need notion selective substitution variables syntax trees 
subset occurrences variable may replaced tree sort identical smaller sort variable 
variable may occur tree assume occurrences ected substitution explicitly marked list variables occurring elements lists treated special way substitution replacing variables list elements elements inserted directly elements original list producing list nested structure 
term containing marked occurrences variable sort term sort de ne selective substitution denoted follows marked 
sep de ne substitution induction length list sep empty list de ne sep 
result substitution sep list form sep um 
distinguish cases result substitution list 
case marked variable sort fs sepg sep de ne sep um 
result substitution term sort de ne sep um 
trees figures obtained corresponding trees variable substitutions assuming occurrences variables marked succ succ real fid decl nat nat succ nat succ id id type fid decl examples syntax trees variables 
nat nat nat id id type real fid id fid id id id exp fid id 
rationale de nitions context free grammar signature de nitions notions introduced previous sections di er respects usual ones 
give arguments particular choices 
bnf grammars non terminals act start symbol 
desirable perspective syntax directed editing need arises parse parts programs 
terminal alphabet consists literal strings lexical nonterminals 
real fid decl call real fid id id fid decl fid call examples syntax trees variables 
notion bnf grammars directly support list constructs separators de ne parse trees way list elements treated symmetrically 
alternative approach left right recursive grammar rules leading correspondingly biased representation lists 
asymmetrical representation translated symmetrical representation syntax tree order avoid asymmetry visible syntax directed editing list elements 
signatures basic sort implicitly de ne di erent list sorts possible separators constructor functions 
way lists elements equal type di erent separators distinguished 
subsorts serve purpose eliminating chain rules form bnf grammar 
give rise void text movements syntax directed editor 
interaction subsorts lists 
relation fs sepg fs sepg holds automatically sorts separators 
inclusion sepg hold automatically perspective syntax directed editing distinction single element list consisting element disappear see instance chapter 
allow declaration associative functions signature means attribute assoc 
syntactic level associative functions may cause ambiguities resolve choosing parse possible associatively equivalent parses see section 
declaring function signature associative allows reconstruction variants associative law 
variables explicitly declared general naming scheme generating nitely variables 
need generality describe naming schemes variables sdf variable declarations 
naming convention sorts functions general normally allow names consisting alphanumeric characters hyphens containing arbitrary characters surrounded double quotes 
allows great exibility generating names sorts functions 
comments substitution order chosen de ne substitution selected occurrences variable occurrences 
clearly easily de ned rst marking occurrences variable applying notion selective substitution 
hand selective substitution fundamental operation syntax directed editing 
sort term may smaller substitution 
particular list sort fs sepg may list sort fs sepg substitution 
sorts elements list may smaller original element sort list result substitution 
overview sdf de nition sdf de nition consists sections de ning sorts lexical syntax context free syntax priorities variables 
sdf de nition purpose de ne sentence characters lexical analysis sentences lexical tokens syntactic analysis parse trees select parse trees construct parse syntax trees abs derived regular grammar derived bnf grammar derived signature sorts lexical syntax context free syntax priorities variables sdf de nition sentence syntax tree 
set sentences strings 
set syntax trees 
relation parse trees sentences syntax trees 
derive information sdf de nition derived regular grammar derived bnf grammar de ning set sentences 
derived signature de ning set syntax trees 
mapping parse trees derived bnf grammar syntax trees derived signature 
xed mapping part de nition sdf 
mappings obtained adding semantic rules sdf de nitions see chapter 
relation di erent sections sdf de nition information derived shown 
gure shows function abs converts input sentence syntax trees auxiliary functions parse select construct 
return gure chapters 
sorts sorts declared listing name sorts section sdf de nition 
constraints imposed sorts sorts layout ignore reject prede ned may 
may result sort functions lexical syntax see sections 
sort char prede ned may 
may declarations variables see chapter 
declared sort non terminal name derived bnf grammar 
sort appears result sort lexical function added derived regular grammar 
declaration prede ned sort char declarations sorts declared sdf de nition added derived signature 
described rules chapter 
lexical syntax lexical syntax describes low level structure sentences sequences characters terms lexical tokens lexical token pair consisting sort name lexeme 
distinguish classes lexical tokens identi ers numbers 
actual text token 
lexical syntax de nes substrings sentence lexical tokens 
substrings sentence layout symbols lexical tokens skipped layout symbols serve purpose separating consecutive lexical tokens 
substrings sentence appearing inside lexical tokens ignored ignored symbols contribute lexeme enclosing lexical token 
sequences consecutive lexical tokens rejected 
de nition lexical syntax consists set function declarations consisting regular expression result sort 
function declarations output sort de ne lexical syntax lexemes sort 
layout symbols de ned functions prede ned sort layout result sort 
typically de ne layout comment conventions 
ignored symbols de ned functions prede ned sort ignore result sort 
typically de ne languages certain layout symbols comments may appear inside lexical tokens 
rejected symbols de ned functions prede ned sort reject result sort 
typically forbid certain sequences lexical tokens 
sdf de nition derive regular grammar 
derived regular grammar obtained follows regular expressions extracted lexical syntax described chapter 
literals appearing context free syntax enumerated section 
regular expressions extracted variable declarations chapter 
regular expressions de ning complete alphabet added variables sort char declared chapter 
lexical analysis derived regular grammar skip tokens sort layout tokens sorts input syntactic analysis phase 
result input sentence subdivided necessarily unique sequence lexemes 
sort may associated lexeme 
situation shown 
comparison classical model lexical analysis model sdf shown 
classical model lexical analysis input string lexical tokens input string lexical tokens lexical tokens lexical tokens classical model lexical analysis sdf model 
input string subdivided single stream lexical tokens separated layout 
lexical ambiguities resolved lexical analysis phase 
model sdf input string may subdivided streams lexical tokens 
lexical ambiguities resolved lexical analysis phase passed syntax analysis phase context information may available resolve 
organization chapter follows 
section elementary lexical functions described 
lexical function de nitions may contain character classes section repetition operators section 
de nition layout functions described section de nition ignore functions dealt section 
literals discussed section 
reject functions treated section 
disambiguation rules section 
rationale way de ne lexical syntax concludes chapter section 
lexical functions lexical syntax contains declarations lexical functions de ning syntactic form lexemes 
simplest form lexical function declarations consist literal strings names sorts result sort 
ects derived regular grammar bnf grammar signature follows 
sort ignore appears result sort lexical function de ne symbol lexical non terminal derived regular grammar terminal symbol derived bnf grammar 

sorts vowel 
lexical syntax 
vowel 
vowel 
vowel 
vowel 
vowel 
vowel vowels ignore de ne lexical non terminal 
add derived bnf grammar rule form name associated derived regular grammar 
add derived signature declarations constants sort char characters alphabet declarations lexical constructor functions form char name written lower case letters 
de nition re ects fact lexemes appear strings characters syntax tree 
regular expression associated symbol consists left hand sides lexical function declarations sort sort names appearing left hand sides replaced symbol de ned previous step 
note want extract regular grammar sdf de nition cyclic dependency may exist lexical function declarations 
step leads rules chapter 
sort vowel lexical functions de ned 
functions result sort vowel 
derived regular grammar example allow context free functions lexical sort output sort variables lexical sorts 
di erent entities may associated sort denotes lexical functions result sort denotes variables sort see chapter denotes entities result sort lexical context free functions variables 

sorts vowel 
lexical syntax 
vowel shorter version vowels character class 
de nition tokens associated input sentence aio 
character classes enumerations characters occur frequently lexical de nitions 
abbreviated character classes enclosed symbols 
character class contains list zero characters stand character ranges instance abbreviation characters 
character range form satisfy restrictions lower case letters precedes alphabet upper case letters precedes alphabet digits numeric value smaller escaped non printable characters see character code smaller character classes may complemented denoted pre operator 
complemented character class accepts characters listed 
derived regular grammar character classes replaced characters class 
see rule chapter 
de nition vowels equivalent abbreviated character class 
lexical syntax input sentence subdivided sequence tokens 
sorts vowel digit 
lexical syntax 
vowel 
digit 
vowels digits characters 
note space character occurring characters character input string classi ed proper treatment layout characters discussed section 
characters special meaning sdf may cause problems needed ordinary characters de nition 
backslash character escape character quoting special characters 
sequence nc special character needed ordinary character de nition 
character classes characters special meaning character class character class character range escape character 
literal strings characters special meaning double quote escape character 
literal strings containing double quote backslash written nn respectively 
addition escape convention abbreviations exist frequently layout characters arbitrary non printable characters nn newline character nr carriage return nt horizontal tabulation non printable character digit octal code ddd 
abbreviations character classes literal strings 

sorts letter 
lexical syntax 
letter 
layout 
layout letters spaces 
layout strings matched lexical functions prede ned sort layout result sort skipped 
string matched layout function functions result sort interpretation layout symbol suppressed interpretations passed syntax analysis phase see section 
lexical syntax de nes sort letter de nes functions output sort letter prede ned sort layout 
derived regular grammar 
input string initially subdivided tokens 
layout tokens skipped tokens sort letter remain 
words result lexical analysis consist tokens 
note lines example replaced line nn layout 
ignore strings matched lexical functions prede ned sort ignore result sort may appear inside lexical token contribute lexeme token 
see lexical syntax de ning simple character identi ers sort id combination rule ignore result sort 
derived regular grammar 
sorts id 
lexical syntax 
id 
ignore identi ers embedded ignored symbols 

sorts letter letter digit id 
lexical syntax 
letter 
letter digit 
letter letter digit id 
layout identi ers 


input strings mention examples yield single lexical token 
ignored symbols describe instance continuation lines treatment space symbols fortran embedding layout characters comments identi ers keywords algol 
repetition cases lexical tokens described patterns exhibit certain repetition 
post operators available purpose 
operators denote respectively zero repetitions sort literal character class attached 
derived regular grammar repetitions mapped corresponding repetition operators regular grammar 
see rule chapter 
illustrates de nition identi ers means operator 
derived regular grammar example 


input string de subdivided lexical tokens elimination single layout token occurring de 

sorts id 
lexical syntax 
id 
layout concise de nition identi ers 

sorts id int 
lexical syntax 
id 
int 
layout 
int id reject rejecting adjacent integers identi ers 
subdivision may arbitrary justi ed discussion lexical ambiguities section 
concise de nition identi ers 
operator applied directly character class 
note due elimination sort letter digit input string de erroneous 
literals chapter see literal symbols keywords operator symbols appear context free syntax added derived regular grammar 
reserve symbol purpose derived regular grammar 
contain literal symbols context free grammar alternatives 
see rule chapter 
context free syntax containing literals instance lead de nition reject constructs described far positive allow explicit description new forms lexical tokens 
prede ned sort reject negative mechanism de ning lexical syntax allows forbid occurrence certain classes strings lexical syntax de ned 
string matched lexical function reject result sort substrings rejected lexical token 
string question embedded longer string acceptable lexical token token returned 
lexical error 
lexical syntax de nes identi ers sort id integer constants sort int 
rule line de nes integer constant followed identi er rejected stated integer constants identi ers may adjacent 
input string rst lexical token id recognized space skipped lexical error due succession tokens int id 
input string correct interpreted single lexical token id 
disambiguation lexical syntax rst illustrate ambiguities lexical level means 
consider possible interpretations input string xy 









xy ambiguities taken seriously possible sdf clear automatic disambiguation method needed reduce vast amount lexical ambiguities 
disambiguation rules order prefer longest match sort prefer non layout prefer literals prefer variables 

sorts int real id op 
lexical syntax 
int 
real 
id 
ne 
op 
layout integers reals ne 
operator 
prefer longest match sort rule rejects interpretations input string included longer interpretation sort 
words sort longest possible match preferred 
interpretation xy remains application rule 
note possible interpretation 
lexical syntax input string ne lead lexical interpretations 
int op ne int 
real id ne real interpretations passed syntax analysis phase rst continue parsing 
application prefer longest match sort rule may interpretation lexical token left 
remaining rules serve purpose reducing number possibilities 
prefer non layout rule eliminates interpretations lexical token layout symbol 
applying rule interpretation remains lexical token taken input sentence 
prefer literals rule applies literals keywords operator symbols introduced context free syntax 
ambiguities may arise literal strings may equal lexemes de ned lexical syntax 
prefer literals rule gives precedence interpretations input string literals 
applies instance identi ers de ned lexical syntax keywords de ned context free syntax 
prefer literals rule favours called reserved word strategy keywords 
section shown restriction circumvented 
ambiguities may arise input string interpreted lexical function literal variable de ned variables section see section 
cases prefer variables rule applies interpretations variable suppressed 
applying disambiguation rules remaining interpretations input string passed syntactic analysis phase 
rationale de nition lexical syntax major reasons making distinction lexical syntax context free syntax 
handling ambiguities di erent 
lexical level uninteresting unintended ambiguities exist 
needs xed disambiguation rules eliminate see section 
possible interpretations remain application rules returned lexical scanner 
allow lexical ambiguities sort 
lexemes represented linear strings characters distinction ambiguities lost 
context free level resolution ambiguities de ned speci cation 
instance giving priority associativity operators context free syntax see chapter 
general disambiguation rules disadvantages considers problem combining modules containing sdf de nitions see chapter 
second value constructed recognition di erent 
lexical level tokens constructed consisting name string 
contextfree syntax level syntax trees constructed 
di erence consequences association semantics sdf de nitions see chapter 
implementation techniques associated implementation tradeo di erent lexical syntax context free syntax see chapter 
limitations current disambiguation rules discussed section 
context free syntax context free syntax describes concrete syntactic structure sentences language 
de nition context free syntax sdf de nition consists declarations context free functions section simplest form context free functions described 
section syntactic repetition discussed 
chain bracket functions described section 
lead elimination certain nodes syntax trees 
note context free functions may followed list attributes 
chapter describe bracket attribute section 
attributes priorities described chapter 
context free functions simplest form context free functions declared giving syntax list consisting zero literal symbols names sorts result sort 
de ne meaning context free functions specifying contribution derived regular grammar derived bnf grammar derived signature mapping parse trees syntax trees 
contributions derived regular grammar derived bnf grammar derived signature described detail literal symbol lit appearing function de nition context free syntax add lit alternative prede ned lexical non terminal derived regular grammar add lit terminal derived bnf grammar 
lexical token identi ed bnf terminal lit 
function declaration context free syntax add grammar rules obtained exchanging left hand right hand side function declarations derived bnf grammar add function declarations derived signature function new name see generated sorts arguments result obtained sort names appearing original function de nition 
see rules chapter 
new names mentioned may chosen arbitrarily long context free function gets name di erent context free functions obtain name 
sdf prescribe particular naming scheme case see section 
manual generate function names concatenating literals original sdf function de nition rules 
consecutive literals new name separated hyphens 
occur literals function declaration name empty 
name generated rules contains characters alpha numerics hyphens surrounded double quotes 
names unique name generated rules post xed hyphen arbitrary numeric string unique 
de ne contribution context free syntax mapping parse trees syntax trees 
principle correspondence function de nitions context free syntax chain bracket functions see section 

sorts nat coord program 
lexical syntax 
nat 
layout 
context free syntax 
nat nat coord 
line coord 
move coord 
program program 
program simple drawing language 
rules derived bnf grammar function de nitions derived signature straightforward de ne mapping parse trees derived bnf grammar syntax trees derived signature 
mapping recursively de ned giving transformation parse tree syntax tree root labeled non terminal single child root labeled lexical non terminal literal result transforming syntax tree root labeled lexical constructor function sort see section single child result transforming root labeled non terminal transformed follows recursively transform children root labeled non terminal 
gives list syntax trees root corresponds rule derived bnf grammar function de nition derived signature 
transformed syntax tree consisting function de ned elements children 
see rules chapter 
mapping parse tree syntax tree associate syntax tree string aware fact parse tree may exist string syntax tree may associated 
problem discussed chapter 
exceptions general rule introduced description lists section chain bracket functions section 
note children labeled terminal eliminated appear syntax tree 
describes simple drawing language 
drawing program consists sequence zero commands 
commands moving pen position plane drawing line current position new position 
position denoted pair numbers 
derived regular grammar sdf de nition 
line move derived bnf grammar line move derived signature sorts char nat coord program functions char char declarations constants characters 
nat char nat nat nat coord line coord move coord empty program program empty program signature introduced new names functions signature name generation rules previously 
note certain freedom exists choice names generated 
instance names move move generated function corresponding move command 
lines illustrate name empty functions syntax 
note numeric post xes name function unique 
derived bnf grammar mapping parse trees syntax trees de ned parse trees corresponding syntax trees drawing language programs line line move line shown figures 
line char nat char nat line empty empty parse tree corresponding syntax tree 
quoted literals occurring de nition contextfree functions 
abbreviation quotes may omitted literal begins lower case letter consists letters digits 
avoid confusion literals sorts require sort names upper case letter 
line instance abbreviated 
line coord coord 
convention examples see appendix 
repetition context free syntax explicitly de nes drawing program recursively de ned sequence commands 
resulting syntax trees encode list structure means xed arity list constructor empty example 
problems approach sdf de nition express repetitive nature syntax clear way 
resulting syntax trees deeply nested bias left right depending form sdf de nition 
attempting de ne lists separators style poor readability resulting de nition apparent 
sdf supports list constructs separately 
forms line move line line move line empty empty empty empty parse tree corresponding syntax tree 
lists separators form indicating respectively zero repetitions sort lists separators form fs sepg indicating respectively zero repetitions sort separated literal sep lists may left hand side function de nition may appear result function 
manual frequently write fs sepg denote list constructs sep may empty string 
case lists separators treated special case sep equal empty string 
ect list constructs derived grammar signature follows 
list construct form fs sepg appears function declaration de ne non terminal name add rule occurrence list construct sdf de nition translated corresponding list construct grammar list form fs sepg translated sepg may wonder seemingly complex translation scheme 
simpler method map list constructs directly corresponding construct 
sorts nat coord program 
lexical syntax 
nat 
layout 
context free syntax 
nat nat coord 
line coord 
move coord 
program list operation de nition drawing language 
de nition derived signature ected 
function definitions occurrences list constructs form fs sepg translated corresponding lists element sort signature fs sepg mapping parse trees syntax trees extended follows 
parse tree root labeled fs sepg cases sep empty children root sep empty root children odd numbered children children corresponding list elements separators 
result transforming syntax tree root labeled fs sepg transformed versions children 
nodes parse tree labeled removed appear syntax tree 
ects list constructs summarized rules chapter 
list constructs de nition drawing language shown 
lines replaced single line 
derived regular grammar ected modi cation 
derived bnf grammar line move derived signature grammar fs sepg function de nition mapped fs sepg derived grammar 
chapter see simple method extended case sdf de nition contains de nitions variables 
line move line line move line empty parse tree syntax tree containing operator 
sorts char nat coord program functions char char declarations constants characters 
nat char nat nat nat coord line coord move coord empty program shows parse tree corresponding syntax sentence 
note list construct represented node variable number children 
list constructor separator illustrated 
example shows simple form variable declarations pascal language 
declaration consists keyword decl identi ers separated commas followed colon type 
derived regular grammar 
decl integer real derived bnf grammar 
sorts id decl type 
lexical syntax 
id 
layout 
context free syntax 
decl id type decl 
integer type 
real type declarations 
decl integer real derived signature sorts char id decl type functions declarations constants characters 
id char id decl id type decl integer type real type shows parse tree corresponding syntax tree sentence decl ab xyz real 
chain bracket functions syntax trees form concise way representing structure sentences 
abbreviations possible eliminating certain classes nodes tree 
sdf de nes abbreviations chain bracket functions 
chain function de nition forms 

fs sepg small big previously de ned sorts sep literal 
chain function establishes inclusion relation sorts 
function declarations lead rules decl real char id char id char id real decl parse tree corresponding syntax tree 
sepg derived bnf grammar function declarations empty empty fs sepg derived signature 
rules syntax tree formation earlier tree sort fs sepg occur directly position tree sort required embedded application function empty 
nodes corresponding chain functions undesirable reasons syntax tree syntax directed editor nodes may visited walk tree 
syntax associated chain functions textual distinction visit node visit parent child 
semantic rules associated syntax trees extra rules needed processing chain functions general concrete form rules ambiguous 
sdf nodes corresponding chain functions eliminated syntax trees way derived signature subsort declarations ordinary function declarations generated chain function 
mapping parse tree syntax tree result transforming parse tree root node corresponds chain function de ned result transforming single child root resulting tree correct due subsort declaration generated previous step 
leads rules chapter 
sequel convenient parent child relationship parse trees disregards nodes corresponding chain rules 
child child double quotes mean immediate child child reached chain rules 
bracket function de nition form 
open close open close arbitrary non empty literals acting opening closing brackets sort typical examples parentheses arithmetic expressions delimiters programs 
application standard de nitions leads appearance additional nodes syntax tree corresponding bracket functions 
cases brackets introduced grouping disambiguation see chapter meaning 
sdf provides facility declaring certain function bracketing attaching attribute bracket 
precisely declaring function 
open close ect achieved derived signature function declaration generated functions attribute bracket 
mapping parse tree syntax tree result transforming parse tree root corresponds bracket function de ned result transforming second child root child labeled non terminal 
resulting tree correct argument result sorts bracket function equal 
leads rules chapter 
brackets necessary priority associativity functions see chapter require suitable bracket functions declared argument result sorts functions occurring priority declarations group associativity declarations functions having attributes left right assoc non assoc 
way guarantee tree derived signature corresponding string representation abs ftg cf 

illustrates concepts chain functions bracket functions 
simple programming language de ned identi ers natural numbers lexical sorts language constructs combined programs 
function line de nes brackets lists statements 
function line chain function fstat series 
functions lines chain functions convert identi ers numbers expressions 
derived regular grammar 

program fi od derived bnf grammar program fi od derived signature sorts char id nat program series stat exp subsorts stat id nat functions declarations constants characters 

sorts id nat program stat series exp 
lexical syntax 
id 
nat 
layout 
context free syntax 
program series program 
series series bracket 
stat series 
id exp stat 
exp series series fi stat 
exp series od stat 
id exp 
nat exp simple programming language 
id char id nat char nat program series program id exp stat exp series series stat exp series stat injections written explicit naming functions syntax recall section names functions derived signature derived automatically sdf de nition 
ne writing self contained sdf de nitions dicult external tools access syntax trees generated sdf implementation 
sdf provides mechanism control names derived signature 
name rule explicitly write function name followed colon context free function declaration plus exp exp exp list constructs names generated form list element sort sep keyword replacing iterated separator 
instance rule list expressions separated semi colon exp exp program fi char id char id char nat fstat char id char nat fstat char id char id fstat program program corresponding syntax tree 

sorts 
lexical syntax 

layout 
context free syntax 


bracket ambiguous de nition simple arithmetic expressions generates name list may 
automatically generated name may overruled inserting name preceded colon iterator exp exp exp user de ned function name may declared 
priorities motivation derived bnf grammar sdf de nition may ambiguous 
consequence may sentences language de ned derived grammar parse tree syntax tree 
consider sdf de nition arithmetic expressions addition multiplication 
ambiguous sentence language instance parses 
associated trees shown 
ambiguity example clearly caused lack de nition priority sentences associativity operators 
parse tree rejected usual higher priority 
trees sentence shown 
instructive compare identical syntax trees figures 
rejected corresponding parse tree contains priority con ict acceptable 
shows parse trees syntax trees disambiguation 
general methods remove ambiguities contextfree grammar 
rst method introduce new non terminals encoding priority associativity operator symbols grammar 
new nonterminals prevent certain derivations possible original grammar ambiguous 
method disadvantage de nition priorities implicit additional measures necessary prevent new non terminals ecting syntax 
char char char char char char parse trees corresponding syntax trees 
char char char parse tree syntax tree 
second method add explicit de nitions priority associativity grammar 
method adopted sdf 
priority associativity sdf provides mechanisms de nition priority associativity functions context free syntax rules derived bnf grammar relative priorities functions associativity functions associativity groups functions 
relative priority functions established declarations form complete function declarations 
notice assign absolute priority levels functions establish priority relative ones 
transitive closure priority declarations sdf de nition strict non re exive partial order set context free functions obtainable 
functions higher priority bind strongly corresponding nodes parse tree appear lower levels tree nodes corresponding functions lower priorities 
chain bracket functions may appear priority declarations 
priorities declared separate section context free syntax 
lists function declarations serve abbreviation fg hg abbreviation associativity attributes attached binary functions form op op literal empty 
associativity attributes nested occurrences functions immediately lead ambiguities shown sentence string op string op string string sentence sort particular associativity associated op determines intended parse sentences 
node corresponding function rst child disregarding intermediate chain function nodes corresponding function call occurrences related associativity attributes de ne accept reject parse trees containing related occurrences single function 
associativity attributes attached function left related occurrences associate left right right related occurrences associate right left assoc related occurrences associate left right non assoc related occurrences allowed 
syntactic point view di erence left assoc 
attribute assoc sdf de nition translated assoc attribute derived signature see rule chapter 
assoc semantic consequences 
group associativity attributes de ne accept reject parse trees containing related occurrences di erent functions priority 
group associativity de ned pre xing list function declarations priority declaration attributes left related occurrences associate left right right related occurrences associate right left non assoc related occurrences allowed di erent functions appearing list 
simplest application priority associativity declarations elimination parse trees contain con icts parent child lower priority parent parent rst child con ict associativity parent child 
examples illustrate priority associativity 
way making example unambiguous shown 
choices de nition 
sorts 
lexical syntax 

layout 
context free syntax 
left 
left 
bracket 
priorities 
unambiguous version example 
sorts 
lexical syntax 

layout 
context free syntax 
left 
non assoc 
left 
non assoc 
right 
bracket 
priorities 

non assoc 
left elaborate arithmetic expressions 
higher priority 
interpretation 
left associative 
interpretation 
left associative 
elaborate version arithmetic expressions 
operators expressions properties highest priority associates right left 
priority ordering left associative nonassociative form non associative group 

sorts id stat 
lexical syntax 
id 
layout 
context free syntax 
id stat stat 
id stat stat stat 
stat stat 
stat stat bracket 
priorities 
id stat stat stat id stat stat solution dangling problem 
lowest priority left associative non associative form left associative group 
leads association parses sentences sentence parse solution classical dangling problem shown 
priority declaration selects parses parts associated nearest possible preceding part 
sentence stat stat parsed stat stat 
examples figures illustrate de nition priority associativity reject certain parse trees sentence 
sdf de nitions form disambiguation sucient generate sentences con ict free parse tree 
cases set remaining parse trees reduced 
solution extend priority ordering functions priority ordering parse trees reject parse tree parse tree higher priority 
relation holds parse trees injections equal contains nodes corresponding contains nodes corresponding function 
covers cases nodes corresponding nodes corresponding 
ordering variant called multiset ordering dm jl 
parse trees sentence selected phases 
parse trees containing con icts removed 
parse trees removed smaller remaining parse tree 
note rst phase may invalidate sentence blocking parse trees second phase selects parse tree sentence passes rst selection phase passes second 
total selection process illustrated 
illustrate approach example arithmetic expressions operators de ned natural real numbers 
example sorts stand respectively natural real numbers 
sorts operators de ned 
chain function embedding ambiguities may arise example choose operator de ned conversion operator de ned directly 
priorities de ned higher priority higher priority higher priority irrespective sort involved usual 
priorities select parses ordinary priority preference functions shows possible parse trees sentence 
priorities example applied follows 
tree contains con ict node corresponding child node corresponding trees con ict free 
comparing trees sees holds 
function occurs occurs 
compensated fact lower priority appears 
tree parse tree associated sentence 
nal example show interaction general context free functions special case functions described means priorities 
example originates concerns expressions describing subscripts superscripts typesetting language eqn 
crucial point typesetting reasons want treat subscript followed superscript special way 
special case sub sup introduced line priority combination functions de ning sub sup lines 
parse trees parse sentence select parse trees con icts select largest parse trees select selected parse trees selection parse trees sentence 

sorts 
lexical syntax 



layout 
context free syntax 
left 
left 

left 
left 
priorities 

arithmetic expressions natural real numbers 
parse trees 

sorts 
context free syntax 
sub left 
sup left 
sub sup 
bracket 

priorities 
sub sup 
left sub sup expressions subscripts superscripts 
sub sup sub sup sub sup parse trees sub sup shows parse trees sentence sub sup parse tree rejected contains con ict caused left group associativity 
remaining trees selected larger multiset ordering 
variables sdf de nitions motivation lexical context free syntax sections sdf de nition completely de ne input sentences legal mapped syntax trees 
input sentences constant completely xed systematic way extend modify 
cases need arises incomplete parameterized input sentences 
important cases associates semantic rules sdf functions see chapter necessary variables rules 
instance de ning rules multiplication natural numbers needs rules form variables sort natural numbers 
syntax directed editing program text construction incomplete 
text contains holes lled strings certain type 
desirable able determine syntactic correctness incomplete programs 
handle cases sdf allows de nition variables de nition variables variables declared fth section sdf de nition 
variables section consists list declarations variables sort 
declaration de nes naming scheme variables may declare unlimited number variables 
naming scheme arbitrary regular expression ones allowed lexical function declaration allow sorts 
sort variable basic sort may contained list construct separators 
rst describe ect variables derived bnf grammar derived signature mapping parse trees syntax trees 
discuss treatment variables prede ned sort char 
variables lead additional rules derived regular grammar derived bnf grammar 
variable declaration form naming scheme rule 
sorts id decl type 
lexical syntax 
id 
layout 
context free syntax 
decl id type decl 
integer type 
real type 
variables 
id id 
type type 
ids id 
ids id declarations extended variables 
naming scheme added derived regular grammar 
note may basic sort list sort 
cases 
declaration form naming scheme basic sort add rule derived bnf grammar 
declaration form naming scheme fs sepg rule sepg var added derived bnf grammar 
principle lists declared fs sepg may contain variables type fs sepg fs sepg elements 
subtle point arises list declared fs sepg contains variables type fs sepg 
case list may empty substitution clearly incorrect view type original list 
impose restriction variable type fs sepg may occur list type fs sepg list contains element type fs sepg 
restriction encoded derived bnf grammar forms additional constraint 
mapping parse trees syntax trees variables mapped corresponding variables derived signature 
variable declaration form naming scheme decl id ids var type parse tree decl id ids type id id char id ids type type decl syntax tree decl id ids type 
lead variables named name name name name strings matched regular expression naming scheme 
leads rules chapter 
recall variables implicitly de ned signature see section 
recall section prefer variables rule gives precedence variables literals context free syntax tokens de ned lexical syntax 
added variables declaration language introduced earlier 
derived regular grammar 
decl integer real id type ids ids derived bnf grammar decl integer real derived signature sorts char id decl type functions declarations constants characters 
id char id decl id type decl integer type real type figures show parse tree corresponding syntax tree sentence decl id ids type contains occurrences variables id ids type 
note variables lexical items structure syntax tree 
turn attention special case variables prede ned sort char 
apart standard treatment variables additional steps necessary 
sorts id decl type 
lexical syntax 
id 
layout 
context free syntax 
decl id type decl 
integer type 
real type 
variables 
id id 
type type 
ids id 
ids id 
char char 
chars char declarations extended variables sort char add derived regular grammar symbol associate regular expression enumerates characters alphabet 
add derived bnf grammar non terminal rules lexical sort add rule form de nes concrete representation lexical constructor function associated leads rules chapter 
ect adding variables prede ned sort char shown 
di erence previous example addition variables char chars 
derived regular grammar 
decl integer real id type ids ids 


char chars derived bnf grammar id decl integer real derived signature sorts char id decl type functions declarations constants characters 
id char id decl id type decl integer type real type figures show parse tree corresponding syntax tree sentence decl ab id char chars type 
substitution variables possible de ne notion string substitution variables concrete sentences directly related variable substitution corresponding syntax trees de ned section 
string containing marked occurrence variable sort string sort want de ne syntactically correct string marked occurrence replaced way abs abs abs abs set syntax trees cf 
variable sort corresponds derived signature operator right hand side substitution operator syntax decl id char chars type parse tree decl ab id char chars type trees de ned section 
requirement meaningful assume single syntax tree 
syntax trees involved unique operator strings simple syntax trees reasons ensure abs distributes require necessary enclose brackets actual string substitution performed 
list variable occurring list non empty separators empty string substitution may require removal list separators adjacent necessary insert layout symbol substituted string avoid di erences lexical interpretation string substitution 
discuss rst points detail assume third point resolved 
call string substitution improper char id char char char chars char id ids type type decl syntax tree decl ab id char chars type syntax tree obtained tree substitution equal tree obtained performing string substitution resulting string words abs abs abs 
rst de ne prot protected version substitution 
cases substitution improper de ne prot string open close open close arbitrary bracket function sort function exists cf 
section 
prot de ne string obtained replacing substring prot de ned follows variable sort fs sepg sep empty appears element list empty list distinguish cases element list marked occurrence element list marked occurrence separator sep preceding layout marked occurrence separator sep layout 
cases marked occurrence give examples 
continuing example giving decl ids id type corresponding syntax tree ids corresponding tree value string substitution ids decl id type corresponding syntax tree fid ids 
second example decl ids id type corresponding tree ids corresponding tree value string substitution ids decl id type corresponding syntax tree fid ids 
note elimination separator ids 
consider arithmetic expressions de ned 
add declaration 
variables 
exp variable exp 
look exp corresponding tree exp corresponding tree value exp syntax tree exp 
look exp corresponding tree exp corresponding tree case brackets inserted function root lower priority function parent node exp 
value exp 
clearly incorrect value exp exp syntax tree 
nal example illustrate ect second phase application multiset ordering selection parse trees priority declarations 
consider example adding declaration 
variables 
exp variable exp 
look sub exp corresponding tree exp sup corresponding tree block higher priority improper parse sub sup function brackets inserted value exp sub fa sup ag syntax tree exp 
discussion problems solved satisfactorily de nition variables 
naive implementation substitution string substitution determine substitution proper 
expect sucient conditions determine implementation conditions correctly eciently implement substitution 
implementation course insert minimal number brackets 
second comments order regarding uniform treatment variables holes known meta variables 
clearly sdf variables allow general description holes xing particular syntax 
implementation syntax directed editor considerably simpli ed certain assumptions syntax holes 
take point view syntax directed editor may automatically extend sdf de nition standard declarations variables sort 
current implementation generic syntax directed editor see chapter declared sort variable declaration form generated 
variables variables editing may 
summary sdf deriving grammars signature parse tree mapping give nal version de nitions derived regular grammar derived bnf grammar derived signature mapping parse trees syntax trees 
derived regular grammar derived regular grammar obtained follows sort including prede ned sorts layout ignore reject appears result sort lexical function introduce lexical non terminal associate regular expression consisting left hand sides translated rules lexical function declarations sort replace sort names appearing left hand sides corresponding lexical non terminals de ned 
variables section contains declarations variables prede ned sort char introduce reserved lexical non terminal associate regular expression enumerates characters alphabet 
negated character classes replaced characters class 
repetitions mapped corresponding repetition operators regular grammar 
literal symbol occurring function de nition context free syntax added alternative reserved lexical non terminal variable declaration form naming scheme naming scheme regular expression may simple sort list sort add regular expression form naming scheme derived regular grammar 
derived bnf grammar de nition frequently say non terminal rule added derived grammar 
cases mean nonterminal rule added de ned derived grammar derived bnf grammar obtained follows introduce non terminal sort terminals literal symbols appearing context free function declarations lexical non terminals derived regular grammar sort appears result sort lexical function add rule form lexical non terminal introduced terminal 
list construct form fs sepg appearing context free function declaration variable declaration introduce non terminal add rule form context free function declaration add rules obtained exchanging left hand side right hand side function declaration 
translate occurrence sort corresponding non terminal introduced translate occurrence list construct function declaration corresponding list construct grammar list form fs sepg translated sepg non terminal introduced 
variable declaration distinguish cases 
declaration form naming scheme basic sort add rule lexical non terminal derived regular grammar 

declaration form naming scheme fs sepg add rule sepg var sepg var lexical non terminal derived regular grammar 
variables section contains declarations prede ned sort char 
add rules lexical non terminal introduced terminal symbol 

sort ignore appears result sort lexical function add rule form 
rule de nes concrete representation lexical constructor function associated see 
derived signature derived signature form declaration prede ned sort char 
declarations sorts declared sdf de nition 
subsort declarations chain functions context free syntax 
declarations constants sort char characters alphabet 
declarations lexical constructor functions form char sort appears result sort lexical function name written lower case letters 
function declarations function declared context free syntax chain functions functions bracket attribute function unique new name generated manner prescribed sdf types arguments result obtained sort names appearing original function de nition 
list constructs form fs sepg translated corresponding lists signature fs sepg attribute assoc attached original function declaration inherited function declaration derived signature 
recall variables implicitly de ned signature section explicit translation variables section sdf de nition derived signature see section 
mapping parse trees syntax trees mapping parse trees syntax trees de ned follows 
parse tree root labeled non terminal single child root labeled lexical non terminal literal result transforming syntax tree root labeled lexical constructor function sort single child result transforming rule 
root labeled lexical token literal children form list characters 
transformed syntax tree root labeled char characters list children 
root labeled fs sepg cases 
sep empty children root 
sep empty root children odd numbered children children corresponding list elements separators 
list syntax trees obtained recursively transforming trees result transforming tree root labeled fs sepg elements children 
root labeled non terminal corresponds chain function result transforming transformation single child root 
root labeled non terminal corresponds function bracket attribute result transforming transformation second child root child labeled non terminal 
root labeled lexical token list consisting characters single child 
transformed corresponding variable derived signature 
root labeled result transforming transformation single child 
root labeled non terminal transformed follows 
children root labeled non terminal transformed recursively 
gives possibly empty list syntax trees 

root children correspond application rule derived bnf grammar function derived signature 
transformed syntax tree root labeled elements children 
static constraints sdf de nitions constraints sdf de nitions listed ease mentioned preceding chapters 
sorts multiple declarations sorts forbidden 
names layout ignore reject char prede ned sort declaration 
sorts layout ignore reject may occur result sort lexical function 
sort char may result sort variable declarations 
sort names lexical context free functions variable declarations declared 
sort occur result sort lexical context free function declaration 
lexical syntax multiple declarations lexical functions forbidden 
sorts lexical function declarations declared 
sort occurring left hand side lexical function declaration occur result sort lexical function declaration 
cyclic dependency may exist lexical function declarations 
result sort layout ignore reject occur left hand side lexical context free function declaration 
character classes satisfy restrictions section 
context free syntax multiple declarations context free functions forbidden di erent attributes 
sorts context free function declarations declared 
sort occurring left hand side context free function declaration occur result sort lexical context free function declaration 
cyclic dependency may exist chain functions 
attribute bracket allowed functions form open close see section 
associativity attributes left right assoc non assoc allowed binary functions form op see section 
suitable bracket function declared argument result sorts context free functions associativity attribute occur priority group associativity declarations 
priorities functions occurring priority declaration declared context free syntax 
group associativity attributes left right non assoc allowed binary functions form op see section 
chain bracket functions allowed priority declarations 
cyclic dependency may exist context free functions due priority declarations 
variables result sorts char occurring variable declarations declared 
result sorts char occurring variable declarations occur result sort context free syntax 
attaching semantics sdf de nitions having completed de nition sdf disposal powerful method transforming concrete strings sets terms 
sucient generate syntax directed editor sdf definition explained couple semantics means syntax tree matching section show sdf combined algebraic semantics 
section introduce modularity constructs 
cases asf bhk chapter semantic speci cation formalism 
attaching algebraic semantics sdf simplest form module algebraic speci cation formalism asf consists signature declaring sorts functions set conditional equations signature 
functions declared module xed syntax 
combine asf sdf obtaining asf sdf manner replace signature asf module sdf de nition de nes derived signature concrete notation functions signature replace equations written form equations written concrete form see 
result formalism completely user de nable syntax 
simplest form asf equation described grammar rule label identifying equation de nes wellformed terms pre form terms appearing equation sort 
example asf equation true false true 
key idea replace terms de nition equations concrete counterpart de ned sdf de nition 
speci cation spec achieved parameterized grammar rule spec equations spec 
sn sorts declared sdf part speci cation spec non terminals corresponding sorts derived bnf grammar 
concrete equation lists subsorts associative functions taken care matching process 

sorts bool sdf definition 
lexical syntax 
layout 
context free syntax 
true bool 
false bool 
bool bool bool assoc 
bool bool bool assoc 
bool bool 
bool bool bracket 
priorities 
bool bool bool bool bool bool bool bool 
variables 
bool 
equations semantic rules 
true true true 
true false false 
false true false 
false false false 
true true 
false 

true false 
false true booleans speci cation boolean data type 

sorts id pair table sdf definition 
lexical syntax 
id 
layout 
context free syntax 
id id pair 
empty table table 
pair table table 
lookup id table id 
variables 
id id 
table 
equations semantic rules 
lookup id id id id 
id id lookup id id id lookup id tables speci cation table data type 
strings transformed equation abs abs provided syntactically correct strings unambiguous alternatively impose weaker condition sets syntax trees contain single tree sort 
mapping carried conditional equations speci cation 
grammar parsing equation speci cation spec consists instance parameterized rule spec derived grammar sdf part spec example illustrate method 
derived regular grammar true false derived bnf grammar true false derived signature sorts bool functions true bool false bool bool bool bool bool bool bool bool bool instantiation booleans example booleans ingredients obvious equations concrete form mapped equations form 
equations instance mapped true false false bool true true conclude section examples 
shows de nition table data type 
illustrates conditional equation line 
shows de nition identi ers length function de ned 
character variables combination implicitly generated lexical function id shows de nition natural numbers decimal representation 
illustrates things list variables 
binding sdf modular speci cation formalism explained asf sdf combined level single module relatively straightforward cover modularization constructs asf 
operations considered 
sorts id nat sdf definition 
lexical syntax 
id 
layout 
context free syntax 
nat 
succ nat nat 
length id nat 
variables 
char char 
chars char 
equations semantic rules 
length id char succ 
length id chars char succ length id chars identifiers speci cation identi ers length function 
export hiding sorts functions import module module renaming sorts functions module parameterized modules 
asf meaning operations de ned means normalization procedure textual expansion procedure eliminates modular structure speci cation yields single unstructured speci cation consisting signature equations 
large method applied combination asf sdf 
examples asf sdf speci cations bhk hen 
notes implementation sdf sdf implemented part asf sdf meta environment described kli 
contains generic syntax directed editor log dk koo mentioned earlier section 
sdf implementation written uses isg incremental scanner generator generate lexical scanners lexical syntax sdf de nition ipg incremental parser generator generate parsers context free syntax sdf de nition 
generators lazy incremental parts scanner parser generated needed modi cations lexical context free syntax propagated generated scanner parser avoiding complete regeneration 
underlying principles described 
distinctive feature isg ipg allow ambiguities 
isg may produce interpretation lexeme ipg handle arbitrary context free grammars may produce syntax tree input string 
discussion basic assumptions brie recall main assumptions choices underlying design sdf implementation sdf impose restrictions class acceptable grammars 
major advantages necessary rewrite grammar particular subclass context free grammars composition grammars possible 
means context free syntax bear close resemblance 
consequence little need explicit syntax tree construction rules see point 
side picture grammars may ambiguous 
xed mapping parse trees syntax trees 
advantages choice twofold writer speci cation give separate de nition tree construction process user speci cation sees trees correspond grammar rules completely predictable way 
clearly degree freedom lost 
associating non standard trees grammar rule achieved case computing means semantic rules 
lexical entities represented strings characters trees 
representation attractive theoretical point view opted reasons eciency sdf implementation 
omissions features included sdf way expressing formats functions 
main reason omission adding information sdf function de nitions harder read 
editors generated nitions editor generator mentioned previous chapter maintain original text representation corresponding syntax tree 

sorts digit nat nat list sdf definition 
lexical syntax 
digit 
digit nat 
context free syntax 
nat nat nat left 
nat nat nat left 
nat nat list 
move digit nat list nat list 
priorities 
nat nat nat nat nat nat 
variables 
nat 
nats nat 
char 
char 
char 
equations semantic rules 
move nats nats 
move nats nats 
move nats nats 
move nats nats 
move nats nats 
move nats nats 
move nats nats 
move nats nats 
move nats nats 
move nats nats 
nat nat 
move digit nats move digit nats nats nat nat 
nat nat nat nat nat nat nat nat nat nat 










nat nat nat nat nat nat nat nat naturals speci cation decimal natural numbers 
notion optional constructs context free functions 
alternative operator 
repetitions lexical syntax context free syntax restricted xed number repetitions 
expressed means semantic rules 
limitations lexical syntax prefer literals rule section gives precedence literals contextfree syntax lexical tokens 
consequence sentence accepted legal statement example tokens recognized literals identi ers 
satisfactory way circumvent limitation shown keywords added explicitly alternatives sort id context free syntax 
de nition disadvantage identi ers de ned function lexical syntax keywords de ned constants context free syntax represented di erently syntax 
di erence manifest string matching attempted identi er happens equal literal 
alternatives solving problem forbid constants context free syntax 
add exceptions de nition derived signature mapping parse trees syntax trees way constants de ned context free syntax lexical functions represented uniform way 
add mechanism de activate prefer literals rule 
research needed determine best approach problem 
general limitation de nition lexical syntax sdf actions updating counters consulting symbol tables performed token recognized 
result aspects lexical syntax dicult express sdf nesting comments instance indentation indicating block structure instance abc occam 
apart default solution form attaching extra semantic rules sdf de nition see really elegant solution class problems 

sorts id exp stat 
lexical syntax 
id 
layout 
context free syntax 
exp stat stat 
exp stat stat 
id exp stat 
exp exp exp 
id exp simple language 

sorts id exp stat 
lexical syntax 
id 
layout 
context free syntax 
id 
id 
id 
id 
exp stat stat 
exp stat stat 
id exp stat 
exp exp exp 
id exp language overlapping keywords identi ers 
related attempts introduce user de nable syntax programming languages 
ideas led user de nable syntax operators algol prolog snobol programming languages various styles macro de nitions pl lisp 
interest called extensible languages 
aim line research de ne small base language combination syntax de nition formalism 
new language constructs added base language de ning syntax describing semantics terms base language 
various reasons goal full syntactic semantic language extensibility completely achieved 
syntactic extension mechanism smalltalk may viewed successful extensible language existence 
smalltalk predecessor smalltalk support syntactic extensibility class parse messages send explicitly 
feature replaced limited scheme keyword parameters smalltalk 
new scheme result readable programs allows ecient implementation 
successful method de ning syntax language constructs means syntax directed translations asu 
lex yacc metal discussed fall category 
system san combines syntax directed translations classes 
apart fact lexical syntax xed user de nable lr syntax 
donnell notational speci cations constitute alternative syntax directed translations 
closely related user de nable dist operators obj voi 
features characterize syntax de nition formalisms class acceptable grammars 
integration description lexical context free syntax 
class context free syntax syntax pairs described 
integration description context free syntax syntax 
treatment variables 
restrict representative examples lex ls yacc joh metal speci cation language mentor system ssl speci cation language synthesizer generator rep rt speci cation language psg system bs 
hk compared sdf lex yacc metal studying examples formalisms 
syntax de nitions lex yacc metal ssl restricted lalr grammars psg ll grammars sdf de nitions allow arbitrary context free grammars 
lex yacc explicit token names communication lexical context free syntax 
similar method metal ssl psg 
sdf better integration lexical context free syntax 
token names instance generated automatically 
lex yacc allow greatest freedom creation syntax trees arbitrary data structures 
metal syntax described means signature notation 
rule context free grammar tree construction rule associated de nes syntax tree constructed strings accepted grammar rule 
allows construction arbitrary trees provided conform signature 
ssl construction syntax trees described separate attribute grammar 
respect ssl expressive power metal 
psg syntax de ned collection class constructor rules resembling signatures concrete syntax de ned string tree transformation grammar de nes syntax tree associated string 
particular name constructor syntax associated context free grammar rule limits set trees constructed grammar rule 
sdf xed correspondence rules context free syntax rules syntax 
impossible associate arbitrary tree strings accepted syntax rule 
metal ssl psg built notations variables called metavariables placeholders holes 
sdf standard convention allows de nition naming schemes variables 
developments problems remain solved treatment ambiguities needs research desirable sucient overly restrictive condition sdf de nitions guarantees de ne non ambiguous language type information resolve ambiguities studied 
combination sdf formalisms des kah prolog rst order logic studied 
problems involved signature term translations necessary map derived signature sdf de nitions terms signatures terms exist target speci cation formalism modeling relations sdf provides de nitions functions 
hans van dijk suggested retain parse trees priority con icts instance parse trees minimal number con icts 
wiedijk commented earlier version manual 
sdf de nition pascal appendix written karin vos 
aho johnson ullman 
deterministic parsing ambiguous grammars 
communications acm 
asu aho sethi ullman 
compilers 
principles techniques tools 
addison wesley 
bhk bergstra heering klint editors 
algebraic speci cation 
acm press frontier series 
acm press operation addison wesley 
bs snelting 
psg system formal language de nitions interactive programming environments 
acm transactions programming languages systems 
des despeyroux 
executable speci cation static semantics 
kahn macqueen plotkin editors semantics data types volume lecture notes computer science pages 
springer verlag 
dk van dijk 
generic syntax directed editor 
report cs centrum voor wiskunde en informatica cwi amsterdam 
dm dershowitz manna 
proving termination multiset orderings 
communications acm 
futatsugi goguen 
jouannaud meseguer 
principles obj 
reid editor conference record twelfth annual acm symposium principles programming languages pages 
acm 
hen hendriks 
implementation modular algebraic speci cations 
phd thesis university amsterdam 
heering hendriks klint rekers 
syntax de nition formalism sdf manual 
sigplan notices 
hk heering klint 
pico revisited 
bergstra heering klint editors algebraic speci cation acm press frontier series pages 
acm press operation addison wesley 
chapter 
heering kahn klint lang 
generation interactive programming environments 
esprit status report continuing pages 
north holland 
part heering klint rekers 
incremental generation lexical scanners 
report cs centrum voor wiskunde en informatica cwi amsterdam 
appear acm transactions programming languages systems 
heering klint rekers 
incremental generation parsers 
sigplan notices 
heering klint rekers 
lazy incremental program generation 
report cs centrum voor wiskunde en informatica cwi amsterdam 
appear acm transactions programming languages systems 
jl 
jouannaud lescanne 
multiset orderings 
information processing letters 
joh johnson 
yacc compiler compiler 
bell laboratories 
unix programmer supplementary documents volume ps 
kah kahn 
natural semantics 
brandenburg wirsing editors fourth annual symposium theoretical aspects computer science volume lecture notes computer science pages 
springer verlag 
kli klint 
meta environment generating programming environments 
bergstra editors proceedings meteor workshop methods formal speci cation volume lecture notes computer science pages 
springer verlag 
kahn lang el ese 
metal formalism specify formalisms 
science computer programming 
koo 
generic text structure editor 
report university amsterdam 
log logger 
integrated text syntax directed editor 
report cs centrum voor wiskunde en informatica cwi amsterdam 
ls lesk schmidt 
lex lexical analyzer generator 
bell laboratories unix programmer supplementary documents volume ps edition 
van der meulen 
algebraic speci cation compiler language pointers 
report cs centrum voor wiskunde en informatica cwi amsterdam 
donnell 
equational logic programming language 
technical report mit press 
rep reps generating language environments 
technical report tr cornell university ithaca 
ph thesis 
rt reps teitelbaum 
synthesizer generator system constructing language editors 
springer verlag 
san sandberg 
language combining exible syntax classes 
conference record ninth annual acm symposium principles programming languages pages 
acm 
voi 
tool interactive grammar construction expression parsing 
science computer programming 
sdf sdf sorts id iterator char char charclass literal module section attributes variable lexical syntax id za za id iterator char char char char char charclass char char char literal literal za za literal layout layout layout context free syntax module id section module module id module imports id section exports section hiddens section sorts id lexical syntax context free syntax priorities variables variable id layout ignore reject id literal charclass charclass iterator id attributes literal id attributes id literal id iterator id literal iterator empty attributes literal attributes literal empty literal empty literal literal id literal literal id variable id id iterator id literal iterator char char iterator de nition gives syntax sdf currently implemented asf sdf meta environment contains module headers sections de ning imports exports hiddens 
observe module header required stand sdf implementations writing asf sdf modules 
words sdf part asf sdf modules form section 
compared previous versions sdf attributes left right longer appear explicit literals de nition represented sort literal 
done easier add new attributes 
addition non empty list attributes enclosed berkeley pascal sdf sorts id base number program block decl typedecl pars par const type simpletype filetype field variant var statement assignment expr lexical syntax layout layout layout include layout za za id oct base hex base bb ee ee number number number context free syntax decl block program decl program program id id statement block label decl const decl id const const id const number const number const number const type typedecl decl id type typedecl simpletype type id type filetype type type packed type id simpletype id simpletype const 
const simpletype file filetype simpletype id packed array simpletype type set simpletype record field id type field empty field case id variant case id id variant empty const variant empty variant var decl id type decl procedure id pars decl block forward external id external decl function id pars type decl block forward external id external par pars empty pars id id par var id id par procedure id pars par function id pars id par id var var id expr expr id id id id var expr assignment assignment statement statement statement expr statement statement expr statement statement statement expr statement statement repeat statement expr statement assignment expr statement statement assignment downto expr statement statement case expr statement var statement statement id statement id statement statement statement goto statement empty statement const statement empty number expr nil expr expr var expr id expr expr expr expr expr expr expr expr expr expr expr expr expr left expr expr expr left expr expr expr left expr expr expr left expr expr expr left expr expr expr left expr expr expr left expr div expr expr left expr mod expr expr left expr expr expr left expr expr expr non assoc expr expr expr non assoc expr expr non assoc expr expr expr non assoc expr expr non assoc expr expr expr non assoc expr expr expr non assoc expr expr bracket expr expr 
expr expr expr expr expr expr expr expr base expr expr base priorities expr expr expr expr expr expr expr expr left expr expr expr expr expr expr expr expr expr expr div expr expr expr mod expr expr expr expr expr left expr expr expr expr expr expr expr expr expr expr expr expr non assoc expr expr expr expr expr expr expr expr expr expr expr expr expr expr expr expr expr expr expr priorities expr statement statement statement expr statement statement note de nition pascal conforms 

