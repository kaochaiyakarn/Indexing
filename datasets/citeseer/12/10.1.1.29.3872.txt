bandera extracting finite state models java source code james corbett university hawai department information computer science honolulu hi corbett hawaii edu matthew dwyer john hatcliff shawn laubach corina pasareanu robby hongjun zheng kansas state university department computing information sciences manhattan ks hatcliff laubach robby cis ksu edu finite state verification techniques model checking shown promise cost effective means finding defects hardware designs 
date application techniques software hindered obstacles 
chief problem constructing finite state model approximates executable behavior software system interest 
current best practice involves models expensive prohibitive smallest systems prone errors result misleading verification results difficult optimize necessary combat exponential complexity verification algorithms 
describe integrated collection program analysis transformation components called bandera enables automatic extraction safe compact finite state models program source code 
bandera takes input java source code generates program model input language existing verification tools bandera maps verifier outputs back original source code 
discuss major components bandera give overview model check correctness properties java programs 
keywords program verification model checking model extraction slicing interpretation program specialization years finite state verification techniques model checking renewed interest formal verification computer systems 
techniques exhaustively check finite state model system violations system requirement formally specified temporal logic ltl 
approach provides level confidence comparable machine checked proof requirement correctness extensive human guidance required theorem provers model property specification constructed verification fully automatic albeit potentially time consuming 
tools supporting techniques matured point hardware manufacturers frequently validate designs 
transfer technology research practice slower software 
reason model construction problem semantic gap artifacts produced software developers accepted current verification tools 
development done general purpose programming languages java ada verification tools accept specification languages designed simplicity semantics process algebras state machines 
order verification tool real program developer extract mathematical model program salient properties specify model input language verification tool 
process error prone time consuming 
obstacle transfer finite state verification technology state explosion problem exponential increase size finite state model number system components grows 
variety methods exist state explosion analyzing certain types systems methods proven sufficient analysis hardware designs tractable 
unfortunately software systems tend state hardware components aggressively abstracted produce tractable models 
efforts attacked problem model checking software ways 
taken monolithic approach building dedicated model checker specific programming language erlang 
built tools java pathfinder translate program directly relatively expressive verifier input language case promela input language spin model checker 
tools useful see number significant limitations approaches 
monolithic approach difficult keep checking engine state art new methods state explosion recoded tool dedicated engine 
translation approach results larger models partly mismatch semantics languages partly translation consider property verified model customized property 
approaches tend lock user single kind checking technology empirical studies shown best analysis method varies program 
tools limited support kinds control data abstraction human analysts build models hand removing irrelevant program features reducing cardinality data types symbolic abstraction 
goal overcome major obstacles finitestate verification software component tool architecture model extraction design criteria ffl reuse existing checking technologies 
model checkers especially widely ones spin smv extremely sophisticated programs crafted years experts specific techniques employed tool 
re implementation algorithms tools yield inferior performance 
ffl automated support abstractions experienced model designers 
important single method extracting tractable models software abstraction 
tool set go simple translation structured optimizing compiler employing complex transformations optimize performance compactness generated code model 
transformations staged improve effectiveness rely static analyses object flow analysis dependency analysis 
transformations commonly employed human analysts supported include slicing interpretation specialization 
ffl specialized models specific properties 
construct single model software system accurate verify relevant properties model customized optimized particular property 
rarely done hand generated models due effort required generating custom model property significantly reduce analysis effort enhance scalability 
ffl open design extensibility 
tool set consist number loosely connected components communicate small set documented intermediate representations allowing new abstraction techniques checking engines added easily 
example back tool set lowlevel intermediate representation easily translated input languages current model checkers 
ffl synergistic integration existing testing debugging techniques 
want tool set complements alongside existing development environments support testing simulation 
supporting environment encapsulate details checking engines allow counterexamples displayed form familiar uniform specific model checker ii leveraged testing debugging simulation 
main contribution description bandera component model extractor java programs designed meet goals 
particular describe major components bandera slicer bandera slicing component compresses paths program removing control points variables data structures irrelevant checking property 
abstraction engine bandera abstraction engine allows user reduce cardinality data sets associated variables 
tool includes language specifying abstractions collected abstraction library reuse 
back back bandera generates bir low level intermediate language guarded commands abstracts common model checker input languages 
back contains translator model checker supported 
user interface bandera advanced graphical user interface facilitates interaction various components displays counterexamples user terms program source debugger 
describe application current implementation bandera handles reasonably large subset java non trivial program 
section give overview process model checking software systems summarize main techniques construct models software 
section describes bandera provides automated support techniques user view bandera followed discussion internal architecture summary functionality bandera component 
section uses small example illustrate model checking java source code bandera 
section discusses related section concludes 
model checking software model checking technique systematically searching possible behaviors system certain kinds errors 
system case java program modeled finite state transition system 
state represents abstraction program state transition represents execution statements transforming state 
second desired property system expressed temporal logic property describes constraint permissible state event sequences finite state model 
third model checking tool algorithmically determines paths finite state transition system satisfy property 
model checker displays path transition system violating property path interpreted behavior system understand error 
checking technique takes worst case exponential time validate crucial properties real software systems 
properties checked include freedom deadlock simple assertions state sequencing properties absence 
success partly due improving methods state explosion model checking algorithms due abstraction 
key applying model checking large software systems clever model checkers clever model builders away details programs leaving essential verify specific property 
experience believe main techniques applied build tractable models verifying property irrelevant component elimination data abstraction component restriction 
irrelevant component elimination program components classes threads variables code may relevant property verified 
example properties testing specific features program selecting certain menu item brings particular dialog independent application code 
ii 
data abstraction eliminating irrelevant components remaining variables relevant recording detail necessary property verified 
range variables safely abstracted smaller set 
example application store set items vector property verified depends particular item vector large number vector states small set 
iii 
component restriction techniques produce tractable models software systems 
methods fail restricted model program usually constructed limiting number components ranges variables bounding number objects created allocator bounding number total execution steps 
restricted models capture behaviors program design errors manifest small versions system useful finding errors 
note semantic gap systems finitestate models wider software hardware may increase need component restriction 
model checkers highly static input languages software written high level languages supporting wide variety dynamic constructs unbounded heap allocation unbounded recursion dynamic creation threads polymorphism 
clever abstractions features defined bounds degree dynamism constructs inferred construct restricted model imposing bounds arbitrarily 
creating challenges model building semantic gap presents additional hurdles diagnosing program errors 
model checker finds violation property analyst interpret model checker violating trace state transition system sequence program statements 
difficult model obtained program nontrivial transformations normally case 
addition program step usually corresponds steps transition system 
bandera primary goals bandera provide automated support model construction error trace interpretation techniques outlined previous section 
specifically bandera uses slicing automate irrelevant component elimination interpretation support data abstraction model generator allows significant flexibility setting bounds various system components 
bandera includes collection data structures automatically mapping model checker error traces back source level facilities graphical navigation traces 
illustrates inputs supplied bandera checking program collection java files requirement internal structure bandera tool set 
user formalizes requirement example temporal logic formula 
aid formalization bandera provides menu driven selection representation intermediate constructor smv trans spin trans sal trans abstraction library supplementary analyses proof obligations compiler ai specification property front counter example heap queue stage run return 
stage run tmp start main main new stage 
extends thread public void run 
public class stage class signs extends int tokens zero pos neg 
pos pos pos connector queue signs sal smv bir jimple java tracer slicer specializer abstraction front java primitive propositions jimple pvs back bir spin abstraction spec restriction specification java source counterexample max stage abstraction binding bandera interfaces internals specification templates existing template library 
user completes specification filling template parameters primitive propositions describe semantic features program user interested reasoning 
currently bandera supports definition propositions define range values object fields defined built types queue propositions capture locations source code stage run return return point run method class stage 
propositions bandera automatically derives slicing criterion slice away program components irrelevant property checked 
user subsequently examine remaining variables fields sliced program decide data components abstracted 
abstractions selected library bound variables user deems particularly compaction contribution system state space 
illustrated possible user add new abstractions signs abstraction specification 
abstraction engine compiles definitions chosen abstractions program simplifies program inlines remaining method calls 
reduced program fed bandera back generates finite state model input language chosen verification tool 
bandera interprets verifier output property fails hold generated model verifier specific counter example mapped back user original source code 
architecture bandera similar optimizing compiler 
compiler multiple intermediate languages stage transformation machine code bandera uses multiple intermediate languages stage transformation java model checker input languages 
bandera front translates java high level intermediate language called jimple bandera back generates model checker inputs low level intermediate language guarded commands called bir bandera intermediate representation just conventional compiler relies sophisticated static analyses transformations produce optimized code bandera relies conventional dataflow control flow dependency analyses slicing specialization transformations supplementary analysis produce compact models 
summarize functionality bandera components intermediate representations 
soot jimple bandera built top soot compiler framework developed sable group university mcgill 
soot framework java programs translated intermediate language jimple intermediate languages supported soot 
developed front called java java compiler maintains tight correspondence java source program jimple representation 
node program jimple representation return corresponding node java syntax tree ast program vice versa 
bi directional mappings similar mappings intermediate language bir facilitate mapping model checker counter example traces back source code traces 
downstream components slicer specializer transform jimple representation careful maintain mappings 
instance specializer performs inlining duplicates bodies methods 
specialization single java source node may map multiple points jimple representation 
similarly slicer removes nodes jimple representation 
mapping java jimple modified indicate corresponding jimple node sliced away 
slicer program statements interest fs called slicing criterion program slicer compute reduced version removing statements affect computation criterion statements checking program specification oe bandera uses slicing remove statements affect satisfaction oe 
specification oe holds oe holds reduced version reduction sound complete respect oe 
showed slicing transformation driven generating slicing criterion oe primitive propositions oe 
example consider ltl response specification 
property states paths execution reaches point queue field heap object value greater eventually return point run method class stage reached 
specification bandera generates slicing criterion containing return statement method stage run statements contain assignments heap queue 
slicing algorithm guarantees preservation program components affect values assigned heap queue relative order execution stage run return assignments heap queue 
building slicer java requires significant amount effort 
fortunately issues surrounding java concurrency primitives able carry development previously developed slicing techniques program dependence graphs 
gave formal presentation slicing includes additional notions dependence arise java concurrency model 
includes dependencies due possibly infinite delays waiting locks notification java notify notifyall data dependencies due access definition shared variables dependencies program statements monitor delimiters enclose 
effectiveness slicing reducing program models varies depending structure program 
systems considered slicing removes entire threads dramatically reduces state space 
cases program components tightly coupled large sections program relevant specification slicing reduction moderate 
slicing cheap compared cost model checking totally automatic bandera slicing option enabled 
abstraction specializer bandera abstraction specializer provides automated support reducing model size data abstraction 
useful specification checked depend program concrete values depends properties values 
example described previous section vector abstracted specification depends particular item vector 
appropriate definition abstraction specialization engine transform source code specialized version concrete operations tests relevant vector objects method calls vector class replaced versions manipulate tokens representing values 
information lost transformation operations tests relied lost information longer determined completely program 
instance vector example length abstracted vector determined 
values determined represented special token 
token flows test conditional expression program specialization engine inserts flag informs downstream model construction components implement test non deterministic choice true false branches 
user guides incorporating abstractions binding variables entries abstraction library 
library entries indexed concrete type entry implements version corresponding concrete type 
abstractions incorporated variable basis different variables concrete type different types 
example int abstractions variable int may bound variable int may bound user chosen abstractions relevant variables type inference phase propagates information program infers abstraction types remaining variables expression program 
type inference informs user abstraction type error 
abstraction library entry automatically generated high level description written bandera abstraction specification language 
general form specification consists declaration finite set tokens abstraction function maps concrete java value token operation operation method concrete type class 
rulebased format incorporates pattern matching simplifies definition operations 
define abstractions integers general forms range abstractions abstraction preserves integer sign modulo abstractions odd abstraction 
designed extension supports abstractions arrays strings general objects 
operation specification compiler generates sophisticated java implementation includes code propagate tokens code generate specialized versions operation operation completely symbolically executed 
abstractions primitive types compiler generates declarations correctness proof obligations theorem prover pvs 
currently experimenting generating definitions variant pvs 
interestingly pvs prove abstraction correctness generate abstractions required grind facility theorem prover 
design transformations implemented grounded rigorously developed framework interpretation 
previous formalized proven correctness simplified version abstraction specialized engine 
despite solid formal foundation designed compact notation shields user technical machinery interpretation allowing non expert users add abstractions bandera abstraction library 
back bandera back code generator sliced abstracted program producing verifier specific representations targeted verifiers 
back components communicate bir bandera intermediate representation intermediary compiler representations verifier representations 
shown back fixed component called bandera intermediate representation constructor accepts restricted form jimple produces bir 
supported verifier translator component accepts program represented bir generates input verifier 
translator spin complete translators smv stanford forthcoming sal model checker construction 
bir guarded command language describing state transition systems 
main purpose bir provide simple interface writing translators target verifiers bandera new verifier write translator bir input language verifier 
guarded command style bir meshes input languages existing model checkers 
bir contains higher level constructs facilitate modeling java threads java locks supporting wait notify bounded form heap allocation 
choose implementation constructs remove bir model lock boolean variable allow translators implement constructs way efficient verifier input language 
bir provides kinds information aid translators producing compact models 
example guarded command labeled invisible indicating executed atomically successor 
set local variables live control location specified dead variables set fixed value spin left unconstrained smv 
translates subset jimple bir 
java locals instance variables mapped bir state variables record fields 
jimple statement graph traversed construct set guarded commands thread 
guarded command marked visible invisible kind data accesses operations locals invisible 
accepts set expressions define primitive propositions model thread specific statement variable value 
embeds proposition definitions bir insures program statement changes value primitive propositions cause visible state change model 
spin translator accepts bir representation produces promela model system suitable input spin model checker 
promela quite expressive basic execution model bir asynchronous processes executing guarded commands translation straightforward 
promela atomic blocks collapse sequences invisible commands 
locks implemented struct containing lock state owner acquisition count wait set 
supplementary analyses effectiveness bandera components improved aid additional static analysis results 
bandera designed allow integration variety analyses results boost precision primary model extraction transformations produce accurate compact models 
examples analyses include lock safety analysis results refine inter thread dependences slicing highly parameterized object flow analysis computes information object values flowing selected program points refine source window property specification window counter example window bandera user interface dependences guide enable precise inlining methods 
model checking java programs bandera tool set provides command line graphical user interface called bandera user interface bui configuring model extraction process 
illustrates bui features including source level code views results applying different bandera components sliced code faded support writing formal specifications specification patterns global absence property support allows users view counterexample information navigating sourcecode statements 
addition bui allows users control abstractions model extraction configure run time options verifier select 
view bui interactive interface configuring model extractions configuration options set bui dumped input interface extraction run repeatedly code changes 
remainder section describe application bandera check properties multi threaded java program 
applying bandera bandera collection analysis transformation components applied variety different ways extract finite state model java source code 
initial experience bandera java programs desirable slice relatively easy pinpoint variables abstraction 
furthermore selection optimal abstractions ones give maximal reduction preserve property checked difficult problem initial experience suggests naive abstraction choices effective 
basic model extraction scenario involves slicing property followed abstraction model generation 
applied basic model extraction scenario analyze properties program implements pipelined computation pipeline stage executes separate thread 
stages interact connector objects provide methods adding data methods typical form conditional wait notify synchronization java programs 
main method constructs connectors creates starts listener objects implement stages 
code slightly different java code typically implement solve problem 
differences reflect limitations current bandera tool set lifted months additional tool capabilities integrated 
currently instance thread object converted separate class 
program specialization unroll loops contain constructor calls thread objects subtypes specialize object run methods values constructor parameters 
code results copies stage class run methods explicitly input output connectors converted static fields techniques 
non thread objects dynamic allocation supported fixed number instances garbage collection instances class heap static connector class main static public void main string argv heap new connector heap new connector new stage start heap new connector new stage start heap new connector new stage start new listener start int heap add heap class connector public int queue public synchronized int take int value queue try wait catch ex fg value queue queue return value public synchronized void add int queue notifyall public synchronized void queue notifyall class stage extends thread public void run int tmp tmp tmp heap take heap add tmp heap 
class stage extends thread class stage extends thread class listener extends thread public void run int tmp tmp tmp heap take system println output tmp threaded pipeline java supported 
checked kinds properties system related proper shutdown pipelined computations 
properties specify eventual shutdown pipeline stage response call pipeline input connector ii stage prematurely shutdown 
stage property expressed global response property ltl heap run return property ii expressed global precedence property ltl heap 
run return heap run return primitive propositions formula expressed collections locations source code indicated 
bui allows users point click identify locations line main selected line number appears ltl formula 
table shows data checking properties described bandera 
table gives total time required extract model code check model property spin result model check number states searched 
times user plus system time rounded nearest second bandera spin running mhz pentium ii xeon running linux 
variations program code basic version defective variant created inverting stage loop exit condition 
properties instances response precedence properties indexed stage number 
different extractions tried transformations slicing slicing abstraction 
identify problem letter problem property extraction response property stage checked model extracted basic program transformations 
data shows benefits property directed slicing abstraction model extraction 
performed single transformation extraction essentially program promela checks spin 
sliced extractions driven completely automatically temporal logic specification 
slicing property able eliminate components shown faded font 
data indicates yields dramatic performance improvement improvement dependent property checked 
response property stage requires run method class heap variable included slice 
abstraction applied program 
queue field connector object abstracted signs manipulates tokens neg zero pos 
collapsing data states abstraction reduces state space check times 
fact properties checked models extracted abstraction depend number size values added pipeline main loop 
slicing driven propositions specification structure models structure property small impact state space check time 
extracted models illustrate model extraction process preserves defects source code 
summary data illustrates bandera support scaling application verification tools 
complexity algorithms bandera typically lower complexity finitestate verification algorithms practice allow properties significantly larger systems verified 
problem extract check check states time time result true true true true true true true false false bandera pipeline data extraction compact models crucial practical application finite state verification software 
concise presentation diagnostic information provided verifiers just important 
example statement long counter example navigated corresponds step counterexample underlying promela model 
reported data connector capacity value implemented single integer 
applied bandera versions program connector implemented circular buffer fixed size instance java util vector 
cases arrays store actual values sliced away leaving fields determine emptiness fields appear condition waiting take values connector 
related significant amount activity past years attempting provide tool support translation software system descriptions input languages verification tools 
major efforts area 
tools java programs promela programs 
promela rich model description language semantic gap nearly great model checker input languages smv 
tools handle significant portion java including dynamic object allocation object exception processing inheritance 
weakness tools inability significantly compress promela program property checked enable tractable model checking non trivial programs 
major design goals bandera 
system extracting promela programs annotated programs checking spin 
allows user configure extraction process defining pairs promela code patterns 
pattern detected promela pattern instantiated output 
way user control abstraction process assurance information encoded model patterns semantics attached 
users debug patterns period time resulting model extraction process proven effective production programs telecommunications applications 
huch built dedicated model checker subset erlang untyped higher order concurrent functional language asynchronous communication primitives 
state space reduction uses single interpretation approximates set data constructors flow expressions runtime 
restricts recursion programs reasonable generalization tail recursion interpretation guaranteed give finite state model 
model properties mutual exclusion absence deadlock livelock checked 
untyped nature language clear obtain effective interpretation multiple abstractions tailored specifications single uniform abstraction huch 
techniques treat recursion java 
huch gives advantages disadvantages monolithic approach noted 
example notes recode model checking optimizations partial order reductions system 
argues working level erlang generated promela description allow easier detection cases optimizations applied 
model checking tools begun apply traditional compiler optimizations dead code elimination live variable analyses optimize checking process 
bandera incorporates sophisticated infra structure implementing analyses transformations 
plan infra structure enable importation techniques developed compiler research experiment model extraction programs recursive data methods exploiting shape analyses 
described design implementation bandera tool model checking java source code 
bandera uses component architecture model extraction designed maximize scalability flexibility extensibility 
discussed technologies studied software engineering programming languages research adapted integrated provide effective model extraction capability 
current implementation handle realistic albeit limited class java programs illustrated potential model extraction enable finite state verification source code 
currently working enrich features supported bandera anticipation general public release tool set summer see www cis ksu edu santos bandera additional information bandera current state tool set 
involves example handling features java interfaces user thrown exceptions integrating support abstracting entire classes abstracting individual fields class supporting additional verifiers stanford forthcoming sal model checker cmu bounded satisfiability model checker 
providing automated support extracting compact finite state models source code tools bandera lower barriers applying model checking software 
hope facilitate transfer technology research practice provide developers powerful tool error detection 
authors david schmidt george avrunin numerous discussions foundations design bandera 
supported part nsf ccr ccr ccr ccr nasa nag sun microsystems 
corbett 
evaluating deadlock detection methods concurrent software 
ieee transactions software engineering mar 
corbett 
constructing compact models concurrent java programs 
young editor proceedings international symposium software testing analysis issta 
acm press march 
cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
conference record fourth annual acm symposium principles programming languages pages 
iosif 
deadlock detection tool concurrent java programs 
software practice experience july 
dill drexler hu yang 
protocol verification hardware design aid 
ieee international conference computer design october 
dong ramakrishnan 
optimizing compiler efficient model checking 
proceedings forte nov 
dwyer avrunin corbett 
patterns property specifications finite state verification 
proceedings st international conference software engineering may 
hatcliff corbett dwyer sokolowski zheng 
formal study slicing multi threaded programs jvm concurrency primitives 
proceedings th international static analysis symposium sas sept 
hatcliff dwyer laubach 
staging static analysis abstraction program specialization 
lncs 
principles declarative programming th international symposium plilp sept 
hatcliff dwyer laubach 
specializing configurable systems finite state verification 
technical report kansas state university department computing information sciences 
hatcliff dwyer zheng 
slicing software model construction 
higher order symbolic computation 
appear 
havelund lowry penix 
formal analysis space craft controller spin 
proceedings th international spin workshop nov 
havelund 
model checking java programs java pathfinder 
international journal software tools technology transfer 
appear 
holzmann 
model checker spin 
ieee transactions software engineering may 
holzmann 
engineering model checker gnu protocol case study revisited 
theoretical applied aspects spin model checking lncs sept 
holzmann smith 
software model checking extracting verification models source code 
proceedings forte nov 
horwitz reps binkley 
interprocedural slicing dependence graphs 
acm transactions programming languages systems jan 
huch 
verification erlang programs interpretation model checking 
proceedings fourth acm sigplan international conference functional programming icfp pages sept 
jackson damon 
elements style analyzing software design feature counterexample detector 
ieee transactions software engineering july 
manna pnueli 
temporal logic reactive concurrent systems specification 
springer verlag 
mcmillan 
symbolic model checking 
kluwer academic publishers 
owre rushby shankar 
pvs prototype verification system 
proceedings th international conference automated deduction lncs 
valle rai hendren sundaresan lam gagnon soot java optimization framework 
proceedings cascon nov 

