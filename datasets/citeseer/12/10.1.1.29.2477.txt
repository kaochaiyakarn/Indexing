appears proceedings th workshop hot topics operating systems hotos viii may 
virtualization considered harmful os design directions conditioned services argue existing os designs ill suited needs internet service applications 
applications demand massive concurrency supporting large number requests second conditioned load avoiding degradation performance predictability demand exceeds capacity 
transparency virtualization provided existing operating systems leads limited concurrency lack control resource usage 
claim internet services far better supported operating systems reconsidering role resource virtualization 
propose new design server applications staged event driven architecture seda 
seda applications constructed set eventdriven stages separated queues 
seda architecture consequences operating system design 

design existing operating systems primarily derived heritage multiprogramming allowing multiple applications distinct resource demands safely efficiently share single set resources 
existing oss strive virtualize hardware resources way transparent applications 
applications rarely opportunity participate system wide resource management decisions indication resource availability order adapt behavior changing conditions 
virtualization fundamentally hides fact resources limited shared 
internet services relatively new application domain presents unique challenges os design 
contrast batch processing interactive workloads existing operating systems designed internet services support large number concurrent operations exhibit enormous variations load 
number concurrent sessions hits day internet sites translates higher number network requests placing great demands underlying resources 
microsoft web sites receive hits users matt welsh david culler computer science division university california berkeley culler cs berkeley edu day yahoo page views daily 
peak load experienced service may times average services deal gracefully unexpected increases demand 
number systems attempted remedy problems os virtualization exposing control applications 
scheduler activations application specific handlers operating systems spin exokernel nemesis attempts augment limited operating system interfaces giving applications ability specialize policy decisions kernel 
design systems multiprogramming mindset focus continues safe efficient resource virtualization 
argue design existing operating systems fails address needs internet services 
key premise supporting concurrency tens users fundamentally different thousands service requests 
proposes new architecture services call staged event driven architecture seda 
seda departs traditional multiprogramming approach provided existing oss decomposing applications set stages connected explicit event queues 
design avoids high overhead associated thread concurrency allows applications conditioned load making informed decisions inspection pending requests 
mitigate effects resource virtualization seda employs set dynamic controllers manage resource allocation scheduling applications 
discuss shortcomings existing os designs internet services seda architecture arguing right way construct applications 
addition set os design directions internet services 
argue server operating systems eliminate abstraction transparent resource virtualization shift enables support high concurrency fine grained scheduling scalable application controlled resource management 
appears proceedings th workshop hot topics operating systems hotos viii may 

internet services existing os designs don match section highlights main reasons existing os designs fail mesh needs internet services inefficient concurrency mechanisms lack scalable interfaces transparent resource management coarse grained control scheduling 

existing os design issues concurrency limitations internet services efficiently multiplex computational flows limited set resources 
extreme degree concurrency required services willing sacrifice transparent virtualization order obtain higher performance 
contemporary operating systems typically support concurrency process thread model process thread embodies virtual machine cpu memory disk network multiplexes virtual machines hardware 
providing abstraction entails high overhead terms context switch time memory footprint limiting concurrency 
number studies shown scalability limitations thread concurrency models context called lightweight threads :10.1.1.36.1021:10.1.1.23.5560
scalability limitations interfaces exported existing oss generally designed provide maximum transparency applications cost scalability predictability 
interfaces employ blocking semantics calling thread suspended pending operation 
obtaining high concurrency requires large number threads resulting high overhead 
traditional interfaces tend degrade performance number simultaneous flows increases 
addition data copies path artifact virtualization long known performance limitation network stacks 
transparent resource management internet services control resource usage order informed decisions affecting performance 
virtualization implies os attempt satisfy application request regardless cost request allocate page virtual memory requires pages swapped disk 
services luxury paying arbitrary penalty processing requests heavy resource contention 
operating systems hide performance aspects interfaces instance existence control underlying file system buffer cache typically exposed applications 
stonebraker cites aspect os design problem database implementations 
coarse grained scheduling thread concurrency model yields coarse degree control resource management scheduling decisions 
possible control prioritization runnable status individual thread blunt tool implement effective load conditioning policies 
desirable control flow requests particular resource 
example consider page cache web server 
maximize throughput minimize latency server prioritize requests cache hits cache misses decision level cache inspecting stream pending requests 
policy difficult impossible implement changing scheduling parameters pool threads representing different request server pipeline 
problem model provides control scheduling individual threads ordering requests particular resource 

traditional event driven programming limitations existing os designs led developers favor event driven programming approach concurrent request system modeled finite state machine 
single thread small number threads responsible scheduling state machine events originating os application readiness completion notifications 
event driven systems generally built scratch particular applications depend mechanisms supported operating systems 
underlying os structured provide thread concurrency blocking event driven applications disadvantage obtain desired behavior imperfect interface 
consequently obtaining high performance requires application designer carefully manage event thread scheduling memory allocation streams 
monolithic event driven design difficult modularize code implementing state directly linked flow execution 
nonblocking provided oss interfaces typically scale number flows grows large 
prior investigated scalable primitives servers solutions afterthought process model perform 
demonstrate fact measured performance nonblocking socket interface linux dev poll event delivery mechanism known scale better standard unix select poll interfaces 
shows performance nonblocking socket layer degrades large number connections established despite efficient event delivery mechanism underlying network stack scale number connections grows large 
appears proceedings th workshop hot topics operating systems hotos viii may 
bandwidth mbit sec nonblocking sockets dev poll blocking sockets threads number connections run connections linux socket layer performance graph shows aggregate bandwidth server making asynchronous blocking socket interfaces 
client opens connection server issues bursts kb packets server responds single byte ack burst 
machines way pentium iii systems running linux interconnected gigabit ethernet 
implementations server shown nonblocking sockets dev poll mechanism event delivery emulates asynchronous behavior blocking sockets threads 
implementation allocates thread socket reading packets uses fixed size thread pool threads writing packets 
threaded implementation support simultaneous connections due thread limitations linux nonblocking implementation degrades somewhat due lack scalability network stack 

staged event driven architecture section propose structured approach eventdriven programming addresses challenges implementing internet services commodity operating systems 
approach staged event driven architecture seda designed manage high concurrency load conditioning demands applications 

seda design discussed previous section eventdriven programming overcome shortcomings conventional os interfaces 
seda refines monolithic event driven approach structuring applications way enables load conditioning increases code modularity facilitates debugging 
seda set design patterns described break control flow eventdriven system series stages separated queues 
task system processed sequence stages representing set states traditional eventdriven design 
seda relies asynchronous prim event queue event handler thread pool controller outgoing events seda stage stage consists incoming event queue thread pool application supplied event handler 
stage operation managed controller adjusts resource allocations scheduling 
expose completion readiness events directly applications placing events queue appropriate stage 
stage self contained application component consisting event handler incoming event queue thread pool shown 
stage managed controller affects scheduling resource allocation 
threads operate pulling events stage incoming event queue invoking event handler 
event handler processes task dispatches zero tasks enqueuing event queues stages 
depicts simple server implementation seda design 
event handlers direct control queue operations threads 
separating core application logic thread management scheduling stage controller able manage execution event handler implement various resource management policies 
example number threads stage thread pool adjusted dynamically controller observation event queue thread behavior 
details scope information provided 

seda benefits seda design yields number benefits directly address needs internet services high concurrency traditional event driven design seda small number threads process stages avoiding performance overhead large number threads managing concurrency 
asynchronous facilitates high concurrency eliminating need multiple threads overlap pending requests 
seda number threads chosen stage level application approach avoids wasting threads stages need 
example unix filesystems usually handle fixed number concurrent read write requests saturated 
case benefit devoting number appears proceedings th workshop hot topics operating systems hotos viii may 
accept connection read packet connection packet parse request receive packet packet request check cache static response cache handle cache hit send response file data file request file packet write socket staged event driven seda server application decomposed set stages separated queues 
edges represent flow events stages 
stage independently managed stages run sequence parallel combination 
event queues allows stage individually load conditioned example thresholding event queue 
threads stage performs filesystem access 
shield application programmer complexity managing thread pools stage controller responsible determining number threads executing stage 
application specific load conditioning explicit event queues allows applications implement load conditioning policies observation pending events 
backpressure implemented having queue reject new entries raising error condition full 
important allows excess load rejected system buffering arbitrary amount 
alternately stage drop filter reorder incoming events queue implement policies event prioritization 
overload stage may prioritize requests requiring resources involve expensive computation policies tailored specific application imposed system generic way 
code modularity debugging support seda design allows stages developed maintained independently 
seda application consists network interconnected stages stage implemented separate code module isolation stages 
operation stages composed inserting queue allowing events pass 
contrast monolithic eventdriven design states request processing state machine highly interdependent 
tools exist understanding debugging complex event driven system stack traces represent control flow processing particular request 
seda facilitates debugging performance analysis decomposition application code stages explicit event delivery mechanisms provide means direct inspection application behavior 
example debugging tool trace flow events system visualize interactions stages 
prototype seda capable generating graph depicting set application stages relationship 

operating system design directions seda aids construction highly concurrent applications conventional os interfaces interfaces number design challenges internet services 
particular argue goal transparent resource virtualization undesirable context server operating systems eliminate abstraction favor approach gives applications control resource usage 
fundamental shift ideology possible implement number features support internet services concurrency scheduling seda uses small number threads driving execution stages scalability limitation threads avoided 
ideally code stage block requiring just thread cpu 
approach feasible os interface nonblocking 
unproblematic may challenging interfaces demand paging memory synchronization 
goal seda oriented operating system eliminate threads altogether support interfaces allows minimized 
seda os allow applications specify thread scheduling policy 
example overload application may wish give priority stages consume fewer resources 
policy delay scheduling stage accumulated amortize startup cost aggregating multiple disk accesses performing 
seda approach simplify mechanism implement application specific scheduling concerns raised safe scheduling multiprogrammed environment avoided 
specifically system trust algorithm provided application need support multiple competing applications scheduling policies 
scalable seda design easier construct scalable interfaces goal support large number streams single appli appears proceedings th workshop hot topics operating systems hotos viii may 
cation fairly multiplex resources multiple applications 
seda oriented asynchronous layer closely follow internal implementation contemporary filesystems network stacks away complexity safe virtualization interface 
example exporting high level socket layer os expose event driven nature network stack directly applications 
approach facilitates implementation zero copy mechanism difficult virtualize number reasons safe sharing pinned network buffers 
application controlled resource management seda operating system need designed allow multiple applications transparently share resources 
internet services highly specialized designed share machine applications plainly undesirable say web server run machine database engine mention scientific computation word processor 
os may enforce protection prevent stage corrupting state kernel stage system virtualize resources way masks availability applications 
instance hiding file system buffer cache os seda system expose lowlevel disk interface allow applications implement caching mechanism 
way seda follows philosophy systems exokernel promotes implementation os components libraries application control 
likewise os expose virtual memory interface physical memory availability explicit approach similar application controlled paging 

related seda design derived approaches managing high concurrency unpredictable load variety systems 
flash web server harvest web cache asynchronous event driven model closely resembles seda architecture 
flash component web server responds particular events socket connections filesystem access requests 
main server process responsible continually dispatching events components 
design monolithic event driven architecture described earlier 
certain operations case filesystem accesses asynchronous interfaces main server process handles events dispatching helper processes ipc 
stagedserver platform bears resemblance seda application components decomposed stages separated queues 
case goal maximize processor cache locality carefully scheduling threads events application 
aggregating execution multiple similar events queue locality enhanced leading greater performance 
click modular packet router scout operating system software architecture similar seda packet processing stages implemented separate code modules private state 
click modules communicate queues function calls scout modules composed path implement vertical resource management integrated layer processing 
click scout optimized improve packet latency allowing single thread call directly multiple stages 
seda threads isolated stage reasons safety load conditioning 
extensible operating systems exokernel spin share desire expose greater resource control applications 
systems primarily focused safe application specific resource virtualization support extreme concurrency robustness load 
proposal sense radical extensible operating systems claim right approach supporting scalable servers eliminate resource virtualization augment application specific functionality 

argue traditional os designs intended primarily safe efficient multiprogramming mesh needs highly concurrent server applications 
large body addressed aspects problem suggests ubiquitous process model attendant requirement transparent resource virtualization fundamentally wrong applications 
propose staged event driven architecture decomposes applications stages connected explicit event queues 
model enables high concurrency fine grained load conditioning essential requirements internet services 
implemented prototype seda system described 
space limitations prevent providing details experience seda prototype implemented java top unix interfaces demonstrated viability design implementing scalable internet service applications commodity oss 
internet services necessitate fundamental shift operating system design ideology 
believe time come reevaluate os architecture support new class applications 
anderson bershad lazowska levy 
scheduler activations effective kernel support user level management parallelism 
acm transactions computer systems february 
banga mogul druschel 
scalable explicit event delivery mechanism unix 
proceedings appears proceedings th workshop hot topics operating systems hotos viii may 
usenix annual technical conference monterey ca june 
bershad savage pardyak sirer becker fiuczynski chambers eggers 
extensibility safety performance spin operating system 
proceedings th acm symposium operating system principles sosp 
chankhunthod danzig neerdaels schwartz worrell 
hierarchical internet object cache 
proceedings usenix annual technical conference pages january 
druschel peterson 
fbufs high bandwidth transfer facility 
proceedings th acm symposium operating system principles 
gribble 
design framework scalable storage platform simplify internet service construction 
phd thesis uc berkeley september 
hand 
self paging nemesis operating system 
proceedings osdi february 
cheriton 
application controlled physical memory external page cache management october 
hu pyarali schmidt 
high performance web servers windows nt design performance 
proceedings usenix windows nt workshop august 
hu pyarali schmidt 
applying proactor pattern high performance web servers 
proceedings th international conference parallel distributed computing systems october 
kato masuda 
unstable threads kernel interface minimizing overhead thread switching 
proceedings th ieee international parallel processing symposium pages april 
kaashoek engler ganger brice hunt mazi res grimm jannotti mackenzie 
application performance flexibility exokernel systems 
proceedings th acm symposium operating systems principles sosp october 
kaashoek engler ganger wallach 
server operating systems 
proceedings sigops european workshop september 

problem 
www 
com html 
larus 
enhancing server performance staged server 
www research microsoft com larus talks stagedserver ppt october 
lemon 
freebsd kernel event queue patch 
www com 
leslie mcauley black roscoe barham 
design implementation operating system support distributed multimedia applications 
ieee journal selected areas communications september 
mogul 
operating systems support busy internet services 
proceedings fifth workshop hot topics operating systems hotos may 
morris kohler jannotti kaashoek 
click modular router 
proceedings th acm symposium operating systems principles sosp pages kiawah island south carolina december 
mosberger peterson 
making paths explicit scout operating system 
proceedings osdi october 
pai druschel zwaenepoel 
flash efficient portable web server 
proceedings annual usenix technical conference june 
pai druschel zwaenepoel 
io lite unified buffering caching system 
proceedings rd usenix symposium operating systems design implementation osdi february 
lever 
scalable network linux 
technical report citi tr university michigan center information technology integration may 
www citi umich edu techreports reports citi tr ps gz 
rodrigues anderson culler 
highperformance local area communication fast sockets 
proceedings usenix annual technical conference 
russinovich 
inside completion ports 
www com htm 
stonebraker 
operating system support database management 
communications acm july 
von eicken basu vogels 
net user level network interface parallel distributed computing 
proceedings th annual symposium operating system principles december 
von eicken culler goldstein schauser 
active messages mechanism integrating communication computation 
proceedings th annual international symposium computer architecture pages may 
wallach engler kaashoek 
application specific handlers high performance messaging 
proceedings acm sigcomm conference applications technologies architectures protocols computer communication pages stanford california august 
welsh 
staged event driven architecture highly concurrent server applications 
ph qualifying examination proposal uc berkeley december 
www cs berkeley edu papers quals seda pdf 
welsh basu von eicken 
incorporating memory management user level network interfaces 
proceedings hot interconnects august 
welsh gribble brewer culler 
design framework highly concurrent systems 
technical report ucb csd berkeley computer science division april 
