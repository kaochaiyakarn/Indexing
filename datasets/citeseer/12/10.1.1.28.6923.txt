design implementation operating system support distributed multimedia applications ian leslie derek mcauley richard black timothy roscoe paul barham david robin support multimedia applications general purpose computing platforms subject considerable research 
evolutionary strategy small changes existing systems 
approach adopted start ab initio backward compatibility constraints 
leads novel structure operating system 
structure aims decouple applications provide multiplexing resources just cpu low level 
motivation structure design structure implementation number hardware platforms described 
purpose multimedia computing platforms endow text images audio video equal status interpreting audio video stream privileged task special functions provided operating system ordinary user programs 
support processing platform user applications running may processing continuous media achieved existing operating systems requires mechanisms consistently share resources manner determined application requirements user preferences 
continuous media streams important properties 
property fidelity dependent timeliness 
temporal property continuous media imposes requirement code manipulates media data may need scheduled suitable windows time 
second property tolerant loss information content particularly known data compression schemes rely human factors achieve high compression rates 
informational property regards exact nature may exploited systems handle continuous media 
properties streams extended applications process temporal requirements applications stronger traditional data processing applications informational requirements weaker 
order operating system support traditional multimedia applications wider range facilities current operating systems needs provided 
describes operating system called nemesis goal provide range facilities 
carried part pegasus project esprit basic research activity 
underlying assumptions pegasus project 
general purpose computing platforms process continuous media simply capture render store 

users run applications manipulate continuous media simultaneously 

application manipulating continuous media varying demands resources execution 

application mix load dynamic 
multimedia systems capture display store continuous media range applications constrained means currently exhausted 
processing continuous media real time adds important new dimension 
current situation typified processors control continuous media systems typified systems data types operated extended include continuous media streams 
concerned provide environment applications developed run 
traditional general purpose operating systems support notion virtual processor interface application sees virtual processor provides method sharing real processor 
virtual ian leslie richard black paul barham robin university cambridge computer laboratory cambridge uk 
derek mcauley department computer science university glasgow uk 
timothy roscoe durham nc 
david research limited cambridge uk 
bell labs nj 
processor sees performance influenced load virtual processors mechanisms control interference generally available 
multimedia applications require mechanisms 
way controlling interference providing multiple real processors 
example multimedia applications parts thereof run processors peripheral cards main processor involved 
code running peripheral embedded danger competing applications peripheral time 
approach mainframes channel processors reduces demands central processors particular ensuring central processors get overloaded interrupts 
aim nemesis allow general purpose processor provide functions find specialised dsp peripheral providing control interference virtual processors achieved distinct hardware 
wish retain flexibility virtual processor system resources efficiently dedicated peripheral approach 
approaching design operating system goals immediate question revolution versus evolution arises 
attempt migrate current operating system current operating system order meet goals start afresh 
reasons current general purpose operating systems appropriate established 
similarly hard real time solutions require static analysis appropriate situation application mix dynamic 
general purpose operating systems real time threads real time behaviour provided static priority inappropriate running single multimedia application afford perform analysis complete system order assign priorities 
better solution take existing operating system modify scheduling system support multimedia applications reason difficulty performing scheduler transplant knowledge characteristics scheduler migrates components making effect replacement unpredictable 
view processor scheduling important aspect operating system support multimedia applications lead start scratch 
describe providing realisation virtual processor properties require profound implications complete structure operating system 
main theme guiding design nemesis multiplexing system resources lowest level case processor multiplexing system scheduling algorithm 
multiplexing resources real virtual determined fundamental structure nemesis 
rise system functionality possible executes domain application includes code traditional microkernel execute shared server 
emphasised need change interface seen application programmers 
api seen programmer thin layer library code supplying veneer set kernel traps messages server processes nemesis majority functionality provided shared library 
example posix api nemesis domain provided posix emulation runs applications domain 
nemesis service provided far possible shared library code design service aim minimise number changes protection domain 
aid construction services various parts code data simplified single address space protection domains provided access control fields address translations 
discussion quality service management application crosstalk section ii structure nemesis kernel virtual processor model event mechanism described detail section iii 
events native concept nemesis 
events support implementation event counts sequencers practice domains currently mapping 
synchronisation primitives built top event counts sequencers required 
scheduling domains described section iv 
domain scheduling algorithms detail briefly 
scheduling important aspect supporting multimedia applications nemesis take view correct scheduling algorithm structure nemesis designed alternative scheduling algorithms straightforward 
aspects system briefly described linkage model single address space interdomain communication mechanisms 
system code implementing operating system services executes application domain gives rise problems linking pieces code data required providing safe efficient sharing code data 
problems directly attributable single address space discussed section higher layer inter domain communication idc systems built events 
section vi presents system interdomain invocations rpc model 
section presents bulk transfer mechanism nemesis context support networking concept domains nemesis explained section iii moment thought analogous unix processes 
current state implementation systems built described early section vii 
ii 
model quality service qos management managing quality service qos operating system done number ways 
extreme hard real time guarantees applications refusing run hard real time guarantees 
extreme hope best providing resource expects 
range options appropriate multimedia systems 
general approach provide probabilistic guarantees expect applications monitor performance adapt behaviour resource allocation changes 
qos architectures example assume context applications specify qos requirements layer determines requirement met turn specifies derived qos requirements layer 
particularly bad approach layers performing multiplexing single thread operating behalf number applications great care taken prevent qos crosstalk 
processing multiplexed escape need recursive mapping qos requirements service stack 
practical approach providing mapping problematic particularly application understand qos requirements change time 
feedback qos control approach introduce notion feedback control 
adaptive approach controller adjusts application qos demands light observed performance 
distinguished usual type feedback applications degrade gracefully resources committed 
shown schematically 
application adaptation instruction stream resource provision application performance application execution qos manager qos controller desired performance fig 
qos feedback control qos controller dictates policy followed directly dictated user agent running user behalf normally 
qos manager implements allocation resources try achieve policies dictated qos controller ensures enforcement informing operating system applications adapt behaviour 
scheme directly analogous window systems window manager server counterparts qos controller manager 
window system applications aware pixels allocated server adapt accordingly server enforces allocations clipping users preference profile resizing windows directly interact window manager agent express desired policies 
approach allows applications application writers free problem determining exactly resources application requires cost requiring implement adaptive algorithms 
useful side effect simplifies porting applications new platforms 
lead relation providing qos guarantees operating system 
left controller manager applications 
brief consideration feedback system leads forward performance function application performance set resources instruction stream need necessarily predictable obtain desired performance consistent note efficiency speed execution desirable important stability qos control system consistency 
consistency turn requires resources accounted correctly applications consume accurate applications cause consumed qos crosstalk applications kept minimum 
qos crosstalk dealing time related data streams network protocol stacks problem quality service crosstalk streams identified 
qos crosstalk occurs contention resources different streams multiplexed single lower level channel 
thread processing channel notion component streams apply resource guarantees statistical delays introduced packets stream 
preserve qos allocated stream scheduling decisions multiplexing point 
qos crosstalk occurs performance network association application level unduly affected traffic pattern associations multiplexed 
solution advocated multiplex network associations single layer protocol stack immediately adjacent network point attachment 
allows scheduling decisions apply single associations multiplexed aggregates 
particular line grew virtual circuits atm networks employed ip networks packet filters fair queueing schemes 
analogously application qos crosstalk occurs operating system services physical resources multiplexed client applications 
addition network protocol processing components device filing systems directory services memory management link loaders window systems needed client applications 
services provide concurrency access control manage system state generally implemented server processes kernel 
means performance client dependent scheduled performance servers requires including kernel 
performance servers turn dependent demand services clients 
client activity delay invocations service 
odds resource allocation policy attempting allocate resources applications servers 
look scheduling act allocating real resource processor 
servers introduce virtual resources allocated manner consistent application quality service 
requirements operating system model qos management including extension cover resources gives rise requirements ffl operating system provide facilities allow dynamic allocation resources applications 
ffl operating system ensure consumption resources accounted correct application 
ffl operating system force applications shared servers applications experience crosstalk applications 
requirements met called qos manager 
runs occasionally requests change allocation resources 
run reason borrow phrase communications said run band respect application computation 
second third requirements strongly related 
concerned band application computation language communication systems lead philosophy low level multiplexing resources system 
consideration gives rise novel structure operating systems 
iii 
structural overview nemesis structured provide fine grained resource control minimise application qos crosstalk 
meet goals important account time application possible keep application informed resource enable application schedule subtasks 
odds desire need code implements concurrency access control shared state execute different protection domain client kernel server process 
number approaches taken try minimize cost interacting servers 
technique support thread migration systems allow threads undergo protection domain switches specialised hardware architectures conventional workstations 
threads easily scheduled parent application implemented kernel manages protection domain boundaries 
kernel consequence provide synchronisation mechanisms threads applications longer control resource tradeoffs 
alternative implement servers separate schedulable entities 
systems allow client transfer resources server preserve qos server calls 
processor capacity reserves mechanism prominent kernel implements objects called reserves transferred client threads servers 
mechanism implemented reasonable degree efficiency fully address problem ffl state associated reserve transferred server thread ipc call 
adds call overhead furthermore suffers kernel thread related problems described 
ffl crosstalk occur servers guarantee server deal clients fairly clients correctly pay service 
ffl clear nested server calls handled particular server may able transfer reserve unrelated thread 
nemesis takes approach minimising shared servers reduce impact application qos crosstalk minimum necessary functionality service placed shared server processing possible performed application domain 
ideally server perform privileged operations particular access control concurrency control 
consequence approach desire expose server internal state controlled manner client domains 
section describes particular interfaces modules nemesis supports model text data occupies single virtual address space facilitating controlled sharing 
emphasised way implies lack memory protection domains 
virtual physical address translations nemesis domains protection rights page may vary 
mean area memory nemesis shared virtual addresses physical memory locations change domains 
unprivileged privileged kernel application device driver application application fig 
nemesis system architecture minimal shared servers stands contrast trends operating systems move functionality away client domains kernel separate processes 
number examples literature services implemented client libraries kernel server 
efficient user level threads packages mentioned 
examples user level libraries include network protocols window system rendering unix emulation 
nemesis designed techniques 
addition support creating linking new domains setting inter domain communication networking performed context application 
result vertically integrated operating system architecture illustrated 
system organised set domains scheduled small kernel 
virtual processor interface runtime interface domain kernel serves purposes ffl provides application information scheduled 
ffl supports user level multiplexing cpu distinct subtasks domain 
key concepts activations scheduler invokes domain events indicate domain invoked 
domain considered virtual processor activations virtual interrupts events virtual interrupt status 
important data structure associated virtual processor interface domain control block 
contains scheduling information communication points protection domain identifier upcall entry point domain small initial stack 
divided areas writable domain readable writable 
privileged service called domain manager creates links scheduler data structures 
details fields described 
activations concept activations similar 
domain allocated cpu kernel domain normally resumed point lost cpu 
allows domain consider scheduling actions soon obtains cpu resource 
exceptional case resumption domain operating critical section activation difficult cope entailing re entrant handlers 
domain controls activated resumed setting clearing activation bit 
considered disabling virtual interrupts 
nemesis domain provided array slots hold processor context 
example case alpha axp implementation slots consisting integer floatingpoint registers plus program counter processor status word 
time slots designated application activation context resume context domain processor context saved activation slot resume slot depending activation bit set 
domain scheduled activation bit clear resume context activation bit set bit cleared upcall takes place routine specified 
entry point typically user level thread scheduler domains initially entered way 
illustrates cases 
activation temporary activation context activation bit activation bit context slots activation slot resume slot activation activation bit activation bit context slots activation slot resume slot fig 
activations resumptions upcall occurs dedicated stack delivers information current system time time reason upcall event notification context slot 
information provided give domain sufficient execution environment schedule thread 
threads package typically context slot thread change designated activation context thread running 
threads slots required slots cache thread contexts 
activation bit appropriate exit checks allow thread scheduler non reentrant simpler 
events operating system requirements provide mechanism various devices components communicate 
nemesis kernel provides events event channels provide underlying notification mechanism range communications channels constructed 
number important considerations event mechanism nemesis 
ffl mechanism force synchronous behaviour domains find asynchronous mechanism convenient 
ffl possible communicate non blocking manner example device drivers servers qos conscious 
ffl loosely coupled multiprocessors explicit memory synchronisation required communication performed invoked 
requirement enable portable partially ordered memory systems alpha axp multiprocessor desk area network 
ffl thread scheduler domain map communications activities scheduling requirements efficiently necessitates communications primitives designed conjunction concurrency primitives 
requirements dictate solution asynchronous non blocking indicate arbitrary number communications occurred receiver 
scheme events value conveyed sending domain kernel recipient domain event channel 
event monotonically increasing integer may read modified atomically sending domain 
domain request current value conveyed recipient domain performing kernel system call send 
recipient domain holds readonly copy event updated kernel result send 
sys send event user kernel process process process event table pending event circular buffer fifo kernel event dispatch table process process event table value event updated value process index fig 
example sending event update example shows value event number domain propagated send system call domain event number mapping table event channels pair entry kernel copies value event table appropriate entry event table places index case circular buffer fifo 
domain kernel protected table destinations event channels originating domain 
management domain called binder described section vi responsible initialising tables creating communication channels 
currently point point events implemented prevent multicast events needed 
exactly event represents known kernel domains 
relationship nemesis events event counts sequencers standard user thread library discussed section iv 
events underlying notification mechanism supporting interrupt dispatch inter domain communication facilities higher level abstraction currently support provided inter domain invocations section vi streaming data operations section vi 
time multimedia environment particular need domain know current time may need schedule activities related time real world 
systems unix current time day clock derived periodic system ticker 
cpu scheduling done ticker system time updated ticker interrupt occurs account adjustment keep time consistent universal time ut ntp 
circumstances domain may able obtain time value accurate time timer interrupt value read may subject significant skew due adjustments 
overcome problems nemesis scheduling time ut kept separate 
kept number nanoseconds system booted scheduling resource calculations requests 
expected granularity updates variable read applications required 
conversion number uct done adding system base value 
base value adjusted take account drift system mankind clock convention 
scheduling time available memory readable domains passed domain activation 
kernel structure nemesis kernel consists entirely interrupt trap handlers kernel threads 
kernel entered domain due system call new kernel stack frame constructed fixed processor area memory likewise fielding interrupt 
kernel traps provided send events yield processor timeout set variations return activation system call rfa 
return activation system calls perform various forms atomic context switches user level schedulers 
privileged domains register interrupt handlers mask interrupts necessary processors ask placed particular processor privileged modes access tlb 
alpha axp implementation calls implemented pal calls scheduler written reasons comprehension 
nemesis aims schedule domains clear allocation cpu time qos specifications 
existing operating systems arrival interrupt usually causes task scheduled immediately handle interrupt preempting running 
scheduler usually involved decision new task runs interrupt service routine 
interrupt service routine isr high interrupt rate device hog processor long periods scheduler hardly gets chance run user process 
high frequency interruptions counter productive describes situation careful interrupts led high throughput interrupts disabled high proportion time 
sensible design hardware interfaces alleviate problem devices designed behaviour mind rare address fundamental problem scheduling decisions interrupting device interrupt dispatching code system scheduler effectively bypassing policing mechanism 
solution adopted nemesis decouples interrupt domain handling interrupt source 
device drivers implemented privileged domains register interrupt handler system called interrupt dispatch code minimum registers saved 
isr typically clears condition masks source interrupt sends event domain responsible 
sequence sufficiently short ignored accounting point view 
example isr lance ethernet driver instructions long 
recipient domain specific application domain application exclusive access device 
recipient domain event device driver domain providing de multiplexing function demultiplexing ethernet frame types domain control qos scheduler resource limits attached 
significant benefit single virtual address space approach virtual addresses valid regardless domain currently scheduled 
maintenance scatter gather maps enable devices dma data directly virtual memory addresses client domains greatly simplified 
iv 
scheduling nemesis scheduler goals reduce qos crosstalk applications enable application specific degradation load support applications need baseline resource providing real guarantees cpu allocation 
key concept applications allocated share processor 
shares allocated qos manager understanding available resources input qos controller applications user 
key decision order simplify computation required scheduler context switches qos manager ensure scheduler meet short term demands ensuring processor contracted domains requiring qos 
qos manager takes long term view availability resources uses algorithms significant hysteresis provide consistent guaranteed resource application 
imply system conserving slack time system supplied applications request information optimistic processor capacity adapt behaviour rely 
mechanism specifying cpu time qos serve purposes allow applications users user agents specify application desired cpu time enable qos manager ensure processor resource allocated enable scheduler allocate processor time efficiently 
section ii nemesis adopts approach users user agents expected provide control observation allocation 
leads simple qos specification 
case cpu time advantage simple qos specification reduces overhead scheduler recalculating schedule context switch 
scheduling architecture service model relatively simple code switch running domains nemesis scheduler variety functions 
ffl account time holder qos guarantee provide policing mechanism ensure domains overrun allotted time ffl implement scheduling algorithm ensure contract satisfied ffl block unblock domains response requests arrival events ffl interface domains aware scheduling passage real time ffl provide mechanism supporting efficient implementation potentially specialised threads packages domains 
applications nemesis specify priorities deadlines 
scheduler deals entities called scheduling domains aims provide particular share processor short time frame 
may correspond single nemesis domain set domains collectively allocated share 
best effort domain best effort domain contracted domain contracted domain contracted domain best effort class best effort domain best effort class scheduler best effort domains fig 
scheduling service architecture service architecture illustrated 
usually correspond contracted domains correspond best effort classes domains 
case processor time allotted shared domains algorithms simple round robin multi level feedback queues 
advantage approach portion total cpu time reserved domains special timing requirements ensure starved processor time 
different algorithms scheduling best effort domains run parallel impacting performance time critical activities 
mentioned nemesis scheduling shares core concept particular scheduling algorithm open choice 
atropos scheduler standard nemesis scheduler described detail 
atropos scheduler atropos scheduler shares specified application dependent period 
share processor receives specified tuple fs lg 
slice period represent processor bandwidth receive ticks cpu time time slices period length boolean value indicate prepared receive slack cpu time 
latency hint described 
atropos scheduler internally uses earliest deadline edf algorithm provide share guarantee 
deadlines operates available specified application implementation scheduler simple fast relies fact qos manager soluble problem ensured applications allowed specify deadlines 
states may scheduler queue queue state running running guaranteed time runnable guaranteed time available qw dw waiting awaiting new allocation time optimistic running slack time blocked awaiting event scheduler holds deadline time current period ends value time remaining current period 
queues qw runnable waiting sorted deadline deadlines periods respective queue heads third queue blocked 
scheduler requires hardware timer cause scheduler entered shortly specified time ideally microsecond resolution better scheduler entered time result timer interrupt event delivery 
time current running deducted value 
zero inserted qw 
qw set new deadline set moved 
time calculated timer interrupt depending dw pw lower 

scheduler runs head empty selects element qw basic algorithm find feasible schedule 
seen regarding task execution nanoseconds qos manager ensured total share processor allocated slices executed point period approach satisfies conditions required edf algorithm function correctly argument relies simplifications firstly scheduling overhead negligible secondly system steady state 
addressed ensuring sufficient slack time system allow scheduler run counting time scheduler anybody 
second concerned moving share allocation safe option set introduces maximum scheduling leeway feasible schedule exists deadlines missed result 
domains sufficient default behaviour 
limit proceed simultaneously instantaneous share processor constant time 
limit referred processor sharing efficiently support domains requiring wide range scheduling granularities 
interrupts latency hint fact unblocking asleep period scheduler sets latency hint 
default behaviour just described achieved setting domains 
case device drivers reacting interrupt faster response required 
device domain share processor capacity unblocking latency hint provides means device driver domain respond interrupt low latency 
consequences reducing way woken complete system heavy load may deadline periods 
scheduler behaviour circumstances truncate running time lose part slice period 
things settle 
high interrupt rate device processor interrupt taken activation driver domain scheduling mechanism enforcing maximum interrupt context switch rate 
activity device approaches maximum driver domain time process cpu allocation driver rarely time block action device cause interrupt converges situation driver polls device cpu 
device activity driver process overrun occurs 
device activity normally cause interrupts ignored system driver keep device 
deemed desirable having device schedule processor driver cpu cycles clients device wouldn able data anyway 
driver processor time timer available eb board prototype nemesis simulated periodic ticker workstations 
domain manager 
system detect condition longer period time reallocate processor bandwidth system adapt conditions 
slack time long non empty head due contracted time run 
empty scheduler fulfilled commitments head qw runnable 
case scheduler opt run qw true requested slack time system 
domains aware running manner contracted time flag 
current policy adopted scheduler run random element qw small fixed interval head qw runnable whichever sooner 
receive processor optimistically non empty 
best policy picking run optimistically subject research 
current implementation allocates small time quantum member qw picked cyclically 
works cases situations unfair beats observed 
schedulers nemesis system prescribe scheduler se atropos scheduler simply common 
schedulers appropriate 
alternative scheduler known scheduler developed 
differs atropos scheduler cpu resources allocated applications single system defined frequency 
period system wide frequency known typically tens milliseconds 
scheduler scheduling levels strict priority order guaranteed cpu successively speculative computations 
atropos mechanism handing slack time system 
priority internal scheduler visible client domains 
fixed remove need edf scheduling particular suited situations application load understood single size chosen 
complete details 
intra domain scheduling section considers implementation intra domain scheduler provide familiar threaded environment 
intra domain scheduler code sits virtual processor interface 
code privileged differ domain domain 
may simple case single threaded domain complex 
base technique synchronization adopted domains extend core nemesis events interdomain communication provide event counts sequencers 
event counts sequencers purely local domain attached outbound events propagated domain send inbound events change asynchronously result domain issuing send 
event counts sequencers operations available event count sequencer read returns current value event count strictly returns value event count start operation termination 
await operation blocks calling thread event count reaches exceeds value advance operation increments value event count amount may cause threads runnable 
read returns current value sequencer strictly returns value sequencer start operation termination 
ticket returns current member monotonically increasing sequence guarantees subsequent calls ticket read return higher value 
fact little difference underlying semantics sequencers event counts difference ticket operation need consider threads advance operation wrong thread await sequencer 
initial value sequencers event counts zero may altered immediately creation primitives 
additional operation await supported waits event value time value convention advance outbound event cause new value propagated issuing send system call 
read await incoming events value may overwritten time 
way local interdomain synchronization achieved interface required user level thread need concern difference 
concurrency primitives events contrast systems implementing style concurrency primitives set expensive efficient implement schemes event counts 
mutexes conditional variables src threads posix threads semaphores system implemented straightforwardly efficiently event counts 
details 
implementing threads packages upcall interface proved remarkably easy 
nemesis module implementing preemptive non preemptive threads packages providing interface event mechanism synchronisation event counts sequencers comes lines heavily commented assembler opcodes 
comparison posix threads library osf achieves essentially functionality osf kernel threads lines code considerably inferior performance 
interfaces invocation architecture introduced section iii raises number questions concerning structure applications services traditionally provided servers kernel provided applications process exceptions 
order describe inter domain system nemesis necessary higher level constructs nemesis complement single virtual address space approach 
full account 
key aspects extensive typing transparency modularity definition nemesis interfaces closures provide comprehensible safe extensive sharing data code 
nemesis programming model concepts interface invocation obtained binding 
interface object containing information part binding build invocation particular instance interface 
invocation closure appropriate type may simple pointer library code local state surrogate remote interface 
local case interface invocation representation pointer closure binding implicit trivial operation 
nemesis spring interfaces strongly typed types defined interface definition language idl 
idl nemesis called similar functionality idls object rpc systems additional constructs handle local low level operating system interfaces 
specification defines single data type declaring supertype giving signatures operations supports 
specification include declarations exceptions concrete types 
word object nemesis denotes lies interface object consists state code implement operations interfaces provides 
class set objects share underlying implementation idea object class distinct type property interfaces objects operation invoked object interfaces environment operation performed depends internal state object arguments invocation 
global symbols programming model 
apart benefits encapsulation provides facilitates sharing code 
order overcome awkwardness lack global symbols produce consider having pass memory allocation heap virtually invocation certain interfaces treated part thread context 
known programming model includes notion currently thread current available 
include exception handlers thread operations domain control operations default memory allocation heap 
programming model supported linkage model 
stub compiler map type definitions language types 
compiler known processes interface specification generates header file giving type declarations concrete types defined interface special types represent instances interface 
interface represented memory closure record pointers array function pointers state record 
invoke operation interface client calls appropriate element operation table passing argument address closure 
vi 
inter domain communication nemesis provides framework building various inter domain communication idc mechanisms abstractions events notification shared memory data transfer 
model inter domain invocation nemesis run time type system allow arbitrary interface available domains 
basic paradigm adopted dictated different distinction class type clear notion interface 
classes contain implementation details added afterthought 
interface definition language remote procedure call rpc addition announcement operations allow message passing semantics 
rpc paradigm invocations way implies traditional rpc implementation techniques marshalling buffer transmission buffer unmarshalling dispatching 
cases rpc programming model appropriate underlying implementation radically different 
particular rich sharing data text afforded single address space number highly efficient implementation options available 
furthermore situations rpc clearly ideal paradigm example bulk data transfer continuous media streams best handled band rpc interface control 
case rbuf mechanism section vi employs binding model described interface control mechanism 
operating systems research date tended focus optimising performance communication systems rpcs relatively little attention process binding interfaces 
contrast field distributed processing sophisticated established notions interfaces binding example trader ansa architecture 
nemesis binding model shares features ansa model 
section describes briefly nemesis approach inter domain binding invocation including optimisations single address space system notion real time reduce synchronisation overhead need protection domain switches followed outline support stream idc 
binding order invoke operations remote interface client interface client requires local interface encapsulating implementation needed remote invocation 
previously described invocation 
nemesis idc invocation closure pointer type remote interface words surrogate remote interface 
interface typically arrives domain result previous invocation 
name servers traders provide services clients request service specifying properties 
interface matched service request returned client 
local case described section interface simply pointer interface closure binding trivial operation reading pointer 
case communication occur protection domain boundaries network interface include information binding process correspondingly complex 
implicit explicit binding implicit binding mechanism creates state associated binding manner invisible client 
invocation declared return interface returns closure valid surrogate interface 
creation surrogate performed stage arrival interface application domain attempt application invoke operation interface 
bindings time re established demand 
key feature implicit binding paradigm information binding hidden client surrogate interface indistinguishable real thing 
approach adopted distributed object systems example modula network objects corba 
intuitive easy point view client programmer applications provides functionality required provided garbage collector available destroy binding longer 
hand traditional rpc systems tended require clients perform explicit bind step due difficulty implementing generic implicit binding 
advent object systems implicit approach prominent reasons mentioned 
implicit binding inadequate circumstances due hidden nature binding mechanism 
assumes single best effort level service precludes explicit control duration binding 
implicit binding ill suited needs time sensitive applications 
reason nemesis bindings established explicitly client needed 
binding explicit operation returns interface create surrogate part unmarshalling process provides local interface create binding 
interface allow duration qualities binding precisely controlled bind time loss type safety efficiency 
price level control extra application complexity arises need parameterise binding loss transparency acquiring interface locally implemented interface different acquiring surrogate 
remote invocation invocation aspect idc invocations occur binding independent binding model 
ideally idc framework able accommodate different methods data transport computational model 
rpc invocations aspects 
transfer information sender receiver client server 
signalling transfer information 
transfer control sender receiver current operating systems support rpc local communications mechanism tend approaches problem carrying procedure invocation domain boundaries message passing thread tunnelling 
care message passing system shared memory regions mapped pairwise communicating protection domains provide high throughput particularly cost context switches invocations words having rpc invocations domain outstanding 
separation information transfer control transfer especially beneficial shared memory multiprocessor described 
thread tunnelling model achieves low latency combining components operation transfer thread client server kernel simulate protected procedure calls implemented hardware example multics capability systems cap 
example replacement original taos rpc mechanism lightweight rpc 
cases performance advantage thread tunnelling comes price thread left client domain effect having blocked far client concerned 
threads scheduled kernel cross protection domain boundaries applications longer reliably internally multiplex cpu 
accounting information tied kernel threads leading crosstalk discussed section iii 
standard mechanism baseline idc invocation transport mechanism nemesis operates conventional rpc mechanism 
bind process creates pair event channels client server 
side allocates shared memory buffer ensures mapped read domain 
server creates thread waits incoming event channel 
invocation copies arguments operation invoked client buffer sends event outgoing channel waiting incoming event channel 
server thread wakes arguments calls concrete interface 
results back buffer exception raised server caught 
server sends event outgoing channel causing client thread wake 
client results re raises exceptions 
stubs transport entirely generated compiler system cases performance critical 
measurements taken null rpc times domains unloaded dec 
calls take compares favourably reported mach opal hardware 
calls experiments take experienced reschedule event transmissions 
nemesis currently implement full memory protection domains cost full protection domain switch consists single instruction flush data translation buffer dtb followed dtb misses 
cost dtb fill current hardware estimated 
inter process communication mechanism described fits needs inter domain invocation quite appropriate stream bulk transfer data 
pipes streams schemes controlling transfers integrated network buffering include mbufs fbufs schemes support application data unit adu transfer ip trailers scheme versions bsd 
full discussion schemes 
scheme intended principal mechanism interdomain streams streams devices application domains 
main design considerations requirements networking context demonstrated fileserver example intended general stream 
requirements buffering system nemesis slightly different systems 
nemesis applications negotiate resources possess availability guarantees 
means application certain amount buffer memory paged 
system short memory qos manager require application free certain amount 
fbuf system need highly dynamic reallocation buffers different data paths 
preferable multi recipient data need copied 
device hardware considerations useful distinguish network interfaces self selecting 
self selecting interfaces vci similar header arriving data access correct buffer control information 
typically high bandwidth interfaces dma support 
non self selecting interfaces require software copying data ethernet 
examples self selecting interfaces include aurora interface combination 
arriving packets enter special buffer memory arriving vci 
device driver reads headers instructs special dma engine copy data final location 
knowledgeable applications may special buffer pools special memory 
practice operating systems support protocol independent scheme determining process packets arriving interface destined 
known packet filtering technology highly advanced 
non self selecting interfaces packet filtering determine path data travel easily determine process receiver 
property assumed nemesis buffer mechanism derived 
older hardware devices dma required single non interrupted access contiguous buffer 
platforms bus architecture requires device burst maximum period relinquishing bus 
prevent cache write buffer starved memory bandwidth halting cpu 
devices expected internal buffering weather gaps 
high bandwidth available dma typical workstations depends accessing drams page mode 
accesses mean dma cycle re initiated crossing dram page boundary 
furthermore workstations designed running unix non contiguous mbuf chains 
result high performance dma hardware capable limited scatter gather capability 
protocol software considerations commonly protocols wish operate data stream ways 

add header ethernet ip tcp udp xtp 
add trailer xtp aal 
break request smaller sizes 
headers headers usually ensure data gets right place signify came particular place 
consider operations affect high performance stream particularly respect security 
internet security exists relies secure port numbers 
port numbers available highest authority machine receivers may assume packet bears full authority administrators source machine arbitrary user 
similarly important machines accurately report addresses 
reason transmission arbitrary packets prohibited transmission include correct headers authorised system 
reason having networking protocols kernel micro kernel implemented single networking daemon 

possible protocol implementations user process retain required security 
device driver perform security control 
broad spectrum possible ways engineering solution 
extreme device drivers include code trusted library understands protocol checks headers close implementing protocol device driver 
alternatively device driver include inverse packet filter code determines packet valid transmission reception 
packet filter reception process highly optimised 
implementation volatility buffer memory taken consideration driver protect process corrupting headers checked 
may entail copying security related fields header checking 
solution may rely caching secure part header device driver private memory updating packet fields 
fields checksums user process suffer initialised correctly 
udp tcp port values need secured 
ip length checksum fields secured ethernet fields secured 
final possible concern respect flow control congestion avoidance conceivably user process private code standards tcp congestion control 
various answers 
malevolent user process simply udp congestion control wished 
second operating system designed quality service support system easily limit rate process permitted transmit 
third application may fact able better resources network due application specific knowledge advanced experimental code 
trailers headers trailers usually contain security information 
trailers easily dealt requiring user process provide space correct padding packet receive transmit 
packet simply discarded loss user processes 
providing space difficult process known necessary value computed shared library discovered ipc call 
application data units applications application specific basic data units may large individual network packets 
example nfs blocks ethernet usually fragmented ip level 
ideally system permit application specify receive buffers way actual data interest application ends contiguous virtual addresses 
hand applications application basic data unit unit application considers loss sub part loss total may small 
may multimedia streams audio atm compressed tiled video 
streams application suffer large numbers interactions device driver able handle data stream aggregate small data units available 
operation rbuf design separates issues buffering ffl actual data 
ffl offset length aggregation mechanisms 
ffl memory allocation freeing concerns 
channel comprised data area actual data control areas aggregation information memory allocation managed independently channel owner memory 
data area rbuf data area consists small number large contiguous regions virtual address space 
areas allocated system backed physical memory 
revocation memory subject band discussion memory system 
large extent possible memory allocator keep contiguous regions virtual addresses backed contiguous regions physical addresses clearly platform dependent factor 
system provides fast mechanism converting rbuf data area virtual addresses physical addresses drivers perform dma 
platforms page table mapping indexed virtual page number exists tlb handler platforms table accessible device driver domain read status 
protection data area determined channel 
writable domain generating data readable domain receiving data 
domains may access data area especially channel spanning multiple domains see section vi 
domains logically owner sense allocates addresses data area 
rbuf data area considered volatile updateable domain generating data 
data aggregation collection regions data area may grouped form packet data structure known record 
closest form unix concept 
consists header followed sequence base length pairs 
header indicates number pairs follow padded size pair 
padding channels appropriate carry additional information 
example exact time packet arrived partial checksum information computed hardware 
points synchronisation important know exactly happened getting process immediately 
control areas control area circular buffer producer consumer arrangement 
pair event channels provided domains control access circular buffer 
event channels going writer reader indicates head position going reader writer indicates tail 
circular buffer memory protection writable writing domain read reading domain 
control area transfer information simplex direction channel 
control areas required form channel sizes chosen time channel established 
shows control area 
describes regions rbuf data area second describes single contiguous region 
usage data data data control area data area head tail fig 
rbuf memory arrangement shows domains control areas send 
control area described provides fifo queue ends channel 
equivalently channel composed simplex control area fifos form duplex management channel 
control areas matter channel 
process process control area control area data area fig 
control areas channel typical channel fact simplex data channel operating modes 
purpose modes allow support adus various contexts 
note requirement channel process data fifo manner merely buffering ends implemented 
transmit master mode tmm originator data chooses addresses rbuf data area places data places records control area 
updates head event control buffer indicating receiver record 
soon downstream side read records control buffer updates tail event freeing control buffer space records 
downstream side finished data places records control area queue direction signals head event control buffer 
originator likewise signals read returned control buffer 
originator free reuse data indicated returning control buffer 
receive master mode rmm operation control areas indistinguishable tmm difference rbuf data area mapped permissions reversed data placed allocated areas downstream side 
receiver data chooses addresses rbuf data area passes indicate wishes data placed downstream side 
downstream side uses control area indicate filled areas data 
master choosing addresses responsible managing data area keeping track parts free busy 
done way deemed appropriate 
applications fifo processing occurs ends may sufficient partition data area initiation channel performing subsequent allocation management 
table presents summary differences tmm rmm diagram shown loss generality master chooses addresses data area 
table tmm rmm properties tmm rmm chooses addresses manages data area write access data read access data event counts control areas available user channel possible operate non blocking manner 
reading event counts associated circular buffers blocking domain ensure rbuf ready collection space dispose buffer 
functions reliably event counts lose events 
routines blocking non blocking access standard parts rbuf library 
longer channels channel needed spans domains 
example may file serving application data arrives network device driver passes fileserver process passes disk driver 
channel set possible share certain areas rbuf data memory allocated domain channel 
domain may wish private direction connection ones accessible domains direction passing privileged information 
fileserver example fileserver may inode information accessible network device driver 
management channel may may middle 
example fileserver tmm communicating disk driver rmm communicating network driver 
important point data need copied longer chain provided trust holds 
shows channels fileserver 
simplicity shows control paths writes 
channel fileserver disk driver contain network buffer data area private inode data area 
network data buffer area receiving packets 
fileserver operating rmm endeavour arrange disk blocks arriving probably fragmented multiple packets contiguous single address space suitable manner writing disk 
complex channels cases flow data may simple channel 
case multicast traffic received multiple domains machine 
cases rbuf memory mapped readable recipients tmm channels recipient 
device driver places records control areas domains receive packet counts rbuf areas memory reused receivers indicated finished control areas 
apart lack copying domains benefit buffering memory provided compared scheme copying 
problem potentially arises receivers multicast data slower processing falls 
ideally able adverse affect receiver 
done limiting amount memory channel 
limit reached placed channel count 
buffers selectively dropped channels receiver unable keep 
appropriate margin may configured fan connection 
approximate efficient way implementing margin limit size circular control buffer 
dropped automatically inserted buffer non blocking manner 
disk device driver network device driver write fileserver data inode blocks written blocks tmm rmm put packets arrived packets inode memory mmu access network data memory writeable network readable disk fig 
longer rbuf channel control path fileserver writes accurate implementation margin required rbuf scheme ensures cost paid channels required general 
table ii comparison buffering properties mbufs fbufs page faults possible alignment ok 
copy user process copy clever device copy multicast 
copy retransmission support adus limit resource cleared vii 
current state nemesis implemented alpha axp mips arm platforms 
libraries ported platforms allow programming familiar environment required things integration limit result socket buffering 
copy user process memory 
networking code rounds sizes certain buffers clearing padding bytes included cause information leak bytes 
buffers cleared memory allocated 
allocation buffer usage fbufs frequent fbufs 
statics library code 
schedulers described developed scheduler far implemented arm platform window system provides primitives similar implemented 
experimentation implemented traditional shared server provide server rendering natural nemesis fashion library provide client rendering 
experiments shown client rendering system reduces application crosstalk enormously best effort applications competing continuous media applications rendering video display 
reported detail near 
atm device driver dec takes full advantage self selecting feature interface direct aal adaptation units directly memory position desired receiving domain rendering video network requires single copy main memory frame buffer 
application check frames discover placed frame buffer 
combination interface device driver mean contention outgoing atm streams occurs result scheduling processor cells hit network wire 
plans nemesis immature done 
represents fundamentally different way structuring operating system regarded family operating systems 
core concepts events domains activations binding minimal kernel define operating system 
task create libraries device drivers system domains provide complete operating system nemesis substrate 
window system filing system ip protocol stack providing initial server implementation porting code platforms moving client execution implementation 
filing system protocol stack just entered second stage 
components stable expect develop port applications take advantage facilities particular flexible quality service guarantees available nemesis architecture 
nemesis means instrumenting multimedia applications trace resource usage directly application domains get accurate picture application performance 
nemesis represents attempt design operating system support multimedia applications process continuous media 
consideration quality service provision application crosstalk led design applications execute code directly shared servers 
shared servers security concurrency control 
organisation gives rise number problems complexity solved typing transparency modularity definition interfaces closures provide comprehensible safe extensive sharing code data 
application programmers protected paradigm shift api need change new facilities required porting library case point 
development new operating system small task 
developed years help large number people 
indebted worked pegasus project 
mullender leslie mcauley operating system support distributed multimedia proceedings summer usenix conference boston massachusetts usa june pp 
available pegasus 
wetherall tennenhouse programming system visual processing digital video proceedings acm multimedia san francisco ca usa oct 
coulson campbell robin blair papathomas design qos controlled atm communication system chorus ieee journal selected areas communications vol 
pp 
may 
mcauley protocol design high speed networks tech 
rep university cambridge computer laboratory january ph dissertation 
tennenhouse layered multiplexing considered harmful protocols high speed networks rudin williamson eds 
elsevier 
mogul efficient workstations passive monitoring local area networks computer communication review 
acm sigcomm september vol 

mccanne jacobson bsd packet filter new architecture user level packet capture usenix winter conference january pp 

demers keshav shenker analysis simulation fair queueing algorithm journal internetworking research experience vol 

wilkes needham cambridge cap computer operating system north holland 
brian bershad thomas anderson edward lazowska henry levy lightweight remote procedure call acm transactions computer systems vol 
pp 
february 
clifford mercer stefan savage tokuda processor capacity reserves operating system support multimedia applications proceedings ieee international conference multimedia computing systems may 
embedded application number processes small 
thekkath thu nguyen evelyn moy edward lazowska implementing network protocols user level tech 
rep department computer science engineering university washington seattle wa 
barham mcauley pratt devices desk area network ieee journal selected areas communications vol 
may 
khalidi michael nelson implementation unix object oriented operating system tech 
rep sun microsystems laboratories december 
thomas anderson brian bershad edward lazowska henry levy scheduler activations effective kernel support user level management parallelism acm transactions computer systems vol 
pp 
february 
reed synchronization sequencers tech 
rep mit laboratory computer science 
mills internet time synchronisation network time protocol internet request comment number october 
dixon system support multi service traffic tech 
rep university cambridge computer laboratory september ph dissertation 
liu james layland scheduling algorithms multiprogramming hard real time environment journal acm vol 
pp 
january 
black explicit network scheduling tech 
rep university cambridge computer laboratory december ph dissertation 
birrell guttag synchronization primitives multiprocessor formal specification tech 
rep digital equipment systems research center 
timothy roscoe structure multi service operating system phd thesis university cambridge computer laboratory april available technical report 
bjarne stroustrup design evolution addison wesley 
dave otway ansa binding model ansa phase iii document apm architecture projects management limited poseidon house castle park cambridge cb rd uk october 
andrew birrell greg nelson susan owicki ted wobber network objects proceedings th acm sigops symposium operating systems principles operating systems review vol 
pp 
dec 
object management group common object request broker architecture specification draft th december omg document number revision 
brian bershad thomas anderson edward lazowska henry levy user level interprocess communication shared memory multiprocessors acm transactions computer systems vol 
pp 
may 
organick multics system examination structure mit press 
jeffrey chase henry levy michael feeley edward lazowska sharing protection single address space operating system technical report revised january department computer science engineering university washington apr 
leffler mckusick karels quarterman design implementation bsd unix operating system addison wesley 
druschel peterson fbufs high bandwidth cross domain transfer facility proceedings fourteenth acm symposium operating systems principles december pp 

leffler karels trailer encapsulations internet request comment number april 
druschel peterson davie experiences high speed network adaptor software perspective computer communication review 
acm sigcomm september vol 
pp 

edwards watson banks dalton user space protocols deliver high performance applications low cost gb lan computer communication review 
acm sigcomm september vol 
pp 

maeda bershad moss mach packet filter efficient packet demultiplexing multiple endpoints large messages usenix winter conference january pp 

digital equipment industry group specifications version 
synchronisation services digital continuous media tech 
rep university cambridge computer laboratory march ph dissertation 
ian leslie received sc sc university toronto ph university cambridge computer laboratory 
university lecturer cambridge computer laboratory 
current research interests atm network performance network control operating systems support guarantees applications 
derek mcauley obtained mathematics university cambridge ph atm internetworking addressing issues interconnecting atm networks 
years computer laboratory cambridge lecturer moved chair department computing science university glasgow 
research interests include networking distributed systems operating systems 
concentrated support time dependent mixed media types networks operating systems 
included development atm switches devices leading dan architecture development operating systems exploit systems components 
richard black obtained bachelor degree computer science ph university cambridge 
awarded research fellowship churchill college continue research university cambridge computer laboratory 
research interests interaction operating systems networking 
previous activities included desk area network atm switch 
timothy roscoe received ba degree mathematics university cambridge phd degree university cambridge computer laboratory principal architect nemesis operating system author initial alpha axp implementation 
currently vice president research development durham north carolina 
research interests include operating systems programming language design distributed naming binding network protocol implementation world wide web chapel hill music scene 
paul barham received degree computer science university cambridge cambridge uk working ph degree 
currently involved pegasus measure projects computer laboratory investigating quality service provision operating system particularly subsystem multimedia workstations 
research interests include operating systems workstation architecture networking distributed parallel prolog 
includes kernel device drivers nemesis dec axp platforms client rendering window system extent filesystem supporting qos guarantees 
david received degree physics theoretical physics ph degree computer science university cambridge cambridge uk respectively 
currently member staff research cambridge continues software support devices applications distributed multimedia atm environment 
robin received degree mathematics diploma computer science university cambridge uk 
worked cap project university cambridge computer laboratory worked digital cartography satellite remote sensing 
current pegasus measure projects working ph investigating provision quality service operating systems 
received sc eng sc 
degrees university queensland australia ph university cambridge computer laboratory uk 
currently member technical staff networked computing research department bell laboratories murray hill 
interests include operating systems high speed networks multimedia systems 
