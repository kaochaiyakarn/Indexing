clustering thinking triangulation denise draper cs washington edu department computer science engineering university washington seattle wa undirected technique evaluating belief networks jensen lauritzen spiegelhalter requires clustering nodes network junction tree 
traditional view junction tree constructed cliques moralized triangulated belief network triangulation taken primitive concept goal clustering algorithm node elimination directed 
alternative conception clustering clusters junction tree property play role primitives graph tree clusters obey modified version junction tree property transform graph obtained tree 
advantages approach clearer easier understand important humans constructing belief networks admits wider range heuristics may enable efficient superior clustering algorithms serves natural basis incremental clustering scheme describe 
belief networks directed acyclic graphs nodes represent uncertain variables arcs nodes represent probabilistic interactions variables 
belief network parameterized providing variable conditional probability variable parents network 
variables parents network simple prior probability provided 
belief network may evaluated give marginal probability variables network possibly conditioned observations values variables 
algorithms evaluating belief networks shown shachter known exact algorithms equivalent undirected belief network evaluation technique jensen lauritzen spiegelhalter algorithm works stages stage junction tree constructed second stage messages propagated junction tree 
give short review triangulation junction tree construction detail see jensen kong kjaerulff jensen jensen junction trees traditionally constructed method 
belief network adding arcs connecting pair parents variable network dropping directions arcs 

triangulate undirected network adding fill arcs chord cycles length greater remain 

create tree vertices cliques triangulated graph connected junction tree property holds cliques contain particular variable clique path cliques contain variable 
triangulation usually done node elimination proceeds iteratively follows 
select non eliminated variable eliminate 

add fill arcs connecting non eliminated neighbors union neighbors fully connected 

mark eliminated 
variables eliminated graph guaranteed triangulated 
cost junction tree cost doing message propagation tree proportional sum sizes potentials clique tree 
size potentials product number states variable clique 
different choices fill arcs generate junction trees radically differing cost ing cost junction tree np complete arnborg effective known heuristic minimum weight heuristic eliminates variable non eliminated neighbors form clique smallest potential kjaerulff difficulty node elimination triangulation general difficult understand 
original graphical structure belief network doesn help generally difficult determine visually graph triangulated seeing cliques triangulated graph difficult especially large overlaps 
belief networks constructed people complexity belief network evaluation may assumed people interested engineering networks reduce cost evaluation 
difficulty visualizing clustering process engineering difficult 
shachter jensen jensen underscores fundamental importance triangulation plays known belief network evaluation algorithms 
follow think terms triangulation hidden triangulation may just effective overt triangulation 
remainder new framework construction junction trees overtly triangulation 
section introduces cluster graphs generalization junction trees multiply connected graphs explains general principles transforming cluster graph junction tree 
section enumerates transformations process section combines transformations algorithms transformational equivalent node elimination algorithm completely new algorithm 
original motivation undertaking research find algorithm incremental clustering allow dynamic addition variables arcs belief network forcing recomputation entire junction tree section presents algorithm incremental clustering arises quite naturally cluster graph framework 
section presents empirical results algorithms section concludes 
cluster graphs junction tree belief network graph vertices clusters sets variables properties singly connected 
tree 
family property 
variable network cluster contains family union parents 
junction tree property 
clusters contain variable cluster path contain furthermore edge clusters associated separator defined intersection clusters 
generalize definition removing property modifying third changing definition separators 
cluster graph belief network graph vertices clusters family property path property modification junction tree property graphs path property 
clusters containing variable exists path cluster path contains separator edge path contains edge clusters associated separator subset intersection clusters 
say edge carries variables separator 
theorem singly connected cluster graph junction tree 
proof obvious definition separators 
consider adjacent clusters singly connected cluster graph path property asserts variable exists path edge carries variable 
singly connected path edge connects 
edge carry note cluster graph belief network trivially constructed creating cluster variable containing family variable connected topology directions arcs 
singly connected polytree cluster graph junction tree 
describe method constructing junction trees starting cluster graph constructed modify transformations preserve cluster graph properties terminate cluster graph rendered singly connected 
clear sufficient resolve multiply connected components cluster graph note cluster graphs different junction graphs jensen junction graphs find junction trees graph triangulated edges pair overlapping cliques 









merge transformation 
separately multiply connected component cluster graph transformed singly connected subgraph adding edges components singly connected 
furthermore restriction multiply connected components recursively transformation succeeds rendering set clusters necessary consider transformations clusters 
wide variety possible transformations algorithms demonstrate examples sections 
transformations transformation operation maps cluster graph preserving family path properties 
transformations explored easy grasp visually typically affect small set clusters adding deleting edges adding variables clusters merging clusters 
merge 
clusters merged union variables union edges clusters demonstrated 
clusters merged create new cluster edges third cluster edges merged new edge merging separators 
pearl clustering technique pearl modeled merge transformations 
special kind merging cluster superset 
triangulation section give stronger result possible certain reasonable conditions resolve iteratively resolving multiply connected subgraph considered algorithms violate restore properties clearly possible 






steal edge transformation 






slide transformation 
tive kind merging happens automatically cliques definition maximal 
scheme transformations done explicitly 
steal edge 
steal edge transformation illustrated 
edge connecting clusters replaced edges pass third cluster order retain path property variables carried edge added 
note new edges need carry old separator larger intersection clusters example path property held transformation path carrying path exists transformation 
slide drop 
slide drop transformations seen special cases steal edge transformation respectively edges exist 
example slide shown named resembles sliding edge cluster neighboring cluster 
drop transformation occurs triangle edges simply deleted 
cases opposite cluster edges cluster augmented necessary carry separator deleted edge 
collapse 
collapse transformation takes simple cycle clusters deletes edge cycle restores path property added separator deleted edge cluster edge cycle 
argument shachter transformational equivalent conditioning 
node elimination 
eliminating node modeled elegantly transformation 
original definition node elimination select variable node add fill arcs necessary connect un eliminated neighbors mark eliminated 
eliminate transformation takes arguments variable set clusters eliminated typically corresponds clusters containing unmarked variables 
clusters represent cliques subsets cliques underlying graph set unmarked neighbors union variables clusters contain bold clusters 
adding fill arcs connect neighbors merging clusters contain single cluster elim 
marking variable eliminated translates creating second buffer cluster buffer contains variables elimination cluster inherits edges clusters incident merged clusters 
construction elim connected part cycles remaining elim need participate transformations variable effectively eliminated consideration 
variable eliminated set clusters eliminated clusters may clusters outside contain variable merged elimination cluster 
order retain path property edges outside merged clusters carry connected elimination cluster buffer cluster 
fact simply migrate edges merged clusters clusters outside elimination cluster 
section indicated necessary consider entire cluster graph doing transformations restrict attention biconnected component cluster graph 
set biconnected component variable eliminated remains outside reproduced refinement elimination algorithm described kjaerulff theorem cites fujisawa source 
wish point optimization arises quite naturally perspective transformations need preserve path property 
dropping spurious variables 
transformations may result variable cluster serves purpose member 






elim buffer 

eliminate transformation eliminates variable set clusters merging bold clusters bold clusters 
family cluster carried cluster 
call variable spurious variable 
order detect spurious variables efficiently note cluster variables part families preserved obviously clusters merged new merged cluster inherit family annotations old clusters 
shows example arise slide transformation variable carry transformation spurious edge 
spurious variables generated transformations steal edge 
spurious variables dropped removing pertinent cluster incident edge carries 
edge cluster empty result removal dropped cluster graph 
define transformations check remove spurious variables created spurious variable removal defined separate transformation right case transformation operate recursively possibly removing entire chains spurious variables 
general notion possible 
consider clusters need variable connected distinct paths carrying cluster paths needs removed part paths compromising path property 
transformation detected removed set clusters edges needed possible lack locality information impractical 
completeness describe transformation corresponding adding single fill arc underlying moral graph belief network add arc cluster contains 
cluster contains done 
remaining variable say added path property restored adding new edge carrying cluster containing wide variety possible cluster graph transformations 
successful general clustering strategy transformations may transformations useful certain special cases 
algorithms transformations need put sequence transform arbitrary cluster graph junction tree 
issue termination addressed clear instances slide transformation undo resulting progress 
cycles result combinations transformations 
attempted general categorization terminating transformation sequences characterize class algorithms function repeatedly identifying transforming multiply connected subgraphs cluster graph 
show construct algorithm transform cluster graph junction tree starting algorithm transform subgraph singly connected subgraph 
subgraph required include edges clusters see 
section transformations described deleting adding edges graph 
proof find convenient define migrating edge deleting edge adding endpoints deleting adding 
wish generalize idea adding edge speak adding edge edge exists case new edge merged existing edge 
example describe merge transformation migrating edges multiple edges merged edge 
theorem algorithm functions repeatedly finding multiply connected subgraph cluster graph halting invoking subroutine sub terminate transformed junction tree example dynamic restructuring transformation described shachter take advantage location evidence junction trees certain topology 
subroutine sub obeys properties 
sub terminates 

sub uses transformations preserve family path properties respect entire graph 
sub transforms singly connected subgraph 

effect sub may clusters edges outside edges clusters may deleted migrated 
edges clusters gns clusters may migrated endpoints permitted move 
proof junction tree singly connected family path properties hold 
family path properties hold follows property 
show singly connected establish disconnected invocation sub subgraph clearly disconnected clusters connected paths outside remain connected 
set edges connect clusters gns clusters clusters gns previously connected path passing path number edges suppose edges 
subroutine edges sx sy possibly migrated versions old edges connected path sx sy remains connected 
show quantity edges clusters decrease invocation sub eventually reach implying singly connected 
simple algebraic proof defined quantities gns clusters invoking sub nt number clusters ns number clusters number edges clusters number edges number edges ks ns number edges clusters invoking sub change ns ffi change ffi change initially total number clusters nt ns number edges 
sub invoked number clusters ns number edges ffi ffi 
putting edges clusters edges clusters ns ks nt ns ffi ffi nt ks ffi ffi ks ffi ffi difference number edges number clusters decrease invocation sub eventually 
describe algorithms transforming arbitrary cluster graph junction tree 
node elimination algorithm second new algorithm 
node elimination set clusters take set variables eliminated union variables clusters choose variable eliminate eliminated subset clusters merged new clusters elim buffer created 
recursively call node elimination xg 
note necessary continue variables eliminated singly connected 
original invocation traditional node elimination algorithm 
alternatively theorem create new algorithm iteratively invoking divide loops divide loops iteratively finds cycle set nodes recursively transforms away subroutine call divide loop 
divide loop uses steal edge slide recursively subdivide cycle smaller cycles smaller cycle branch eventually encountering cycles length resolved drop transformation 
shows example 
theorem guarantees divide loops correctly transform junction tree divide loop clearly terminates affect edges clusters outside cycle invoked possibly delete edges clusters divide loops parameterized choice cycle divide loop divide loops transforms graph tree recursively subdividing cycle 
transformation apply trio clusters 
tried greedy heuristics discussed section 
pre postprocessing addition procedures render subgraph singly connected may consider procedures transform ways 
preprocessing aimed making subgraph singly connected simplifying ways hope improve performance main algorithm making faster causing generate lower cost tree 
postprocessing takes singly connected subgraph applies transformations improve cost 
pre postprocessing procedures applied globally individually subgraphs free variable elimination preprocessing procedure uses eliminate transformation eliminate variable occurs cluster node elimination known free variables eliminated increasing cost final junction tree rose merging redundant clusters cluster subset preprocessing step 
subtlety suppose subset variables carrying neighbors part family 
disadvantageous merge preprocessing step subsequent transformations remove variables merged 
avoid require family variables subset family variables merging redundant clusters valuable postprocessing step 
definition junction tree section require clusters cliques maximal clearly advantage retaining clusters cliques 
section indicated slide transformation result spurious variables dropped 
combination slide dropping spurious variables changes cost cluster graph change equal decrease size potential cluster looses edge minus increase size cluster acquires edge 
note slide applied tree result tree 
postprocessing procedure slide beneficially edges tree finding slide transformations reduce cost tree dropping spurious variables 
incremental clustering structure belief network modified dynamically reasons desirable modify existing junction tree incrementally generating new scratch network large modifying existing junction tree considerably expensive generating new 
incremental modification produce stable results previous tree important junction tree network designer especially designer trying optimize junction tree 
incremental clustering natural framework 
assume basic acts modifying belief network addition deletion arc variable 
add new variable 
create new cluster containing variable variable parents add arcs follows 
add new arc find cluster containing family variable add family 
find cluster containing family add edge add separator existing edge 
delete arc find cluster containing family variable remove family spurious may simply dropped appear family spurious carries adjacent clusters may retract adding edges carrying sufficient connect neighbors contain removing incident edges 
retraction may carried recursively edges carrying clusters member family 
delete variable 
delete arcs variable variables remove family cluster cluster empty 
modifications junction tree cause multiply connected invoke algorithm transform back tree 
transformations section correctness procedures follows maintenance family path properties 
incremental clustering network modified ways 
example junction tree modified optimize computation placement evidence network 
particular query variable identified junction tree modified omit separated parts network 
empirical results transformations section algorithms section implemented common lisp 
run experiments networks ii networks study triangulation techniques kjaerulff randomly generated networks 
variables arcs ii variables arcs names randomly generated networks see indicate number variables arcs respectively 
networks non binary variables 
performed kinds tests tests algorithm applied entire network biconnected components original cluster graph incremental tests network built contiguously adding arcs calling transformation algorithms cluster graph multiply connected 
experimented retraction 
kind test ran algorithms times randomly breaking ties generated heuristic ranking transformation perform 
node elimination min weight heuris completely reverse operations generated junction tree necessary able take apart clusters component families connected sufficient edges guarantee path property naturally 
matter heuristics 
id id ii id id id id comparison node elimination divide loop divide loop applied incrementally id node elimination applied incrementally networks 
algorithm bars represent order minimum median average cost junction tree sum sizes cluster potentials runs 
tic merge redundant clusters postprocessing step tried slide beneficially helped 
quite number parameterizations divide loops possible choices pre postprocessing steps apply apply cycle individually call divide loop apply entire graph cycle picked cluster random tried finding cycle shortest length lowest cost weighted combination shortest length lowest cost transformation divide cycle minimize increase cluster cost minimize increase cost minimize increase cluster degree combinations thereof 
results show different parameterizations divide loops indicated id performed best respectively experiments real networks experiments artificial networks incremental experiments networks 
preprocessing free variable elimination call divide loop 
choice cycle weighted combination shortest cheapest prefers shortest expensive 
choice transformation minimize increase cluster cost 
postprocess entire graph finished slide beneficially followed merge redundant clusters 

choice cycle shortest cycle 
id postprocessing done call divide loop include merging 
probably surprising result merging redundant clusters bad idea processing done incremental clustering best results show significantly affect cost result 
strongest impression experiments divide loops high variance matter choice parameters 
cases median may lower node elimination average higher minimum lower 
divide loops works single cycle time surprising performance substantially applied incrementally applied ii 
node elimination hand performs generally worse applied incrementally especially denser networks 
appears divide loops competes favorably node elimination denser networks sparser networks 
results indicate algorithm superior new algorithm different principles comparable 
encourages believe clustering framework may yield algorithms 
long research implemented simple graphical interface demonstrate effect transformations 
interface quickly discovered existence spurious variables able rule heuristics ineffective 
graphical interface simple visual nature transformations greatly aided understanding 
feel simplicity equally beneficial belief network designers making easier understand computational properties networks 
viewing clustering process transformations opens wide vista possible new heuristic approaches clustering may prove superior known methods 
possible transformations algorithms employ embarrassment simply possibilities explore 
analysis revealing organizational properties space quite helpful example sets transformations complete sense generate minimal triangulations summary new framework clustering algorithms transformations cluster graph triangulation 
demonstrated set transformations framework new algorithm transformations 
demonstrated algorithm incrementally clustering dynamically changing network 
acknowledgments kjaerulff providing ii networks mike williamson insightful comments 
research funded national science foundation iri 
kong russell kong 
optimality issues constructing markov tree graphical models 
research report harvard university april 
arnborg stefan arnborg derek corneil andrzej 
complexity finding embeddings tree 
siam journal algebraic discrete methods april 
fujisawa fujisawa 
efficient algorithm finding minimal triangulation graph 
ieee international symposium circuits systems pages 
jensen jensen finn jensen frank jensen 
optimal junction trees 
proceedings uai pages seattle wa july 
jensen finn jensen steffen lauritzen olesen 
bayesian updating causal probabilistic networks local computations 
computational statistics quarterly 
jensen finn jensen olesen anderson 
algebra bayesian belief universes knowledge systems 
networks 
jensen finn jensen 
junction trees decomposable hypergraphs 
research report aalborg denmark 
kjaerulff kjaerulff 
triangulation graphs algorithms giving small total state space 
technical report department mathematics computer science aalborg university denmark march 
lauritzen spiegelhalter steffen lauritzen david spiegelhalter 
local computations graphical structures application expert systems 
journal royal statistical society 
pearl judea pearl 
probabilistic reasoning intelligent systems networks plausible inference 
morgan kaufmann san mateo california 
rose donald rose endre tarjan george 
algorithmic aspects vertex elimination graphs 
siam journal computing 
shachter ross shachter 
anderson peter szolovits 
global conditioning probabilistic inference belief networks 
proceedings uai pages seattle wa july 
