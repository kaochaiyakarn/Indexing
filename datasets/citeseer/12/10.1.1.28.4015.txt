efficient accumulators trapdoor extended tomas sander international computer science institute center street berkeley ca usa sander icsi berkeley edu 
benaloh de mare introduced notion way accumulators allow construct efficient protocols proving membership list related problems time stamping authentication 
required benaloh signature protocols central trusted authority needed 
accumulator protocols improve hash tree protocols proving membership list verification storage requirements independent number items list 
benaloh accumulator construction exponentiation modulo rsa modulus pq 
noted benaloh party parties generated needed rsa modulus system set knows factorization knowledge allows party completely bypass security accumulator protocols 
example time stamping agency forge time stamps arbitrary documents 
parties need trusted ways 
abuse knowledge trapdoor secondly adequate security place system set prevented outside attackers getting hold describe way construct generalized rsa moduli factorization unknown anybody 
yields theoretically efficient accumulators knows trapdoor mentioned trust requirements parties set system removed 
keywords way accumulator rsa modulus 
basic idea accumulator authentication scheme suggested benaloh de mare follows rsa modulus zz theta fy ym ae zz theta list items membership proved 
accumulated hash value list defined value deltay delta delta deltay mod assume victor obtained authenticated channel 
prove membership element alice presents victor th root victor accepts ii assume fact belongs list th root computed raising power alice obtained computed knowledge items victor prove contributed accumulated hash bari pfitzmann showed basic scheme turned provably secure scheme assuming variants rsa assumption describe accumulator protocol forging membership proofs unfeasible :10.1.1.43.4889
postpone discussion security accumulator protocols section 
main advantage accumulator protocols proving membership list protocols merkle authentication trees improved efficiency hash tree protocols elements list authenticated inserted leaves hash tree 
assume victor obtained root hash tree authenticated channel 
prove membership alice presents victor hash path leading leaf root victor verifies correctness path 
alice needs store log values victor checking correctness path depends logarithmically number items contrast complexity accumulator protocols independent number items hashed length hash chain alice needs prove membership collapses 
accumulator schemes efficient serious disadvantage hash tree authentication schemes 
hash tree schemes secure sole cryptographic assumption hash function strongly collision resistant party able forge membership proofs 
longer case accumulator protocols 
efficient accumulator constructions known today rsa type functions 
problem rsa modulus needs constructed system setup 
rsa moduli typically choosing random large primes multiplying 
party provides system setup knows trapdoor unfortunately party knows completely bypass system security 
forge membership proofs arbitrary values zz theta party computes ty mod 
th root proves victor undesirable property applications benaloh asked original accumulators trapdoor constructed 
main result question affirmative answer 
secure multiparty computation protocols employed system setup colluding curious coalition group recover general problem knows trapdoor remains distributed setting 
iii describe examples illustrate weaknesses accumulators known trapdoor 
efficient round time stamping protocol accumulators suggested 
round submitted documents hashed accumulator 
time stamping agency parties provided modulus forge arbitrary time stamps document choice 
time stamping agency needs fully trusted abuse knowledge trapdoor destroyed system set 
different example provided electronic cash scheme suggested sander ta 
system offers unconditional anonymity previous blind signature schemes vulnerable bank attack 
serious bank attack described jakobsson yung 
attack secret key bank uses sign coins compromised insider attack 
scheme described users submit withdrawal hash values electronic coins bank inserts leaves hash tree 
root distributed merchants bank 
payment user demonstrates merchant validity coin proving zero knowledge argument hash path system resistant bank attack critical bank secrets allow forge money 
speed system asked accumulators trapdoor exist substitute hash trees 
remarked parties know trapdoor accumulator forge arbitrary amounts electronic money 
resistance scheme bank attack partially lost existing accumulators 
system set scheme vulnerable bank attack 
examples motivate useful accumulators trapdoor 
accumulators trapdoor construction accumulator trapdoor nyberg 
accumulator provably secure 
accumulator space efficient time efficient accumulated hash items length log 
potential performance advantages offered accumulator protocols preserved 
efficient accumulators far exponentiation modulo rsa modulus 
note rsa type accumulator described benaloh exploitable trapdoor algorithm outputs rsa moduli pq parties executing algorithm way extract best knowledge algorithm known today 
unfortunately algorithm 
avoid problem constructing rsa moduli suggest generalized rsa moduli unknown complete factorization construction accumulators 
abuse notation call numbers 
call number rsa ufo large prime factors iv infeasible coalition players including generated find splitting factors infeasible construct splitting factors separate suggest theoretically efficient algorithm constructs rsa ufo high probability security parameter element ffl algorithm running time polynomial log ffl outputs element rsa ufo primes bit length probability gamma ffl 
call number ffl rsa ufo 
choosing ffl sufficiently small practically desirable degree certainty achieved 
algorithm outputs ffl rsa described section 
techniques bari pfitzmann construct section accumulator ffl rsa knows trapdoor :10.1.1.43.4889
show accumulator provably secure natural rsa type assumption 
constructing generalized rsa moduli unknown factorization general strategy construction ffl rsa follows prove constant fraction integers bit length roughly distinct prime factors bit length picks uniformly independently log ffl integers bit length 
probability numbers distinct prime factors length gamma ffl 
product delta delta delta factor large distinct prime divisors 
avoid cheating random choices choosing bits expansion numbers public publicly verifiable random source see paragraph brief discussion ways achieved 
argue reasonable believe ffl rsa ufo 
factors say distinct bit prime divisors assume coalition players able produce splitting factors probability polynomially randomly chosen numbers common large prime factor negligible 
gcd gcd yield splitting large number factors contains different large prime divisor player simulate choices random numbers 
algorithm non negligible probability success splits random number large prime factors factors separate completely infeasible task available factoring algorithms 
theorem 

number integers distinct prime factors gamma ln ln delta proof 
fy xg set multiples smaller equal qx pq number integers divisible distinct primes furthermore denote number primes ln logarithm base deltac greatest integer function 

distinct sets pq rs disjoint pq rs lcm lcm prime divisors case 
pq gamma pq gamma delta get gamma pq gamma delta gamma pq gamma delta gamma pq gamma ln delta series converges 
estimate sum known number theoretic fact constant py ln ln cf 

identity obtains ln ln gamma ln ln ln 
pq gamma ln delta ln obtain gamma ln delta gamma ln ln delta claim proved 
vi describe algorithm construct rsa ufo input outputs rsa ufo modulus bit length kl 
slightly larger picked 
sufficiently large 
theorem constant depending previous choice randomly chosen number bit length rsa ufo probability chooses list random numbers bit length done choosing bit bit representation public random source 
probability elements rsa ufo rsa ufo modulus bit length kl algorithm construct rsa ufo outputs careful determination constants contained full version 
certainly improvements general algorithm possible order obtain rsa smaller bit length 
may test sampled numbers primality throw prime away 
furthermore divide small prime factors elements decrease bit length output 
think theoretically interesting question algorithm produces rsa ufo moduli bit length smaller kl 
practical applications interesting find rsa bit length small possible parameters give adequate security practical applications 
example interesting rsa offering security comparable usual bit rsa moduli 
ask smallest bit length rsa 
basic algorithm sketched yield output bit length greater bits parameters may large practical applications 
generation public random strings construction depends availability publicly verifiable random strings 
describe example give idea strings may practice 
assume november congress publicly decides string generated 
congress may fix date noon december decide stock quotations nyse nasdaq time generation random string 
procedure generate stock market data random string fixed congress november 
noon dec snapshot stock market taken predetermined hash function hashed shorter string 
random bits needed may repeat procedure predetermined dates concatenate obtained strings 
congress decision public everybody knows snapshot taken 
stock market quite unpredictable particular possible reasonable coalition players vii able manipulate stock market way output hash functions substantially influenced forced belong small set values 
hash function extract assumed randomness stock market data produce bits close uniform 
important party verify procedure construct random string correctly executed 
certainly heuristic argument plausible practically useful ways generate certified public random string exist 
accumulators generalized rsa moduli section described algorithm outputs rsa 
section construct provably secure accumulators techniques developed :10.1.1.43.4889
intuitively accumulator secure list hashed accumulated value infeasible produce membership proof element belonging assume regular rsa modulus basis zz theta exponentiation 
original protocol authenticate elements list fy ym accumulators secure sense described 
recall authenticate value alice needs th root victor 
alice knows authenticate elements ym belong element delta may belong th root general subset ae value authenticated value lns list contains items potentially items authenticated 
clearly unsatisfactory 
bari pfitzmann solve problems restricting inputs accumulator function prime numbers alice authenticates value th root verification step victor checks prime 
restrict accumulators inputs restricted prime numbers victor checks primality verification 
bari pfitzmann introduce stronger notion security accumulators requiring unfeasible construct list membership proof element forged adversary allowed choose list 
accumulator achieves requirement called collision free :10.1.1.43.4889
strong notion security appropriate applications sketched 
time stamping application possible produce viii time stamps documents submitted time accumulated hash computed matter submitted documents chosen 
electronic cash application users submit hash values coins bank inserts leaves hash tree 
assure users able forge money able submit set coins bank prove new forged coin belongs tree 
substitute trees accumulators necessary preserve property accumulator schemes 
bari pfitzmann definition collision freeness considers adversaries know factorization accumulator collision free parties know trapdoor consider stronger definition security requiring coalition polynomial time players able forge membership proofs 
bank insiders forge electronic coins time stamping agency forge time stamps 
call accumulators achieving stronger security property universally collision free 
definition 
family accumulators called universally collision free infeasible coalition probabilistic time bounded players find list fy ym ae zz theta authenticates delta delta deltay mod nonnegligible probability success 
strong rsa assumption formulated collision freeness accumulator adversaries knowing trapdoor proved :10.1.1.43.4889
formulate strong rsa ufo assumption prove security accumulator coalition polynomial time players 
strong rsa problem zz theta find prime element strong rsa ufo assumption construct rsa ufo probabilistic algorithm described section outputs composite number probabilistic polynomial time algorithms polynomials sufficiently large mod prime log construct rsa ufo zz usual rsa assumption adversary allowed pick exponent suggest rsa type accumulator described modulus rsa ufo output algorithm construct security parameters random number modulo constructed public random source inputs accumulator restricted set primes log 
ix theorem 
strong rsa ufo assumption accumulator universally collision free 
proof 
proof proceeds 
assume rsa ufo adversary find collision accumulator parameters find list primes fy ym ae prime element delta delta deltay prime integers delta delta delta ym vy adversary extract th root prime breaking strong rsa ufo assumption 
strong rsa ufo assumption strong rsa ufo assumption obtained strong rsa assumption formulated considering rsa usual rsa moduli note variants regular strong rsa assumption :10.1.1.43.4889
strong rsa assumption tested long arguments support soundness assumption :10.1.1.43.4889
want give relative argument believes strong rsa assumption reasonable believe strong rsa ufo assumption 
rsa moduli pq primes bit length commonly cryptographic applications constitute hardest known instances factoring algorithms running time measured bit length input 
argue reasonable believe computing th roots random elements zz theta obtained output construct rsa ufo log easier extracting th roots zz usual rsa moduli pq bit primes assume adversary able extract th root random element modulo output algorithm construct rsa ufo 
recall obtained product randomly chosen large numbers factor say distinct prime divisors length adversary compute th root mod particular compute th root mod mod random number modulo mod random number modulo oracle give adversary complete factorization free factorization divisor delta adversary left problem compute th root mod delta primes bit length pq 
problem doesn look easier computing th root modulo true rsa modulus product primes length exactly universally collision free accumulators random oracle assumption motivated fact strong rsa assumption needs tested assuming random oracle hypothesis collision free accumulator normal rsa assumption constructed :10.1.1.43.4889
replacing rsa moduli rsa construction proofs yields easily accumulator proved universally collision free normal rsa assumption formulated rsa ufo moduli random oracle hypothesis 
completely analogous construction omit details :10.1.1.43.4889
refer reader directly discussion conversion algorithm allows convert inputs prime numbers suitable inputs accumulator :10.1.1.43.4889
showed provably secure accumulator known trapdoor 
solution algorithm outputs integers large prime divisors knows complete factorization 
think theoretically practically interesting question algorithm produces integers smaller bit length algorithm described 
acknowledgments pleasure amnon ta helpful stimulating discussions lead 
stuart haber moti yung interesting conversations aspects 

pfitzmann 
collision free accumulators fail signature schemes trees 
eurocrypt advances cryptology proceedings eurocrypt volume 

josh benaloh michael de mare 
way accumulators decentralized alternative digital signatures extended 
tor editor advances cryptology eurocrypt volume lecture notes computer science pages 
springer verlag may 

camenisch 
group signature scheme improved efficiency 
lecture notes computer science 

fujisaki okamoto 
statistical zero knowledge protocols prove modular polynomial relations 
burton kaliski jr editor advances cryptology crypto volume lecture notes computer science pages 
springer verlag august 
xi 
hardy wright 
theory numbers 
oxford university press th edition 

jakobsson yung 
revokable versatile electronic 
clifford neuman editor rd acm conference computer communications security pages new delhi india march 
acm press 

merkle 
protocols public key cryptosystems 
ieee editor proceedings symposium security privacy april oakland california spring street suite silver spring md usa 
ieee computer society press 

nyberg 
fast accumulated hashing 
dieter editor fast software encryption third international workshop volume lecture notes computer science pages cambridge uk february 
springer verlag 

sander ta 
anonymous electronic cash 
appear proceedings crypto 
forthcoming volume lecture notes computer science 

adi shamir 
generation cryptographically strong pseudorandom sequences 
acm transactions computer systems february 

von naccache 
blind signatures perfect crimes 
computers security october 
