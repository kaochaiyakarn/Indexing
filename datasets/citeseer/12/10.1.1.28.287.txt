aspect oriented programming quantification obliviousness robert filman daniel friedman riacs computer science department nasa ames research center indiana university moffett field ca bloomington arc nasa gov cs indiana edu proposes distinguishing characteristic aspect oriented programming aop systems allow programming making quantified programmatic assertions programs written programmers oblivious assertions 
aop systems analyzed respect critical dimensions kinds quantifications allowed nature actions asserted mechanism combining base level actions asserted actions 
consequences perspective recognition certain systems aop mechanisms expressive allow programming aop system 
corollary aop applied object oriented programming independent concept applicable programming styles 

aspect oriented programming aop qua programming language 
interested determining language aop 
prompted question asked event publish subscribe example aop 
publish subscribe system separate concerns realized subscribing events interest concerns 
thinking question come belief properties quantification obliviousness necessary aop 
understanding relationships clarifies variety possible aop languages 
demonstrates systems aop systems environments easily build aop system 

local unitary statements programming languages writing structure statements compilation interpretation process elaborate series primitive directions 
directions finite text interpretation may unbounded 
earliest computer machine language programs strict correspondence program text execution pattern 
generally programming language statement unitary local unitary ended having effect precisely place elaborated program local proximate neighboring statements 
addressing structural essence aop application somewhat similar difference defining object oriented programming oop systems terms polymorphic methods inheritance versus objects appropriate way model world 
minor exception locality unitarity types 
type declarations nonlocal quantified effects type coercion type consistency checks 
types conventional languages example built separate concern 
history part programming languages moving away purely local unitary languages mechanisms programmer separate concepts pragmatically tied saying things just happen 
exceptions locality subprograms procedures subroutines functions 
subprograms great invention enabling abstracting behavior 
virtues separating concerns 
example expertise say runge kutta methods centered writer runge kutta library 
application programmers users library 
know runge kutta useful invoke locally explicitly call code 
cognizant going 
identify statements execute order program unitary exhibited direct correspondence statement programming language written sequence machine instructions executed 
inheritance object oriented programming oop second important non locality 
executing inherited behavior non local 
different fashions inheriting behavior send super mixins 
send super systems java smalltalk allow programmer explicitly invoke behavior parent class classes knowing exactly behavior invoked 
adding behavior classes higher class structure allows limited form quantified program statements statements effect loci underlying code 
example suppose wish introduce display aspect program simulating traffic movement 
want quantified statements moves executes move method screen updated imagine things move descendants class moveable object 
accomplish send super inheritance cooperative base class programmer consistently follow directions 
behavior move method movable object display update request programmers derivative classes invoke send super code 
requires derived class programmers know relieves having know exactly 
re restricted respect locus behavior ask programmers send super start code directions probably need consistent system 
requiring cooperation 
programmers may fail systematically cooperative base program may written may control 
true aop want system oblivious programmers ones don expend additional effort aop mechanism 
earliest example oblivious quantification mixin inheritance maclisp symbolics lisp 
mixins derived class functionality determined assembling code derived class advice super classes 
aspect programmer quantified statements code adding mixins derived class programmer remains ignorant actions 
scope quantification controlled classes inherit mixin 
quantify descendants superclass single method 
screen update example adding mixin movable object move accomplishes automatic update 
inheritance achieve aspects single superclass inheritance systems require aspects match class structure original program multiple inheritance systems allow quantification independent program dominant decomposition 
mixins multiple inheritance full aspect oriented programming technology 
general aop understood desire quantified statements behavior programs quantifications hold programs written oblivious programmers 
want able say code realizes concern 
execute circumstances hold breaks completely local unitary demands organize program form appropriate coding maintenance 
need local markings cooperation 
weaving mechanism aop system take quantified statements base program produce primitive directions performed 

quantification aop desire programming statements form programs condition arises perform action 
conventionally coded programs implies major dimensions concern designer implementer aop system quantification kinds conditions specify 
interface interface actions interact base programs 
weaving system arrange execution base actions program actions aop system quantified statements code execute circumstances 
quantify 
broadly quantify static structure system dynamic behavior 

static quantification static structure program text 
common views program text terms public interfaces program typically methods occasionally public variables parsed program syntax tree 
black box aop systems quantify public interface components functions object methods 
examples black box systems include composition filters synchronization advice 
simple implementation mechanism black box aop wrap components aspect behavior 
clear box aop systems allow quantification parsed structure components 
examples system include aspectj allows things quantifying calling accepting calls subprograms subject oriented programming composition rules allow quantifying elements interpretation variables modules 
aop system quantification language may simple just allowing aspect decoration subprogram calls complex represent pattern matching syntax tree program 
understood way clear box aop system allow static quantifications add print statement show new value assignment variable body loop variable occurs test loop clear box black box techniques advantages disadvantages 
clear box techniques require source code 
provide access static nuances program 
environments corba proxies equivalent straightforwardly implement caller side aspects aspects associated calling environment subprogram invocation 
black box techniques typically easier implement environments lisp trivial components source code lacking 
applied aop distributed systems important perform aspects actions client server machines 
fortunately common implementations distributed object systems corba employ proxy compiler easily subverted insert calls aspects 
black box techniques quantify program interface clear box techniques especially useful debugging 
example clear box system implement concern statement execution counting profiler writing log file update variable name starts log black box techniques produce reusable maintainable aspects aspect tied code module easily slip dependence coding tricks module 
interfaces imply contracts 
clear box techniques difficult implement usually imply developing major fraction compiler 
typical clear box implementation structural quantification needs obtain parsed version underlying program run transformation rules realizing quantified aspects syntax tree output resulting tree back source language processing conventional language compiler 
lot 

dynamic quantification dynamic quantification tying aspect behavior happens run time 
examples things raising exception 
call subprogram temporal scope call size call stack 
patterns history program try password routine failed times intervening successes 
keep mind abstractions programming languages structure execution program subset possible available abstractions scheme allows programmer capture current context current behavior 
programmers stack content knowledge pattern procedure calls straightforwardly recognizable long machine compiler remain constant 
lisp allows programmer access interpreter state 
elephant allows previous variable values 
ability program respect properties aspect programming language design 
elements absent underlying language aspect language may allow quantification 

implementation issues assertion suggests dimensions aspect oriented language design bear mentioning lack space discuss fully 
popularity java byte coding allows possibility quantifying respect byte code 
clearly quantify byte code features demanded jvm architecture method entry points 
extent recognizable features surface structure realized recognizable ways byte code quantify features class files 
luck different compiler 
exception handling catching remotely thrown exceptions provides dynamic quantification exception events late interesting things exception context lost 
interlisp mean mechanism allowed quantification exception events context exception 
fall structural relationships subprograms may invoked pointed function easily arise polymorphic oop 
call context problem instance jumping aspect problem 
concrete example problem arises move interior step move moving collection objects simultaneously 
case want update display grand operation 
context 
context underlying program action 
clear box systems go far aspect action seamless part resulting code tangling aspect expression specifics implementation raises questions real separation concerns 
quantification scope 
elements program quantify 
typical choices include methods objects class methods objects package methods name objects subclasses class instance level variations 
dynamic quantification 
quantified assertions running system dynamically adding removing actions 
incomplete obliviousness 
want application programmer oblivious aspect system times application needs communicate aspects 
example consider action provides higher quality service higher priority tasks 
application needs mechanism specifying current task priority 
action interaction 
actions communicate 
different actions locus action different loci may need exchange information 
example authentication access control aspects method object may need interact 
similarly authentication aspect objects may need share common space 
relative aspect orderings 
specify order multiple actions apply locus 
inconsistent aspects 
action may violate semantics 
example action logs progress may violate semantics transactional action 
aop system may linguistic mechanisms warning inconsistencies 
weaving 
implementation sense arrange behavior actions intermixed behavior base system code 
answer may include compile time weaving altering run time interpretation process 

aspect oriented languages return question aspect oriented language 
consider possibilities rule systems 
rule systems ops lesser extent prolog programming purely dynamically quantified statements 
rule says condition true corresponding action programmed rules wouldn aop discussions 
just talk rules expressed concerns added original system mention tricks involved getting rules run right order communicate 
base idea things going main flow control wouldn bit strange 
large people don program rule systems 
rule systems notoriously difficult program 
destroyed fundamental sequentially 
sequential local unitary style really nearly neat rule systems people insist doing matching conditions considering problem implementation detail 
expressing things 
cleverness classical aop augmenting conventional sequentially quantification wholesale 
event publish subscribe 
systems subscription mechanism precisely quantification mechanism 
know see 
question oblivious 
application programming style events interface components black box aop mechanism 
hand expect programmer scatter event generation purposes conventional programs oblivious aop 
intentional programming meta programming 
intentional programming ip meta programming mp provide ability direct execution order arbitrarily defined computational patterns 
seen environments writing transformation compilers mechanism implementing clear box aop self contained realizations aop idea 
generative programming 
similarly generative programming works transforming higher level representations programs lower level ones compiling high level specifications 
incorporating aspects transformation rules achieve aop generative programming environment 
correspondingly creator generative programming system may recognize aspects important domain specific system defined precisely leave place generative language expressing aspects 

closing remarks identified aop ability assert quantified statements programs written oblivious programmers 
implies aop oop 
oop current dominant programming language technology 
implementations new language ideas done context oop 
oblivious quantification independent oo concepts 
perfectly reasonable develop aop functional imperative language 
aop useful singletons 
got orthogonal concern exactly place original code re sure orthogonal concern propagate loci system evolves probably bad idea aop concern 
just write call aspect procedure place code permute source code way thought necessary achieve aspect 
quantity communication programmers required aspects general probably equals quantity communication required modify just program 
homogenized code leaves ambiguity happening may clear happening written separate aspects 
better aop systems oblivious 
minimize degree programmers particularly programmers primary functionality change behavior realize benefits aop 
really nice bumper able say just program ll able add aspects change mind downstream policies ll transform code 
class hierarchy oo systems convenient structure quantify 
oop pleasant environment aop necessary 
diana lee patel comments drafts 

aitken de moor richter transformation intentional programming devanbu 
eds 
proc 
th intl conf 
software reuse victoria canada ieee computer society press june pp 
www research microsoft com ip overview pdf 
aksit solving modeling problems object oriented languages composing multiple aspects composition filters 
aop workshop position 
cs utwente nl docs html 
de de jumping aspects 
workshop aspects dimensions concerns ecoop cannes france june 

farrell kant martin programming expert systems ops 
reading massachusetts addison wesley 

cannon flavors non hierarchical approach object oriented programming 
symbolics 


czarnecki eisenecker generative programming methods tools applications 
boston addison wesley 

des rivieres smith implementation procedurally reflective languages 
conference record acm symposium lisp functional programming pp 
austin texas august 

filman barrett lee linden inserting controlling communications 
communications acm press 
ic www arc nasa gov ic darwin leo filman text cacm final pdf 
filman lee managing distributed systems smart subscriptions 
proc 
international conference parallel distributed processing techniques applications pdpta las vegas june pp 


harrison ossher subject oriented programming critique pure objects 
proceedings conference object oriented programming systems languages applications washington september pp 


holmes noble potter reusable synchronisation object oriented languages 
aspect oriented programming workshop ecoop july 
www mri mq edu au research aop workshop ecoop html 
kiczales des rivieres bobrow art metaobject protocol 
cambridge ma mit press 

lopes kiczales developments aspectj 
ecoop workshop reader 
berlin springer verlag lncs 
www parc xerox com csl groups sda publications papers lopes ecoop 
mccarthy elephant 
www formal stanford edu jmc elephant html 

moon object oriented programming flavors 
acm conference object oriented programming systems languages applications oopsla acm sig plan notices vol 
pp 


teitelman masinter interlisp programming environment computer vol 
pp 


