designing implementing combinator languages doaitse swierstra pablo joao doaitse swierstra department computer science utrecht university box tb utrecht netherlands email doaitse cs uu nl url www cs uu nl doaitse pablo department computer science utrecht university box tb utrecht netherlands email pablo cs uu nl url www cs uu nl pablo jo university utrecht university box tb utrecht netherlands email cs uu nl url www cs uu nl authors 
ii contents defining languages extending languages embedding languages overview lectures circular programs rep min problem straightforward solution lambda lifting tupling computations merging tupled functions table formatting parser tables walks trees 
computing height computing widths formatting attribute grammars rep min problem table formatting problem comparison monadic approach pretty printing general approach improving filtering filtering page width narrowing estimates loss sharing computations extending grammar par apply pretty printing combinators iii chapter defining languages computer science community discovered concept programming language continuous quest ideal programming language 
hand overwhelmed flow kind special purpose programming languages 
attempts bridge gap language infinitely caused research called extensible programming languages 
certain sense programming language name binding constructs extensible 
lectures show unique combination higher order functions typing system availability lazy evaluation haskell promising candidates ideal extensible language 
start giving examples guidelines features just mentioned bit past limits want spend time explain constitutes programming language 
proper programming language description contains context free grammar describing concrete syntax language mapping underlying context free grammar describing structure language context sensitive conditions capture constraints easily expressed context free level correct name type checking usually context conditions expressed compositional way directly expressed terms fixed point function may computed compositional way compositional mean property construct expressed terms properties constituents 
mechanism assigning meaning construct common ways doing giving denotational semantics boils describing function represents meaning construct derived program structure 
case haskell may expressing algorithm 
haskell types may domain algorithms 
fact higher order functions plays crucial role 
fot domains functions denoting semantics may haskell types 
course design new language scratch defining components 
languages lot common definitions type systems abstraction mechanism io systems lot implement anew new language borrow language nice 
extending languages ways extend existing language far common way extend language including form macro processor 
extensions syntactic level form global analysis steer behaviour 
embedding term rewriting system principle possible acquire information parts program move information places may 
disadvantage approach hand method elaborate hand hard keep track happens independently designed term rewriting systems transform program text composition confluent term rewriting systems usually confluent 
giving access underlying interpreter providing reflection 
endless world possibilities appears 
unfortunately price paid consequence constructs analyzed dynamically general guarantee program terminate erroneously 
approaches fourth call embedding described section 
embedding languages embed language language extending language look case extend language 
concept shows available mechanisms language describing components mentioned section describing concrete representation syntax prefer term extension typically introduce new operators functions 
nice underlying language distfix operators fi available practice quite sufficient number operator priorities possibility define new infix operators 
representation syntax may haskell data types nicely correspond syntax trees overview lectures describing context sensitive restrictions catamorphisms capture notion exploiting compositional nature restrictions describing semantic domains haskell types 
way composed catamorphisms 
want emphasize approach fruitful led nice combinator libraries 
show attractive job code catamorphisms needed introduce special notation attribute grammars seen way defining catamorphisms programmer friendly way 
attribute grammars traditionally describing implementations programming languages appearance come surprise 
attribute grammars limited need choose specific language describing semantic functions specific target language 
fortunately show nowadays quite straightforward attribute grammar way thinking programming setting modern lazily evaluated functional language declarative way thinking formalisms bridges gap haskell get attribute grammar evaluator free thinking terms attribute grammars useful writing complicated functions associated calls 
explicitly naming argument result positions attribute names longer restricted implicit positional argument passing enforced conventional function definitions 
identify haskell stands strong points limitations prohibit profitable approach 
overview lectures chapter describe number called circular programs 
serves familiar lazy evaluation done exploit systematic way 
serves familiar algebraic approach programming design programs constructing algebras combining 
works nicely done systematic way show approach extremely cumbersome things want describe getting complicated needs book keeping genius keep track writing calculating combining 
course discussion clear approach solely relies monads attacking problems expected 
chapter solve example problems attribute grammar approach 
chapter large case study attack pretty printing problem described 
hughes defines set operators may describe dimensional layout documents especially documents contain structured text formatted structure 
designing language long standing testbed program design techniques hope show problems attacked step wise fashion proper administrative support may easily generate quite complicated programs dare write hand 
chapter show consequences techniques taken simplest form describe program transformations may result large set relatively small strict pure functions 
ml programmers happy continue read 
chapter circular programs start developing somewhat different way looking functional programs especially programs heavy functions recursively descend data structures case may think data structures syntax trees 
computing property recursive object program new language may defining sets functions set describing recursively visit nodes tree set algebras describing compute node visited 
important steps process deciding carrier type algebras 
step taken types guideline development algebra 
see carrier types may functions deciding type functions may simple 
section view recursive computations enable design carrier type incremental way 
constructing algebras algebras 
way define meaning language semantically compositional way 
rep min problem famous examples power lazy evaluation demonstrated called rep min problem 
wondered program achieves goal sight impossible compute program 
problem associated solutions build understanding class programs 
listing data type interest tree case stands simple binary trees associated signature 
carrier type algebra distinguished type describes objects algebra 
represented type parameter signature type type tree algebra int associated evaluation function cata tree systematically replaces constructors leaf bin corresponding operations circular programs data tree leaf int bin tree tree type tree algebra int cata tree tree algebra tree cata tree alg leaf leaf leaf cata tree alg bin bin bin cata tree alg cata tree alg listing rm start algebra alg passed argument 
want construct function rep min tree tree returns tree shape argument tree values leaves replaced minimal value occurring original tree 
example argument result 
leaf bin bin leaf leaf leaf bin function rep min straightforward solution bin leaf leaf simple solution consists function tree twice computing minimal value leaf values constructing resulting tree 
function replace min solves problem way listing 
notice variable global variable rep alg algebra tree constructing call cata tree 
shown flow data recursive call cata tree computing minimal value 
previous solution problem try construct solution tree 
rep min problem min alg id min int int int replace min cata tree rep alg cata tree min alg rep alg const leaf bin leaf bin listing rm sol min bin leaf min leaf computing minimum value circular programs rep alg leaf lr rr bin lr rr replace min cata tree rep alg cata tree min alg lambda lifting listing rm sol intermediate step achieve goal program listing 
program global variable removed second call cata tree construct tree anymore atree constructing function type int tree takes computed minimal value argument 
notice emphasized fact function returned superfluous notation extra lambda introduced definition functions alg 
process done routinely functional compilers known lambda lifting 
shown flow information function called 
arrows left non terminals correspond parameters constructed function arrow right results call constructed functions 
look top level node see final value function takes argument case minimum value returns tree 
tree constructs final function pasting small functions rep alg algebra 
small functions identified small data flow graphs large graph constructed 
small data flow graphs corresponding functions making rep alg separately 
labeled nodes names variables program 
tupling computations ready step formulation cata tree called 
note solution calls cata tree don interfere 
consequence may perform computation tree constructing function minimal value go tupling results computations 
solution listing 
function tuple defined 
function takes tree algebras arguments constructs third carrier tuples carriers original algebra resulting computation shown 
rep min problem leaf leaf bin leaf leaf bin bin bin leaf leaf flow information building result leaf leaf bin lt rfu rt building blocks bin min bin bin lm lt rm rt tupling computations circular programs infix tuple tuple tree algebra tree algebra tree algebra leaf bin tuple leaf bin leaf leaf bin fst fst bin snd snd min tup rep tree algebra int int tree min tup rep min alg tuple rep alg replace min cata tree min tup rep listing rm sol merging tupled functions step transform type carrier set previous example 
int int tree purpose equivalent type int int tree 
transformation essential demonstrate compute cartesian product functions may transform type new type compute function takes arguments cartesian product arguments functions tuple returns result cartesian product result types 
example computation minimal value may seen function type int 
consequence argument new type int isomorphic just int result type int tree 
want mention reverse general true function type general possible split function functions type cand achieve effect 
new version listing 
notice attempt different les parameters explicit introduced extra lambdas definition functions making algebra 
parameters second lambda construct values higher order carrier set 
parameters lambda deal tree algebra 
step taken part result case value passed back argument result cata tree merged alg 
lazy evaluation 
programs possible came originally great surprise functional programmers especially program lisp ml languages requires arguments evaluated completely call evaluated called strict evaluation contrast table formatting merged alg tree algebra int int tree merged alg leaf lm lr rm rr lm min rm bin lt rt replace min cata tree merged alg listing rm sol replace min tree tree leaf leaf tree bin lm lt tree rm rt tree lm min rm bin lt rt listing rm sol lazy evaluation 
surprising behaviour class programs known circular programs 
notice circular program 
value defined terms values value defined terms ones ones 
give listing version program function cata tree unfolded 
obtain original solution problem bird 
table formatting section treat complicated example show systematically design algebra involved 
final goal develop program recognizes formats pos circular programs nested html style tables described grammar table table rows table rows row row tr elems tr elems elem elem td string table td example accepted input associated output 
table tr td td td table td tr tr td table tr td formatter td td td tr tr td functional td td polytypic td tr table td td style td tr table html input parser tables table formatting table style formatter functional polytypic output version table formatter parses input returns syntax tree 
subsequent sections modify parts compute actual formatting 
program written called parser combinators defined infix operators functions construct parsers elementary parsers completely analogous known recursive descent parsing technique 
example advantages embedding formalism case context free grammars language provides powerful abstraction techniques automatically gives abstraction mechanism embedded language case contextfree grammars 
naming mechanism available deal separately concept nonterminal 
table formatting parsing combinators giving structure chapter remarked may want distinguish syntax syntax 
assume set parsing combinators enables mapping effort 
describe structure combinator construct parser recognising html tagged structures briefly discuss basic combinators construction 
types basic combinators example parser parser parser parser parser parser parser parser succeed parser quite complicated described 
suffices know parser recognise sequence tokens type result parsing process 
sequence combinator composes parsers sequentially 
meaning combined result computed applying result component second 
choice combinator constructs new parser may perform role argument parser 
succeed parser returns parser succeeds recognizes empty string returns argument succeed semantic value 
sequence choice succeed form elementary parsers keywords pkey parsers lower case identifiers basic constructors parsers context free languages 
fifth combinator defined describing processing semantic values returned parsers 
application defined succeed applies function called semantic function tothe result parser see careful combination semantic functions parser combinators prevent parse tree coming existence :10.1.1.30.9032
take look program listing take combinator 
combinator takes arguments string providing text tag structure enclosed tags 
semantics recognize open tag combinator recognize structure parse close tag 
combinators combine parsers throw away result symbol name 
result result call returns result recognized call inside body 
kleene grammar rules realized combinator see listing 
argument tuple values zero op alg list uniquely defines homomorphism carrier set initial algebra carrier set argument algebra case type 
second argument circular programs type alg list type alg table table rows row elems elem rows table alg list row rows elems row alg list elem elems string elem table elem eval string parser token parser token pkey pkey pkey pkey pkey pkey format table sem table sem rows sem row sem elems sem sem ptable ptable sem table table sem rows tr sem row sem elems td sem sem ptable listing parsing tables symbol eval alg list parser parser alg op zero pfm pfm op pfm succeed zero useful algebras init list max alg max take max element sum alg sum elements listing list manipulation table formatting parser structures 
alg op zero structure apply parser combine results binary operator op 
elements recognized semantic value 
example sum alg integer provided defined recognize integers 
expression recognize sequence integers return sum 
may note op binary operator actual parse result large expression constructed applications op calls recognized elements zero elements recognized 
lazy language value expression evaluated needed usually test strict argument position 
look function format table 
see takes non terminal algebra describing construct semantic value nonterminal semantic values elements right hand side 
type alg table carrier types argument 
result parser polymorphic domains recognising structure table composing recognized elements told compose argument type alg table 
simulating structure walks adding semantics providing different definitions algebras passed calls sem antic functions may describe quite different results 
set definitions describe data structure holding table result parsing process type table rows type rows row type row elems type elems elem data elem string table table format table id init list id init list type element returned table table 
type parameter table algebra 
possible previous functions see role played semantic functions list algebras 
apply functions collected elements provide intermediate computations transforming data types collecting intermediate values computing new values 
sections focus systematic description functions 
give polymorphic collection functions algebra tables corresponding computations 
walks trees 
previous section seen algebras describe construction syntax trees 
trees circular programs elem sem sem row sem row elems elem sem table rows elems table rows sem elems nil building ast sem rows elem row id id elems elem id rows elems table max max 
rows max alg nil computing heights computations trees sum alg compute meaning recognized structure 
attribute grammars want express meaning compositional way meaning structured object expressed terms substructures 
expressed mathematical style define homomorphism initial algebra syntax trees algebra meaning 
homomorphisms known catamorphisms 
interesting consequence trees initial function completely defined target algebra 
expressed computer science terms just saying structure recursion follows directly data type definition fact known functional programmers attribute grammar system users 
direct consequence possible compute meaning structure directly going explicit tree form representation referring initial algebra constructed data type constructors meaning algebra constructed semantic functions performing reduction construct tree node parsing process 
computing height step final solution define functions computing height formatted table 
depicts attribute grammar view solution 
synthesized attribute height 
height element height simple element height nested table 
table formatting height row maximum heights elements row height table sum heights rows 
computational structure capturing roll elements list element account accumulating result 
list algebra parser known sem elems computing height row max alg 
height table sum heights rows 
list algebra express computation sem rows pass sum alg 
complete set functions height table id sum alg id max alg const id note sem table sem row need special attention case pass argument 
observe relation set functions defined attribute grammar results applying semantic functions children nodes correspond synthesized attributes attribute computations nicely described algebras 
computing widths table level computation widths deserves bit attention 
able deduce maximum widths table recognized table 
keeping table maintain list maxima far 
new row recognized width values compared accumulated list maxima columns pair 
just applying algebra elements list obtaining list 
introduce star combinator star alg list alg list star op zero zipwith op repeat zero takes algebra returns algebra carrier set lists elements original algebra 
way defined algebra computing maximum max alg define algebra computing pairwise maxima lists star max alg compute widths table level 
want combine computations height width 
thinking attribute grammar style need synthesized attribute 
functions return single value pair results height width deliver 
row width collection widths elements init list 
return 
pair computation heights computation widths 
algebraic style programming define algebra composition combinator called tupling combinator takes algebras returns algebra computes pair values 
way possible structure computations attributes 
note composition semantic level syntactic 
infixr infix binary operator right associative circular programs width table sum star max alg id init list length id star alg list alg list star op zero zipwith op repeat zero hw table id sum sum alg star max alg id id max alg init list const split length id id split alg list alg list alg list xs xs xs xs listing computing heights widths alg list alg list alg list xs ys xs ys max alg list init synthesizing height row paired list widths elements row 
table level obtain algebra sum alg star max alg 
result computation table pair obtain list widths application 
need transformation id sum 
combinator applies argument functions corresponding left right elements pair 
new version program shown listing 
note compute properties tree time tupling computations tuples constructed computations elements tuples star split operators algebras composition star split product independent problem hand taken library 
ex 
exercise provide composition operator table algebra formatting computed width columns height rows start formatting table 
take approach rep min problem 
computing table table formatting layout table bot right mk table compose sum alg star max alg apply fst split snd compose max alg init list mk box 
split const split length mk box apply fst lift fst fst snd snd snd listing computing formatted table directly compute function gets passed widths columns builds table 
function constructed functions construct row get passed height row 
format table elements topleft element quarter plane call boxes extending east south see 
table layout constructed placing boxes top 
code semantic functions algebras shown listing 
simplify place element upper left corner box 
additional horizontal vertical glue blank text lines padded elements fit actual layout space 
elements furthermore equipped nice top left corner frame delineating quarter plane see 
row level elements composed laying row table 
composition done follows concatenate text line table lines 
elements row filled vertical glue process creates blank spaces element large fill vertical space 
furthermore processing row finished final height row known applied boxes shaping row horizontally 
surgery performed row applying computed height synthesized function pattern captured function apply fst 
table level rows formatted composed 
task reduced concatenating text lines 
rows processed actual width column known table shaped circular programs top left bottom right glue glue superposition boxes frame boundary vertically 
done mk table apply fst 
grid closed bot right placing bottom right lines correcting actual size table 
implementation box manipulation functions listing 
observe size boxes flexible know corresponding height width possible obtain nicely formatted table 
noticing put grid table placing elements top 
need take care closing grid providing element top left grid 
simplicity compose compose suspicious 
take look inside compose 
terms text elements string manipulation take attribute grammar view 
elems situation depicted elems cons node inherited attributes height list widths synthesized attribute layout element 
inherited attributes passed children height distributed global value row widths split element element 
synthesized attributes combined zipwith general 
patterns attribute manipulation pass global value fork pass split composed value value list want decompose list head tail combine inherited attributes combine synthesized attributes see 
abstraction higher language patterns abstracted compositional way express computation compose 
code combinators shown listing 
note inherited attributes 
create partially table formatting mk box box box rh rw map take rw take rh top left add glue top left map line mk table apply fst split split sum bot right close grid close grid map take line compose fork zipwith nil table compose lift nil row nil table repeat nil row glue repeat glue repeat glue add glue map glue glue line repeat elems ws nrs ws rs elem elems listing functions manipulating boxes fork ws ws zipwith attribute computation example combining patterns nrs rs circular programs lift op op fork id split id head split tail inh inh inh ll inh lr inh inh rl inh rr inh inh ll inh rl inh lr inh rr fork merge op inh inh inh ll inh rl inh lr inh rr fork inh inh syn inh ll inh rl syn inh lr inh rr merge op syn syn listing attribute computation combinators parameterized functions know dependent value apply function value 
attributes play double role synthesized height row value computed subsequent computation acting inherited attributes 
believe program clearly captures notion attribute grammar context free grammar represented parser combinators attributes attribute computations expressed terms algebras parameterized functions 
furthermore program generalized straightforward polytypic function constructors general 
algebra composition operator defined arbitrary data type constructor final notice probably hardest part derivation design combinators fork construct data flow patterns 
chapter attribute grammars previous chapter developed programs rep min table formatting problems 
cases computed tuple values result catamorphism elements tuples function point applied element tuple 
rep min example tree constructing function applied computed minimal value table formatting example occurrences phenomenon row constructing function applied computed maximum height row table constructing function applied list computed row widths 
pattern quite common composition invention algebras straightforward introduce attribute grammar notation may easily generate equivalent definitions 
design programs rep min table formatting drawing pictures ones rep min example 
price paid having semantic compositionality fall back syntactic compositionality 
hand think advantages approach developing combinator libraries completed form large attempts maintain semantic compositionality simply high 
hope show attribute grammar approach easier extend library efficiency improvements 
chapter develop set pretty printing combinators sequence steps example allowed flexibility 
anticipate people want experiment different implementations designs tried design attribute grammar formalism way definitions easily changed expanded having change original program texts 
rep min problem listing show formulation rep min problem attribute grammar notation 
data declarations introduce grammar corresponding structure problem 
attr declarations specify inherited attribute grammars data tree leaf int int bin left right tree data root root tree tree computation value attr tree int sem tree leaf lhs int bin lhs left min right attr tree minval int sem tree bin left minval lhs minval right minval lhs minval computation resulting tree attr tree res tree sem tree leaf lhs res leaf lhs minval bin lhs res bin left res right res computed minimal value attr root res tree sem root root tree minval tree lhs res tree res listing ag rep min problem synthesized attributes nonterminals 
attributes occurring inherited attributes corresponding downward arrows pictures seen attributes synthesized attributes corresponding arrows pictures 
declarations introduce attributes name inherited synthesized 
sem parts specify way attributes computed attributes 
actual definitions pieces haskell text parsed typechecked copied literally generated program 
attributes rules follow naming convention synthesized attribute res child left referred left res inherited referred lhs minval 
semantic rule specify nonterminal sem tree alternative leaf component production lhs left attribute res specified rule 
put text small system code listing generated 
ex 
exercise parser combinators generated file construct solution rep min problem reads tree file writes result file 
wonder progress input generated program longer original program previous section 
place input elaborate form notation making explicit different components definition 
abbreviations exist order cope occurring patterns attribute 
completely equivalent input listing 
see attributes may declared introductions new nonterminals new alternatives new semantic rules 
furthermore straightforward called copy rules easily inferred system 
extension notation things really 
attribute minval automatically available nodes tree rule child father node inherited attribute name automatically passed father child semantic rule defined rules doing bit complicated description time 
rule captures pattern normally associated reader monad 
attributes pattern introduce new monad describing jointly passing values 
furthermore lot small convenient conventions element right hand side production explicitly named name constructed type making letter lower case 
consequence creative inventing name value leaf just called int 
attribute grammars module tree data tree tree leaf int tree bin tree tree deriving show semantic domains type tree int tree int sem tree leaf int tree sem tree leaf int lhs minval leaf lhs minval int sem tree bin tree tree tree sem tree bin left right lhs minval left res left left lhs minval right res right right lhs minval bin left res right res left min right root data root root root tree deriving show semantic domains type root tree sem root root tree root sem root root tree tree res tree tree tree tree res data tree leaf int bin left right tree listing sem tree minval int int res tree leaf lhs int res leaf lhs minval bin lhs left min res bin left res right res data root res tree root tree sem root root tree minval tree listing ag table formatting problem data table table rows data rows nil cons row rows data row row elems data elems nil cons elem elems data elem str string tab table listing ag ag attr table row elem mh int sem table table lhs mh rows mh attr rows mh int attr elems mh max int sem elem str lhs mh tab lhs mh table mh listing ag table formatting problem section treat table formatting problem number steps 
remember previous chapter combining algebra really semantic compositionality algebra defined separately compiled separately modules composed moment want format table 
chapter dealing generation haskell code haskell assembly language adhere strict typing naming lexical rules language freedom designing attribute grammar formalism way may express convenient way 
emphasize compositional nature approach split attribute grammar separate pieces text combined system 
start grammar listing directly corresponds grammar 
program listing import previous file ag introduce nonterminal synthesized attribute grammars ag type int attr table elem mws int attr rows row mws sem table table lhs mws loc sum rows mws sem rows nil lhs mws repeat zero cons lhs mws zipwith max row mws rows mws attr elems mws sem elem str lhs mws length string tab lhs mws table mws listing ag attribute containing minimal height formatted table 
listing version extended attributes semantic functions computing minimal required widths note tupling done implicitly system introduce special combinators merge height widths algebras combined 
listing see small language element lines preceded literally copied generated file 
way small additional functions type definitions passed generated haskell program obviating need edit generated file contain import 
lines 
furthermore possible provide synthesized attribute binary operator unit element see phrase attribute mws 
semantic rule attribute attributes children th name combined binary operator attributes exist unit element taken value case nonterminal elems want attribute mws building list minimal widths elems achieved phrase 
note construct typically polytypic works kind nonterminal data type functor 
step downwards distribution computed final heights widths individual elements described element formatted actual size occupies formatted table listing 
advantages attribute grammar formulation show clearly invent combinators combining subcomputations indicate computed heights comparison monadic approach ag attr elems ah int sem row row elems ah elems mh attr rows row elems aws sem table table rows aws rows mws sem elems cons elems aws tail lhs aws listing ag widths flow back syntax tree 
add computation final formats sequences lines listing listing see small extension formalism ext clause 
effect clause case extend nonterminal elems extra element top left top left 
nonterminal top left introduced productions 
interpreted external nonterminal 
show parameter generated semantic functions call generated 
come final convention inherited attribute declared rule attribute name allowed semantic function semantic functions generated automatically 
listing inserted call external function passing available attributes 
extend final addition glue listing comparison monadic approach mentioned tried employ monads capturing occurring patterns parameter passing 
unfortunately monads general compose 
recognizing problem formalism taken purely syntactic approach 
reader monads correspond formalism inherited attribute automatically passed elements tree copy rule generation process provided indicated interest value declaring inherited attribute provided parent types done 
parameterizing computation global value easily done 
furthermore repeated needed effort programmer 
state monads correspond called chained attributes pairs inherited synthesized attribute name 
order attribute grammars ag type lines string attr table row elems elem lines lines sem table table lhs lines bot right rows lines attr rows lines lines sem elems nil lhs lines repeat cons lhs lines zipwith top left ls elems lines loc head lhs aws sem elem str lhs lines string data top left elem mws lhs ah elem mh elem lines ls ext elems cons top left listing ag comparison monadic approach ag additional layout functions sem top left lines mh ah mw aw hor line aw hor glue aw mw lines vg vg ver glue aw ah mh bot right mw lines lines hor line mw hor glue take repeat ver glue take repeat hor glue hor line take repeat listing ag attribute grammars support generation copy rules explain complete process underlying copy rule generation 
element right hand side production context steers generation non specified semantic functions 
attribute function defined check exists element elem defines synthesized attribute def elem def includes inherited attributes father lhs def 
case value taken 
checked left hand side synthesized attribute name 
taken element step left checked 
appropriate search inherited attributes checked 
rule applies synthesized attributes left hand side case searching process starts element right hand side 
want maintain label counter supplying new label numbers generating code define attribute labels inherited synthesized data expr labels int ce te ee expr sem expr ce 
labels lhs labels generated code find sem expr ce te ee lhs labels ce code ce labels ce lhs labels te code te labels te ce labels ee code ee labels ee te labels ce code te code ee code lhs labels ee labels see labels value nicely passed 
done attributes time having worry composition instances 
writer monads correspond synthesized attributes composed clause 
chapter pretty printing section attack pretty printing problem described 
pretty printing deals representing tree structures area top left right order way logical structure tree clearly represented layout 
chapter develop set combinators describing layouts 
suppose want pretty print fi structure 
may display different layouts depicted 
layout chosen normally depend page width 
page width layout preferred chosen range wins 
attempt display inside page characters wide bound fail 
define layout optimal takes number lines overflowing right page margin 
examples optimal page widths respectively 
second layout respect page width considered non optimal 
approach relation height width layout higher elements placed horizontally limited page width wider 
prefer wider solutions lead smaller height evident examples 
potentially solutions taken account cause gross inefficiency 
fortunately saved fact possible combinations inspected 
possible solutions max max fi height width max max fi max max fi height width height width pretty printing fi structure pretty printing height limited number candidates taken account 
combinations discarded computation selecting narrowest solution height inspect candidate solutions height final solution 
example may want describe possible layouts follows ite cond te ee ifc fi ifc fi ifc fi ifc text cond text te text ee fi text fi text converts strings layouts places arguments places combines possible layouts 
combinators indent inserts specific amount white space front argument empty represents empty document unit element 
effect operations sketched 
specification ll lw rl rw implementation pretty printing operations going implementation details want fix interface concrete grammar prefer semantic domains involved infixr infixr infixr empty formats text string formats indent int formats formats formats formats formats general approach formats formats formats formats formats formats sections improving search process develop increasingly sophisticated versions combinators 
general approach start defining basic set combinators context free grammar listing 
rely existence set basic combinators generate alternative layouts sorted lists assuming arguments sorted lists 
take example combinator assume type formats format combined solution merging lists obtained putting element left argument list elements right argument list 
lazy language resulting list generated incremental way need arises 
operations implemented analogous way 
detailed description implementation underlying basic machinery 
attribute grammar listing specification operations reduced producing appropriate basic function calls 
improving filtering potential candidates taken account new choice point doubles amount done detecting solutions wider page width early possible improve efficiency process 
filtering page width filter idea communicating node page width preventing candidates wider page width constructed 
adding filter program trivial declaring extra inherited attribute nonterminals introduced far including pseudo non terminals stand external function calls see listing 
compare effort convert program monadic form order reader monad 
want able different versions combinators tell system prefix calls pw indicated phrase pre pw 
change underlying machinery necessary need pass width filtered basic combinators actual combination process takes place 
take operation depicted 
construct new solutions width resulting layout computed ll rw length line rw width global page width pw 
pretty printing context free grammar data pp fmts formats empty text string indent int pp left right pp upper lower pp choice pp calling external functions ext pp empty empty fmts text text fmts indent indent fmts fmts fmts choice choice fmts introducing external functions data empty fmts fmts data text fmts string fmts data indent fmts pp fmts int fmts data fmts right fmts left fmts fmts data fmts lower fmts upper fmts fmts data choice fmts fmts fmts fmts pre sim display solution data root fmts output best pp sem root best lhs fmts putstr display best pp fmts type output io listing simple pretty printer spp ag improving filtering spp ag attr pp root pw pw attr empty fmts text fmts indent fmts fmts fmts choice fmts lhs pw pre pw listing filtering page width narrowing estimates page width may seen upper bound space available nodes 
want improve bound context node account 
know nodes placed space take available may compute estimate space available 
bound available space replaces attribute pw called frame 
look example assume page width 
root node start bounds total width length line formats generated node compute frame left subtree minimal width subtree fit inside frame 
similar line subtree units left frame subtree 
frame accommodate string set functions left alternative choice node locally discarded combined candidates discarded part impossible solution top computation 
listing show compute minimal space node needed adjust frames inherited fellow nodes 
depict attribute computations involved operation 
listing semantic functions passing frames downwards shown illustration data flow operation shown 
recall code data flows relevant computations explicit 
copy rules involving passing information generated automatically mag compiler mentioned chapter 
note top level initiating attribute computations frame lhs pw lhs pw 
listing add synthesis formats attribute handling error conditions 
ex 
exercise note need compute height document 
anticipate situation needed 
modify pretty printing spp ag pretty set functions set functions frame bound sem pp minw max int minll max int text loc minw length string lhs minll minw indent lhs minw int pp minw minll int pp minll lhs minw left minw max left minll right minw minll left minll right minll choice lhs minw minw min minw minll minll min minll listing computing min bounds ag improving filtering minll minw max minll minw minll min bound attributes ll narrow ll narrow frame wl lll wr llr minw minll minw minll frame attributes computing frame sem pp frame frame indent pp frame narrow frame int lhs frame left frame narrow ll right minw lhs frame right frame narrow frame left minll lhs frame sem root pw pw best pp frame lhs pw narrow frame narrow ll listing computing communicating frame ag cont minw pretty printing attr empty fmts text fmts indent fmts fmts fmts choice fmts lhs frame pre frame display solution sem root best lhs fmts putstr null pp error display best pp fmts pp error error handling sem pp error error indent lhs error err int txt err type error string err cond message cond cond case message negative indentation listing error formats ag loss sharing computations program ag computation heights included 
starting read section useful try hard solve problem 
combinator hv formats formats formats behaviour render hv text aaaa text bbbb render hv text aaaa text bbbb aaaa bbbb combinator places arguments vertically horizontally depending available frame 
note type formats latest version combinators type formats int int error minw minll type minw int type minll int type error string type elements manipulated underlying machinery 
ex 
exercise write combinator hv 
loss sharing computations may solution exercise hv unfortunately way inefficient solution 
previous definition hv solve problem 
arguments aand expression plain values functions secretly frame passed evaluated twice hv 
lost sharing unfortunate consequence higher order domain 
order get back situation computations shared collect arguments passed different occurrences expression 
fortunately pleasant property filters generators program far constructed way filter place value value solutions generated call may place call occurring 
manage collect arguments places expression occurring may compute maximal value argument perform call 
problem solved new combinators pretty printing ag data ppc fmts formats indent int ppc left right ppc upper lower ppc choice ppc par data pp apply ppc data nil cons pp listing extending pp ppc par acts placeholder shared expression app binding held places shared expression form application new combinators write previous definition hv par par par par app example hv text hello text world knowing actual value construct efficient combinators pretty printing structures 
extending grammar par apply introduce different non terminal grammar complicated formats shown listing 
text empty nodes excluded contain placeholders 
implementation par apply proceed follows compute nodes number numpars occurrences subtrees listing compute minimal sizes arguments distribute information tree numpars computed step listing sizes leaves available may compute minimal sizes minll minw nodes listing turn may compute frames nodes provide frame par nodes listing information reqs canbe loss sharing computations app par par par par mins mins mins mins mins collect number par mins mins app par mins par mins par mins par pp pp con pp con mins collect distribute pp con con nil mins mins mins attribute computations par app mins nil pretty printing sem ppc reqs reqs numpars int lhs reqs left reqs right reqs numpars left numpars right numpars lhs reqs upper reqs lower reqs numpars upper numpars lower numpars choice lhs reqs zipwith max reqs reqs numpars numpars par lhs reqs lhs frame numpars txt type reqs frame listing collecting placeholders collected compared way listing right argument list app node filter list solutions shared arguments lists passed distributed tree listing solutions reached final destinations original computation take place listing 
choice node distribute set children 
note keep track number placeholders node possible detect ill formed expressions insufficient arguments rhs apply node shape required argument structure match shape actual argument structure 
nicer solution subsequent section exploit language features solve problem 
loss sharing computations sem ppc fills mins loc lfs rfs splitat left numpars lhs rfm splitat left numpars lhs left lfs right rfs rfm loc ufs lfs splitat upper numpars lhs ufm splitat upper numpars lhs upper ufs ufm lower lfs sem pp apply ppc sem reqs reqs fills mins len int nil lhs len cons pp frame head lhs reqs reqs tail lhs reqs lhs pp error pp fmts pp minw pp minll len len txt type fills error formats type mins int int listing collecting distributing pretty printing attr ppc frame frame sem ppc indent ppc frame narrow frame int lhs frame left frame narrow ll right minw lhs frame right frame narrow frame left minll lhs frame attr ppc minw minll int sem ppc lhs minw left minw max left minll right minw minll left minll right minll lhs minw upper minw max lower minw choice lhs minw minw min minw minll minll min minll sem ppc par loc minw minll head lhs listing computing minimal values sem ppc indent lhs fmts frame indent fmts lhs frame int ppc fmts lhs fmts frame fmts lhs frame left fmts right fmts lhs fmts frame fmts lhs frame upper fmts lower fmts choice lhs fmts frame choice fmts lhs frame fmts fmts par loc error fmts head lhs sem ppc error error indent lhs error err int choice lhs error err length reqs length reqs error error sem pp apply lhs error err len length ppc reqs txt err incomplete parameter list incomplete parameter list choice listing producing final formats error messages loss sharing computations zipwith max app par par par par pp con pp con compute frames par positions collect upwards app par par par par con pp fm fmts con pp fmts distribute frames collect fmts fmts nil nil fmts attribute computations par app cont 
pretty printing fmts fmts fmts fmts fmts fmts fmts fmts app par fmts par fmts par fmts par distribute formats app fmts fmts fmts fmts fmts fmts fmts fmts fmts par par par par fmts fmts fmts pp compute final result pp con fmts fmts fmts pp con pp fmts fmts con fmts fmts fmts fmts fmts fmts con fmts attribute computations par app final nil nil chapter previous section remarked possible combine function band function single function fg having combined effect 
fact enabled small system generate large catamorphism walking tree argument inherited attributes returning result synthesized attributes 
programmers point view having merging separate functionalities single function quite easy refer computation results computed computation 
may wonder reverse transformation possible 
attribute grammars exists long tradition optimizing implementations order achieve efficiencies similar hand written compilers 
section analyses results respect pretty printing combinators 
known attribute grammar world translates nicely functional setting 
effect having single large function lazily evaluated manages deal dependencies results arguments construct set smaller functions exhibit behaviour evaluated strict way 
implementation technique chosen course project wanted evaluate attribute grammars incremental way function caching 
function caching implemented transformations needed convert program strict functions lazy functions albeit possible want large scale 
pretty printing combinators look type tree catamorphism generated rep min problem see returns result function takes computed minimal value argument returns tuple containing minimal value new tree result type int int tree 
analyzing dependencies argument result function may deduce component result depend argument computation higher tree production root case 
augment type arrows indicating dependency get flow type 
minval int int res tree tree flow type tree dashed arrow indicated dependencies occurring context tree catamorphism 
trick getting rid right left dependencies necessitate lazy evaluation split function functions shown 
inspect tree int minval int tree flow types tree tree res tree dependencies attributes pretty printing libraries done automatically find dependencies complicated pretty printing type ppc shown 
initially may compute number par occurrences numpars purely syntactical issue number depend attribute value 
number split list minimal sizes fill ins nodes 
constitutes second pass 
sizes pars available may return minw minll attributes 
turn adjust value filtering done frame passed tree 
possible collect maximal sizes available corresponding par occurrences collected compared returned synthesized 
application pretty printing combinators frame visit ppc visit numpars visit visit flow type ppc minll minw node compute actual list formats having available may construct sought list candidate formats node tree 
constructor node inspected process approach taken may say tree traversed times 
code generated attribute grammar system lrc combinator case children may contain par nodes listing listing generated functions takes kinds arguments values computed previous visits needed visits 
dependencies purely algebraic approach cumbersome computations get intertwined 
functions constructed earlier visits encompass rest done children completed 
subscript refers visit number stand 
inherited attributes available previous visit enabling computation visit 
www cs uu nl groups st software reqs fmts lambda left right lambda left numpars right numpars left right numpars right right numpars right left left numpars left numpars left numpars right numpars lambda left numpars right numpars left right lambda left minll left numpars right minw right numpars left right minll minw left take left numpars left left minll left minw left left right drop right numpars right right minll right minw right right minll left minll right minll minw max left minw left minll right minw lambda left minll left numpars right minw right numpars left right frame lambda frame left numpars right numpars left right reqs left frame narrow ll right minw frame left left reqs left left frame right frame narrow frame left minll frame right right reqs right right frame reqs left reqs right reqs lambda frame left numpars right numpars left right fmts left take left numpars left fmts left left right drop right numpars right fmts right right fmts fmts frame left fmts right fmts listing code generated lrc combinator bibliography de moor bird algebra programming 
prentice hall london 
pages fokker functional parsers :10.1.1.38.8777
jeuring meijer editors advanced functional programming number lecture notes computer science pages 
springer verlag berlin 
pages hughes design pretty printing library 
jeuring meijer editors advanced functional programming number lecture notes computer science pages 
springer verlag berlin 
pages jeuring jansson polytypic programming 
meijer sheard launchbury editor functional programming second international school number lecture notes computer science pages xxx xxx 
springer verlag berlin 
pages thomas johnsson 
attribute grammars functional programming paradigm 
kahn editor functional programming languages computer architecture volume lncs pages 
springer verlag september 
pages kuiper doaitse swierstra 
attribute grammars derive efficient functional programs 
computing science netherlands csn november 
ftp ftp cs ruu nl pub ruu cs cs ps gz 
pages fokkinga meijer paterson functional programming bananas lenses barbed wire 
hughes editor proceedings acm conference functional programming languages computer architecture number lecture notes computer science pages 
springer verlag berlin 
pages swierstra optimal pretty printing combinators 
available www cs ruu nl groups st software pp april 
pages hudak haskore music tutorial 
meijer sheard launchbury editor functional programming second international school bibliography number lecture notes computer science pages xxx xxx 
springer verlag berlin 
pages wadler deforestation transforming programs eliminate trees 
theoretical computer science 
pages wadler printer 
available cm bell labs com cm cs wadler topics html march 
pages bird circular programs eliminate multiple data 
acta informatica 
pages kieburtz lewis programming algebras 
jeuring meijer editors advanced functional programming number lecture notes computer science pages 
springer verlag berlin 
pages swierstra de moor virtual data structures 
ller editors formal program development number lecture notes computer science pages xxx xxx 
springer verlag berlin 
pages swierstra duponcheel deterministic error correcting combinator parsers 
meijer sheard launchbury editor functional programming second international school number lecture notes computer science pages xxx xxx 
springer verlag berlin 
pages 
