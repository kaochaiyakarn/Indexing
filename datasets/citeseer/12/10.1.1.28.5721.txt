incremental theory reasoning methods semantic tableaux bernhard beckert christian pape institute logic complexity deduction systems university karlsruhe am karlsruhe germany ira uka de www ira uka de beckert 
theory reasoning important technique increasing efficiency automated deduction systems 
incremental theory reasoning method improves interaction foreground reasoner background theory reasoner efficiency combined system 
incremental theory reasoning free variable semantic tableaux cost reduction achieved discussed example completion equality reasoning including experimental data obtained implementation 
theory reasoning important technique increasing efficiency automated deduction systems 
knowledge domain theory applying efficient methods reasoning domain 
general purpose foreground reasoner calls special purpose background reasoner handle problems certain theory 
pioneering stickel sound complete theory reasoning methods described various calculi path resolution connection method model elimination 
addition background reasoners designed various theories particular equality reasoning overview 
efficiency foreground background reasoner interaction plays critical role efficiency combined system difficult problem decide useful call background reasoner certain point time resources spend computations 
general give perfect answer questions difficult theory reasoning problem theory undecidable undecidable call background reasoner useful 
heuristics hand avoid calling background reasoner wrong point early late 
problem partially avoided incremental methods background reasoning algorithms futile try solve theory reasoning problem allow save results background reasoner computations reuse data call 
case doubt background reasoner called early running risk doing useless computations 
addition incremental background reasoner reuse data multiply different extensions problem handled 
important example completion methods equality reasoning inherently incremental 
focus theory reasoning semantic tableaux related methods model elimination connection method background theory reasoner close tableau branches resp 
compute connections links total theory reasoning 
organized follows section introduce notation recall basic definitions theory reasoning section define particular version free variable semantic tableaux sections stress results easily adapted versions semantic tableaux similar calculi 
section main results incremental theory reasoning introduced formally defined free variable semantic tableaux described cost reduction achieved discussed 
sections completion equality reasoning example describe actual implementation section contains experimental data obtained implementation 
section draw 
preliminaries notation fix order language built countable sets predicate symbols function symbols constant symbols object variables usual manner arity countably function predicate symbols 
logical connectives conjunction disjunction oe implication equivalence negation quantifier symbols 
tableau proofs necessary introduce skolem terms extend order language language adding countably constant symbols function symbols arity appear standard notions free bound variable grounding substitution sentence model logical consequence denoted valuation satisfiability tautology see definition 
subst set idempotent substitutions finite domain making real restrictions consider substitutions type 
substitution oe domain fx xng denoted fx xn confused partial theory reasoning background reasoner derives new formulae hands back foreground reasoner 
information derived incremental background reasoner foreground reasoner background reasoner calls 
oe 
substitution may applied quantified formulae case quantified variables replaced result applying substitution fx bg 
theory reasoning general satisfiable set universally quantified formulae theory identify theory defining set axioms 
definition 
theory ae satisfiable set universally quantified formulae 
interpretation interpretation satisfies formula oe set phi formulae satisfiable interpretation satisfying oe resp 
phi unsatisfiable 
sentence oe tautology satisfied interpretations 
formula oe consequence set psi formulae denoted psi oe oe satisfied interpretations satisfy psi restriction theories consisting universally quantified formulae necessary exactly formulae herbrand type theorem holds essential completeness tableau calculi theory reasoning 
restriction easy get existential quantifiers removed skolemization 
theorem 
set phi universally quantified formulae unsatisfiable iff finite set ground instances formulae phi unsatisfiable 
example 
important theory practice equality theory consists axioms define reflexivity symmetry transitivity function predicate symbols equality predicate denoted confusion meta level equality arise 
basic definitions theory reasoning definition 
phi set formulae 
phi complementary iff instance phi unsatisfiable 
example 
formula unsatisfiable complementary instance satisfiable 
formula unsatisfiable complementary 
definition 
phi set literals called key 
set literals residue phi substitution oe subst 
complementary denotes negation ae ae rg 
roe 
case pair hoe ri called phi 
residue empty identify substitution oe hoe really necessary require formulae key residue literals considerations simpler way 
partial total theory reasoning central idea theory reasoning calculi way herbrand theorem tableau calculi resolution key phi ae psi chosen set psi formulae derived foreground reasoner passed background reasoner computes hoe ri phi 
main approaches background reasoner computes empty residue speak total theory reasoning partial theory reasoning 
case partial reasoning fae ae ng formula ae ae added derived formulae psi substitution oe applied 
foreground reasoner able show psi oe fae ae unsatisfiable substitution proves psi oe unsatisfiable psi oe satisfiable sets psi oe fae ae shown unsatisfiable satisfiable 
total theory reasoning seen special case partial theory reasoning way foreground reasoner quite different derivations foreground reasoner psi oe proven complementary background reasoner 
tableau framework usually key phi taken tableau branch closes substitution oe applied see section 
restrict considerations total theory reasoning techniques introduced applicable partial theory reasoning 
completeness combination foreground background reasoner background reasoner compute sets certain sense complete 
definition strong sufficient theories calculi depending actual theory calculus weaker requirements may sufficient preserve completeness definition 
set sigma complete key phi ground substitution oe subst phi oe sigma substitution oe ffi oe semantic tableaux free variable semantic tableaux formally define free variable tableau calculus slightly nonstandard representation difference classical free variable tableaux notation way tableaux represented tableaux multi sets multi sets order formulae usual branches tableau implicitly disjunctively connected formulae branch implicitly conjunctively connected 
definition 
tableau finite multi set tableau branches tableau branch finite multi set order formulae 
possibilities derive new tableau old applying tableau expansion rule closing branch applying substitution tableau incremental theory reasoning provides third possibility calling background reasoner see sec 

expansion rules classical ff fi fl ffi rules order formulae 
rule patterns summarized table 
ff ff ff oe oe oe oe oe oe oe oe oe oe fi fi fi oe oe oe oe oe oe oe oe oe oe oe oe oe fl fl oe oe oe oe ffi ffi oe oe oe oe ff ff ff fi fi fi fl fl new free variable 
ffi ffi xn new skolem function symbol xn free variables occurring ffi 
table 
formula types tableau rule schemata 
prove formula oe tautology start initial tableau ff 
new tableaux derived applying tableau expansion rules closing branches applying substitution 
definition 
tableau branch closed substitution oe iff formulae oe oeoe oe oeoe oe complementary 
problem finding single substitution closes branches tableau simultaneously simplified usual practical applications closing branches substitution closes single branch applied tableau close branch branches considered 
closed branches removed tableau just marking closed 
proof empty tableau derived 
theorem soundness completeness 
order sentence oe tautology iff sequence ff tn gamma tn ffi rule liberal proposed proven sound schmitt 
ffi rules investigated 
tableaux tableau constructed gamma 
applying expansion rules table branch gamma formula oe literal gamma fbg foeg fff ff gg oe type ff gamma fbg foeg ffi foeg ffi gg oe type fi gamma fbg fb ffl gg oe type fl gamma fbg foeg fffi gg oe type ffi 
closing branch gamma gamma fbg oe branch closed oe def 

construction closed tableau highly non deterministic process step general free choose branch tableau expand close choose formula oe expansion substitution closes semantic tableaux total theory reasoning fact empty residue key taken tableau branch instances unsatisfiable definition 
theory tableau branch closed substitution oe oe key phi ae definition theorem easily adapted theory reasoning theorem soundness completeness theory reasoning 
theory order sentence oe tautology iff sequence ff tn gamma tn tableaux tableau constructed gamma 
applying expansion rules table see theorem formal definition 
closing branch gamma gamma fbg oe branch closed oe def 

incremental background reasoners motivation mentioned main problems theorem reasoning techniques practice efficient combination foreground background reasoner interaction late call background reasoner lead bigger tableaux redundancy 
branches may share contain key exists background reasoner called separately branches computed repeatedly 
hand early call background reasoner may successful time consuming particular disadvantage theory undecidable result background reasoner terminate exists 
phenomena may considerably decrease performance prover difficult decide resp 
develop heuristics decide 
call background reasoner 
background reasoner find 
example 
example shows earlier calls background reasoner reduce size tableau proof exponentially assume gamma set formulae gamma theory shows proof gamma delta delta delta background reasoner called literal form appears branch 
result left hand branches closed immediately tableau linear size background reasoner called branch exhausted expansion possible tableau branches background reasoner called times times 
incremental background reasoner additional advantage computations necessary show gamma similar case single call background reasoner may provide information reused close branches effort 
best heuristic avoid calls background reasoner wrong time 
certain conditions possible avoid adverse consequences early calls algorithm background reasoner uses incremental data produced background reasoner futile try compute reused call 
early calls negative effects disadvantages late calls easily avoided heuristics case doubt call background reasoner early time 
problem knowing background reasoner solved calling resources time call 
additional advantage incremental background reasoners tableau framework computations reused repeatedly different gamma delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta gamma gamma gamma gamma gamma gamma fig 

short tableau proof gamma delta delta delta example 
extensions branch computation proceeds differently extensions 
incremental keys obviously strong relation keys transferred background reasoner possible reuse information computed 
calls background reasoner want extend tableau new formulae apply substitutions tableau operations want allow changing key definition 
sequence phi keys incremental set psi literals substitution oe phi phi oe psi psi psi oe general phi phi substitution applied phi phi new formulae added 
iterative incremental algorithms able formally denote state computation background reasoner reached data generated notion background reasoner definition 
background reasoner triple ha si consisting algorithm function operating data structure initialization function fl transforms key data structure format output function 
subst extracts computed data structure 
course input output functions reasonably easy compute practice cost linear polynomially input particular cost computation smaller applying algorithm supposed actual 
sake simplicity focus algorithms iterative sense definition 
background reasoner ha si iterative key phi inclusion phi ae phi holds 
sound key phi set phi set phi 
complete key phi set phi complete set phi def 

practice condition background reasoner iterative weakened extent allowed remove subsumed 
goal able background reasoner reached certain state computations key phi proceed state new key phi psi purpose need update function adapts data structure representing state computation new literals psi substitution oe 
definition 
theory ha si sound complete iterative background reasoner update function theta fl theta subst gamma 
correct key phi psi dn phi psi oe 
dn set phi soundness 
dn complete set phi completeness 
definition correct update function behaves expected single incremental step 
theorem shows behavior extends sequences incremental steps 
addition algorithm applied arbitrarily incremental steps real restriction background reasoner applies different transformations data step computation modeled adding index state reasoner data structure right operation sub algorithm applied time background reasoner invoked 
theorem 
phi incremental sequence keys phi phi oe psi sound complete iterative background reasoner def 
correct update function def 

ae defined 
phi 
oe psi 

set phi soundness 
complete set phi completeness 
example 
phi incremental sequence keys phi phi oe psi 
sound complete iterative background reasoner ha si trivial update function defined psi oe phi oe psi correct 
example shows sufficient correct update function achieve better performance calculus trivial update function means information reused 
useful update function preserve information contained computed data 
useful reasonably easy compute update function depends theory background reasoner data structure 
section show useful update function exists background reasoner completion equality handling 
important example background reasoners resolution resolvent derived key phi valid extensions phi psi phi resolvents may invalid instance key check easier recompute resolvents 
uniform translation horn theories partial background reasoners unit resulting positive hyper resolution input restriction described 
procedure generate incremental background reasoners huge class theories 
semantic tableaux incremental theory reasoning incremental theory reasoning method previous section easy tableau calculi definition incremental sequences keys matches construction tableau branches 
keys sequence taken expanding branch substitutions applied tableau 
general complete set keys inclusion relation holds sets incremental sequence keys 
keys calls background reasoner information computed far background reasoner attached tableau branches definition 
tableau finite multi set tableau branches tableau branch triple theta phii theta finite multi set order formulae data structure background reasoner phi set literals key 
free variable tableau calculus introduced section adapted incremental theory reasoning calling background reasoner added third possibility change tableau expanding closing branches 
soundness completeness resulting calculus corollary theorems theorem soundness completeness incremental version 
theory sound complete background reasoner ha si def 
correct update function def 

order sentence oe tautology iff sequence fhf oeg ig tn gamma tn tableaux def 
tableau constructed gamma 
applying expansion rules table branch theta phii gamma formula oe theta literal gamma fbg fh theta foeg fff ff oe type ff gamma fbg fh theta foeg ffi phii theta foeg ffi oe type fi gamma fbg fh theta ffl oe type fl gamma fbg fh theta foeg fffi oe type ffi 
closing branch theta phii gamma fh theta oe phi theta phi gamma fbg oe 
calling background reasoner branch theta phii gamma number applications key phi psi ae theta gamma fbg fh theta psi oe phi ig maximal keys literals branch keys attached branch 
achievable cost reduction maximal cost reduction achieved incremental reasoner reached costs non incremental background reasoner called early late right key incremental sequence chosen background reasoner called key possible practice 
formally search substitution keys incremental sequence phi phi phi oe psi index min right key minimal number applications background reasoner nmin defined min phi nmin minfn phi min general minimal costs finding non incremental approach cost phi min cost nmin phi min cost denotes costs computing application function argument minimal costs reached deterministic nonincremental background reasoner index min known equivalent problem early late calls 
costs incremental approach depend number applications algorithm step number incremental steps bigger min chosen small 
costs cost phi gamma cost psi oe cost phi gamma psi gamma oe gamma 
actual costs smaller approach minimum costs applying update function approach zero information computed background reasoner reused call numbers applications chosen small 
substitutions applied oe empty substitution usually information derived key phi reused part invalid instance phi oe see section 
practice costs incremental method ideal value costs calling non incremental reasoner keys incremental sequence reusing 
costs sequence closing tableau branch higher non incremental method costs closing tableau small information reused branch 
equality handling semantic tableaux total theory reasoning methods employed handling equality free variable tableaux background reasoner solve rigid unification problems compute definition 
rigid unification problem ti consists finite set equalities terms substitution oe solution problem iff eoe soe toe free variables eoe held rigid treated constants 
complete set key phi computed extracting set phi rigid unification problems phi definition solving problems phi definition 
phi key 
phi fl phig set equalities phi phi fhe phi hs ht ii phi fhe phi ti phig set rigid unification problems phi 
theorem 
key phi set solutions rigid unification problems phi complete set phi equality theory 
various methods computing rigid unifiers described efficient completion 
fortunately methods rigid unification easily incremental background reasoning phi sequence incremental keys equations hold sequence phi corresponding rigid unification problems phi phi oe psi phi phi oe psi contains additional unification problems extracted literals phi oe psi 
correct update function 
apply substitution oe old set unification problems rewrite rules 
add new rewrite rules unification problems old ones 
remove rewrite rules valid substitution oe rules constitute information reused 
version total theory reasoning semantic tableaux branches closed 
close branches simultaneously simultaneous rigid unification problem solved 
difficult version simultaneous rigid unification undecidable non simultaneous problem np complete 
implementation completion method solving mixed unification problems extension rigid unification implemented part tableau theorem prover 
unification problems extracted branch resp 
key transformed sets constrained terms rewrite rules constraints describe sets substitutions substitution applied tableau derived term rewrite rule remains valid 
algorithm seen extension unfailing knuthbendix algorithm narrowing employed search 
maximal keys literals tableau branch 
free variable tableaux resolved closing branches left right fixed order formulae expanded backtracking substitutions applied tableau branch closed application substitution oe undone closing substitutions searched close branches oe 
old version information computed background reasoner reused background reasoner called exhausted tableau branches expansion rule applicable observing limit number fl rule applications usually led late calls called time fi rule applied usually led early calls 
fortunately due inherently incremental nature algorithm solving mixed unification problems easy design implement correct reasonably simple update function psi oe rewrite rules unification problems extracted new literals psi added data structure changes 
substitution oe applied constrained rules terms rewrite rules terms valid oe removed checked constraints attached rules terms experiments show practice rules terms removed 
new incremental version background reasoner called fi rule applied 
number iterative steps call determined heuristic user affect changing certain parameters 
mixed unification combination classical universal unification rigid unification 
performance provers unification handling equality increased considerably mixed unification purely rigid version equality applied proof time different substitutions variables occurring 
tableau calculi mechanism generate instances equality 
possible recognize equalities universal variables contain equalities occur branch tableau 
mixed unification knowledge avoid generating additional copies equalities 
experiments results experimental data obtained implementation described previous section 
different theory reasoning methods compared 
calling background reasoner time fi rule applied reusing computed information calls reuse reusing information reuse 
calling background reasoner exhausted branches late call 
generated tableaux general cases different larger background reasoner called exhausted branches case 
statistics tr number tableau rule applications eq denotes number calls equality background reasoner 
proof times seconds running sun sparc means proof reasonable time 
table shows results pelletier problems pel problems taken application program verification lemmata specification hash tables proven hash 
specification consists axioms heavy equality predicate 
branches closed time sec problem tr eq background foreground reuse reuse late call pel pel pel pel pel hash hash hash hash hash hash tableaux pelletier problems quite small 
reusing information lead improvement negative effects 
proof problem pel shortened considerably making early calls background reasoner 
difficult examples program verification improvement gained reusing information corresponds roughly size tableau proof branches re computations information avoided 
differ reusing information case limit number equality applications reached branch closed limit reached information reused case 
incremental theory reasoning technique improves interaction foreground total background reasoner 
adverse effects early late calls background reasoner may partially avoided addition information computed background reasoner reused multiply compute different extensions key 
experimental evidence section shows practice information reused incremental methods may increase performance deduction system 
theory reasoning directed designing efficient foreground background reasoners 
shows completely separated interaction equally important 
incremental methods essential develop heuristics depending theory domain order decide key long call background reasoner 

baaz 
non elementary speedups different versions tableaux 
proceedings th workshop theorem proving analytic tableaux related methods st lncs pages 
springer 

baumgartner 
model elimination calculus built theories 

ohlbach editor proceedings german workshop artificial intelligence lncs pages 
springer 

baumgartner 
linear unit resulting refutations horn theories 
journal automated reasoning 
appear 

baumgartner furbach 
unified approach theory reasoning 
university koblenz 

beckert 
adding equality semantic tableaux 
agostino gor johnson reeves editors proceedings rd workshop theorem proving analytic tableaux related methods pages imperial college london tr 

beckert 
completion method mixed universal rigid unification 
bundy editor proceedings th international conference automated deduction cade nancy france lncs pages 
springer 

beckert 
tableau theorem prover multiple valued logics 
proceedings th international conference automated deduction cade saratoga springs ny lncs pages 
springer 

beckert gei pape sulzmann 
tableau theorem prover version 
bericht universitat karlsruhe fakultat fur informatik 

beckert schmitt 
ffi rule free variable semantic tableaux 
gottlob editors proceedings rd kurt godel colloquium brno czech republic lncs pages 
springer 

bibel 
automated theorem proving 
vieweg braunschweig second revised edition 

de 
rigid unification simplified 
proceedings th workshop theorem proving analytic tableaux related methods st lncs pages 
springer 

voronkov 
simultaneous rigid unification undecidable 
technical report uppsala university may 
annual conference european association computer science logic csl paderborn 

fitting 
order logic automated theorem proving 
springer 

gallier narendran snyder 
theorem proving equational rigid unification 
journal acm apr 

schmitt 
ffi rule free variable semantic tableaux 
journal automated reasoning 

knuth bendix 
simple word problems universal algebras 
leech editor computational problems algebras pages 
pergamon press oxford 

loveland 
simplified format model elimination procedure 
journal acm july 

murray rosenthal 
theory links applications automated theorem proving 
journal symbolic computation 

nutt smolka 
basic narrowing revisited 
journal symbolic computation 

pelletier 
problems testing automatic theorem provers 
journal automated reasoning 


build open theory connection calculi 
journal computer artificial intelligence 


order logic 
springer 

stickel 
automated deduction theory resolution 
journal automated reasoning 
