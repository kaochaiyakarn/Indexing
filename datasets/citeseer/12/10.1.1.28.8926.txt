babel preliminary version framework interoperability kathleen fisher labs research park ave florham park nj riccardo pucella department computer science cornell university ithaca ny john reppy bell labs lucent technologies mountain ave murray hill nj practical implementations high level languages provide access libraries system services apis specified low level language usually 
important characteristic mechanisms foreign interface policy defines bridge semantic gap high level language example idl tools generate code marshal data high level representation user annotations 
design space foreign interface policies large pros cons approach 
commit particular policy choose focus problem supporting gamut interoperability policies 
describe framework language interoperability expressive support efficient implementations wide range different foreign interface policies 
describe tools implement substantially different policies top framework benchmarks demonstrate efficiency 
email research att com email riccardo cs cornell edu email research bell labs com preliminary version 
nal version published electronic notes theoretical computer science url www elsevier nl locate entcs fisher pucella reppy high level languages functional object oriented languages programmer model data representations 
abstraction hides details special run time representations needed support high level features comes cost making interoperability low level languages non trivial 
incompatibility poses serious challenges implementors users high level languages numerous important libraries apis application program interfaces 
purposes view prototypical low level language 
widely high level language implementations provide means calling foreign functions written mechanism called foreign function interface ffi 
requirements ffi mechanism convert arguments call high level low level representations called marshaling handle transfer control high level language back convert low level representation results corresponding high level representation called unmarshaling 
addition ffi mechanism may map errors high level exceptions 
details data marshaling unmarshaling performed define policy determines highlevel code interact foreign functions 
important policy question treat complicated foreign data structures structs arrays pointer data structures 
existing ffi mechanisms handle scalars usually treat large data structures values high level language 
approach sufficient situations high level language needs direct access large data structures marshaling infeasible 
examples include situations outside authority data format expressible high level language network packet headers rpc stub generation volume data data marshaling prohibitively expensive real time graphics applications pass large amounts vertex texture data rendering engine 
situations need foreign data interface fdi mechanism allowing high level language manipulate representations directly 
combination ffi fdi provides complete solution interoperability problem 
describes architecture moby compiler architecture efficiently supports wide range interoperability policies including ffis 
moby high level statically typed programming language ml module system fr 
moby support interoperability features compiler 
compiler intermediate representation called bol expressive implement easy interoperability tools generate bol code manipulate data structures access global variables invoke functions 
second compiler import bol code consider problems associated interoperability different high level languages 
fisher pucella reppy compilation environment including bol code produced interoperability tools 
framework produces efficient foreign interfaces compiler infrastructure supports cross module inlining bol code allowing tightly integrate bol code manipulating structures high level client code 
inlining assembly code sequences generated moby compiler accessing data structures little overhead instruction sequences mimic produced compiler 
mechanism define moby primitive types integers associated operations addition 
efficiency mechanism crucial performance moby compiler 
architecture serves basis implementing number different foreign interface policies 
policy determine types packaged moby 
built tools implement different policies marshals data cross boundary moby simply embeds moby 
belongs family interoperability tools interface description language idl ler pr 
idl provides annotations specify function argument result passing conventions semantics types marking char value string 
moby idl tool generates moby interface functions idl specification 
second tool called charon implements minimal identity policy 
embedding directly moby tool provides foreign function interface foreign data interface allows high level code manipulate low level data structures place 
worth noting framework moby program may foreign apis sources 
organized follows 
section describe architecture moby compiler explain architecture supports data level interoperability 
describe moby idl charon section examples interoperability tools built framework 
section give experimental evidence showing tools yield efficient foreign interfaces moby 
discuss related section conclude section 
moby compiler infrastructure framework interoperability existing compiler infrastructure 
aspects infrastructure key supporting interoperability compiler intermediate representation called bol expressive describe low level data representations manipulations expressible moby 
primitive moby types operations defined terms bol types functions 
definitions external moby interface files called fisher pucella reppy mbi mbi mbi compilation environment idl charon moby idl fig 

moby compiler infrastructure mbi files play role similar native methods java lia allow moby interfaces implemented low level code written moby 
compiler import inline code mbi files 
tool generating mbi files textual descriptions called files 
illustrates compiler infrastructure compiling moby source file imports interfaces idl file idl header file 
moby idl generate mbi idl file charon generate mbi header file 
section discuss infrastructure small number additional features added support interoperability 
mbi files addition object file moby compiler generates mbi file compiling source file 
file contains information support typechecking analysis inlining 
collectively mbi files application called compilation environment 
mbi file contains information moby signature contain information implementation visible signature representation types bol types implementation functions bol terms 
mbi files generated compiler moby source files compiler mbi files sources 
example primitive types operations int specified hand written mbi files compiler imports 
mechanism import information foreign functions data representations compiler 
strictly speaking write file translated binary mbi file 
fisher pucella reppy bol moby compiler uses extended calculus called bol intermediate representation optimization 
describe bol type system connect moby types underlying bol representation 
give overview bol terms support efficient interoperability 
bol weak type system guarantee type safety think bol type system roughly equivalent recursive types 
moby compiler uses bol types guide mapping bol variables machine registers provide representation information garbage collector smith morrisett copying collector sm provide sanity checking optimizer transformations 
example bol type constructors enum ptr vector struct define names bol types typedef char enum typedef string data ptr vector char typedef string ptr struct int string data char value string data pointer vector unknown length storing chars size byte string pointer heap object consisting integer length string data pointer 
promote interoperability runtime representation string data null terminated 
bol struct types describe heap objects 
example notation bol struct type gives size alignment respectively offsets fields 
definitions assume bit architecture 
mbi file format allows moby type defined terms bol type definition 
example mbi file implements primitive moby types defines moby string type terms primitive bol type string 
type string prim string bol types stratified levels kinds types kind word describe values represented general purpose register target machine scalars pointers types kind var describe values bound bol variable includes word types types kind memory describe values held memory includes word var types 
target specific aspects type system captured kinding judgements 
example bit architecture bit integer type var kind bit architecture bit integer type word kind 
syntactically bol direct extended calculus 
includes primi strictly speaking bol normalized representation requires intermediate results including literals bound fresh variables tools compiling mbi files textual description accepts complicated subexpressions performs normalization introducing new temporary variables 
unnormalized representation fisher pucella reppy tive notion heap object primitive operations manipulating raw machine data types addresses bit integers 
binding form obj ty alloc xn allocates heap object fields binds obj 
memory layout obj inferred types notation select ith field objects zero indexing 
bol primitive operations include add adding bit integers pointer arithmetic comparing addresses fetching bit integers memory 
mbi files include definitions moby functions terms bol terms definitions support cross module inlining inlining primitive operations 
example length function strings defined follows val length string int fun len string exn handler int return line gives moby name type function remaining code bol definition 
bol function len name allow recursion parameters 
parameter bol string type representation moby string type second implicit continuation parameter required moby calling convention 
implementation length function parameter wildcard 
body function trivial select component recall bol type string pointer heap object bind return moby compiler inlines bol implementations reduce overhead calling associated moby functions enable optimizations 
example compiling moby expression length definition length inlined resulting intermediate bol term add return case bound known literal expression reduced constant 
interoperability extensions support interoperability added calls function types declarations bol 
improve efficiency foreign function calls added mechanism stack allocate temporary storage 
describe pieces turn 
bol binding form calling functions result ccall id arg argn easier read 
fisher pucella reppy identifier id bol variable may bound known function function pointer 
type id controls calling convention call added function type constructor bol type system purpose 
types function parameters mapped bol types way preserves specified calling convention small integer types promoted bol equivalent int 
technical complication arises struct parameters 
bol kinding system allow bol variables bound values type memory kind represent struct values addresses 
problem distinguish pointer struct struct parameter 
added additional type constructor case solve problem 
added void type represent void return types functions 
mechanism support possible underlying code generator support 
mbi file function contain external declaration form textual representation external result ty ident param ty param result ty param ty param ty bol types var kind 
connecting high level language requires temporary space marshaling struct arguments results 
efficiency considerations require lightweight mechanism allocating space 
lifetime storage call function efficient place storage stack frame wrapper function 
support allocation added binding form bol allocating stack space 
binding form sz align binds sz bytes stack storage aligned align byte boundary sz align integer constants 
lifetime storage scope binding bol code uses allow storage escape 
practice restriction problem furthermore moby optimizer perform transformations expand extent variable scope 
applications framework designed support wide range interoperability policies 
section describe foreign interface generator tools moby implement significantly different policies top framework 
describe potential uses framework 
code generator framework 
fisher pucella reppy moby idl popular ways automating connection high level languages interface description language idl specify foreign interface ler pr 
idl specification essentially header file annotations 
annotations specify direction parameters interpretation pointer types 
idl generators compile specifications high level interfaces glue code 
retargeted sml nj idl foreign interface generator pr produce mbi files idl specification 
moby idl tool generates mbi file defines moby type non trivial type idl specification stub function function prototype 
stub function embodies copy copy policy calling functions input parameter translated moby representation passed function result output parameter translated moby representation 
stub functions moby types implemented bol 
discussion concrete give examples highlighting different aspects moby idl tool 
example getenv function library 
function takes string argument names environment variable returns value variable string 
named variable value null returned 
idl specification capture behavior typedef unique string char getenv string char name type annotated unique means null annotated string 
name parameter getenv function marked input parameter string 
moby idl tool guided annotations produce moby specification val getenv string option string mbi file stub function definition val getenv string option string fun getenv str string exn handler str str res ccall getenv str res nil return res str ccall moby res res alloc res str return res number idl variants sml nj tool moby idl accepts extension osf dce dialect essentially version microsoft uses com 
fisher pucella reppy bol code converts input parameter str string selecting second component heap object recall moby strings represented pair length data pointer passing getenv function 
result res null returned representation moby constant 
result null moby string allocated initialized res calling moby runtime system function moby 
moby string wrapped word heap object representation data constructor returned 
slightly involved example idl specification interface unix gettimeofday system call typedef struct long tv sec long tv usec typedef struct int tz int tz int gettimeofday ref ref tz specification includes annotations parameters gettimeofday 
annotations identify parameters pointers storage returning results function call 
moby idl tool produces moby interface specification datatype int int datatype int int val gettimeofday int tool translated struct types moby singleton datatypes 
tool mapped parameters results generating moby type function gettimeofday 
implement stub code connects moby bol code generated mbi file 
code form val gettimeofday int fun gettimeofday exn handler tm tz res ccall gettimeofday tm tz tm alloc tm tm tz alloc tz tz return res tm tz code uses bol construct allocate temporary storage results stack 
variables tm tz bound address bytes stack storage byte alignment 
extent storage labeled record type preferable moby records 
fisher pucella reppy scope variables rest function case 
calling gettimeofday function code extracts contents results temporary storage allocates pair heap objects results 
framework uses getenv gettimeofday functions inlined call site avoids extra level function call idl ffi mechanisms provides opportunities optimization avoiding unnecessary marshaling 
section provides experimental results demonstrate efficiency approach 
charon moby compiler infrastructure built second interoperability tool called charon 
tool implements minimal interoperability policy simply embeds moby 
maps types moby types provides moby functions implemented bol manipulating values 
provides moby functions implemented bol calling functions 
charon takes input header file produces output files 
file contains moby signature describing types operations defined header file 
second file mbi file containing bol code implements signature file 
note signature implemented moby directly bol moby include low level operations necessary manipulate data structures 
moby compiler converts mbi files assembly code linked compiled code implements header file 
charon factors embedding parts generic specific input header file 
generic part interface library implemented hand written mbi file 
interface library provides type constructors encoding types type lvalue type type sizeof lvalue ty type assignable value type ty 
underlying representation lvalue ty address memory location containing value type ty address global variable heap location 
ty type pointer value array values type ty 
sizeof ty type representation size ty explain 
define collection phantom types corresponding primitive types signed characters sint signed integers 
phantom types constrain types generic operations values 
example interface library defines operations pointers phantom types types purpose serve arguments type constructors bur rep lm 
idea phantom types encode types suggested matthias blume blu 
fisher pucella reppy val bool val deref lvalue val lvalue val lvalue val malloc sizeof notation binding type variable 
interface library defines specific operations primitive types operations signed integers val lvalue sint int val lvalue sint int val sizeof sint addition generic support provided interface library charon generates mbi file contains types functions specific input header file 
example consider declarations describe binary tree type function creating trees typedef struct tree int label tree ptr left tree ptr right tree node tree ptr extern tree ptr int depth declarations charon generates mbi file implements moby interface type struct tree type def tree node struct tree type def tree ptr struct tree module stree val label lvalue struct tree lvalue sint val left lvalue struct tree lvalue def tree ptr val right lvalue struct tree lvalue def tree ptr val sizeof sizeof struct tree val int lvalue def tree ptr type struct tree phantom type corresponding struct tree type 
type definitions tree node tree ptr translated moby type definitions 
struct tree type mapped module operations accessing fields 
note access functions return lvalues assign fields 
addition sizeof function provided allocate objects type struct tree 
lastly function mapped moby function 
interface library generated interface write moby code manipulates tree data structures calls function 
example moby function walks tree adding label fisher pucella reppy fun struct tree val deref stree label stree label stree left stree right generated moby interface implemented bol types functions generated mbi file 
interface mbi file contains definitions type struct tree prim void type def tree node struct tree typedef def tree ptr addr data type def tree ptr prim def tree ptr notice phantom type struct tree defined bol void type 
bol recursive types map tree ptr type addr data bol equivalent void 
access functions struct tree type implemented follows module stree val label lvalue struct tree lvalue sint fun fld lvalue exn handler return val left lvalue struct tree lvalue def tree ptr fun fld lvalue exn handler return val right lvalue struct tree lvalue def tree ptr fun fld lvalue exn handler return val sizeof sizeof struct tree fun sz exn handler return function implemented trivial wrapper function 
extern addr struct tree int val int struct tree fun arg int exn handler result addr struct tree ccall arg return result applications approaches generating foreign interfaces compatible framework 
example haskell tool uses interface specification file coupled header file generate haskell interface library cha 
fisher pucella reppy table measured execution times gettimeofday benchmark language execution time seconds relative tool sys usr tot usr tot moby idl direct haskell interface implemented ghc foreign interface support 
framework express level interoperability building moby tool straightforward 
interesting application framework support domain specific data objects 
example tool generating evaluators grammar specifications highly tuned tree representation expressed directly moby 
tool generate mbi file defines tree representation operations trees code written moby 
compiler cross module inlining mechanism eliminate performance penalty type 
experimental results section results synthetic benchmarks demonstrate efficiency interoperability framework 
measurements performed dual mhz piii workstation running linux kernel version 
benchmark tests overhead marshaling moby idl tool 
benchmark measured time taken perform calls gettimeofday system call 
interface gettimeofday generated idl specification example section 
compare performance moby idl tool haskell direct tool ghc ocaml direct version gcc version 
measured user system times benchmark table 
data columns give execution time seconds user system total 
columns give ratio user total times compared direct version 
expected version test uses essentially amount system time seconds different user times 
discounting system time moby idl version marshaling overhead direct version 
result compares favorably overhead direct overhead 
believe high execution time direct version caused malloc fisher pucella reppy table measured execution times tree benchmark language execution time seconds relative tool sys usr tot usr tot charon ghc second benchmark designed test efficiency direct access data structures moby code framework 
iteration benchmark constructs complete binary tree depth nodes node labeled integer generated calling rand function library 
constructing tree perform depth traversal find largest label explicitly free tree 
benchmark iterates steps times 
wrote moby version benchmark entirely moby charon generated interface representation 
tree data structure managed moby interface library interface malloc free 
compare performance moby program native version algorithm results table 
results see data level interoperability supported charon overhead native code 
measured version program compiled ghc 
version ghc addr type strictness annotations implement interface similar provided charon 
measurements demonstrate ghc foreign data support expressiveness framework lags efficiency 
related approach interoperability moby compiler infrastructure 
infrastructure serves foundation wide range interoperability policies user level mechanism 
approach contrasts prior language interoperability fixes particular interoperability policy user level mechanism 
high level language implementations provide mechanism connecting code 
mechanism requires hand written stub functions translate high level representations 
examples languages mechanisms include java java native interface lia sml nj ocaml ler 
framework supports hand written stubs 
stubs free manage temporary storage needed results gettimeofday call 
slight performance advantage moby benchmark result slightly efficient argument passing mechanism 
course systems multiple mechanisms supports different policy 
fisher pucella reppy written done low level run time system functions file 
case moby compiler cross module inlining mechanism allows stub code inlined call sites 
systems possible write interoperability code high level language 
example sml basis library gr glasgow haskell compiler ghc ghc provide operations reading writing scalar values 
mechanism manipulate data structure importing program 
user responsible understanding layout data structure 
ghc mechanism lower level sml basis specifically ghc bounds checking possible read write pointer values 
respects ghc foreign interface support closest providing flexibility framework 
mechanism slightly expressive support functions struct arguments 
demonstrated section significant performance advantage 
complicated policies required idl bol construct greatly reduce overhead data marshaling 
difficult put mechanism high level language sophisticated type system control extent stack allocated variables 
described moby interoperability infrastructure consists expressive intermediate representation called bol ability import externally defined bol code compilation environment 
infrastructure supports wide range interoperability tools idl tools marshal data tools charon provide data level interoperability embedding moby 
infrastructure highly efficient supports inlining bol code 
experimental evaluation showed overhead associated invoking foreign functions manipulating data structures low 
supporting data level interoperability requires compiler support approach specific moby language se 
specifically expect approach compatible compilers strongly typed irs 
blu blume longer foreign teaching ml compiler speak natively 
babel september 
appear 
bur burton type extension polymorphism 
toplas january pp 

cha chakravarty haskell interfacing tool 
ifl vol 
lncs 
springer verlag september 
fisher pucella reppy finne leijen meijer peyton jones 
direct binary foreign language interface haskell 
icfp september pp 

fr fisher reppy 
design class mechanism moby 
pldi may pp 

george reppy 
portable optimizing back sml nj compiler 
cc april pp 

ghc glasgow haskell compiler user guide version edition january 
gr gansner reppy eds 
standard ml basis library 
cambridge university press cambridge england 
appear 
essential idl 
addison wesley reading ma 
ler leroy user manual march 
available caml inria fr 
ler leroy objective caml system release april 
available caml inria fr 
lia liang java native interface 
addison wesley reading ma 
lm leijen meijer 
domain specific embedded compilers 
proceedings second conference domain specific languages dsl pp 

pr pucella reppy 
idl mapping standard ml 

rep reppy safe interface sockets 
technical memorandum bell laboratories 
sm smith morrisett 
copying collection viable alternative conservative mark sweep 
technical report tr department computer science cornell university august 

