napier manual release ron morrison fred brown richard connor cutts dearle graham kirby dave munro contents context free syntax specification types type rules 
universe discourse type algebra 
aliasing 
recursive definitions 
type operators 
recursive operators 
type equivalence 
type rules 
class citizenship 
literals integer literals 
real literals 
boolean literals 
string literals 
pixel literals 
picture literal 
null literal 
procedure literals 
image literal 
file literal 
expressions operators evaluation order 
boolean expressions 
comparison operators 
arithmetic expressions 
arithmetic precedence rules 
string expressions 
picture expressions 
pixel expressions 
persistent store 
precedence table 
declarations identifiers 
variables constants declaration data objects 
declaration types 
sequences 
brackets 
scope rules 
recursive object declarations 
recursive type declarations 
clauses assignment clause 
clause 
case clause 
repeat clause 
clause 
procedures declarations calls 
recursive declarations 
polymorphism 
equality equivalence 
aggregates vectors 
creation vectors 

indexing 
equality equivalence 
structures 
creation structures 
indexing 
equality equivalence 
images 
creation images 
raster operations 
indexing 
depth selection 
equality equivalence 
variants variant types 
variant values 

projection variants 
variant usage 
equality equivalence 
data types data type definition 
creation data objects 
data objects 
equality equivalence 
files file literal 
equality equivalence 
type injection type 
projection type 
equality equivalence 
environments creating new environment 
adding bindings environment 
bindings environments 
removing bindings environments 
contains clause 
equality equivalence 
appendix appendix ii appendix iii appendix iv index john napier john napier born edinburgh 
st college university st andrews 
little known period study paris travel italy germany returning scotland marry 
period scottish reformation napier committed cause 
wrote discovery revelation saint john addressed king james vi letter 
scottish book interpretation significant place history scotland 
john napier best known inventor logarithms 
important steps theory taken sixteenth century notably napier brought subject large way attention mathematicians 
important mathematics produced great britain inspired briggs professor geometry college london develop system common logarithms decimal base 
napier invented napier rods bones multiplication development known oriental method number formulae relating circular parts 
mathematical works include de published rods described published years death 
napier great advocate decimal fraction system invented 
appears napier introduced decimal point common usage eliminated notation indicate fractional position 
napier persistent programming system provides facilities orthogonal persistence models data independent longevity type completeness restrictions constructing types higher order procedures procedures data objects parametric polymorphism generic forms may specialised existential data types sophisticated protection viewing collections bindings name space control incremental system construction system evolution strongly typed stable store populated environment typed data objects may updated atomically graphical data types line drawings raster images concurrent execution data access threads semaphores transactions support reflective programming system evolution napier system consists language persistent environment 
persistent store populated system uses objects persistent store support 
implication orthogonal persistence user need write code move convert data long short term storage abc 
model persistence napier reachability root object 
persistent store stable transformed consistent state 
stabilisation invoked explicitly user preserve data programs terminate normally generate automatic stabilise operation 
execution persistent store restarted stabilised state 
concurrency provided threads semaphores mun operative concurrency cacs system sm competitive concurrency designer transactions 
notions stability visibility commitment orthogonal kra amp mbb 
entire computation including state programs threads transactions stable recoverable system crash 
napier language algol tradition predecessors algol mor ps algol ps 
strachey str languages obey principles correspondence abstraction type completeness 
languages defining rules allowing exceptions 
belief designers approach language design yields powerful complex languages 
napier type system evolving time cardelli wegner cw published 
ideas related theirs borrowed 
philosophy types sets values value space 
type system statically checkable property wish retain possible 
dynamic projection unions types env dea variant selection allows dynamic binding required orthogonal persistence abc system evolution mcc 
type system polymorphic ml mil mth russell dd poly mat uses existentially quantified types mitchell plotkin mp cmm data types 
deliberately type inference allow explicit specialisation polymorphic forms persistent store 
unique design feature implementation typed objects storage format may non uniform mdc 
type system includes graphical types line drawing infinite dimensional real space manipulating raster images 
type equivalence rule napier structure recursive parameterised types allowed type algebra general leads undecidable type checking 
dealt napier syntactic convention allows type checking sound complete complete con 
napier system designed layered architecture bro consisting compiler dea con cut persistent machine pam bcc cbc persistent storage architecture bro bm mun 
napier architectural layers virtual implementation may implemented separately efficiency dictates 
definitional concrete 
current release stable storage provided shadow paging mechanism bro bm mun 
architecture shown stable heap persistent objects stable storage non volatile storage protection mechanism distribution concurrency user transactions persistent machine local heap napier programs executed strict left right top bottom manner flow control altered language clauses 
encountering error state pam generates call standard error procedure held persistent store 
error procedures may redefined user 
persistent machine monitors interaction operating system napier resides 
asynchronous interrupt occurs pam records causes appropriate procedure call standard event procedure persistent store 
user may redefine procedures intercept asynchronous interrupts 
may incarnations stable persistent store activations pam 
pam incarnation may persistent store time 
version manual corresponds release napier language 
language changes release mbc mbc persistent environment significantly enriched 
changes language dynamic witness model types type operators separate manual napier standard library manual kbc describes persistent environment release 
main changes provision browser compiler reflective programming threads semaphores new organisation object store provide navigation free store distributed stores remote scan copy hyper programming system 
environment provides mechanism internet sites contribute programs data may accessed remote scan copy napier stores 
mechanism described napier release installation guide kbc 
third manual napier persistent machine compilation rules manual bbc describes formal definition napier rules generate code persistent machine 
napier persistent programming system originally planned part pisa project amp intended testbed experiments type systems programming environments concurrency bulk data object stores persistence 
form napier language conceived ron morrison malcolm atkinson main design implementation done fred brown richard connor alan dearle ron morrison 
release constitutes major re engineering re organisation enhancement system addition cutts graham kirby dave munro 
people contributed napier design 
malcolm atkinson played major role mbc am mbb research assistants richard cooper francis wai paul 
stc technology john scott john robinson dave sparks michael guy aided criticised constructively early designs 
visiting fellows st andrews john hurst chris barter chris marlin john rosenberg dave stemple robin stanton contributed influenced design research undertaken context napier 
ron morrison context free syntax specification formal definition programming language gives programmers precise description providing implementors model 
levels definition syntactic semantic 
section deals formal syntactic rules define context free syntax language 
informal semantic descriptions syntactic categories 
formal rules define set syntactically legal napier programs remembering meaning programs defined semantics 
define syntax language notation required called meta language case variation backus naur form 
syntax napier specified set rules called productions 
production specifies manner particular syntactic category clause formed 
syntactic categories names productions distinguished names reserved words language 
syntactic categories mixed productions terminal symbols actual symbols language 
productions terminal symbols reached set legal programs derived 
meta symbols symbols meta language describe grammar language include allows choice production 
square brackets pairs denote term optional 
zero times repetition indicated 
reader confuse meta symbols actual symbols reserved words napier 
help reserved words appear bold actual symbols appear outline bold 
names productions appear italics 
example identifier letter letter digit indicates identifier formed letter optionally followed zero letters digits 
productions napier recursive means infinite number legal napier programs 
syntax napier described productions 
full context free syntax napier appendix types type rules napier type system notion types set structure imposed value space 
membership type sets defined terms common attributes possessed values operations defined 
absence polymorphism sets types partition value space polymorphic forms napier polymorphic procedures data types allow values belong single type 
sets may predefined integer may formed predefined type constructors structure 
constructors obey principle data type completeness str mor 
type may constructor type legal exception 
benefits 
firstly rules general exceptions rich type system may described small number defining rules 
reduces complexity defining rules 
second benefit type constructors powerful possible restrictions domain 
universe discourse base types defined napier 
scalar data types int real bool pixel file null 

type string type character string type embraces empty string single characters 

type pic type conceptual line drawing modelled infinite real space type embraces single points 

type image type value consisting rectangular matrix pixels 

type env type environment values type consist collection bindings 

type infinite union type values type consist value type representation type 
type constructors defined napier 
type type vector elements type 
identifiers types structure type structure fields corresponding types 
identifiers types variant type variant identifiers corresponding types 

types proc type procedure parameter types result type type procedure proc 

proc definitions types may include type variables type procedure universally quantified type variables 
polymorphic procedures 

abstype definitions types may include type variables type structure existentially quantified type variables 
data types 
world data values defined closure rules recursive application rules 
addition clauses yield value type void 
type algebra napier provides simple type algebra allows succinct definition types programs 
base types constructors introduced types may defined aliasing recursive definitions type operators aliasing legal type description may aliased identifier provide shorthand conceptually meaningful representation type 
example type ron int type man structure age int size real type variant ron second man alias may place full type description 
recursive definitions expressibility may achieved type algebra recursive types 
recursive types allow definition user defined types values regular structures 
reserved word rec introduced type alias allows instances alias appear type definition 
mutually recursive types may defined grouping aliases 
case binding identifiers mutual recursion group takes precedence identifiers scope 
rec type intlist variant cons tip null structure head int tail intlist type operators type operators allow families types defined operators may specialised provide particular types 
operators simple functions types note statically resolved 
type operators defined overloading syntax type aliasing formal parameters provided square brackets alias 
example type structure second type structure second operators applied identifier followed specialising types square brackets 
example type int real type int notice operator identifiers may appear fully specialised 
convenient define higher order operators type oper structure second oper int notice case inner brackets may formal parameter simply indication arity formal parameter oper 
identifiers contexts extent 
recursive operators napier distinguish syntactically recursive type operators operators recursive types 
example generic description family list types rec type list variant cons node tip null node structure head tail list uncontrolled recursive type operators leads ability describe types decidable structural equivalence algorithm known 
restriction napier definition recursive operators follows specialisation recursive operator right hand side definition may include types constructed formal parameters 
rule extends dependencies sets mutually recursive definitions example list allowed right hand side example way definition list depends definition node 
rule precludes description useful type operators types example may describe type array dimension rec type array variant simple higherorder array restriction introduced allow fully decidable typechecking napier restrictive schemes investigation 
type equivalence type equivalence napier meaning types independent way type expressed type algebra 
aliases recursion variables operator applications fully factored equivalence assessed 
style type equivalence normally referred structural equivalence 
structural equivalence rules follows base type equivalent 
constructed types equivalent constructor constructed equivalent types 
bounds vector significant type equivalence 
structure variant abstype constructors labels significant part type ordering 
procedure polymorphic procedure types parameter ordering significant part type construction 
definition type equivalence types involve type variables polymorphic procedures data types somewhat subtle defined appropriate sections manual 
napier subtyping implicit coercion rules 
values may substituted assignment parameter passing types known statically equivalent 
types expressions napier inferred 
type inference mechanism particular types procedure parameters results explicitly stated programmer 
type rules type rules form second set rules conjunction context free syntax define formed programs 
generic types required formal definition napier described type arith int real type ordered arith string type literal ordered bool pixel pic null proc file image type nonvoid literal structure variant env abstype parameterised poly nonvoid type type nonvoid void generic type arith int real representing types integer real language 
type rules concrete types generic types written shadow face distinguish reserved words meta symbols actual symbols 
type categories corresponds type construction rules described manual 
check syntactic category correctly typed context free syntax conjunction type rule 
example type rule armed clause type clause bool clause clause rule may interpreted follows type table 
type including void 
comma type rule states reserved word followed clause type boolean 
indicated bool 
alternatives clauses type resultant type indicated production alternatives 
type rules manual conjunction context free syntax rules describe language 
complete set type rules napier appendix ii 
class citizenship application principle data type completeness str mor ensures data types may combination language 
example value data type may parameter returned procedure 
addition number properties possessed values data types constitute civil rights language define class citizenship 
values data types napier class citizenship 
additional civil rights define class citizenship right declared right assigned assigned right equality defined right persist 
literals literals basic building blocks napier programs allow values introduced 
literal defined literal int literal real literal bool literal string literal pixel literal picture literal null literal proc literal image literal file literal integer literals type integer defined int literal add op digit digit add op int literal int integer literal digits optionally preceded sign 
example real literals type real defined real literal int literal digit int literal real literal real number ways writing real literal 
example 
means times power boolean literals literals type boolean true false 
defined bool literal true false bool literal bool string literals string literal sequence characters character set ascii enclosed double quotes 
syntax string literal char char ascii character special character special character special follow followed special follow special follow string literal string empty string denoted 
examples string literals string literal am string programmer may wish double quote inside string literal 
requires single quote escape character single double quote required inside string literal preceded single quote 
example value value 
number special characters may inside string literals 
backspace ascii code horizontal tab ascii code newline ascii code ascii code carriage return ascii code pixel literals literals type pixel 
defined pixel literal pixel literal pixel picture literal picture literal 
define picture points 
picture literal pic null literal literal type null 
ground recursion variant types 
null literal nil nil null procedure literals procedures introduced program literal value 
defined proc literal proc type parameter list named param list type id clause type parameter list identifier list named param list constant identifier list type id named param list type proc type parameter list named param list type identifier clause example proc procedure literal 
meaning procedures described chapter 
image literal image literal 
define image pixels 
dimensions depth 
image literal image file literal file literal 
denote file value bound file file system 
file literal file expressions operators evaluation order order execution napier program strictly left right top bottom flow control altered language clauses 
rule important understanding side effects store 
parentheses expressions override precedence operators 
error occurs system standard error procedure called automatically 
standard error procedures stored standard environment may altered user napier facilities updating environments 
event may occur execution napier program 
event acts unexpected procedure call 
events defined standard environment may manipulated manner errors 
details events errors may napier standard library manual kbc 
boolean expressions objects type boolean napier value true false 
boolean literals true false operators 
boolean unary operator boolean binary operators 
defined truth table true false false true false false true true true false true true false true true false false true false false precedence operators important defined descending order equivalent reflected syntax rules expression exp exp exp exp exp exp exp 
exp bool exp bool bool exp bool exp bool bool exp bool bool evaluation boolean expression napier non strict 
left right evaluation expression computation performed expression necessary 
example true expression gives value true evaluating expression false expression gives value false evaluating expression 
comparison operators expressions type boolean formed binary operators 
example true false boolean 
operators called comparison operators greater greater equal equal equal particular member variant particular member variant contains environment see syntactic rules comparison operators exp exp rel op exp rel op eq op op variant op eq op op variant op nonvoid exp eq op exp bool eq op ordered exp op exp bool op expression variant variant op identifier bool variant op note operators defined integers reals strings defined napier data types 
interpretation operations data type introduced 
operators testing variant identifier defined chapter 
equality types scalar types strings defined identity 
arithmetic expressions arithmetic may performed data objects type integer real 
syntax arithmetic expressions exp exp add op exp exp exp mult op exp exp add op exp mult op int mult op real mult op exp arith exp add op exp arith add op exp exp int int mult op exp int int int mult op div rem exp real real mult op exp real real real mult op operators mean addition subtraction multiplication real division div integer division throwing away remainder rem remainder integer division div rem result negative exactly operands negative 
examples arithmetic expressions language deliberately provide automatic coercion integer real transfer may explicitly invoked standard procedure float standard procedure truncate provided transfer real integer 
described napier standard library manual kbc 
evaluation arithmetic expression may cause standard error procedures int real called 
arithmetic precedence rules order evaluation expression napier left right precedence table div rem operations div rem evaluated 
operators precedence expression evaluated left right 
example div rem gives value brackets may override precedence operator clarify expression 
example yields string expressions string operator concatenates operand strings form new string 
example abc def results string abcdef syntax rule exp exp string mult op exp exp string string mult op exp string string string mult op new string may formed selecting substring existing string 
example string abcdef string cd 
new string formed selecting elements starting character 
syntax rule exp expression clause clause expression string clause int clause int string purposes substring selection character string numbered 
selection values start position length respectively 
compare strings characters compared pairs string left right 
strings considered equal characters order length equal 
characters string ordered ascii character code 
true 
null string string 
relation resolved characters pair pair strings 
strings equal length compared shorter considered longer 
abc relations defined evaluation string expression may cause standard error procedures concatenate substring called 
picture expressions picture drawing facilities napier allow user produce line drawings dimensions 
system provides infinite dimensional real space 
altering relationship different parts picture performed mathematical transformations means pictures usually composed number 
line drawing system simplest picture point 
example expression defines point 
points pictures implicitly ordered 
binary operation pictures operates point picture point second 
resulting picture point point picture point second 
infix picture operators 
forms new picture joining picture second straight line point picture point second 
forms new picture including operand pictures 
transformations operations pictures shift new picture consists points obtained adding shift values ordinates points old picture 
ordering points preserved 
scale new picture consists points obtained multiplying scale values ordinates points old picture respectively 
ordering points preserved 
rotate new picture consists points obtained rotating ordinates points old picture clockwise origin angle indicated degrees 
ordering points preserved 
colour new picture old new colour 
text new picture consists text string converted picture representation 
points represent base line string scaled fit 
text expression may cause standard error procedure text called picture drawn 
full syntax picture expressions exp exp pic mult op exp pic mult op expression pic pic mult op expression pic pic value constructor picture constr picture op picture constr clause clause picture op shift clause clause clause scale clause clause clause rotate clause clause colour clause clause text clause clause clause clause clause clause real clause real pic shift clause pic clause real clause real pic scale clause pic clause real clause real pic rotate clause pic clause real pic colour clause pic clause pixel pic text clause string clause real clause real clause real clause real pic pixel expressions pixels may concatenated produce pixel greater depth operator 
exp exp exp exp pixel exp pixel pixel example pixel depth representing number planes pixel 
planes numbered new pixels formed 
syntax exp expression clause clause expression pixel clause int clause int pixel example assuming declaration pixel expression interpreted pixel formed starting plane selecting planes 
evaluation pixel expression may cause standard error procedures subpixel called 
pixels equal depth corresponding planes value 
persistent store predefined procedure napier allows access persistent store 
defined exp ps ps structure persistent store described napier standard library manual kbc 
precedence table full precedence table operators napier div rem declarations identifiers napier identifier may bound data object procedure parameter structure field variant label data type label type 
identifier may formed syntactic rule identifier letter id follow id follow letter id follow digit id follow id follow identifier consists letter followed number underscores letters digits 
legal napier identifiers look record ron note case significant identifiers 
variables constants declaration data objects identifier napier declared 
action declaring data object associates identifier typed location hold values 
napier programmer may specify location constant variable 
constant may manipulated exactly manner variable may updated 
introducing identifier programmer indicate identifier type data object usually deduced variable constant initial value 
identifiers declared syntax identifier init op clause init op identifier init op clause nonvoid void variable declared identifier clause example introduces integer variable initial value 
notice compiler deduces type 
constant declared identifier clause example discrim introduces real constant calculated value 
language implementation detect flag error attempt assign constant 
declaration types type names may declared user napier 
name represent set objects drawn value space may type identifier legal 
syntax type declarations type decl type type init rec type type init type init type init identifier type operator list type id type operator list type operator type operator type operator identifier identifier type operator type id int real bool string pixel pic null env image file identifier parameterisation type constructor parameterisation type list type list type id type list type constructor type id structure type variant type proc type abstype structure type structure named param list named param list constant identifier list type id named param list variant type variant variant fields variant fields identifier list type id variant fields proc type proc type parameter list parameter list type id parameter list type id parameter list abstype abstype type parameter list named param list type parameter list identifier list type bool type declaration aliasing identifier boolean type 
type may interchangeably 
examples type declarations chapters 
sequences sequence composed combination order declarations clauses 
type sequence type clause sequence 
sequence ends declaration definition type void sequence type void 
clause sequence type void 
sequence declaration sequence clause sequence sequence void void type declaration void sequence type clause void sequence type clause brackets brackets sequence clauses declarations single clause 
forms sequence sequence type sequence type sequence allow sequence written clearly line clause 
example sequence longer line alternative gives greater clarity 
nonvoid sequences called block expressions 
scope rules scope identifier limited rest sequence declaration 
means scope identifier starts immediately declaration continues unmatched 
identifier declared inner sequence inner name scope outer 
recursive object declarations necessary define values recursively 
example defines recursive version factorial procedure rec factorial proc int int factorial effect recursive declaration allow identifier enter scope immediately 
init op declaration clause case non recursive declarations 
identifier factorial literal refers location defined 
chapter gives example mutually recursive procedures 
identifier declared identifiers come scope time 
names declared available clauses init op 
initialising clauses recursive declarations restricted literal values 
full syntax object declarations object decl object init rec rec object init rec object init object init identifier init op clause rec object init identifier init op literal init op declaration void object decl object init rec rec object init rec object init object init identifier init op clause nonvoid rec object init identifier init op literal nonvoid init op recursive type declarations full syntax type declarations type decl type type init rec type type init type init type init identifier type operator list type id type operator list type operator type operator type operator identifier identifier type operator list example rec type intlist variant cons tip null structure head int tail intlist defines type list integers 
clauses expressions described chapter clauses allow operators language produce data objects 
kinds clauses napier allow data objects manipulated provide control flow program 
assignment clause assignment clause syntax clause name clause nonvoid name clause void example discriminant gives discriminant value expression right 
course identifier declared variable constant 
clause alters value denoted identifier 
assignments may vector elements fields structures data types 
semantics assignment defined terms equality 
clause identifiers implies execution true 
seen assignment scalar types means value assignment constructed types means pointer assignment 
clause forms clause defined clause clause clause clause clause clause bool clause void void type clause bool clause clause single armed version condition true clause executed 
example clause value assigned smaller clause executed 
second version allows choice actions 
clause true second clause executed third clause executed 
notice second third clauses type result type 
contains examples clauses temp case clause case clause generalisation clause allows selection item number possible ones 
syntax case clause case list default clause case list clause list clause case list type nonvoid case clause case list default clause case list clause list clause case list clause list clause clause list example case clause case car colour green red default execution clause value car colour compared strict order left right top bottom expressions left hand side colon 
match clause right hand side executed 
control transferred clause case clause 
match default clause executed 
case clause result type string 
repeat clause forms clause allow loops constructed test start middle loop 
forms encapsulated production alternatives repeat clause clause clause clause clause repeat clause void clause bool clause void void clause bool clause void void forms loop executed boolean clause false 
version perform loop zero times repeat times 
example repeat clause factorial repeat factorial factorial factorial factorial clause clause included language syntactic sugar fixed number iterations defined initialisation loop 
defined identifier clause clause clause clause identifier clause int clause int clause int clause void void clauses initial value limit increment clause repeated respectively 
type int calculated start 
clause may omitted increment 
identifier known control constant scope void clause range values successively defined initial value increment limit 
control constant considered declared start repetition clause 
repetition clause executed times necessary complete loop time control constant initialised new value starting initial loop value changing increment limit reached 
example clause factorial factorial factorial positive increment loop terminates control constant initialised value greater limit 
negative increment loop terminates control constant initialised value limit 
procedures declarations calls procedures napier constitute abstractions expressions return value clauses type void 
accordance principle correspondence str method introducing name declaration equivalent form parameter 
declarations data objects giving name initial value equivalent assigning actual parameter value formal parameter 
type declaration data objects language parameter passing mode commonly known call value 
declarations formal parameters representing data objects name type indication variable constant 
procedure returns value specify return type 
scope formal parameters declaration procedure clause 
procedures defined literals syntax proc literal proc type parameter list named param list type id clause type parameter list identifier list named param list constant identifier list type id named param list type proc type parameter list named param list type id clause integer identity procedure called int id may declared int id proc int int syntax procedure call expression application application clause list type expression proc clause list clause list clause nonvoid clause list correspondence actual formal parameters types 
call integer identity procedure int id evaluate integer 
type int id written proc int int 
complete principle correspondence procedures parameters may constant 
variable parameters may assigned local variables local effect 
constant parameters may assigned 
example parameter int id assigned appropriately constant 
declaration int id proc constant int int note constancy parameter part type notion important deciding type equivalence 
recursive declarations recursive mutually recursive declarations procedures allowed napier 
example rec tak proc int int tak tak tak tak declares recursive takeuchi procedure 
mutually recursive procedures may defined 
example rec expression proc repeat exp exp proc repeat exp exp proc case symb identifier symbol default expression declares mutually recursive procedures 
polymorphism polymorphism permits abstraction type 
example id proc constant declares procedure identity procedure types 
square brackets signify procedure type universally quantified type type procedure type call procedure programmer may write id int yields id real yields type parameter may 
example id int yields procedure equivalent int id 
procedure id fact infinite number identity procedures type specialised 
square brackets quantifier type variables signify types part value space language philosophy types sets values 
type id written proc napier 
procedures polymorphic types class may stored passed parameters returned results advantage polymorphic abstraction obvious context software reuse 
example procedure sort vector integers may written procedure sort vector reals 
polymorphism napier procedure types different type may written 
greatly reduces amount code written large system 
equality equivalence procedures equal napier values derived evaluation procedure expression 
means closure 
common aggregate objects napier equality means identity 
procedure types structurally equivalent parameter types correspondence result type 
polymorphic procedures additional constraint number quantifiers consistently substitutable manner 
terms types sets polymorphic procedures infinite intersections types cw 
declaration quantifier type variable acts type new base type type equivalence purposes 
quantifier type variables equivalent derived instantiation type variable identifier 
consequence value quantifier type variable injected infinite union may projected quantifier type variable 
aggregates napier allows programmer group data objects larger aggregate objects may treated single objects 
object types napier vectors structures images 
constituent objects type vector may structure 
images collections pixels 
vectors structures images civil rights data object napier 
data types chapter environments chapter may considered methods aggregation chosen treat separately 
aggregate data objects napier pointer semantics 
aggregate data object created pointer locations object created 
object referred pointer may passed assignment tested equality 
location containing pointer constituent parts aggregate data object may independently constant variable 
vectors creation vectors vector provides method grouping objects type 
napier allow locations initial values elements specified 
syntax vector constr constant vector vector element init vector element init range clause range clause clause clause clause range clause clause nonvoid vector range clause nonvoid vector range clause proc int nonvoid vector clause int clause clause range clause int clause int example vector vector integers type written int lower bound variable locations initialised 
similarly abc vector introduces variable abc type int initial value expressed 
multi dimensional vectors necessarily rectangular created 
example pascal constant vector constant vector constant vector constant vector constant vector constant vector constant vector pascal type int 
constant elements 
fixed table 
word constant vector indicates elements constant 
checking constancy performed assignment element 
pointer constancy determined init op case indicates pointer constant 
form vector expression tedious write large rectangular vectors common initial value 
form vector expression available 
example vector produces element integer vector elements variable initialised 
lower bound vector upper bound 
element initialising expression evaluated result assigned elements 
third form vector initialisation provided allow elements vector initialised function index 
example squares proc int int squares vector constant vector squares initialisation procedure squares called index vector order lower upper bound 
corresponding element initialised result index passed procedure 
case vector squares vector elements initialised 
initialising procedure type proc int resulting vector type style initialisation particularly useful vectors constant elements 
creation vector may call standard error procedure 
necessary interrogate vector find bounds 
standard procedures provided napier purpose 
defined napier standard library manual kbc type proc int 
indexing obtain elements vector indexing 
vectors index integer value 
syntax exp expression dereference dereference clause dereference nonvoid expression clause int example selects element vector associated index value 
vectors may indexed commas separate indices 
indexing expressions may call standard error procedure assignment vector element may call 
equality equivalence vectors equal identity pointer 
vectors type equivalent equivalent element types 
notice bounds part type 
structures creation structures objects different types grouped structure 
fields structure identifiers unique structure 
structures sets labelled cross products value space 
structure may created ways syntax structure constr struct struct init list struct init list identifier init op clause struct init list struct struct init list structure struct init list identifier init op clause nonvoid struct init list example struct true creates structure field constant integer identifier second field variable boolean identifier structures may created type identifier 
syntax structure types structure type structure named param list named param list constant identifier list type id named param list example structure type may declared follows type person structure constant name string age height int declares structure type person fields type string int int respectively 
name field constant 
declares field identifiers name age height 
create structure type declaration type identifier followed initialising values fields 
structure creation identifier specialisation clause list example ron person ronald morrison creates structure type person defined 
initialising values correspondence structure type declaration 
indexing obtain field structure field identifier index 
example ron declared ron age yields 
indexing operation legal structure contain field identifier 
vectors constancy check performed assignment 
field identifiers indices scope brackets structure expression 
identifiers need unique structure type 
comma notation may vectors structures elements fields structures vectors 
indexing vectors structures may freely mixed 
example vector vectors persons name name name equivalent expressions 
attempted assignment constant field structure cause standard error procedure called 
equality equivalence structures equal identity pointer 
type structure set field identifier type pairs 
structure ron type structure name string age int height int structures equivalent types types set pairs fields 
note order fields unimportant 
images creation images image rectangular grid pixels 
images may created manipulated raster operations provided language 
creation images defined image constr constant image clause clause image init image init clause clause subimage constr limit clause clause clause clause clause image clause int clause int clause pixel image image clause int clause int clause image image limit clause image clause int clause int clause int clause int image integer values subjected upper bound check 
integer values 
conditions violated standard error procedure called 
image dimensional object rectangular grid pixels 
image may created follows image creates pixels direction direction 
origin images case depth 
multi plane images may formed multi plane pixels image images class data objects may assigned passed parameters returned results 
example assign existing image new order map operations usual bitmapped screens assignment new copy merely copies pointer 
image acts vector structure assignment 
raster operations raster operations may described syntax 
raster raster op clause clause raster op ror rand xor copy nand xnor raster op clause image clause image void clause xor performs raster operation xor 
notice altered situ unchanged 
images origin automatic clipping extremities destination image performed 
raster operations performed considering images bitmaps altering bit destination image source bit operation 
multiple plane raster operations discussed 
gives meanings operations stands destination source operation interpretation result ror inclusive rand xor exclusive xor copy overwrite nand inclusive source xnor exclusive xor images may created initialising image background pattern 
example constant image abc create image size copy image abc times necessary fill directions starting 
style initialisation particularly useful setting images constant pixels images regular patterns 
image constant pixels causes standard error procedure called 
indexing limit operation allows user set aliases parts images 
example limit sets part starts size 
origin window sections images sections images may performed example xor limit limit automatic clipping edges limited region performed 
starting point limited region omitted size region omitted taken maximum possible 
taken starting point edges host image 
limited regions limited regions may defined 
source destination images overlap raster operation performed manner pixel source destination 
evaluation limit operation may cause standard error procedures called 
depth selection operations seen images raster limit assignment generally depth 
raster operations perform raster function plane plane correspondence source destination 
automatic depth clipping destination performed source fewer planes destination extra planes remain unaltered 
limit operation works planes image 
depth image may restricted depth selection operation 
example assuming earlier definition yields alias part depth planes 
start plane number planes 
depth origin dimensions 
full syntax depth selection operation exp expression clause clause expression image clause int clause int image indexing expression may call standard error procedure subimage 
equality equivalence images equal pointer 
images equivalent types 
variants variant types variants sets labelled disjoint sums value space 
variant value identifier value pairs 
variant type may defined variant type variant variant fields variant fields identifier list type id variant fields example type variant variant int real declares type variant may int real 
variant values variant value may formed naming variant type injecting pair 
syntax variant creation identifier specialisation identifier clause example variant declares value type variant int real value value injected identifier variant type contain identifier type pair initialisation 
variant object tested having particular identifier 
syntax exp exp type op identifier type op expression variant type op identifier bool type op legal yield boolean value true 
compilation error occur variant type contain identifier tag 
projection variants variants particularly useful conjunction recursive types 
example type definition list integers rec type intlist variant cons tip null structure head int tail intlist element list formed intlist tip nil intlist cons struct hd tl order facilitate static type checking value injected variant rebound constant location project clause 
syntax project clause identifier project list default clause project list 
variant project list variant project list identifier clause variant project list type project clause variant identifier variant project list default clause variant project list identifier clause variant project list projected value constant binding identifier 
scope identifier clauses right hand side colons 
mechanism prevents side effects projected value inside evaluation right hand side clauses allows static type checking 
projection variant compared labels left hand side colons 
match causes corresponding clause right hand side executed 
clause identifier type projected value 
control passes clause project clause 
default clause constant identifier bound original variant value 
example procedure reverse list rec type intlist variant cons tip null structure hd int tl intlist proc list intlist intlist temp intlist tip nil done false done project list cons temp intlist cons struct hd hd tl temp list tl default done true temp variant usage value variant may projected single quote notation 
syntax expression identifier example assuming definition yields value type real 
scope variant identifiers may variant injections symbols 
procedure reverse integer list written proc list intlist intlist temp intlist tip nil list tip temp intlist cons struct hd list cons hd tl temp list list cons tl temp evaluation operation may cause standard error procedure called 
equality equivalence variant types equivalent set identifier type pairs 
variants equal equivalent types identifier tags equal values 
data types data types may data object displays behaviour independent representation type 
second mechanism abstracting type 
data type definition data types may introduced syntax abstype abstype type parameter list named param list type test abstype constant proc declares type test 
type identifiers enclosed square brackets called witness type identifiers types abstracted 
comparison polymorphic procedures universally quantified types 
types existentially quantified constitute infinite unions types mp 
data type interface declared round brackets 
case type elements field type constant procedure type proc 
creation data objects create data object syntax abstype creation expression specialisation clause list example int proc int int test int int declares data object type definition test concrete opposed witness type int integer procedure int 
creation values type correspondence type definition 
data object created user tell constructed 
type abstype proc user discover witness type integer 
test int int creates data object 
constructed concrete witness type information abstracted type abstype proc real proc real real test real real vector objects formed abs test vec constant vector type 
data objects internal representation data object hidden inappropriate mix operations 
data object totally enclosed may operations 
second requirement system type checking objects static 
achieve aims clause introduced define constant binding data object 
constant binding indexed refer values manner statically checkable 
syntax clause clause identifier witness decls clause clause abstype identifier witness decls clause void void example abs test vec apply procedure value storing result data object referred abs test vec 
declared constant initialised abs test vec 
generalised procedure act elements vector 
example increment proc test lower test abs test vec upper test abs test vec lower upper increment abs test vec scope identifiers interface restricted clause constant binding identifier 
clause witness types may named 
example id proc id renames witness type allows type identifier clause 
equality equivalence data object equal equality means identity 
data types equivalent identifiers equivalent types interface number witness types substitutable manner 
witness types equivalent derive instance data type 
value witness type injected infinite union may projected corresponding witness abstype instance 
files file data type access devices available host environment napier system implemented 
file may refer disk file terminal mouse tablet window socket shell raster graphics display 
certain operations specific kind file range operations applicable files 
value type file implemented pointer object describes device associated state 
set standard procedures provided create manipulate file descriptors devices refer 
operation standard procedures fully described napier standard library manual kbc 
file literal literal type file 
see section 
equality equivalence values type file equal file 
values type file equivalent types 
type type type union values napier 
values explicitly injected projected type 
operations performed dynamically particular projection type involves dynamic type check 
argued abc type check required support binding independently prepared programs data type secure persistent object store 
injection type values may injected type syntax clause nonvoid clause example int declares int integer value injected type 
values type may passed parameters 
example identity procedure type 
id proc polymorphic procedures may written type injecting parameters call projecting results call 
projection type values may projected type project clause 
project clause identifier project list default clause project list project list project list type id clause project list type project clause identifier project list default clause project list type id clause project list projected value constant binding identifier 
scope identifier clauses right hand side colons 
mechanism prevents side effects projected value inside evaluation right hand side clauses allows static type checking 
projection type compared types left hand side colons 
match causes corresponding clause right hand side executed 
clause identifier type projected value 
execution project clause control passes clause project clause 
example projection write type proc string project int type integer real type real default type integer real equality equivalence values type equal projected equivalent types projected values equal 
values type type equivalent 
environments environments dea infinite union labelled cross products 
environments differ structures bindings may added removed environments dynamically 
mechanism napier provide method dynamically composing block structure controlling name space 
environments provide method storing composing independently prepared programs data control persistent object store language resides 
binding napier components identifier type value variable constant location indicator am 
type environment written env napier 
creating new environment new environment created standard procedure environment type proc env calling procedure creates environment bindings 
procedure fully described napier standard library manual kbc adding bindings environment bindings added environments means declarations 
syntax env decl clause object init clause rec rec object init rec object init object init identifier init op clause rec object init identifier init op literal init op program segment environment creates environment 
environment creates binding identifier value type integer constant int constant 
binding added environment local scope 
standard error procedure called binding added unique identifier environment 
binding may added writing rec fac proc int int fac form int constant fac proc proc int int variable non recursive declarations bindings added environments time 
recursive declarations added simultaneously case 
corresponds scoping rules non recursive recursive declarations blocks 
example mutually recursive procedures environment rec type list variant cons node tip null node structure hd tl list rec type object variant ron bool fred list object rec show proc object string project ron true false fred default proc list object string tip show cons hd cons tl notice show refer appears local scope 
calls procedures bound 
achieve desired bindings mutually recursive procedures environments rule identifiers bind environment objects declared 
bindings environments bindings environment brought scope clause 
syntax clause clause signature clause signature named param list named param list constant identifier list type id named param list type clause env signature clause example fac declared earlier programmer may write fac proc int int fac 
effect clause bring name fac scope head clause 
fac binds location environment 
local assignment fac alter value environment 
notice partial match signature environment necessary 
binding identifiers environment binding types equivalent 
constancy determined original binding may separately specified constant clause 
update constant value allowed run time compiler flag syntax error assignment binding specified constant 
bindings environment specified signature clause scope clause may 
standard error procedure called signature clause matched environment 
removing bindings environments bindings may removed environments drop clause 
syntax clause drop identifier clause drop identifier clause env void example drop fac effect binding longer reachable environment 
imply destruction object dangling bindings value dropped binding valid 
standard error procedure called dropped identifier exist environment 
contains clause environment may tested infix operator contains determine contains binding certain characteristics 
syntax exp clause contains constant identifier type id clause env contains constant identifier type id bool forms allow testing identifier environment binding identifier type pair identifier constancy binding identifier constancy type binding 
environment earlier contains true contains int true contains constant true contains constant int true contains string false contains false equality equivalence values type environment equal refer environment 
environments equivalent types 
abc atkinson bailey chisholm cockshott morrison approach persistent programming 
computer journal pp 
am atkinson morrison types bindings parameters persistent environment 
data types persistence atkinson buneman morrison 
ed springer verlag pp 
amp atkinson morrison designing persistent information space architecture 
proc 
th ifip world congress dublin pp 
bbc brown connor cutts dearle kirby morrison munro napier persistent machine compilation rules 
university st andrews technical report cs 
bcc brown connor dearle morrison persistent machine 
universities glasgow st andrews technical report 
bm brown morrison generic persistent object store 
software engineering journal pp 
bro brown persistent object stores 
ph thesis university st andrews 
cbc connor brown dearle morrison persistent machine 
persistent object systems rosenberg koch 
ed springer verlag proc 
rd international workshop persistent object systems newcastle australia pp 
cmm connor morrison subtyping assignment database programming languages 
proc 
rd international workshop database programming languages greece 
con connor types polymorphism persistent programming systems 
ph thesis university st andrews 
cut cutts delivering benefits persistence system construction execution 
ph thesis university st andrews 
cw cardelli wegner understanding types data abstraction polymorphism 
acm computing surveys pp 
dd demers donahue revised report russell 
cornell university technical report tr 
dea dearle construction persistent programming environments 
ph thesis university st andrews 
dea dearle environments flexible binding mechanism support system evolution 
proc 
nd international conference systems sciences hawaii pp 
kbc kirby brown connor cutts dearle moore morrison munro napier standard library manual version 
university st andrews technical report cs 
kbc kirby brown connor cutts dearle morrison munro napier release installation guide 
university st andrews 
kirby reflection hyper programming persistent programming systems 
ph thesis university st andrews 
kra building flexible multilevel transactions distributed persistent environment 
proc 
nd international workshop persistent object systems scotland pp 
mat matthews poly manual 
university cambridge 
mbb morrison barter brown connor dearle hurst language design issues supporting process oriented computation persistent environments 
proc 
nd international conference system sciences hawaii pp 
mbc morrison brown connor dearle atkinson polymorphism persistence software reuse strongly typed object oriented environment 
software engineering journal december pp 
mbc morrison brown connor dearle napier manual 
universities glasgow st andrews technical report 
mbc morrison brown connor dearle napier release 
university st andrews 
mcc morrison connor cutts kirby stemple mechanisms controlling evolution persistent object systems 
journal microprocessors microprogramming pp 
mdc morrison dearle connor brown adhoc approach implementation polymorphism 
acm transactions programming languages systems pp 
mil milner theory type polymorphism programming 
journal computer system sciences pp 
mor morrison development algol 
ph thesis university st andrews 
mp mitchell plotkin types existential type 
acm transactions programming languages systems pp 
mth milner tofte harper definition standard ml 
mit press cambridge massachusetts 
mun munro integration concurrency distribution persistence 
ph thesis university st andrews 
ps ps algol manual th edition 
universities glasgow st andrews technical report 
sm stemple morrison specifying flexible concurrency control schemes operational approach 
proc 
th australian computer science conference hobart pp 
str strachey fundamental concepts programming languages 
oxford university press oxford 
language design methods semantic principles 
acta informatica pp 
available ftp ftp fide dcs st andrews ac uk pub persistence papers www www fide dcs st andrews ac uk publications html appendix context free syntax session session sequence 
sequence declaration sequence clause sequence declaration type decl object decl type declarations type decl type type init rec type type init type init type init identifier type operator list type id type operator list type operator type operator type operator identifier identifier type operator list type descriptors type id int real bool string pixel pic null env image file identifier parameterisation type constructor parameterisation type list type list type id type list type constructor type id structure type variant type proc type abstype structure type structure named param list named param list constant identifier list type id named param list variant type variant variant fields variant fields identifier list type id variant fields proc type proc type parameter list parameter list type id parameter list type id parameter list abstype abstype type parameter list named param list type parameter list identifier list object declarations object decl object init rec rec object init rec object init object init identifier init op clause rec object init identifier init op literal init op clauses clause env decl clause clause clause clause clause repeat clause clause clause clause clause identifier clause clause clause clause clause signature clause clause identifier witness decls clause case clause case list default clause raster drop identifier clause project clause identifier project list default clause name clause expression env decl clause object init clause rec rec object init rec object init signature named param list witness decls type parameter list case list clause list clause case list raster raster op clause clause raster op ror rand xor copy nand xnor project list project list variant project list project list type id clause project list variant project list identifier clause variant project list expressions expression exp exp exp exp exp exp exp rel op exp exp exp add op exp exp exp mult op exp exp add op exp exp literal value constructor clause sequence sequence expression clause clause expression dereference expression identifier expression specialisation expression application clause contains constant identifier type id clause ps name dereference clause dereference specialisation type parameter list application clause list name identifier expression clause list clause list clause list clause clause list value constructors value constructor vector constr structure constr image constr subimage constr picture constr picture op structure creation variant creation abstype creation vector constr constant vector vector element init vector element init range clause range clause clause clause clause range clause clause structure constr struct struct init list struct init list identifier init op clause struct init list image constr constant image clause clause image init image init clause clause subimage constr limit clause clause clause clause clause picture constr clause clause picture op shift clause clause clause scale clause clause clause rotate clause clause colour clause clause text clause clause clause clause clause structure creation identifier specialisation clause list variant creation identifier specialisation identifier clause abstype creation expression specialisation clause list literals literal int literal real literal bool literal string literal pixel literal picture literal null literal proc literal image literal file literal int literal add op digit digit real literal int literal digit int literal bool literal true false string literal char char ascii character special character special character special follow followed special follow special follow pixel literal null literal nil proc literal proc type parameter list named param list type id clause picture literal image literal file literal miscellaneous add op mult op int mult op real mult op string mult op pic mult op pixel mult op int mult op div rem real mult op string mult op pic mult op pixel mult op rel op eq op op variant op eq op op variant op identifier list identifier identifier list identifier letter id follow id follow letter id follow digit id follow id follow letter digit appendix ii type rules type arith int real type ordered arith string type literal ordered bool pixel pic null proc file image type nonvoid literal structure variant env abstype parameterised poly nonvoid type type nonvoid void session sequence void void type declaration void sequence type clause void sequence type clause object declarations declaration void object decl object init rec rec object init rec object init object init identifier init op clause nonvoid rec object init identifier init op literal nonvoid init op clauses clause env init void clause rec object init void clause env contains constant identifier type id bool clause bool clause void void type clause bool clause clause repeat clause void clause bool clause void void clause bool clause void void identifier clause int clause int clause int clause void void type clause env signature clause clause abstype identifier witness decls clause void void type nonvoid case clause case list default clause case list clause list clause case list clause list clause clause list raster op clause image clause image void drop identifier clause env void type project clause identifier project list default clause project list type id clause project list type project clause variant identifier variant project list default clause variant project list identifier clause variant project list nonvoid name clause void expressions exp bool exp bool bool exp bool exp bool bool exp bool bool nonvoid exp eq op exp bool eq op ordered exp op exp bool op expression variant variant op identifier bool variant op nonvoid clause expression env contains constant identifier type id bool arith exp add op exp arith add op exp exp int int mult op exp int int int mult op div rem exp real real mult op exp real real real mult op exp string string mult op exp string string string mult op exp pic pic mult op exp pic pic pic mult op exp pixel pixel mult op exp pixel pixel pixel mult op ps literal literal nonvoid value constructor type clause type sequence type sequence expression string clause int clause int string expression image clause int clause int image expression pixel clause int clause int pixel nonvoid expression clause int value constructors nonvoid vector range clause nonvoid vector range clause proc int nonvoid vector clause int clause clause range clause int clause int image clause int clause int clause pixel image image clause int clause int clause image image limit clause image clause int clause int clause int clause int image struct struct init list structure struct init list identifier init op clause nonvoid struct init list clause real clause real pic shift clause pic clause real clause real pic scale clause pic clause real clause real pic rotate clause pic clause real pic colour clause pic clause pixel pic text clause string clause real clause real clause real clause real pic literals add op digit digit int int literal digit int literal real true false bool char string pixel nil null type proc type parameter list named param list type identifier clause pic image file appendix iii program layout semi colons lexical rule napier semi colon may omitted separator coincides newline 
allows semi colons program left 
help compiler deduce semi colons rule line may binary operator 
example valid 
rule applies invisible operator vector structure image index list procedure parameters 
example valid misinterpreted vectors assigned 
comments comments may placed program symbol 
line regarded compiler comment 
example add appendix iv reserved words abstype bool case colour constant contains copy default div drop env false file int image limit nand nil null pic pixel proc project real rec rem repeat ror rand rotate scale shift string struct structure text true type variant vector xnor xor index data types data type creation data type definition equality equivalence data types equivalence equality injection projection arithmetic precedence rules see expressions assignment clause see clauses backus naur form brackets case clause see clauses clauses assignment case repeat comments see program layout comparison operators see expressions constancy context free syntax context free syntax specification declarations data objects procedures see procedures recursive objects recursive types type declarations environments adding bindings contains clause creation equality equivalence removing bindings bindings expressions arithmetic arithmetic precedence rules boolean comparison operators evaluation order expressions operators operator precedence table picture pixel string expressions operators see expressions files equality equivalence clause see clauses hyper programming identifiers clause see clauses images creation depth selection equality equivalence indexing raster operations literals boolean file image integer null picture pixel procedure real string napier john napier concurrency layered architecture release installation guide semaphores standard library manual napier persistent machine compilation rules threads transactions operator precedence table see expressions persistent machine persistent store pisa project polymorphism principle data type completeness see types procedures call declaration equality equivalence polymorphic procedures recursive declarations program layout comments semi colons raster operations see images repeat clause see clauses reserved words scope rules separators sequences structures creation equality equivalence type rules see types types declarations see declarations class citizenship principle data type completeness recursive definitions recursive operators recursive type declarations see declarations structural equivalence type algebra type aliasing type equivalence type operators type rules universe discourse universe discourse see types variables variants equality equivalence projection types variant values vectors creation equality equivalence indexing clause see clauses 
