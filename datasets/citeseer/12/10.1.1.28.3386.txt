xfs wide area mass storage file system randolph wang thomas anderson cs berkeley edu computer science division university california berkeley ca current generation file systems inadequate facing new technological challenges wide area networks massive storage 
xfs prototype file system developing explore issues brought technological advances 
xfs adapts techniques field high performance multiprocessor design 
organizes hosts hierarchical structure locality clusters workstations better exploited 
invalidation write back cache coherence protocol xfs minimizes network usage 
exploits file system naming structure reduce cache coherence state 
xfs integrates different storage technologies uniform manner 
due intelligent local hosts local storage expect xfs achieve better performance availability current generation network file systems run wide area 
advances robot technology tertiary media resulted emergence large capacity cost effective automated tertiary storage devices 
placed high performance wide area networks devices dramatically increased amount digital information accessible large number geographically distributed users 
amount storage degree cooperation possible hardware advances unprecedented 
presence wide area networks tertiary storage brought new challenges design file systems ffl bandwidth latency short run bandwidth wan expensive lan 
furthermore latency wide area parameter restricted speed light remain high 
supported part national science foundation cda digital equipment systems research center external research program foundation 
anderson supported national science foundation young investigator award 
ffl scalability central file server model breaks ffi thousands clients ffi terabytes total client caches server keep track ffi billions files ffi petabytes total storage 
ffl availability file systems scalable allowing larger groups clients servers time clients servers unable communicate 
existing distributed file systems originally designed local area networks disks bottom layer storage hierarchy 
inadequate facing challenges wide area networks massive storage 
suffer shortcomings ffl poor file system protocol frequently techniques broadcasts write protocols acceptable lan longer appropriate wan inefficient bandwidth 
ffl dependency centralized servers availability performance existing file systems depend crucially health centralized servers 
ffl data structures scale example server keep cache coherence state piece data stored clients amount data number clients system quite limited 
ffl lack tertiary support existing file systems poor job hiding multiple layers storage hierarchy 
manual migration file migration 
convenient efficient 
offer ad hoc extensions existing systems 
usually increases code complexity 
addressed aspects problem system handles wans mass storage 
pretend reached perfect solution providing fast cheap reliable wide area access massive amounts storage xfs prototype design point issues mass storage wide area explored measurements taken 
goal xfs provide performance availability local disk file system sharing minimum storage requirement small 
observe problems face considered researchers studying distributed shared memory multiprocessors tested solutions applied design 
particular xfs features ffl xfs organizes hosts sophisticated hierarchical structure analogous high performance multiprocessors dash 
requests satisfied local cluster possible minimize remote communication 
ffl xfs uses invalidation write back cache coherence protocol pioneered research done multiprocessor caches 
clients local stable storage store private data indefinitely consuming wide area bandwidth lower latency modifications written server 
data cached locally clients operate server attention 
coda study illustrates offer better availability case server network failure 
ffl xfs exploits file system naming structure reduce state needed preserve cache coherence 
ownership directory descendents granted 
avoiding maintenance cache coherence information strictly file block basis xfs reduces storage requirements improves performance 
ffl xfs integrates multiple levels storage hierarchy 
xfs employs uniform log structured management fast lookup storage technologies 
xfs currently middle implementation stage performance numbers report 
remainder position organized follows 
section presents hierarchical client server structure xfs 
section describes cache coherence protocol 
section describes xfs reduces amount cache coherence information maintained hosts 
section discusses integration multiple levels storage 
section discusses additional issues including crash recovery 
section concludes 
hierarchical client server organization andrew nfs sprite simple layer client server hierarchy 
conceivable port model wide area network result unsatisfactory requires large amount communication wan 
xfs uses clustering geographic proximity exploit distinction local remote communication utilize locality data usage clusters increase scalability system 
server ucb client ucla client ucla client ucsb client ucsb client ucb ucsb ucb wan lan client client simple client server relationship 
model seen number problems 
wans higher latency lower bandwidth higher cost 
situation expected improve technology matures believe wide area communication remain costly offer bandwidth lan counterpart time 
bandwidth bottleneck solved latency continue naive system 
best possible circumstances round trip delay km comparable disk seek 
simple client server model seen fails recognize distinction wide area links local links 
result overuse wide area communication turn leads high cost poor performance 
secondly locality plays important role wide area clusters hosts geographically close share information frequently easier time talking 
file system treats clients equals sense lan clients virtually peers exhibit little distinction 
organization acceptable wide area paying attention locality improve performance 
thirdly organization problems scale 
server load amount cache coherence state server increases number clients 
straightforward deployment existing file systems wide area wide massive 
attempt solve problems xfs employs hierarchy similar scalable shared memory multiprocessors understand motivation organization instructive study analogy dash xfs 
dash system consists number processor clusters 
communication clusters provided mesh network 
analogous wan links xfs bandwidth limited latency high 
dash cluster consists small number processors analogous clients lan 
intra cluster communication provided bus 
analogous lan links xfs local communication cheap fast 
analogy 
firstly dash recognizes distinction intra cluster communication bus inter cluster communication point point optimize performance 
sim principle possible extend hierarchy form clusters clusters 
cluster home lan ucb wan ucla ucsb cluster cluster ucla server ucsb server client ucla client ucla client ucsb client ucsb client ucsb server ucb home ucb client ucb client consistency consistency xfs hierarchy 
xfs clients may choose write broadcast frequently lan communication cheap fast 
communicating slower expensive wan links xfs hosts speak write back protocol section 
secondly hierarchical organization better job advantage potential locality clusters workstations 
dash processor data cached local cluster remote communication incurred 
similarly experiment shown roughly thirds files read workstation cached neighboring clients 
study done dahlin shows clients cluster effectively serve cache misses 
exploit locality xfs client data local cache queries consistency server cluster see peer clients supply data 
hope local traffic contained cluster 
occasionally consistency server contact home cluster handle cache misses 
function consistency server analogous directory mechanism dash responsible locating data enforcing cache coherence 
location desired data discovered data flows directly sender receiver 
way separation control messages data messages xfs analogous approach taken mass storage model name services file movement storage management distinct information flow paths 
number studies explored idea hierarchical organizations 
experiment employed intermediate data cache server hit rate surprisingly low 
hierarchy data caches higher levels technology lower ones higher level caches contain little lower level counter refers messages related requesting granting revoking ownerships discussed section 
refers messages contain actual data 
parts 
effect intermediate servers delay servers 
xfs consistency server hand participating data caching avoids unnecessary delays 
thirdly xfs hierarchy provides better scalability 
consistency servers shield home servers intra cluster traffic 
furthermore organization shown server keep long lists clients requiring consistency actions 
xfs hierarchy home servers track consistency servers act agents local clusters 
believe xfs hierarchy better suited wide area context 
recognizes distinction local versus remote communication 
exploits locality aggressively 
distributes burden centralized server number consistency servers peer clients 
expected offer better scalability 
cache coherence protocol existing file systems protocols provide strong consistency semantics generate excessive amount network traffic 
xfs speaks invalidation write back protocol designed minimize communication 
client local stable storage store private data indefinitely 
ability client operate independently server intervention result better availability 
nfs writes offers little consistency guarantee concurrent read write sharing 
andrew provides consistent view file open time writes back close time 
sprite enforces perfect consistency disabling caching write shared files writes dirty data server seconds reliability reasons 
furthermore file systems effective directory caching consequently optimizing write back policies large number name related operations left 
unnecessary network traffic posed little problem lan performance bottleneck wide area 
observe field multiprocessor computer architecture extensive literature maintaining consistency cached replicas minimizing network usage limiting communication cases data truly shared 
reduce number bytes transferred wide area network xfs uses protocol multiprocessor style cache coherence 
xfs host requests ownership file directory higher level server 
client possesses read ownership allowed cache data locally reads client possesses write ownership assured valid copy data 
copy considered private host cache refers client consistency server 
unix file access times kept 
modify copy indefinitely stable storage contacting server 
ownership data obtained consistency server granted lower level clients 
server order enforce cache coherence may refuse ownership 
may choose revoke ownership data previously granted hosts 
client write ownership obliged transfer dirty data back receipt revoking call 
existing stateful file systems open involves requesting ownership close involves relinquishing ownership callback associated revoking ownership 
systems distinguish notion open requesting ownership notion close relinquishing ownership 
system aggressively exploits caching sprite client merely passes user system calls server 
user repeatedly opens writes file event sprite client transmits open request writes dirty data seconds 
xfs different respects 
firstly xfs explicitly separates notion open requesting ownership 
ownership requests sent necessary 
secondly xfs protocol include resembles close system call 
hosts voluntarily relinquish ownership 
give ownership response servers revoking calls 
user repeatedly writes file initial open result request ownership communication required client requests data 
way file directory data transferred wide area network cache cache flush true sharing multiple clients 
words xfs writes demand opposed traditional file systems write data guard possibility shared 
client server user open close callback close open home server request ownership revoke ownership request ownership client user open close sprite style protocol xfs protocol ownership revoke server consis separating notions open close callback requesting relinquishing revoking ownership 
shows xfs file state transition detail 
example consider file read sharing state 
new host requests read ownership granted ownership file stays state 
host requests write ownership server revokes ownership current readers 
reply messages readers specify desire read ownership 
previous readers want retain read ownership file goes write state new writer granted write ownership 
readers actively reading file file goes write sharing state hosts denied ownership 
read sharing multiple hosts read ownership write sharing ownership ownership owned host read ownership host write ownership read write xfs file state transition 
due better local cache dependency servers xfs clients observe lower latency bandwidth achieve better availability 
existing file systems rely heavily servers write throughs name related operations 
demise single server failed network link usually renders clients 
xfs hosts hand acquiring ownership proper data operate independently 
furthermore xfs hosts easier time disconnection 
coda client example required write dirty data accumulated disconnection back server reintegration 
xfs writes necessary dirty data needed 
number problems cache coherence scheme 
large amount state information host needs keep 
addressed section 
second problem need local stable storage keep dirty data indefinitely 
addressed section 
third need policies deal network partitions hosts 
discussed section 
reducing cache coherence state existing stateful file systems maintain cache consistency way designed scale handle massive amount client cache 
xfs reduces cache coherence state exploiting hierarchical naming structure file system 
sprite andrew server example keep track file cached client 
amount server state grows total size client caches 
xfs lives wide area network potentially large number clients large amount callback information associated client 
way deal explosion state information needs 
hierarchical nature system discussed section partially alleviates problem 
home servers need keep track top level consistency servers 
bottom level consistency servers need tally leaf clients serve 
reduces length client lists reduce number files require consistency actions 
second technique xfs uses deal state explosion observation clusters files tend ownership 
little need keep state individual files representative large cluster 
illustrates idea 
see user foo working machine 
acquired read ownership cluster write ownership clusters 
happened result modification home directory directory baz user foo 
similarly machine acquired read ownership cluster write ownership cluster 
see ownership needs associated clusters files 
baz foo bar read owned write owned write owned write owned hierarchical state information 
third technique observation large number files system widely shared rarely modified 
files entire subtree exported read example remembering exactly hosts acquired read ownership xfs merely remembers fact read ownership granted hosts 
rare event files get modified xfs resorts broadcasts locate readers 
broadcasts necessarily flood single host due hierarchical nature xfs 
home server communicates consistency servers serves consistency servers acquired read ownership forward revoking broadcast clients 
xfs server maintains cache coherence state clusters files individual files 
cluster files server keeps list consistency servers individual clients 
files modified list done away 
employing techniques expect substantially reduce storage requirements cache coherence state 
integration multi level storage xfs designed utilize multi level hierarchy stable storage capable indefinitely storing modified file directory data 
xfs integrates storage devices simple uniform manner ffl storage devices treated caches 
ffl storage devices written log structured manner 
ffl data blocks located looking virtual translation tables maintained fast devices 
addition deciding appropriate migration policies move data need address immediate questions 
locate data blocks migrate different levels storage 
second lay data media efficient manner 
solve problem locating data multiple levels storage existing systems extend ufs data structures incorporate tertiary devices 
example block address highlight belong disk farm tertiary store disk cache tertiary storage 
number pair locating data involves locating inode indexing inode 
block address tertiary fetch done bring missing data disk cache operation resumes 
extensions usually complicate code force new storage devices inherit data structures originally designed disks 
solution second problem laying data media efficiently provided log structured file system lfs 
lfs appends newly written data segmented log optimized write performance 
old data deleted lfs reclaims disk space sparsely populated segments tail log marks segments clean 
lfs provides superior performance environments large main memory caches absorb reads consequently disk write speed limiting factor 
tertiary devices append tertiary archival storage media deliver best performance append devices 
write log structured layout natural way managing devices 
highlight descendant lfs bases design observation 
employs different cleaner process migrate selected data blocks tertiary store written logstructured 
designing xfs approach locating data draw analogies solutions memory management problems 
virtually addressed memory word chip cache secondary backing store 
find translate virtual address physical address 
xfs equivalent virtual address block id file id block virtual address physical incarnation hierarchy storage devices 
device treated cache 
device employs fast translation table translates block id physical address device 
translation table entry form block id blocks device address data migrate different storage levels simply change corresponding translation tables simpler cleaner approach extending existing ufs data structures 
similar approach taken logical disk addresses mapped physical ones allow clean separation file disk management sacrificing performance 
memory management analogy unfortunately apply data layout 
firstly processor caches usually direct mapped xfs devices fully associative 
secondly processor caches main memory storage technologies xfs manages truly random access devices 
reasons xfs writes caches log structured manner 
xfs device receives read request queries translation table find corresponding physical address 
successful search leads directly device location data 
search fails device declares cache xfs device receives write request appends data blocks log updates translation table reflect new mapping 
invalidation data blocks involves removing corresponding mappings translation table 
time clean block live determined comparing identity corresponding translation table entry 
xfs device accomplished migration process 
chooses number victim blocks policy 
blocks dirty migration agent retrieves blocks source device sends destination device 
simply invalidates blocks source device freed space reclaimed cleaner 
principle translation table paged slower device 
simplicity opted keep translation table entirely faster device 
example translation table disk cache kept entirely memory translation table tertiary kept entirely disk 
obvious disadvantage doing storage requirement needed translation tables 
example tens megabytes main memory needed manage gigabytes disk storage 
problem partially alleviated single translation table entry point number consecutively written blocks 
large sequentially written files need little space translation table 
believe fast decrease memory cost memory translation table money spent exchange resulting simplicity 
similarly studies workloads suggest gigabytes disk space suffice translating terabytes tertiary storage investment probably worthwhile 
plan implement interfaces kind xfs device storage interface allows device caching store translation interface allows device translation device 
disk example interfaces allow storage device translation table tertiary 
appropriately chosen pair slow fast devices glued form storage bin 
migration agents running machine chooses blocks inject eject storage bins 
pieces file potentially spread multiple levels storage hierarchy wide area reflecting widely distributed tertiary nature xfs 
issues question distributed system answer handles machine crashes network partitions 
xfs client remember ownerships acquired servers 
xfs server needs remember ownerships granted clients 
applying state compression techniques described section amount information large keep entirely memory sprite nfs 
part needs written stable storage 
hand afford log ownership change disk 
consequently need recover memory resident information lost crash 
task relatively simple clients 
client commits data stable storage conveniently logs corresponding ownership 
lost ownership crash dirty data associated 
worst case server believe granted reboot memory resident translation table reconstructed examining identities data blocks disk 
ownership certain clients clients lost crashes 
server sends revoking calls clients simply reply 
recovering server recover exact state crash 
appears server centric approach done 
scheme recovering server directs clients help rebuild lost server state 
noted frequently updated small amount volatile state candidate inclusion stable memory survive machine crashes recovery cost kept minimum 
question need answer deal machines respond ownership revokes due crashes network partitions 
alternatives 
fail operation resulted revoke place hang operation indefinitely revoke answered operation proceed risk allowing consistency conflicts resolved offending hosts rejoin 
adopt third approach taken coda trades quality availability 
fortunately coda study shown conflicts extremely rare events expect ownership revokes frequent xfs 
xfs approach storing data locally indefinitely raises concerns 
security 
andrew treats servers class citizens clients deemed trustworthy 
xfs line clients servers blurred clients allowed serve section 
organization clusters treated security domains cluster members trust foreign clusters homes deemed untrustworthy 
paranoid approach require writer compute checksum 
kaliski devised efficient algorithm computationally infeasible find messages checksum message prespecified checksum 
reader receipt data checksum run algorithm verify data altered 
difficulty backup 
storage concentrated gigabytes disks servers disaster recovery opposed crash recovery accomplished rolling world back tape dump 
approach fails massive amounts storage storage widely distributed consistent snapshots virtually impossible 
possible way providing disaster recovery xfs avoid disaster place insisting having copies different sites times 
effective way providing backup mass storage wide area topic research 
existing disk local area file systems longer meet demands mass storage wide area 
xfs uses hierarchy better take advantage locality nature 
speaks cache coherency protocol minimizes wide area communication 
consequently expected operate lower latency consume wide area bandwidth 
xfs minimizes cache coherence state information exploiting hierarchical nature file system name space hierarchical nature cluster organization 
xfs integrates multiple levels storage uniform manner 
ability take advantage local storage deliver better economy superior performance higher availability 
discussions mike dahlin dave patterson helped improve xfs design particularly hierarchical client server structure 
soumen chakrabarti mike dahlin john hartman arvind krishnamurthy clifford helpful comments 
baker sullivan 
recovery box fast recovery provide high availability unix environment 
usenix association summer conference proceedings pages june 
blaze alonso 
massive distributed systems 
proceedings rd workshop workstation operating systems pages april 
coleman miller 
mass storage system model version 
ieee technical committee mass storage systems technology may 
dahlin 
private communication 

muntz honeyman 
multi level caching distributed file system 
usenix association winter conference proceedings january 
howard kazar menees nichols satyanarayanan sidebotham west 
scale performance distributed file system 
acm transactions computer systems february 
de jonge kaashoek hsieh 
logical disk new approach improving file system performance 
proceedings th symposium operating systems principles december 
appear 
kaliski jr md message digest algorithm 
workshop theory application cryptographic techniques proceedings may 
kohl staelin 
highlight logstructured file system tertiary storage management 
usenix association winter conference proceedings january 
lenoski laudon gharachorloo gupta hennessy 
directory cache coherence protocol dash multiprocessor 
proceedings th annual international symposium computer architecture pages may 

unitree software file storage management 
digest papers proceedings th ieee symposium mass storage systems pages may 
mogul 
recovery protocol nfs 
proceedings usenix workshop file systems may 
smith 
archive server 
ucb csd report university california berkeley september 
nelson welch ousterhout 
caching sprite network file system 
acm transactions computer systems february 
patel 
low overhead coherence solution multiprocessors private cache memories 
proceedings th annual international symposium computer architecture pages june 
rosenblum ousterhout 
design implementation log structured file system 
operating systems review october 
sandberg goldberg kleiman walsh lyon 
design implementation sun network filesystem 
proceedings summer usenix conference june 
satyanarayanan kistler kumar okasaki siegel steere 
coda highly available file system distributed workstation environment 
acm transactions computer systems april 
srinivasan mogul 
nfs experience cache consistency protocols 
proceedings th symposium operating systems principles pages december 
welch 
sprite distributed file system 
phd thesis department electrical engineering computer science university california berkeley march 

