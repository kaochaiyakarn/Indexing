multiset discrimination solve language processing problems hashing cai robert paige new york university courant institute new york ny usa generally assumed hashing essential solve language processing problems efficiently symbol table formation maintenance grammar manipulation basic block optimization global optimization 
questions assumption initiates development efficient alternative compiler methodology hashing sorting 
methodology rests efficient solutions basic problem detecting duplicate values multiset call multiset discrimination 
paige tarjan gave efficient solution multiset discrimination detecting duplicate elements occurring multiset varying length strings 
technique develop improved algorithm lexicographic sorting importance stems largely solving variety isomorphism problems 
current related show full lexicographic sorting needed solve isomorphism problems solved efficiently straightforward extensions simpler multiset discrimination technique 
reformulating language processing problems terms multiset discrimination show subtask compilation solved hashing worst case running time worse frequently better best previous expected time solution assumption hash operation takes unit expected time 
simplicity solutions may practical theoretical interest 
various applications new algorithm solve iterated strength reduction folded useless code elimination runs worst case asymptotic time auxiliary space represent lengths initial optimized programs respectively 
previous best solution due cocke kennedy takes 
preliminary version appeared conference record eighteenth annual acm symposium principles programming languages 
part done authors visiting university wisconsin madison paige visiting diku university copenhagen 

research author partially supported national science foundation 
ccr air force office scientific research 
afosr 

research author partially supported office naval research 
air force office scientific research 
afosr 
hash operations worst case 
categories subject descriptors programming languages processors compilers optimization parsing preprocessors data structures graphs lists trees analysis algorithms problem complexity algorithms problems sorting searching general terms algorithms languages theory additional key words phrases hashing multiset discrimination symbol tables hygienic macro expansion left factoring value numbers acyclic coarsest partition sequence congruence reduction strength useless code 

important practical theoretical question computer science algorithms worst case performance match expected performance solutions utilize hashing 
context broader question initiate investigation efficient compilation hashing consequently raise doubts prevailing view hashing universal hashing essential efficient implementation various subtasks compilation symbol table management reduction strength hashed temporaries 
assume sequential ram model computation uniform cost criterion restricted pointer machine prohibits address arithmetic 
aho sethi ullman data structures storing symbol tables linear linked list linear search time hash table 
propose data structures methods turn expression tree dag general basic block optimization value numbering 
hashing involved preprocessing global optimizations perform constant propagation global redundant code elimination code motion 
best algorithms strength reduction rely hashed temporaries obtain practical implementations 
reasons hashing applications 
set elements hashing supports membership testing element addition element deletion data expected time auxiliary space 
method universal hashing due carter wegman especially desirable expected time independent input distribution 
universal hashing suited applications compilation hash table implement symbol table persist single compilation run 
applications mentioned hashing leads simple line algorithms supporting immediate storage access 
consequently various phases compilation carried incrementally passes space utilization 
liberal hashing incurs certain costs 
positive integers consider hash function defined rule ax mod mod input argument constants belong 
discounting costs collisions rehashing calculation single hash operation greater cost array pointer access 
mairson proved minimal class universal hash functions exists bad input set hash function perform better binary search 
slow speed setl observed setl implemented ada ed compiler attributed overuse hashing 
hash table implementation involving array twice size data set cost 
arrays lack benefits offered linked lists easy dynamic allocation dynamic maintenance easy integration data structures 
line algorithms vital incremental compilation batch processing may suffice 
presents new algorithms applications mentioned worst case asymptotic time space matches exceeds expected performance best previous algorithms utilize hashing assumption single hash operation takes unit time 
achieved reformulating language processing problems terms subproblems solved efficiently simple algorithmic tools exclude sorting important multiset discrimination finding duplicate values multiset 
paige tarjan multiset discrimination varying length strings design efficient lexicographical sorting algorithm 
focus lexicographic sorting importance stems largely solving variety isomorphism problems 
application multiset discrimination mentioned 
current uncover greater significance multiset discrimination showing straightforward extension paige tarjan technique general class datatypes including sequences trees dags solve isomorphism problems efficiently methods full lexicographic sorting 
demonstrate generalized multiset discrimination method help improve theoretical performance dozen applications language processing virtually aspect compiling front macro processing optimization strength reduction 
applications include 
array list symbol tables formed lexical scanning unit time pointer storage access 
tables may support efficient implementation hygienic macro expansion 
grammar transformations implemented efficiently multiset string discrimination 
included new linear time left factoring transformation 
simpler forms heuristic transformation previously studied stearns see turn non ll context free grammars ll grammars 
expression tree dag transformation implemented hashing simpler way linear time space 
applications include linear pattern matching algorithm turned efficient nonlinear matching algorithm subtree equality check takes unit time 
method perform basic block optimizations previously carried hashing value numbers hashing 
leads faster solution program equivalence problem integration yang horwitz reps 
main parts algorithms global constant propagation global common subexpression detection code motion hashing preprocessing portions algorithms 
hashing eliminated penalty efficient construction maintenance symbol table 
strength reduction remained complex understood practical machine independent program optimizations 
strength reduction transformation cocke kennedy may practical reduction strength algorithm published literature 
transformation due allen cocke kennedy powerful reduce multivariate products analyzes control flow deeply algorithm degrade performance introducing sums order remove nests products shown 
knoop steffen approach general algorithm difficult implement runtime performance may require exponential time 
solve progressively complex versions cocke kennedy transformation hashing superior worst case time space expected performance previous hash solutions 
final version algorithm solve iterated strength reduction folded useless code elimination worst case asymptotic time auxiliary space linear maximum text length initial optimized programs 
solution additional practical theoretical significance achieves important goal program optimization methodology combine technically different program optimizations sacrificing performance 

partial tool kit algorithm design hashing simple combinatorial problems hashing natural way obtain efficient solution 
include basic computations set union difference intersection multiset string discrimination finding duplicates multiset strings set pairs indexed collection sets compute set pairs 
hashing may panacea incur costs overlook contexts preceding computations solved efficient hash free approach 
paige different general discussion principles underlying algorithms simple set operations 
sharper techniques focus multiset discrimination discussed 

terminology convenient notations terminology specifying algorithms 
variable expression ref pointer expression deref ref value stored record field term retrieves value field record different brackets distinguish sets multisets sequences 
collection necessarily distinct values formed set contains distinct values enumerated values multiset sequence writing respectively 
empty set empty multiset empty sequence denoted respectively 
finite set multiset sequence number elements denoted arbitrary element chosen denoted elements undefined 
finite map defined set pairs single multi valued 
single valued application map argument denoted undefined doesn belong domain multi valued multi valued map application denoted represents set 
finite nonempty set partition collection pairwise disjoint nonempty subsets called blocks union partitions finite set refinement block subset block finite set represents set finite sequences values belonging sequence denotes value occurring th component value leftmost component 
sequences equal length component wise equal 
term 
denote subsequence th th component 
term abbreviation prefix 
abbreviation suffix 

equals 
sequences denotes concatenation strings treated conventional way special case sequences finite alphabet 
written contiguous components bracket delimiters abcd 
single characters regarded symbol strings arguments concatenation 

basic multiset discrimination multiset discrimination described simple terms finding duplicate values finite multiset give problem greater operational significance adding level indirection 
new useful characterization multiset discrimination problem function inversion partitioning finite set preimages function defined set 
formally multiset discrimination problem inputs sets lambda term called discriminator 
outputs pair yv subset distinct discriminator values underly multiset yv yv multi valued map preimage sets contained respect discriminator 
problem main aspects inverting function finding duplicate values multiset basic 
central database index formation techniques willard database predicate retrieval theory 
essential earley program optimization iterator inversion 
paige tarjan design new algorithms minimization symbol finite automata lexicographic sorting 
algorithms special instance multiset discrimination finite alphabet discriminator vs maps element xv string symbols th symbol string 
extend solution order solve general multiset discrimination problem sets elements belong wide variety datatypes general class discriminators 
set implemented data structure called directory stores distinct element accessible component necessary distinguish endogenous implementation elements stored entirely directory exogenous implementation directory stores pointers elements 
element directory exogenous implementation implicit dereferencing assumed contexts clear actual value needed 
useful distinguish related implementations directory 
implementations directory array accessed cursors integers distinct cursors locate distinct elements implementation directory arbitrary set locations accessible pointer 
case directory unequal unit time operation values refer unequal 
implementations just described combined single basic multiset discrimination procedure input parameters 
parameter directory built function name deref pointer multiset discrimination 
name array storing array implementation 
parameter locs set ref pointers elements discriminator domain implementations 
parameter discriminator lambda term maps pointers locs cursors pointers elements array implementation array array storing directory discriminator cursor array discriminator stores corresponding element pointer directory implementation discriminator pointer corresponding element deref discriminator output set list cursors respectively pointers elements directory array respectively pointer implementation output map representation implementations 
element belonging image set directory equals locs discriminator stored list back pointers elements assume initially empty procedures md array md pointer implement approaches just described 
data structures approaches shown 
pointer implementation proc md pointer locs discriminator return md basic locs discriminator deref array implementation proc md array locs discriminator directory return md basic locs discriminator directory multiset discrimination driver proc md basic locs discriminator directory set underlying pointer locs loop linear search locs directory discriminator directory discriminator element discriminator discriminator locates element directory discriminator directory discriminator loop return basic multiset discrimination algorithm implementation depicted domain mapping set shared 
element implemented record field contains pointer initial value nil representing empty set set back pointers easy see methods just described implemented run time space locs execution discriminator takes unit time 
locs 
data structure abstraction basic multiset discrimination course efficiency solutions multiset discrimination rests key assumption set distinct values discriminator locate distinct values methods manipulate unit space cursors pointers respectively efficiency independent type element ironically paige tarjan considered simplest form multiset discrimination elements type char array algorithm easily turned polymorphic procedure md array shown 
alternative implementation procedure md pointer pragmatic theoretical reasons 
nonsequential access array component involves address arithmetic expensive pointer access 
numeric representation arbitrary values somewhat complex pointer representation 
numeric representations array access elements space proportional range numbers greater number elements sets 

multiset discrimination sequences multiset discrimination sequences natural extension basic multiset discrimination 
terms problem inputs sets discriminator vs outputs pair yv subset distinct values underly multiset yv yv multi valued map preimage sets contained respect discriminator 
problem harder basic multiset discrimination discriminator range implemented directory 
solution essentially builds directory discriminator range 
paige tarjan solved multiset discrimination sequences special case finite alphabet implemented array directory sequences belonging implemented arrays precisely strings 
order investigate general utility multiset discrimination sequences extend solution making polymorphic allowing elements belong general class datatypes 
approach widely applicable allowing sequences belonging implemented lists 
case basic multiset discrimination array array array storing directory pointer directories considered implementing convenient augment set unique sentinel value denoted belong input sequences 
implement set header records providing pointer access distinct body stores sequence elements body implemented way linked list cells fields 
data field ith cell body stores sequence pointer cursor element corresponds st list cell cell data field stores sentinel element list cell field stores pointer cell list nil case cell 
header record contains fields field containing pointer element body current position field containing pointer element initially element body 
see 
current position header body 
implementation initial value input sequence 
formulation multiset sequence discrimination parameters 
basic multiset discrimination parameter directory array pointer implementations directory equals name array storing array implementation deref 
parameter locs stores set pointers elements parameter discriminator lambda term maps pointers locs discriminator elements assume lambda term deref deref current position data discriminator 
new parameter update lambda assignment lhs rhs 
maps pointer locs header record assignment lhs rhs updates current position points sequential list cell body assume update equals 
deref current position deref deref current position 
helpful explain multiset sequence discrimination algorithm virtual fields fields implemented associated header record sequence stored body associated header virtual fields pos equal position corresponding list cell referenced current position prefix equal prefix pos body equal record initial value current position pointer element corresponding body initial values pos prefix respectively empty sequence 
state multiset sequence discrimination algorithm partition locs 
block designated solved know maximum subset locs pointers records equal bodies 
block isn solved called unsolved 
initially contains set locs single unsolved block 
algorithm repeatedly refines block solved refinement step maintains invariants block record referenced pointers belonging prefix header records referenced different blocks different prefix pointer locs record prefix body iff directory discriminator 
describing refinement step see immediately invariants hold initially 
initial partition block locs containing pointers records prefix 
locs refers header body empty iff directory discriminator 
starting initial state algorithm proceeds long contains unsolved block performing refinement step easily shown preserve invariants 
refine 
remove arbitrary unsolved block perform basic multiset discrimination md basic discriminator directory 
call md basic compute set ff distinct directory discriminator pointers cursors elements stored directory pointer pointer belonging ff computes set ff directory back pointers header records referenced pointers discriminator equals images ff directory ff partition images added back new blocks designated solved unsolved cases arise 
case 
ff directory contains single back pointer record say record body body invariant semantics md basic 
block solved 
case 
directory sentinel ff directory set pointers records referenced pointers current position points list cell body prefix equals body invariant 
invariant semantics md basic know record body body 
block solved 
case 
ff directory set pointers records referenced pointers bodies prefix formed concatenating value directory right prefix 
invariant semantics md basic know record prefix 
longer prefixes records examined bodies distinguished 
current position field records updated point list cell body perform update back pointer ff directory 
block processed unsolved 
preceding arguments show invariants preserved refinement step 
update operation case ensures algorithm progresses pointer locs eventually block solved cases 
code multiset sequence discrimination appears just 
efficient implementation represented list blocks block represented list pointers records multiset sequence discrimination proc md seq locs discriminator directory update set underlying locs loop ff ff md basic discriminator directory ff loop ff directory directory ff directory contains maximal set headers bodies store sequence witness points arbitrary body copies witness deref directory witness deref witness ff directory ff directory loop headers sequence point witness body deref witness deref current position witness loop ff directory loop update deref current position point list cell loop ff directory loop loop return multiset sequence discrimination algorithm preceding algorithm abstracted extended formulation paige tarjan technique multiset discrimination varying length strings alphabet 
earlier algorithm array directory implemented strings packed arrays cursors referencing directory 
earlier algorithm running time space number strings total length prefixes needed distinguish strings list implementation time space bounds advantage easier memory management 
earlier array implementations simple involve pass prefixes sequences 
consequently proposed applications may practical 
previously lexicographic sorting algorithm aho hopcroft ullman book solve congruence closure tree isomorphism 
sorting algorithm theoretical disadvantage complexity time auxiliary space total length input strings 
algorithm practical disadvantage complex multi pass implementation requirement map graph structures explicit symbols totally ordered alphabet 
problems solved simply preceding list method solve multiset discrimination sequences 

multiset discrimination numeric constants multiset discrimination numeric constants solved treating constants strings bit alphabet arbitrary array directory size 
applications 
symbol tables multiset discrimination strings directly implement pass lexical scanner 
program text string form scanned produce tokens initial pointers symbol table entries 
symbol table multiset lexemes implemented doubly linked list 
additional pass needed remove redundant entries redirect pointers lexical values distinct entries modified table implemented pointer directory 
performance linear time space length input string 
consequently compiler phases syntactic semantic analysis symbol table accessed pointers hashing 
approach supports scope rule block structured languages conveniently implement symbol table entry stack pointers records store identifier name symbolic address value attributes 
symbol table implement macro expansion 
example hygienic macro expansion algorithm reported clinger rees frequently performs operations replace occurrences bound variable binding scope fresh identifier store macro definition environment symbol table transparency achieved macro expanded identifiers referenced respect environment macro defined paint expansion replace identifier introduced expansion identifiers occurring explicitly macro body arguments macro fresh identifier sharing symbol table entry interpreted environment macro defined 
making new copy environment originally stored macro definition original environment preserved 
clinger rees assume time environment operation straightforward implementation definition require linear search lists long input text 
suggest efficient implementation 
table represent symbol table entry identifier recall parsed program text represented pointer symbol table entry table implemented stack pointers records containing identifier name program variable keyword macro name attributes 
approach string substitution simple replace identifier fresh identifier binding scope just push pointer new record representing table pop table exiting binding scope 
cost time independent number occurrences replaced 
store definition macro paint symbols introduced expansion push painted macro definition table replace identifier macro body introduced expansion pointer fresh symbol table entry push top table table 
leaving scope macro definition pop table 
paint expansion replace newly introduced identifier pointer fresh symbol table entry push top table table 

fast left factoring left factoring context free grammar transformation investigated stearns tool turning non ll grammars ll grammars 
describe optimal forms factoring algorithmic details 
define new class factorable grammars turned equivalent ll grammars applying optimal sequence left factoring transformations 
show find apply optimal sequence obtain ll grammar linear time respect number symbol occurrences input grammar 
solution depends basic multiset discrimination 
terminology notation context free grammars 
context free grammar nt tuple nonempty finite set nonterminal symbols nonempty finite set terminal symbols disjoint distinguished nonterminal called start symbol finite nonempty set productions form nonterminal finite string grammar symbols terminals nonterminals 
binary relation defined strings grammar symbols rule anb adb iff exists production reflexive transitive closure denoted defined rule iff exists sequence strings nt 
language generated called set sentences set sentential forms set tn 
generally set sentences respectively sentential forms derived string tn grammar symbols defined respectively tn 
context free grammars equivalent generate language 
upper case italic letters denote nonterminals lower case italic letters denote terminals greek letters denote strings terminal nonterminal symbols 
convenient alternation notation abbreviate context free grammar productions section convenient identify grammar set productions 
assume context free grammar contains nonterminals derive nonempty sentences occur sentential form definition 
see productions belonging form ll conflict iff conditions holds exists terminal symbol exists terminal symbol start symbol definition 
set strings alphabet define split xw xw longest common prefix nonempty set strings denoted lcp defined recursively rule lcp singleton set say select elseif split symbol string lcp xw grammar said ll ll conflicts 
divide ll conflicts kinds factorable ll conflict ll conflict ab lcp ab nonempty replacing conflict productions ac new nonterminal symbol ll conflict 
ll conflict ll conflict factorable 
said factorable grammar conflicts factorable 
definition 
left factoring transformation set productions grammar 
new nonterminal lf grammar formed adding nonterminal replacing productions productions lemma 
consider grammar lf 
nonterminal set sentential forms derived contained set sentential forms derived set sentences derived equals set sentences derived 
particular equivalent 
proof 
follows immediately definition 
lemma 
conflicts eliminated left factoring 
proof 
conflict grammar consider grammar lf results left factoring transformation 
contain productions remain form conflict 
contains productions definition exists nonempty string strings contains productions productions form ll conflict 
reach contradiction factorable ll conflict 
belongs contains productions lemma sentential form derived start symbol grammar derived respectively tc start symbol grammar 
definition forms ll conflict productions form ll conflict suppose factorable 
definition exist strings tc ra rb lcp tc nonempty 
replacing productions tc productions rc new nonterminal symbol know productions form ll conflict 
leads contradiction productions form factorable conflict left factoring transformation lf safe production production belong lcp prefix lemma 
factorable lf factorable iff lf safe 
proof 
suppose lf safe 
production production lcp ga gb prefix proper prefix nonempty string contain productions tc ra 
assume nonterminal derive nonempty string terminals derive sentential form starts terminal symbol string rb derive sentential forms start occur string rb tc form ll conflict 
suppose factorable lf safe 
show ll conflict factorable 
ll conflict kinds 
occurrence factorable factorable ll conflict 
corresponding factorable ll conflict contained factorable ll conflict 
occurrence contain factorable ll conflict formed production belongs production 
lf safe lcp ta prefix factorable 
theorem 
factorable finite number successive applications safe left factoring transformations yield ll grammar 
proof 
lf safe left factoring transformation production nonterminal left hand side 
weight denoted sum lengths longest common prefixes right hand sides ll conflict 
ll conflict productions belonging productions belonging production belonging 
kind conflict occurs case proof lemma 
second kind eliminated shows distinct case conflict proof lemma 
number different conflicts total weight reduction results replacing productions left hand sides 
third kind conflict contains production ta belongs production 
analysis case proof lemma ta form ll conflict production conflicts associated replaced single pair productions tc 
left factoring reduces weight kind conflict agg lcp 
weight agg lcp 
weight monotonically decreasing respect safe left factoring finite number applications safe left factoring yield equivalent ll grammar weight 
theorem give rise variety strategies turning factorable grammars ll grammars 
say strategy optimal applies smallest number left factoring transformations 
optimal strategy introduce smallest number new nonterminal symbols 
shall see produce grammar productions contain fewest occurrences grammar symbols 
order investigate optimal strategies need introduce additional terminology notation 
pair gap nonterminal grammar bg prefix lcp 
gap transformation left factoring transformation lf gap obvious properties gaps gap transformations stated proof 
lemma 
gap transformation safe 
gaps nonterminal grammar prefix iff rq 
prefix iff disjoint 
lemma gaps partially ordered 
gap equal gap iff qr 
gap maximal gap different maximal gaps disjoint 
production said factored production 
set productions grammar partitioned factored productions sets productions maximal gaps 
theorem 
factorable minimum number applications safe left factoring transformations obtain ll grammar equals total number gaps proof 
lf safe left factoring transformation production left hand side nonterminal show number gaps show number gaps number gaps iff gap 
gaps divided corresponding cases grammars 
gap disjoint contained production cases correspond gaps contains productions occurrence nonterminal contains productions left hand side nonterminal contains occurrences right hand side 
qg claim gap iff gap case disjoint 
part obvious 
prove part suppose gap qg follows lemma partial ordering gaps lcp nonempty contains unique maximum gap qw 
suppose production ba belongs 
ba belongs exists nonempty string tr productions tc ra belong 
lf safe lcp xq ba prefix qr contradiction 
gap iff gap case subset gap correspond gap 
gap iff gap disjoint 
case strict subset left factoring safe 
case exactly fewer gap iff gap result follows 
theorem optimal left factoring strategy iterate gap transformations lf grammar free gaps 
theorem 
number grammar symbols occurring grammar produced optimal left factoring strategy independent order gap transformations chosen 
proof 
recall lemma incomparable gaps disjoint sets productions 
suffices consider gaps nonterminal grammar lemma know grammar lf replaces productions aa productions aa cb productions grammar fewer occurrences grammar symbols productions grammar gap transformed gap appearing grammar cb prefix 
see productions grammar lf precisely fewer occurrences grammar symbols productions grammar total reduction grammar symbols resulting transforming 
reader verify factoring respect alternative order gap transformations yields reduction grammar symbols 
algorithm repeatedly perform gap transformations maximal gaps grammar free gaps factored productions remain 
key strategic idea maintain partition productions map prefix blocks strings grammar symbols invariant holds 
invariant 
maximal gap corresponds block prefix common prefix right hand side strings productions included prefix prefix initial partition stores productions nonterminal separate block nonterminal grammar 
convenient right hand side production special sentinel symbol outside set grammar symbols 
initial block prefix 
clearly invariant holds initially 
algorithm proceeds repeatedly removing block performing refinement step refine 
assume contains productions left hand side nonterminal assume induction hypothesis invariant holds just refinement step performed 
cases consider 
case 
contains production induction hypothesis factored 
included final grammar 
simple case invariant clearly preserved 
case 
split right hand side strings productions symbol occurring just prefix string cf definition split perform split prefix subcases consider 
contains set symbol say occurs just prefix right hand side production redefine prefix prefix add back set string sentinel 
follows definition gaps induction hypothesis invariant maintained 
prefix initial block 
set dd add new block bb dd define prefix bb symbol occurring immediately prefix string belonging dd 
sentinel dd contain string block bb handled case 
definition gaps particular fact string nonempty gap invariant maintained prefix prefix maximal gap induction hypothesis definition gaps 
perform part corresponding gap transformation adding single factored production prefix final grammar new nonterminal 
set dd add new block bb prefix dd define prefix bb symbol occurring just prefix string belonging dd 
sentinel dd contain string block bb handled case 
invariant maintained proof theorem case proof theorem 
algorithm proceeds search gaps factored productions newly introduced productions 
design efficient implementation note right hand sides productions re introduced step suffixes right hand sides original grammar input 
particular new grammar symbols introduced step appear right hand side production introduced partition note prefix substrings right hand sides original input grammar 
performing gap transformations reuse right hand side strings original grammar 
represent block productions left hand side nonterminal stored prefix record subset right hand side productions initial grammar input prefix 
string ith st symbol string 
preceding representation partition implemented way list blocks implemented triple 
grammar initial partition contains triple nonterminal grammar 
initialization algorithm computes new grammar described loop remove block contains string factored production find left factor strings block starting ith position bb split bb contains block ith jth symbols string form part nonempty left factor add bb contains block ith st symbols string form complete left factor left factor initial block represents nonterminal left factor create new nonterminal efficient joint implementation cases block bb loop contains string add try find left factor strings loop loop optimal left factoring algorithm implement preceding algorithm minor modification pointer multiset discrimination method strings described section 
directory store set nt grammar symbols sentinel 
right hand side production implemented header record current position field body storing list pointers nt 
multiset discrimination sequences form set distinct right productions grammar triple implemented set pointers header records associated strings modify implementation section slightly way 
header record current position point respectively ith jth list cell body 
initially current position pointers point list cell header record 
program points optimal left factoring algorithm current position pointer header record block respectively updated sequential list cell routine md seq section 
program point pointer header record block replaced current position pointer 
program point test initial block performed unit time checking current position pointers header record block implement split efficiently basic multiset discrimination 
record referenced elements current position field pointing jth list cell split implemented call md pointer lx deref deref current position data 
recall call returns pair maps symbols nt back pointers header records strings jth symbol 
preceding discussion leads theorem 
theorem 
optimal left factoring algorithm correct runs linear time number grammar symbol occurrences productions input grammar 
proof 
basic operation preceding algorithm takes unit time split takes time 
incremented just blocks added see new symbol occurrences processed input strings call split 
result follows 

multiset discrimination trees applications suppose forest syntax trees produced syntactic analysis 
internal node syntax tree associated node list begins identifier function symbol arity greater followed ordered successors node 
successor identifier constant variable internal node 
applications depend identifying subtrees equivalent sense 
say identifiers equivalent equal nodes equivalent components node lists pairwise equivalent subtrees equivalent respective root nodes equivalent 
problem deciding subtree equivalence arises common subexpression detection turning arbitrary linear tree pattern matching algorithm nonlinear matching algorithm deciding structural equivalence type expressions preprocessing input form required wegman paterson unification algorithm 
cocke schwartz solved problem representing distinct node identifiers nodes distinct integers called value numbers 
method involves extensive hashing 
alternative method related tree isomorphism solution uses lexicographic sorting compute value numbers 
runs linear worst case time size forest complex multi pass method outperform value number method practice 
problem solved multiset sequence discrimination efficiently hashing numeric representation identifiers nodes 
suppose symbol table implemented pointer directory identifiers 
suppose identifier component node list represented pointer symbol table entry component represents successor node represented way sequences section header record node list solution rests simple ideas 
symbol table forms directory equivalence solved outset components node lists represent identifiers 
define height identifier height internal node plus maximum height components node list second idea nodes distinct heights forest equivalent 
allows solve multiset subtree discrimination separately nodes height bottom starting nodes height 
suppose forest maximum height procedure multiset sequence discrimination solve multiset subtree discrimination 

tree root forest create dummy header record node list 
height repeat step 
locs set pointers header records forest roots contained node lists nodes height solve multiset discrimination sequences calling procedure md seq arguments locs modified minor way 
updating header record referenced locs point witness program points completely replace header record pointer witness perform assignment deref witness 
preceding algorithm solves subtree equivalence problem compresses syntax forest dag redundant subtrees occurrences equivalent subtrees worst case time space linear number nodes forest 
great deal simpler previous theoretically best algorithm lexicographic sorting 
expect outperform method value numbering practice 

multiset dag discrimination acyclic coarsest partitioning solution multiset tree discrimination extends modification solve multiset discrimination ordered dags edges nodes worst case time auxiliary space 
space bound improves space bound obtained solve problem aho hopcroft ullman lexicographic sorting algorithm 
show multiset dag discrimination obtain improved solution acyclic instances function coarsest partition problem 
function coarsest partition problem hopcroft model problem dfa minimization applications program optimization program integration 
formulated follows 
directed multi graph set vertices sets edges initial partition find coarsest refinement block exists block image set xc 
assume degree vertex graph 
hopcroft gave algorithm solves problem time kn log space worst case described hopcroft algorithm nondeterministic behave way case 
push block partition stack 
nonempty pop block split blocks way 
split block partition disjoint subset new blocks 
belongs push push whichever larger consider input instance single function defined rule initial partition 
lemma 
preceding problem instances satisfy properties 


disjoint union sets cardinality 
proof 
property trivial 
property proved establishing simple identities combine identities obtain applying sides identity confirm prove property note function consequently set disjoint union sets having cardinality property 
set disjointness preserved function preimage operations see disjoint union having cardinality 
result follows property replace term expression 
theorem 

acyclic function coarsest partition problem solved hopcroft algorithm time space kn worst case 
ii 
solved multiset dag discrimination time kn space 
proof 
suffices give example input instance just function hopcroft algorithm run logn steps 
consider instance satisfying lemma 
assume hopcroft algorithm starts initializing stack 
show time block popped stack partition remains unchanged splitting step single block belonging stack split half 
furthermore final partition contains singleton blocks 
splitting block half takes time proportional half size block cumulative cost splitting input block singleton blocks log log 
inductive argument establish claim 
right block popped stack time conditions hold 
stack contains original input blocks 
blocks partition 
blocks twice number elements 
block split blocks 
basis properties follow definition input instances fact blocks 
block split block algorithm proceeds stack block conditions hold 
condition holds inspection holds property lemma 
induction assume conditions hold 
property lemma 
hopcroft algorithm blocks split blocks new blocks cardinality follows properties lemma 
blocks splits partition way twin split equals property lemma 
conditions hold block popped stack collection singleton blocks 
part theorem holds 
ii 
problem reduced multiset dag discrimination follows 
form pointer directory elements uniquely associated set element define label pointer directory element uniquely associated set remove self loops leaves 
node form node list label consists label followed ordered successors 
interpret leaf nodes having height solve acyclic coarsest partitioning multiset dag discrimination 
original version included theorem proof appeared learned independently observed acyclic coarsest partitioning solved linear time 
rediscovered multiset discrimination algorithm originally described independently procedure modification obtain result 
show hopcroft algorithm take nlogn steps acyclic input instances 
approach efficient pointer dag discrimination avoids numeric representation needed order direct algorithm 

sequence congruence problem sequence congruence problem arises context program integration 
problem partition program components classes members equivalent execution behavior 
algorithm solves problem phases program components partitioned respect flow dependence graph refined respect control graph 
hopcroft coarsest partition algorithm phases giving logm logm time complexity sizes flow dependence graph control graph respectively 
control graph essentially acyclic linear time multiset dag discrimination method second phase improve time bound logm 

basic block optimization value numbering standard program analysis technique determining equalities values computed instructions basic blocks 
technique implemented hashing multiset discrimination obtain efficient implementation hashing numeric representations 
consider basic block consisting sequence assignment statements form lhs rhs lhs variable rhs constant variable expression form op op ary operator constants variables 
assume lexically scanned variables constants represented pointers symbol table described previously 
want determine equivalence classes variable expression occurrences run time value 
achieved steps 

construct initial dag representation tmax vertex set edge sets tmax tmax maximum arity operators appearing instructions leaves represent constants initial values variables internal nodes represent values computed right hand side expressions 
internal node representing value right hand expression op vertices representing values op contains edge construct scanning statements order scan vertex node representing current value variable constant accessed pointer stored symbol table entry rhs statement scanned 
argument rhs node defined assign new node node labeled pointer symbol table entry consider cases 
rhs variable constant simply set node node 
rhs form op 
constants enter computed value op symbol table create new node labeled pointer set node create new vertex labeled op set node add edge node 
step may create duplicate entries symbol table newly computed constants 
compress symbol table performing multiset discrimination constants new constant entries adjust pointers entries accordingly 

recognize common subexpressions multiset dag discrimination 

reduction strength final examples preceding techniques obtain new solutions strength reduction worst case performance asymptotically better expected performance previous best algorithms 
ironically efficiency obtained stems batch techniques implement strength reduction uses incremental techniques improve program performance 

basic strength reduction consider new hash free algorithm implements cocke kennedy strength reduction transformation 
algorithm runs worst case time space linear length final program text show orders magnitude better hash algorithm 
cocke kennedy transformation concerned replacing hidden costs linear polynomials involved array access formula programming languages fortran algol 
suggested allen cocke kennedy earlier transformation improved sharper analysis control flow safety code motion account 
improvement orthogonal solution 
strength reduction transformation may defined follows 
strongly connected region code 
assume code consists assignments simple non array variables form op op conditional branches boolean valued variables predicates 
assume implicit assignment certain designated input variables implicit output variables printed assigned 
concern control flow simplified accepting conservative assumption control flow graph representation forms clique statements executed runtime 
accordance conventional terminology cf 
variable occurrences left assignment called definitions variable occurrences called uses 
variable definitions region code called region constant variable 
variable live entry program region sequence instructions entirely instruction entering free definition save instruction sequence 
definition 
region constant variable constant variable defined product reducible definitions occurring forms definition form occurs product reducible definition form occurs products kc reducible 
reducible product occurs strength reduction transforms follows 
replace occurrence new variable ic uniquely associated text expression 
variable live entry introduce assignment ic unique entry block detail add transformation correctness entered entering 
just prior definition insert assignments newly generated temporary variables ic uniquely associated product definitions form insert code ic ic jc respectively 
definitions form insert code ic kc ic kc ic kc ic jc kc respectively 

products introduced step 
previously eliminated code motion strength reduction replace associated temporary variable 
remove products introduced step 
code motion recursive application strength reduction appropriate 
cocke kennedy assume strength reduction performed redundant code elimination constant propagation code motion 
strongly connected program region input initial solution preceding transformation shares steps cocke kennedy algorithm 

compute set rc region constant variables set defs definitions variable defined 
compute set iv induction variables set variables definitions occurring product xc reducible constant procedure described cocke schwartz 

find set cands reducible products xc occur find associated program points products occur 

induction variable compute set variable constant right hand side assignment occurs 
algorithmic analysis provided known cocke kennedy strength reduction algorithm carries steps 
worst case time space linear length program text describing remaining steps algorithms need take closer look problem structure 
regarded binary relation represents transitive closure fact immediately follows cocke kennedy 
lemma 
set reducible products removed recursive application strength reduction defined rm jc ic cands 
calculation rm central implementation strength reduction linearity algorithm depends fact 
lemma 
represents initial program text represents final program text strength reduction applied rm 
proof 
product vc rm cases consider 
product belongs cands appears induction variable vc doesn belong cands definition variable vc introduced transformation step 
uniquely associated product 
variable vc introduced steps 
uniquely associated product 
cases consider 
case induction variable uniquely associate pair definition occurs uniquely associate pair variable constant occurring assignment inside order compute rm time rm need avoid redundant computation arises products belong cands nonempty 
case may substantial overlap subsets kc rm kc rm rm 
sources redundancy rm innocuous worth mentioning 
case arises belong cands 
case rm contain second case arises rm contains different products completely different constant arguments evaluate value 
redundant products cases may included initial calculation rm eliminated postpass cleanup 
simplification reduce number variables eliminate variable uses counting argument lemma 
algorithm combines multiset discrimination data structuring techniques 
point solution differs cocke kennedy 
go compute transitive closure time say warshall algorithm see number variables constants contained number assignments induction variables 
transformation conservative assumption control flow graph region forms clique transitive closure large heuristic approach compute improve substantially warshall algorithm 
cocke kennedy greedy strategy committed hashing product removed strength reduction 
contrast compute strong components directed graph representing inverse directed edge iff 
graph constructed time space multiset discrimination sequences length eliminate multi edges arise different assignments variable uses variables constants 
strong component decomposition computed tarjan algorithm 
note roots nodes degree represent constants region constant variables 
nodes represent induction variables 
convenience refer nodes terms variables constants represent 
dag structure strong component decomposition efficiently compute rm time 
algorithm rests obvious fact lemma 
cs cands 
cs set strong components containing variable cands 
cs set products rm removed strength reduction defined rm jc path component 
proof 
lemma product reducible fixed constant region constant variable iff ic cands 
graph representation inverse path node node iff 
definition strongly connected component subgraph directed graph path entirely inside node node path node node iff path node strong component containing node reducible constant region constant variable iff cm path cm 
remaining steps algorithm just algorithmic analysis 
simultaneously compute sets cs cs described lemma basic multiset discrimination identifiers occurring products cands 
time mark variables vc belongs cands 
symbol table pointer directory product cands pair pointers directory step takes cands time space 

scd dag representation strong component decomposition initialize empty multiset mrc products vc empty multiset mc numeric constants 
constant cs repeat steps compute set scd depth search dag scd reverse direction edges starting components belonging 
recall previous discussion strong component scd incoming edges entries constants region constant variables entries induction variables 
identifier consider cases 
induction variable link new symbol table entry containing unique identifier vc live entry insert assignment vc vc entry marked indicating vc cands replace occurrence vc pointer symbol table entry vc 
scd region constant variable link new entry mrc containing product vc 
scd constant link new entry mc containing computed value cc induction variable scd assignment defs introduce update code vc strength reduction transformation step 
replace products introduced update code symbol table mrc mc indicated links scd depth search scd step takes linear time number edges traversed 
assignment induction variable scd corresponds edges portion dag traversed step 
number assignments greater equal half number edges traversed step 
assignment update code introduced step 
step 
takes time space 

multiset discrimination sequences length case belonging mrc discrimination constants belonging mc respectively find eliminate duplicate region constant expressions mrc duplicate values mc 
consequently augment symbol table new variables distinct item mrc mc 
time re adjust pointers inside new symbol table entries insert assignment entry product mrc 
step takes time space mrc mc bounded number edges traversed step 
preceding discussion establishes theorem 
theorem 
strength reduction transformation performed worst case time space 

strength reduction useless code elimination cocke kennedy noted strength reduction applied necessary apply global cleanup transformations useless code elimination elimination statements contributing output variable subsumption eliminating useless copy operations 
section show fold useless code elimination strength reduction 
hash free solution runs worst case time space linear sum lengths initial final program texts 
assume strongly connected region code defs set definitions variable defined computing cands directly compute set products appearing places occur 
set iv induction variables computed explicitly detected implicitly simpler way 
spoiler mean variable defs contains definition forms compute set spoilers variables 
generalize relation defined variable just induction variables assigned directed graph denote inverse 
compute strong component decomposition dag scd recall strong components incoming edges contain constants region constant variables 
strong components contain induction variables spoilers 
product belongs cands iff path spoiler mark strong components containing spoilers mark components reachable marked components unmarked portion corresponds precisely data structure heart strength reduction algorithm preceding subsection 
recall induction variables variables contained unmarked strong components incoming edges 
preceding discussion simplifies steps 

cocke kennedy algorithm leads alternative linear time strength reduction algorithm continues step 
subsection 
supports new algorithm includes efficient analysis elimination useless code 
consider new graph new program region strength reduction differs initial graph old lemma 
subgraph induced unmarked strong components subgraph induced marked strong components invariant respect strength reduction 
ii 
new strong components new contain temporary variables edges incident components marked components 
iii 
edges go unmarked marked components deleted strength reduction 
proof 
strength reduction alters loop ways assignments introduced modify temporary variables xc steps 

right hand side assignment contain temporary variables 
assignments create new edges old strong components new containing temporary variables 
assignment xc appearing replaced assignment xc case variable spoiler product assigned belongs marked strong component scd old appear unmarked component scd old edge scd scd product xc replaced edge strong component new containing xc scd edge respectively deleted new assignment remains respectively righthand side 
inputs set input variables outputs set output variables controls set predicate variables control statements 
assume variables useful strong components containing call critical set crit useful 
useful components include crit strong components reach components crit 
assume statements initially useful strength reduction applied induction variables region constant variables constants useless 
temporary variables introduced strength reduction useful 
consequently replacement products temporaries create useless code 
statements undergo replacement useful 
modify algorithm previous subsection facilitate useless code elimination follows 
edge store count number distinct uses right hand side assignments occurring implemented pointer linking assignment vc directly adjacency list step assignment vc replaced assignment vc decrement edge counts edges edge count reaches zero edge deleted add new edges vc step introduce new edge assignment temporary variable introduced 
step 
multiset discrimination determine new vertices corresponding new temporary variables add final step 
useful variables computed linear time search inverse opposite direction edges starting vertices crit 
assignments variables useful components removed 
preceding discussion theorem 
strength reduction transformation combined useless code elimination performed worst case time space 

iterated strength reduction useless code elimination cocke kennedy noted strength reduction applied new compiler generated variables vc variables new induction variables new products defined terms variables removed applications strength reduction 
section show iterated strength reduction folded useless code elimination solved worst case time space linear maximum length initial final program texts 
note iterated strength reduction terminates iteration eliminate product original strongly connected region order achieve promised linear time complexity careful generate temporaries useless 
final code resulting iterated strength reduction 
cands set products initial code reduced iterated strength reduction 
cocke schwartz say temporary vc available program region referenced execution stores value vc case say sequence region constant variables constants tail set tails variable constant denoted tails 
default tails iff useless recall denotes empty sequence 
main task algorithm determine tails variable constant appearing straightforward introduce temporary variables generate code keep available 
consider preprocessing 
graph representation subsection 
edge compute tails tails making set label defined inductively smallest set satisfying rules 
labels includes instruction occurs 
labels includes instruction occurs rc constant 
labels includes instruction mentioned 
case mark spoiler 
scd dag representation strong component decomposition vertices scd strong components scd edge strong components iff contains edge node node extend definition labels edges scd 
edge scd define labels labels 
say component scd clean elements spoilers edge nodes labels 
say reducible ancestors scd clean 
difficult see variable occurring induction variable iteration cocke kennedy algorithm iff belongs reducible component 
belongs non reducible component products vx reducible 
assume variables occurring useful initially variables belonging non reducible components remain useful straightforward compute reducible components scd processing components scd topological order direction edges 
clean component scd reducible predecessors reducible reducible 
follows tails computed inductively lemma 
lemma 
set cands consists products vc occurring rc constant belongs reducible component 
ii 
edge labels tails tails 
iii 
edge labels tails belongs reducible component sequence tails 
iv 
belongs non reducible component tails 
component scd reducible tails tails lemma iii 
reducible tails tails lemma iv 
case define tails tails arbitrary computing tails variables compute tails components scd 
simple way computing tails follows scd topological order opposite direction edges loop reducible tails tails succ labels tails contains output variables tails tails loop succ set successors scd 
multiset sequence discrimination computing union line worst case cost due sequence tails slow 
efficient modify preceding algorithm generate tails length applying multiset discrimination 
suppose strength reduction transformation iterated times new products reduced 
ith iteration reduces products arguments corresponds computation tails length algorithm compute tails length round initially tails empty components scd 
round compute tails length component assuming new tails generated round 
useful program variables detected 
round assign unique identifier distinct tail length round newly generated sequence represented pair name 
consequently order determine distinct tails generated ith round multiset sequence discrimination needed sequences length 
implementation details 
pred scd reducible labels pred scd reducible labels contains label 
pred generate tails length tails length pred propagate tails components 
tails set tails length heads set components tails empty 
initially set heads 
compute tails length generate tails length propagate tails length pred tails length generated lemma iv follows 
scd loop reducible contains output variable tails heads heads loop tails length generated lemma iii follows 
heads loop pred loop tails heads heads loop loop heads loop pred loop tails tails labels tails loop loop perform multiset sequence discrimination tails tails length propagated scd lemma ii heads scd reachable components heads edges pred heads topological order pred direction edges loop perform multiset sequence discrimination tails pred loop tails tails tails loop loop representation sequences initialize temporaries 
tail generated round name store value insert assignment initialization block 
tails initialized insert assignment vs vt initialization block temporary vs rest algorithm includes replacing products cands temporaries inserting code keep temporaries available eliminating dead code 
tasks straightforward third done easily help tails sets 
analyze algorithm note tail added tails line code exists instruction jc distinct instruction inserted keep temporary vp available 
similarly tail added tails line code exists instruction xy respect need insert instruction keep temporary vp available 
accumulated cost code bounded size output code 
consequently theorem 
iterated strength reduction problem useless code elimination solved time auxiliary space 
algorithm theoretically superior iterated form cocke kennedy algorithm 
program text ith iteration cocke kennedy algorithm 
perform dead code elimination iteration size large inserted code may stay program iterations dead 
lemma induction variable region constant set induction variables transitive closure computed time hashing set element addition 
iterating cocke kennedy algorithm take hash operations worst case 
closer look algorithm reveals computed variables xc candidate product optimization iterated strength reduction cocke kennedy algorithm takes hash operations worst case 

extensions possible approaches exploit commutative associative laws products may reduce number strings temporaries generated preceding strength reduction algorithms 
approach weak form paige tarjan lexicographic sorting algorithm generate strings constants arbitrarily chosen order 
effective efficient approach compute product constants identifying temporary multiset constant discrimination 
currently investigating ideas extensions implement powerful transformation integrating strength reduction sums products quotients exponentiations multivariate expressions 
extensions allow different kinds spoilers different arguments candidate expressions 
development simpler hash algorithms promising direction 

new theoretically efficient hash free solutions assortment programming language problems 
solutions worst case asymptotic time space complexities match improve expected time worst case space best previous solution involved hashing assumption hash operation takes expected time 
case iterated strength reduction solution worst case time orders magnitude better expected time best previous solution 
solutions large part efficient multiset discrimination methods datatypes built basic datatypes implemented directories sequence constructors 
datatypes include strings lists ordered trees ordered dags 
multiset discrimination arbitrary datatypes formed identifiers constructors sequences sets multisets 
generic nature methods wide ranging successful applications language processing problems demonstrates basic algorithm design tool solving problems various areas computer science 
replacement solutions hashing solutions multiset discrimination illustrates fundamental principle algorithm improvement 
problems considered batch problems problems input available computation 
problems previously solved reducing simpler line problem breaking problem sequence simpler subproblems uses portion original input contributes portion output 
solution line reformulations hashing 
approach advantage simple easily implementable algorithm local strategy decisions small portion input 
problems reformulated terms multiset discrimination batch subproblem 
algorithms complicated better theoretical performance partly depend global strategy decisions larger portions input multiset discrimination solved efficiently 
algorithms better theoretical performance clear computational advantage 
empirical investigation comparing hash free alternatives conventional counterparts worthwhile 

ralph wachter workshop randomized algorithms brought attention questions randomized versus deterministic algorithms felt raised similar questions hash versus hash free algorithms led current 

author ada uk news vol num pp 
jan 

aho hopcroft ullman design analysis computer algorithms addison wesley 

aho sethi ullman compilers addison wesley 

allen cocke kennedy reduction operator strength program flow analysis ed 
muchnick jones pp 
prentice hall 

alpern wegman zadeck detecting equality variables programs proc 
th acm popl jan 

cai paige look ma hashing arrays acm popl pp 
jan 

carter wegman universal classes hash functions jcss vol 
pp 


clinger rees macros proceedings th acm symposium principles programming languages pp 
jan 

cocke global common subexpression elimination acm sigplan notices vol 
pp 


cocke kennedy algorithm reduction operator strength cacm vol 
pp 
nov 

cocke schwartz programming languages compilers lecture notes cims new york university 

cytron lowry zadeck code motion control structures highlevel languages ibm research center yorktown heights 

downey sethi tarjan variations common subexpression problem jacm vol 
pp 
oct 

earley high level iterators method automatically designing data structure representation computer languages vol 
pp 


fong elimination common subexpressions high level languages proceedings fourth acm symposium principles programming languages pp 
jan 

hoffmann donnell pattern matching trees jacm vol 
pp 
jan 

hopcroft log algorithm minimizing states finite automaton theory machines computations ed 
kohavi paz pp 
academic press new york 

knoop steffen strength reduction code motion institute fur informatik und praktische mathematik christian university kiel germany feb 

knuth art computer programming vol fundamental algorithms addison wesley 

lewis stearns compiler design theory addisonwesley 

mairson program complexity searching table th ieee focs pp 
nov 

paige tarjan efficient algorithms partition refinement siam journal computing vol 
pp 
dec 

paige efficient translation external input dynamically typed language proc 
ifip congress vol ed 
simon pp 
elsevier north holland 

paige symbolic finite differencing part proc 
esop ed 
jones lecture notes computer science vol 
pp 
springer verlag 

paige real time simulation set machine ram ed 
computing information vol ii pp 


paige tarjan linear time solution single function coarsest partition problem tcs vol 
pp 
sep 

paterson wegman linear unification journal computer system science pp 


rewrite systems pattern matching code generation ph dissertation ca berkeley 

minimisation acyclic deterministic automata linear time theoretical computer science vol 
pp 


rosen degrees availability program flow analysis ed 
muchnick jones pp 
prentice hall 

schwartz schonberg programming sets setl springer verlag 

stearns deterministic top parsing proc 
th princeton conf 
information sciences systems pp 


interactive system data structuring setl programs ph dissertation dept computer science new york university new york ny may 

tarjan class algorithms require nonlinear time maintain disjoint sets comput 
sys 
sci vol 
pp 


tarjan data structures network algorithms siam 

tarjan depth search linear graph algorithms siam comput vol 
pp 


warshall theorem boolean matrices jacm vol 
pp 


wegman zadeck constant propagation conditional branches proc 
th acm popl jan 

willard quasilinear algorithms processing relational calculus expressions proc 
pods pp 


yang horwitz reps detecting program components equivalent behaviors tr computer sciences dept univ wisconsin madison wi april 

yang new algorithm semantics program integration ph dissertation tr computer sciences dept univ wisconsin madison wi august 
