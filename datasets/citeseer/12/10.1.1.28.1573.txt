abcd eliminating array bounds checks demand rajiv gupta vivek sarkar university wisconsin bodik cs wisc edu university arizona gupta cs arizona edu ibm watson research center ibm com guarantee typesafe execution java strongly typed languages require bounds checking array accesses 
checks may raise exceptions block code motion instructions side effects preventing useful code optimizations partial redundancy elimination instruction scheduling memory operations 
furthermore expressible bytecode level elimination bounds checks performed run time bytecode program loaded 
existing powerful bounds check optimizers run time feasible heavyweight dynamic compilation setting 
abcd light weight algorithm elimination array bounds checks demand 
design emphasizes simplicity efficiency 
essence abcd works adding edges ssa data flow graph performing simple traversal graph 
despite simplicity abcd surprisingly powerful 
benchmarks average abcd removes dynamic bound check instructions achieving close ideal optimization 
efficiency abcd stems factors 
abcd works sparse representation 
result requires average fewer simple analysis steps bounds check 
second abcd demand driven 
applied set frequently executed hot bounds checks suitable dynamic compilation setting compile time cost constrained hot statements known 
advent safe mobile computing general java particular brought significant changes optimizing compilers 
type safety requires expensive run time semantic checks bounds checks null checks type checks 
second mobile bytecode verifiably typesafe loaded optimizer remove semantic checks run time 
addresses problem eliminating redundant bounds checks lightweight techniques suitable time constrained dynamic compilation setting 
bounds checks cause programs execute slower reasons 
cost executing bounds checks occur quite frequently involve memory load array length compare operations 
importantly presence bounds checks greatly limits application code optimizations 
precise exception semantics java requires program state exception point order exceptions occur preserved code transformations 
consequence application traditional optimizations restricted prevent side effect causing instructions moving exception points traps 
exception points introduced array bounds checks quite frequent scope optimizations applicable severely restricted 
designing optimizations java face conflicting goals optimization algorithm fast general globally identify bounds checks fully redundant partially redundant 
observations provide insight meeting challenge keeping cost dynamic optimization low employ demand driven analysis techniques highly suitable dynamic optimization 
analysis focus attention hot regions program hot bounds checks bounds checks highest execution frequencies 
furthermore demand driven analysis suited dealing incremental updates data flow information program transformations need expensive initialization phases needed exhaustive analyses 
develop algorithms reuse representations commonly compilers 
approach start ssa form cfr assume available develop algorithm works simple traversals cheaply computable extension ssa graph 
existing algorithms array bounds check elimination heavyweight theorem provers si nec nl suitable deployment dynamic optimization setting 
simpler algorithms value range analysis har pat rr eliminate partially redundant checks 
algorithms eliminate partial redundancy mcm gup gup asu kw operate dense program representations control flow graph rely exhaustive iterative data flow analyzers 
meet compile time requirements 
introduce new algorithm called abcd elimination array bounds checks demand 
abcd algorithm contributions 
sparse representation abcd uses novel sparse representation called inequality graph built extended ssa representation 
example see inequality graph representation powerful enable array bounds checks eliminated bubblesort program 
best knowledge existing java compiler fully eliminate bounds checks example 
representation cheaply easily constructed ssa representation program 

demand driven analysis abcd employs demand driven approach algorithm proceeds propagating inequality assertions need verified eliminate bounds check 
optimization performed incrementally starting hot bounds checks 
best knowledge abcd optimization algorithm perform elimination style data flow analysis demand sparse representation 

generality effectiveness abcd stems ability remove fully partially redundant checks 
simple traversals sparse inequality graph representation algorithm able verify inequality assertions locate insertion points checks required eliminating partial redundancy 
remain tight compile time constraints dynamic compiler abcd exploits results redundancy elimination show simple algorithms achieve nearly complete removal redundancies bgs 
sake efficiency assertion checking theorem proving restricted classes statements described section 
empirical evaluation experience shows despite simplicity abcd efficient effective simple implement 
implemented abcd jalapeno optimizing compiler bcf 
results show abcd removes average dynamic bounds checks performing fewer analysis steps bound check 
rest organized follows 
section gives overview abcd 
section presents sparse program representation section describes constraint system detecting redundant checks 
section shows solve constraint system remove fully redundant bounds checks 
section extends removal partially redundant bounds checks 
section outlines possible extensions abcd algorithm 
section presents experimental evaluation abcd algorithm 
section compares abcd existing 
overview abcd bounds check check redundant length check executed 
abcd optimizes lower bound check upper bound check length independent problems 
restrict attention optimization upper bound checks 
dual algorithm lower bound checks derived trivially 
straightforward approach detecting redundant checks construct constraint system program point propagating constraints dataflow analysis ii apply theorem prover point bounds check 
forgo rare optimization opportunities created interplay problems sake simplicity 
limit length st st st limit st limit st running example bidirectional bubble sort 
shows relevant fragment program symantec benchmark suite 
bounds check performed array accesses 
simplify presentation rest disregards second loop 
abcd eliminate bound checks example 
expensive steps abcd streamlines ways 
constraint propagation abcd builds single program point independent constraint system 
constraint system sparse fact ssa form extra edges 

relying theorem prover abcd performs simple demand driven traversal sparse representation 
despite limited power traversal prover able eliminate dynamic upper bound checks experiments 
remainder section outlines main components abcd constraints sparse constraint system graph representation constraint solver handling partially redundant bounds checks 
constraints 
abcd efficient operates simple difference constraints pra clr form program variable program variable symbolic literal length array integer constant 
restricting constraint form enables abcd efficiency constraints pairs variables represented sparse global constraint system difference relationships processed simple traversal solver 
sho beneficial restrict attention class inequalities 
furthermore abcd gathers constraints obtained local examination program code constraint propagation preprocessing 
types program statements generate constraints useful bounds check elimination array length literal length constant assignment constant increment decrement conditional branches array bounds check check constraints generated restricted forms assignments 
constraint exploits invariants generated exit branch branch conditional expression 
constraint exploits successful array bounds check check guarantees length 
note constraints expressed difference constraints 
variable defined assignment generates complex constraints outside abcd considers variable unconstrained appears statements 
general disregarding existence constraints safe worst hide redundant checks 
sparse global representation constraints 
constraints generated program statements program point specific 
guaranteed hold live range informally range cfg nodes generating statement dominance frontier killing definition whichever closer 
encode constraint live ranges compactly globally node abcd splits live ranges program variables ssa style renaming 
effect renaming converts flow sensitive constraint system equivalent flow insensitive system done pointer analysis hh 
abcd splits live ranges variables resulting live range refers unique variable name ii variable live range larger live range constraint involving expressed unique variable names constraint system program point independent global 
inheriting ssa properties constraint system sparse connects directly statements generate related assertions speeding constraint solving process 
ssa split live ranges inserting dummy assignments 
split live ranges constraints standard ssa assignments sufficient 
constraints require additional splitting perform inserting assignments conditionals bound checks 
call resulting representation extended ssa ssa form 
ssa form running example shown 
solving constraint system 
simplify presentation view sparse constraint system system inequalities graph called inequality graph 
graph substitutions constraints viewed graph traversal exploit formulating simple traversal prover constraint system 
inequality graph extension ssa value graph 
node ssa variable constant array length literal value length edge weights constrain differences pairs nodes 
inequality graph upper bounds check check redundant shortest path length negative length corresponds bounds check condition length true 
inequality graph running example shown 
traversal solver constraint system equivalent shortest path computation demand driven version solver amounts computing shortest path pair vertices length 
situation complicated fact inequality graph hypergraph ber rr generalizes notion shortest path see section 
handling control flow 
reason abcd constraint system induces non standard notion shortest path constraints treated different ways control flow path variable bounded strongest constraint generated path 
contrast set control 
build ssa form insert nodes see section compute ssa form cfr 
build inequality graph gi see table 
remove redundant checks check form check gi hx length remove program abcd algorithm removing fully redundant checks 
flow paths variable bounded weakest constraint produced paths 
max min semantics inequality graph encoded kinds nodes 
max nodes nodes correspond control flow merges 
remaining nodes act min nodes 
inequality graph enables elimination partially redundant bound checks 
partially redundant checks redundant necessarily control flow paths 
typical example loop invariant check outcome loop iteration optimized executed loop entered 
fully redundant bounds checks deleted partially redundant checks require insertion compensation checks ensure check redundant control flow paths 
identify insertion points nodes inequality graph 
shown context expression elimination insertion points correspond certain subset edges nodes 
extend approach inequality graph 
insertion performed abcd may speculative rely profiling data determine profitability optimization 
approach relies results demonstrate speculative insertion nearly effective techniques perform complete redundancy removal code duplication bgs 
abcd algorithm 
entire abcd algorithm fully redundant checks outlined 
step transforms program ssa form second steps connects ssa variables constraints third step solves constraint system removes checks proven redundant 
extended ssa form abcd encodes scope constraints transforming program extended ssa ssa form described section 
salient property ssa constraints generated ssa program valid variables live 
implicit encoding obviates need explicitly qualify constraints cfg scope results compact constraint system 
important property constraints expressed ssa program define sparse constraint system solved efficiently 
understand relationship live ranges variables scopes constraints consider constraint generated cfg node example statement 
safe rule delineating scope constraint restrict nodes values node typically approximated requiring values originate definition sites node rule scope represented enumerating nodes definitions condition holds 
abcd uses efficient approach splits renames live ranges variables variables appear constraint live constraint scope 
effect renaming converts flow sensitive constraint system equivalent flow insensitive system loss precision style hh 
abcd splits variable live ranges means assignments existing new ones 
ssa form assignment writes unique variable name uniquely names live ranges 
assignments needed points case constraint created live ranges constraints start assignments target variables directly renamed 
constraints start exits conditionals constraints start bounds checks 
capture constraint types abcd inserts assignments discussed 
case constraint killed scope constraint generated node terminated node redefined ii control flow join reached path redefined iii control flow join dominated standard ssa form sufficiently splits variable live ranges encode constraints 
renaming performed follows new definitions called assignments placed recursively control flow join points reachable different definitions variable renaming targets original assignments enforces cases renaming targets assignments enforces cases ii iii 
renaming variable dominated single reaching definition guarantees desired property value entire live range 
express constraints case requires additional renaming 
renaming performed introducing assignments exits conditionals bounds checks 
consider conditional statement shown left assignments inserted variable appearing conditional expression cfg edges conditional branch 
outcome conditional associated distinct variable name serves hook attaching constraints generated branch 
assignments inserted cfg edges textual representation program assignments placed basic blocks targeted branch 
reduce amount program transformation allow variables appearing constraint live outside scope long simultaneously live scope 
note assignments analogous switch operators dependence flow graph jp 
similarly generate new name constraints assignment inserted bounds check 
bounds check viewed special statement transfers program control exception handler check fails check fail useful constraint generated check check constraint expressed new name erroneously lead elimination bound checks including generating check 
example ssa form depicts running example conversion ssa form 
sake brevity second loop omitted 
reduce number assignments induced assignments assignment limit inserted loop 
safe uses limit loop 
constraint system inequality graph program converted ssa form constraints generated program connected single flow insensitive constraint system 
simplicity constraints considered abcd difference constraints variables constraint system represented weighted directed graph solved relatively efficient graph traversal algorithms 
section presents graph representation constraint system properties 
section presents efficient solver constraint system 
representing simple constraint systems graphs standard technique common example constraint graph pra clr 
inequality graph gi generalizes constraint graph allows representing program control flow follows 
gi allows detect bounds check redundant control flow paths 
second gi maintains program structure information perform code motion partially redundant bounds checks see section 
solution constraint system represented gi computed similarly computed constraint graph notion shortest path see section 
informally vertices inequality graph represent program variables ssa form constants literals 
edge connects vertices program generates constraint difference variables program generate constraint create disconnected vertices 
definition inequality graph gi program ssa form inequality graph weighted directed graph gi distinguished set vertices fv fa program variable length program literal denoting length array ck integer constant appearing program contains directed edge iff generates constraint rule table 
weight edge distinguished subset vertices iff variable defined program ssa assignment 
original program limit length st st st st st limit limit st st check check goto goto ssa form limit length st limit limit limit st st st st limit st st limit limit st st limit limit st limit limit limit check check goto goto running example conversion ssa form 
recall table defines edges gi elimination upper bound checks elimination lower bound checks analogous separate inequality graph 
example inequality graph gi shows inequality graph gi running example 
vertices program entities ssa variables literal length constant set contains assignments 
note ssa form vertex represents definition uses variable 
ssa form guarantees gi multigraph 
note names denote interchangeably program entities vertices inequality graph 
worth mentioning decided represent constraints generated program assignments inequalities equalities appear intuitive choice allow inequality graph upper lower bounds check elimination 
motivation represent constraints uniformly exclusively inequalities 
important motivation formulate consistent constraint system presence constraints 
consider rules table 
assignments vk translated constraints vk vk done abcd constraint system imply vk similarly system imply ws assignments 
result constraints generated exit conditional rule ws vk inconsistent value program variables satisfy constraint vk vk ws vk avoid inconsistency abcd translates assignments vk constraints vk variables vk mutually unconstrained reflecting fact vk live simultaneously node program values compared 
ready define system difference constraints 
definition constraint system constraint system inequality graph gi distinguished set vertices set inequalities max fu min fu 
constraint generating generated edge edge weight type statements constraint length length length wr ws wr wr ws ws wr ws ws vk vk vk wr wr wr vk vk check ak ak length ak length control vk flow vk table edges inequality graph elimination upper bounds checks 
feasible solution constraint system assignment integer values variables satisfies constraints 
handling control flow 
abcd extends standard system pra order express control flow program 
standard system consists set equations equivalent set equations min fu see abcd extends standard difference constraint system compare equations set distinguished vertices constrained strongest constraint holds weakest 
reflect semantics vertices mnemonics refer vertices max vertices vertices min vertices 
corresponds assignments eq 
ensures bounds check redundant incoming control flow paths 
example consider variable st defined st st st 
constraints hold arguments assignment line follows fact array length non negative represented edge gi st length st st limit length control flow predecessor corresponding st constrains value st path corresponding st constraint holds incoming control flow paths st length weaker constraints correctly computed eq 
st st 
consistency 
gi may contain negative cycles constraint system may inconsistent due implying 
informally consistency constraint system guaranteed presence max vertex cycle breaks cycle negative 
consider negative cycle limit limit limit 
negative cycle strengthens constraint weakest constraint max vertex limit come outside cycle 
propagating constraint outside cycle max node effectively breaks cycle 
formally negative cycle gi cycle gi created result cyclic control flow contain assignment arguments defined outside cycle 
defined vertex 
constraint system 
assume argument defined outside negative cycle closes negative cycle 
cg yields equivalent constraint system negative cycle redundancy bounds check 
relate solution constraint system redundancy bounds check 
definition fully redundant check upper bound check check fully redundant length check executed 
terms constraint system bounds check redundant check true feasible solution constraint system 
words bounds check redundant implied constraint system 
theorem upper bound check check program gi inequality graph check redundant feasible solution gi length 
proving redundancy bounds check check entails computing greatest value 
length length feasible solutions gi bounds check check redundant 
length 
call value 
distance vertices gi alternatively distance 
defined smallest value adding constraint constraint system change set feasible solutions system 
problem computing distance gi generalization shortest path problem weighted directed graph 
outline generalization note upper bound check elimination distance gi corresponds longest path shortest path reverse problem max operator selects shorter path 
st st st st st st limit length limit limit limit limit limit limit inequality graph gi running example 
meaning edge upper bound check represented gi vertices array length vertex array index vertex 
example bounds check check vertices length bounds check redundant distance vertices 
compute distance node propagate sum edge weights way node distance equals greatest incoming distance remaining node distance equals smallest incoming distance 
distance length 
shortest path distance ha length limit limit limit limit limit rest terms shorter longer refer reverse problem shorter 
intuitive way describe distance generalizes shortest path give instance gi distance shortest path defined identically 
case vertices multiple predecessors 
restriction path gi corresponds control flow path distance gi corresponds shortest path gi selecting constraint valid control flow paths 
contrast vertices allowed multiple predecessors gi may contain paths corresponds different constraints hold control flow path 
computing distance control flow path pick longest different paths gi elegant formalism dealing kinds paths hypergraph ber rr 
directed hypergraph consists set nodes set hyperarcs hyperarc connects set nodes single target node 
concept hyperpaths defined recursively 
exists empty hyperpath set nodes node non empty hyperpath set nodes node consists hyperarc set hyperpath node hyperpath set component paths sequences vertices 
turn inequality graph hypergraph group edges vertex single hyperarc vertex represent separate hyperarc 
distance defined follows length hyperpath equals length longest component paths distance equals shortest hyperpaths example determine bounds check check redundant inequality graph compute distance vertex length vertex distance array index greater array length bounds 
distance length 
check check redundant 
distance equal longest component path shortest hyperpath vertices ha length limit limit limit limit limit constraint solver section presents details solver abcd uses identify fully redundant checks 
extensions partially redundant checks described section 
constraint system represented inequality graph solved various ways 
mentioned inequality graph gi viewed hypergraph ber rr redundancy check reduced computing shortest hyperpath vertices array length vertex array index vertex 
second hypergraph viewed grammar problem ram shortest hyperpath fixedpoint computation 
third shortest hyperpath computed efficiently dataflow analysis solver gw time gi irreducible 
abcd uses algorithm worse asymptotic time complexity practical running time mainly typical gi small 
contrast exhaustive analysis approaches solver works demand 
exhaustive algorithm analyzes bounds checks program context shortest paths means computing single source shortest path problem array length vertex 
demand driven approach analyzes single bounds check amounts computing shortest path array length vertex array index vertex 
solver demand driven sense expect dynamic optimizer optimize small fraction bounds checks design favors performance analysis batch analysis bounds checks 
solver return length shortest path boolean information shortest path limit sufficient prove bounds check redundant 
strict question allows solver examine fewer paths necessary compute precise value shortest path 
explain solver works consider gi acyclic contains min max nodes 
efficient way computing shortest path source array length vertex target array index vertex perform topological traversal performing min max operations process 
determine topological order traverse entire graph demand analysis seeks avoid place 
topological traversal solver performs brute force depth exploration graph node may visited multiple times 
successive visit node corresponds stronger question distance node array length vertex 
algorithm shown performs depth traversal gi starting array index vertex intuitively recursive exploration graph proceeds forward direction gi edges source vertex reached cycle detected 
goal determine traversed path longer forward pass propagates value adjusts crosses edge source vertex reached traversed path longer propagated value greater zero 
depending outcome comparison recursion return value true path shorter false path longer length 
consider cyclic inequality graphs 
mentioned previous section arbitrary inequality graphs may contain negative weight cycles cycles nondecreasing effect path distance cycle broken max node 
cycles positive weight may impact path distance broken min vertex 
consider cycle variable st example 
edge limit st removed cycle st cause distance st positive infinite weight 
cycles gi cumulative weight positive correspond program loops program variable incremented loop body 
call gi cycles amplifying cycles 
cycles involving st cycle involving amplifying 
contrast cycle limit amplifying 
conceptually algorithm works identifying reducing amplifying cycles 
cycle broken situations may occur 
cycle articulation point source vertex bounds check vertex distance correctly computed infinite weight means check proven redundant 
breaking cycle path leads source min vertex value distance may small prove check redundant 
consider 
amplifying cycle broken removing edge alternative path length remains limit weight sufficient prove bounds check redundant 
detect positive weight cycles forward exploration keeps active value propagated value vertex active depth traversal path 
backedge traversed positive weight cycle detected comparing current value value cycle ago 
positive weight cycle detected value false returned 
harmless cycle weight zero detected consider path reduced returning value reduced 
cycle reduced sense influence distance summary forward exploration stops node know path originating distance shorter equal result true longer result false reduced result reduced 
recursion returning backwards algorithm merges results min max semantics gi vertices lattice true reduced false true top element false bottom element 
max node merges values meet operator min node merges values join operator removing partially redundant checks previous section identified checks fail 
checks strong guarantee proven 
typical example loop invariant bounds check prove fails iteration loop fails 
general checks called partially redundant guaranteed fail control flow paths leading 
partially redundant checks eliminated optimization called partial redundancy elimination pre generalizes common subexpression removal loop invariant code motion 
pre works inserting compensating checks program points partially redundant check fully redundant insertions check performed control flow paths removed 
pre optimization array bounds checks natural extension abcd algorithm full redundancies 
proceed describe extensions abcd introduce partial redundancy running example 
task easily accomplished removing assignment limit length 
effect inequality graph vertex limit disconnected vertex length breaks shortest path prove check fully redundant 
check partially redundant loop invariant 
analysis order turn partially redundant bounds checks fully redundant checks analysis determine insert compensating checks 
goal find partially redundant check set cfg edges checks inserted fully redundant 
check sufficient insert check function gi return boolean gi inequality graph max vertices hb ci check proven check index variable array length literal 
example analyzing check hx length 
vertices source target shortest path computation respectively 
result proving array length literal 
maps hv ci ftrue false 
active detects cycles active null active distance check index variable 
active maintains distance vertex path current dfs stack 
active prove ftrue return true return false function prove vertex vertex int return ftrue reduced falseg stronger difference proven true return true weaker difference disproved false return false cycle reduced stronger difference reduced return reduced traversal reached source vertex success return true constraint exist value fail predecessor gi return false cycle encountered active null active return false amplifying cycle return reduced harmless cycle active edge prove edge prove active null return prove algorithm proving redundancy bounds check 
procedure gi returns true check hb ci proven redundant inequality graph gi equivalent showing distance vertex vertex gi greater edge corresponds argument limit node entry loop 
abcd algorithm extended pre computes set insertion edges backtracking recursive exploration inequality graph 
check inserted node edge exactly node arguments proven procedure prove returned true able proven prove returned false 
false arguments collected backtracking insertion set 
compensating checks inserted 
compensating check may different check optimized 
specifically checks may differ index expression compensation check check may require insertion check check 
example check compensated check check limit 
identifying index expression abcd trivial 
due reliance simple difference constraints index expression form assume index expression optimized bounds check form variable corresponds node argument insertion performed 
constant equals distance insertion point array index vertex example distance limit equals compensating check example check limit 
distance easily computed value propagated recursive procedure prove 
profitability removing partial redundancies 
ensure inserted checks increase dynamic number checks program traditional pre techniques insert check cost amortized removing check control flow path emanating insertion point 
amortization condition computed backward dataflow problem anticipability 
abcd estimates profitability run time profiling 
require check removed emanating path 
allow control speculative insertion speculate program follow path insertion lead removal check 
determine speculative insertion profitable abcd compares cumulative execution frequency insertion points frequency partially redundant check 
impairment due insertions lower benefit due removal check carry transformation 
profile pre shown nearly powerful complete removal redundancies program restructuring bgs 
algorithm easily extended remove partial redundancies 
recursive function prove extended return lattice values value false list insertion edges optimized check fully redundant 
meet join operators manipulate insertion sets 
min vertex abcd selects set lower execution frequency 
max vertex propagated sets merged 
transformation abcd allows elegant analysis compensating checks inserted address problem transforming program 
broader problem maintain exception semantics presence code motion hoisted inserted check fails exception raised immediately delayed raised location original partially redundant check 
broader problem scope 
subsection describe solution currently implementation abcd 
sketch solution investigating 
current solution bounds check split instructions compare instruction sets register index bounds trap instruction raises exception flag set 
discuss traps require different transformation compares 
current approach optimizes compare instructions 
leaving traps original locations prevents moving code freely array accesses primary motivation bounds check optimization note partially redundant traps left code fully redundant traps majority traps removed 
removing traps similar removing conditional branches 
traditionally conditional branches optimized program restructuring code duplication mw bgs 
see restructuring expensive dynamic compiler current exploring transformation techniques unique dynamic optimization setting 
approach run time removal traps follows 
optimized version loop executes trap 
compare instruction fails code unoptimized version loop trap generated execution transferred 
possible hoisted check failed spuriously executed speculatively see section 
case unoptimized loop finishes encountering trap proceed execution optimized version code 
extensions global value numbering inequality graph gi represent local constraints generated individual program statements shown table constraints deduced global program analysis example global value numbering 
ssa variables value congruent equivalence reflected gi constraint edge weight 
restrictions value numbering algorithm edge inserted definition dominates definition serves guarantee constraint holds hold executed 
current implementation abcd exploits global value numbering restricted economical fashion described 
encode results analysis gi consult congruence information demand common scenario attempting eliminate check check able establish length length 
case consulted value numbering analysis congruent obtained desired proof length 
elimination lower upper bounds checks abcd algorithm eliminates upperbound checks 
detect redundant lower bound checks changes algorithm needed 
reverse relational operator constraints see table 
second source vertex shortest path computation length lower bound java constant vertex 
interesting note context abcd performs implicit subsumption bound checks 
example upperbound check redundant respect upper bound check 
equivalent subsumption performed lower bound checks lower bound check redundant respect lower bound check 
abcd treats analysis upper lower bound checks independent problems problems treated transformation stage optimization 
describe trick merge upper lowerbound check single check instruction 
trick applies arrays zero lower bound java 
merged check performed unsigned comparison negative value array index transformed large positive value guaranteed exceed size largest array allowed java virtual machine 
upper bound check unsigned value equivalent performing lowerbound check negative value upper bound check signed value 
pointer aliasing array ssa form convince reader abcd correctly handles pointer aliasing useful highlight aliasing strongly typed language java differs language explain abcd deals kinds aliases 
java local variables subject pointer aliasing address taken 
furthermore statement change size array referenced local java variable 
consider program 
new int new int passes bounds check middle statements affect value array access remains valid bounds array created new int statement 
ssa form correctly accounts fact modified placing def edge definition 
new int new int fails bounds check 
consider second example 
copy statement array access refers array created new int statement array access bounds 
ssa form correctly capture effect value result memory load assumed return unknown array 
edge definition array access abcd algorithm conclude refers unknown array 
plan array ssa form sk ks perform precise def analysis presence pointers enable abcd algorithm conclude refers array created new int statement 
preliminary experiments initial experimental evaluation abcd algorithm 
experimental results obtained jalapeno optimizing compiler infrastructure bcf mhz powerpc processor running aix 
experiments jalapeno optimizing compiler performed basic set standard optimizations including copy propagation type propagation null check elimination constant folding local common subexpression elimination load store elimination dead code elimination linear scan register allocation 
previous bcf demonstrated jalapeno performance optimizations roughly equivalent ibm product jvm jit compiler aix powerpc platform 
experiments java benchmarks db mpeg jack compress jess specjvm suite microbenchmarks bubblesort qsort sieve hanoi dhrystone array symantec suite sym java programs toba 
spec codes medium size inputs 
focus measurements dynamic counts bounds check operations 
report timing information report best wall clock time runs 
preliminary implementation limitations 
interprocedural summary information jalapeno optimizing compiler assumes open world due dynamic class loading 
perform code duplication generation multiple versions loop partitioning loop iteration space safe unsafe regions mms 
importantly jalapeno optimizing compiler lacks optimizations global code motion benefit removal array bounds checks 
reasons experimental results considered lower bound potential gains due array bounds check elimination expect results improve jalapeno matures 
shows dynamic number bounds checks removed abcd 
baseline represents bounds checks analyzed abcd upper bound checks measured dynamic terms 
spec benchmarks number broken local checks basic block checks redundancy required global analysis 
division remaining programs 
manual examination symantec benchmarks showed abcd achieved near optimal performance sense checks left unoptimized optimizable intraprocedural analysis hanoi requiring complex pointer analysis dhrystone 
static terms average number checks fully redundant 
significant number static checks partially redundant 
average number analysis steps invocations recursive procedure prove analyzed check 
low number confirms benefit sparse approach 
time analyze bounds check ranged milliseconds averaged milliseconds 
time include time construct ssa form 
measured run time speedup symantec benchmarks 
observed improvement 
number lower expected mainly due limitations infrastructure outlined 
db mpeg jack compress jess bubblesort qsort sieve hanoi dhrystone array toba bounds checks removed upper bound checks dynamic count global checks local checks amount bounds checks removed 
amount shown benchmark represents fraction upper bound checks removed measured terms dynamic instruction counts 
benchmarks specjvm top bars fraction divided local global checks 
related elimination array bounds checks 
number approaches taken performing elimination array bounds checks 
theorem proving style algorithms suzuki si necula lee nec nl xu 
powerful abcd theorem proving expensive unsuitable dynamic optimization setting 
value range analysis compute bounds values index expressions purpose eliminating full redundancy har pat rr 
goals handle non scientific programs complex control flow 
addition full redundancy important handle elimination partial redundancy 
conventional iterative data flow style bounds check elimination algorithms developed eliminate partial redundancy mcm gup gup asu kw 
algorithms exhibit efficiency algorithm demand driven analysis sparse representation 
research focuses imperative programs xi pfenning considers functional programs xp 
midkiff mms focused elimination bounds checks scientific code written java 
complementary focus non scientific code complex control flow 
techniques eliminating partially redundant conditional branches bgs mw determine compile time analysis outcomes branch conditionals similar nature bounds check conditions 
algorithms limited power algorithm interpret increments variables critical bounds check elimination index expressions loops nearly refer loop induction variables 
algorithm bodik bgs uses demand driven analysis quite expensive dynamic optimization setting 
employ sparse representation uses expensive restructuring transformations elimination partial redundancy perform hoisting 
chow developed pre algorithm operates ssa graph 
algorithm employ demand driven analysis 
algorithm simpler require explicit distinction speculative redundancy removal 
importantly focus works redundancy elimination krs bgs pre expressions array bounds checks 
demonstrated elimination bounds checks significantly different character assertions generated different sources loop exit conditions increments induction variables analyzed concert prove bounds check redundant 
check elimination exhibits min max hypergraph behavior 
demand driven data flow analysis 
duesterwald dgs horwitz hrs developed demand driven data flow analysis frameworks iterative approaches allow lattices finite size height 
purpose bounds check elimination need handle lattices require elimination style analysis handle loops 
bodik elimination style demand driven analyzer handle lattices infinite height bgs 
operates dense program representation control flow graph satisfy efficiency goals dynamic optimization 
contrast algorithm developed achieves efficiency performing demand driven analysis sparse program representation 
indebted susan horwitz ramalingam tom reps mark wegman xu discussions suggestions presentation 
anonymous referees suggestions 
tom reps discussions relationship inequality graph hypergraphs grammar problems 
asu 
optimization array subscript range checks 
acm letters programming languages systems june 
bowen alpern mark wegman kenneth zadeck 
detecting equalities variables programs 
th annual acm symposium principles programming languages pages san diego california january 
bcf burke 
choi fink grove hind sarkar serrano sreedhar srinivasan whaley 
jalapeno dynamic optimizing compiler java 
acm java grande conference june 
ber claude berge 
graphs hypergraphs transl minieka 
north holland amsterdam 
bgs bodik rajiv gupta mary lou soffa 
interprocedural conditional branch elimination 
proceedings acm sigplan conf 
prog 
language design impl pages june 
bgs bodik rajiv gupta mary lou soffa 
complete removal redundant expressions 
proceedings acm sigplan conference programming language design implementation pages june 
bgs bodik rajiv gupta mary lou soffa 
load reuse analysis design evaluation 
proceedings acm sigplan conference programming language design implementation may 
chow chan kennedy 
liu lo tu 
new algorithm partial redundancy elimination ssa form 
proceedings acm sigplan conf 
prog 
language design impl pages june 
cfr ron cytron jeanne ferrante barry rosen mark wegman kenneth zadeck 
efficiently computing static single assignment form control dependence graph 
acm transactions programming languages systems october 
clr cormen leiserson rivest 
algorithms chapter pages 
mit press mcgraw hill book 
dgs evelyn duesterwald rajiv gupta mary lou soffa 
practical framework demand driven interprocedural data flow analysis 
acm transactions programming languages systems november 
gallo longo pallottino sang nguyen 
directed hypergraphs applications 
discrete applied mathematics 
gup rajiv gupta 
fresh look optimizing array bound checking 
mark scott johnson editor proceedings acm sigplan conference programming language design implementation sigplan pages white plains ny usa june 
acm press 
gup gupta 
optimizing array bound checks flow analysis 
acm letters programming languages systems march december 
gw susan graham mark wegman 
fast usually linear algorithm global flow analysis 
communications acm december 
har harrison 
compiler analysis value ranges variables 
ieee transactions software engineering se may 
hh rebecca hasti susan horwitz 
static single assignment form improve flow insensitive pointer analysis 
proceedings acm sigplan conference programming language design implementation pldi pages montreal canada june 
hrs susan horwitz thomas reps mooly sagiv 
demand interprocedural dataflow analysis 
proceedings third acm sigsoft symposium foundations software engineering pages october 
jp richard johnson keshav pingali 
dependence program analysis 
proceedings acm sigplan conference programming language design implementation pages june 
krs jens knoop oliver bernhard steffen 
lazy code motion 
sigplan notices july 
proceedings acm sigplan conference programming language design implementation 
ks kathleen knobe vivek sarkar 
array ssa form parallelization 
conference record popl th acm sigplan sigact symposium principles programming languages pages san diego california january 
kw michael wolfe 
elimination redundant array subscript range checks 
acm sigplan notices june 
proceedings acm sigplan conference programming language design implementation pldi 
mcm markstein cocke markstein 
optimization range checking 
proceedings symposium compiler optimization pages june 
mms midkiff moreira snir 
optimizing bounds checking java programs 
ibm systems journal august 
morel 
global optimization partial redundancies 
cacm 
mw frank mueller david whalley 
avoiding conditional branches code replication 
acm sigplan conference programming language design implementation volume acm sigplan notices pages 
acm sigplan acm press june 
nec george necula 
compiling proofs 
phd thesis carnegie mellon university october 
available technical report cmu cs 
nl necula lee 
design implementation certifying compiler 
proceedings acm sigplan conference language design implementation pldi pages 
pat jason patterson 
accurate static branch prediction value range propagation 
pages june 
proceedings acm sigplan conference programming language design implementation pldi 
pra pratt 
easy theories hard 
technical report massachusetts institute technology 
ram ramalingam 
bounded incremental computation volume lecture notes computer science 
springer verlag new york ny usa 
rr ramalingam thomas reps incremental algorithm generalization shortest path problem 
journal algorithms september 
rr radu martin rinard 
automatic parallelization divide conquer algorithms 
proceedings acm sigplan symposium principles practice parallel programming atlanta ga may 
acm sigplan 
sho robert shostak 
deciding linear inequalities computing loop residues 
journal association computing machinery 
si suzuki 
implementation array bound checker 
conference record fourth acm symposium principles programming languages pages los angeles california january 
acm sigact sigplan 
sk sarkar knobe 
enabling sparse constant propagation array elements array ssa form 
lecture notes computer science 
mooly sagiv thomas reps susan horwitz 
precise interprocedural dataflow analysis applications constant propagation 
theoretical computer science 
sym just time compilation 
www symantec com cafe analysis html 
xu barton miller thomas reps safety checking machine code 
proceedings acm sigplan conf 
progr 
language design implementation page appear jun 
xp hongwei xi frank pfenning 
eliminating array bound checking dependent types 
acm sigplan notices may 
proceedings acm sigplan conference programming language design implementation pldi 
