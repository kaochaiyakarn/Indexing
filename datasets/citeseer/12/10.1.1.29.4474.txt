dynamic types type dependent functions marco pil computing science institute university nijmegen gl nijmegen netherlands cs kun nl 
programs communicate programs flexibility demanded 
programs necessarily information 
assigning types communications certain amount dynamic typing unavoidable 
want entire language dynamically typed consequently interface statically dynamically typed parts program defined 
interface dynamics introduced abadi leroy extended system dynamics allow inclusion polymorphic objects dynamics 
extend system restricted form type dependent functions allow types dynamics functional level 
clean type dependent functions implemented overloading 
programs communicate programs possibly incarnations flexibility demanded 
programs necessarily know existence may terminated launched 
known examples communication asynchronous message passing file typing file differs typing ordinary expressions compiletime knowledge contents file run time 
general static link name file type contents 
types parts program perform file checked run time reading writing 
certain amount dynamic typing unavoidable 
want entire language dynamically typed 
statically typed programming languages allow earlier error checking generation efficient object code languages type consistency checks performed run time 
interface statically dynamically typed parts program defined 
concept objects dynamic types dynamics short introduced abadi provide interface 
values dynamic type roughly speaking pairs value type value component typed type component 
leroy system dynamics extended able include polymorphic objects dynamics 
extend system restricted form type dependent functions 
functions enable types dynamic type patterns construction dynamic objects 
structure 
introduce dynamics clean define simple language dynamic types 
specify type system language details define operational semantics prove decidability type assignment 
dynamics section introduces dynamics implemented dynamic syntax introduced pil 
typing communication independent programs perform run time type checks want object program tagged type 
distinguish objects static type objects dynamic type 
dynamic consists normal object paired encoding type enable run time type checks 
point view dynamics belong static type type dynamic 
values type dynamic self described far types concerned 
contain type information type checked runtime 
dynamic created pairing object encoding type dynamic construct dynamic expr type checked statically expression expr static type type 
example 
examples dynamics dynamic true bool dynamic fib int int dynamic reverse access objects type dynamic limited 
value accessed type matches specific statically determined type 
purpose pattern match mechanism clean extended describe matching types 
guaranteed compile time type contained dynamic matches statically specified type described patterns value contained dynamic safely right hand side expression known appropriate type 
example 
example dynamic pattern match dynamic int int int int type patterns need fully specify demanded type may include type pattern variables match subexpression dynamic type 
type pattern scope alternative type pattern right hand side expression 
example 
type pattern variables allow specification powerful functions polymorphic types dynamics dynamic dynamic dynamic dynamic df dx dynamic error string new feature type pattern variables need binding occurrence type pattern 
bound function type 
case scope function function type function alternatives left hand side right hand side 
function type binds type pattern variable indicated adding type context tc annotating variables 
type class tc stands type code function overloaded representation type example 
type context bind type pattern variable dynamic dynamic tc dynamic dg dynamic error string run time checked dynamic argument function matches type determined context applied 
type variables bound type context necessarily occur dynamic type patterns 
appear dynamic type expressions right hand side example 
function wrap wraps value dynamic wrap dynamic tc wrap dynamic mechanism overloading takes care correct type code deduced context wrap 
type dependent functions allow types dynamics scope function just type pattern variables types function alternative 
powerful form abstraction desired 
illustration consider function lookup searches list dynamics finds integer returns fails come element aborts 
lookup dynamic int lookup abort integer list lookup int xs lookup dy xs lookup xs note allowing program abort write function lookup dynamic 
int yields list contains integer 
lookup function easily altered search list real bool generalised polymorphic function lookup dynamic wrong lookup abort element correct type list lookup xs lookup dy xs lookup xs version lookup incorrect parametric representation type looking polymorphic 
new mechanism type dependent functions able write general lookup function lookup dynamic tc lookup abort element correct type list lookup xs lookup dy xs lookup xs actual type determined context lookup example list dynamics lookup sin lookup example integer picked added 
example applies sin function real 
implementation issues undesirable compiler generate specialised instantiation different types 
ad hoc polymorphism parametric polymorphism implementation instance 
accomplish clean compiler transform type dependent functions giving extra arguments 
type expressions function depends passed arguments 
example 
transformed version lookup function lookup typecode dynamic lookup tc abort element correct type list lookup tc tc xs lookup tc dy xs lookup tc xs applications lookup transformed compiler lookup typecode int sin lookup typecode real formal language chapter idea fact function depends certain type reflected extra argument type code passed 
formal system expressions dynamic types section describes formal system formalizes notion objects dynamic types 
formal system term graph rewriting introduced barendsen smetsers 
formal system allows reasoning decidability typing provides handle presentation operational semantics 
syntax formal language full new constructs language introduced barendsen smetsers discussed individually 
typing rules new constructs 
syntax definition 
types built type variables type constructors oe ff oe oe oe ranges type constructors 
function type seen special binary type constructor 
note kinds variables generic variables ff fi type schemes type pattern variables construction pattern matching dynamics 
intuitively generic variables ff may seen universally quantified type pattern variables properties existentially quantified variables 
definition 
expressions generated letrec case oe oe hoe ei open ha xi typecase fail equal success fail coerce success fail ranges data constructors function symbols type constructors 
definition 
notion symbol type redefined incorporate abstractions type variables 
symbol type arity type arity quantified tuple pi oe oe 
denoted pi oe oe types called type arguments types oe called argument types 
type result type 
new constructs dynamics constructed pairing type expression hoe ei type oe may include type variables express polymorphism type pattern variables bound open typecase construct 
dynamic unpaired open construct 
value component bound term variable type component type pattern variable open ha xi expr actual type component unify statically type actual type component 
constructs typecase equal coerce constructs 
typecase construct enables matching type constructors 
typecase 
tn en fail fail compared definition barendsen smetsers intended meaning selector type expression matched type patterns pattern matches cause branch taken 
patterns match branch fail taken 
type pattern variables bound typecase may way variables introduced open construct 
normal case construct consider left linear functions type variable may occur pattern 
type pattern variables local occur equal construct compare types run time 
equal success succ fail fail intended meaning unifiable expression succ evaluated succ desirable unify types 
comparison consist coercion check type instance 
coerce success succ fail fail intended meaning instance expression succ evaluated fail note constructs typecase equal coerce match type pattern variables full types 
done proof decidability type checking easier see sect 
complex types required clean expressions translated formal language 
type dependent functions represented level function definitions fact arguments function type pattern variables symbol type function quantifies variables pi oe 
may occur oe 
syntax function application adapted allow type arguments function specified oe oe arity type arity rules type assignment section auxiliary definitions typing rules new language constructs 
typing rules existing parts barendsen smetsers 
auxiliaries addition standard basis ib need type basis keeps track type pattern variables declared surrounding expressions equation basis holds equations form oe types may assumed equal syntactically different 
definition 
term basis ib finite set term variable declarations form oe term variable oe type 
ii type basis finite set type variable declarations form ff ff type pattern variable 
iii equation basis finite set type equations form oe oe types 
iv write gamma abbreviation ib 
definition 
set type variables tv oe type oe defined inductively tv ff fffg tv fag tv oe tv oe tv oe oe tv oe tv oe ii set type variables tv ib basis ib defined naturally extending definition tv ib ftv oe oe definition 
type oe formed type basis oe iff contains variables declared iff constructed rules ff oe delta delta delta oe arity oe oe note star 
play role star barendregt cube 
intuition types may terms inhabitants 
saying type formed equivalent type may term 
type variables may terms type pattern variables introduced surrounding expression composite types components may 
definition 
types equivalent notation oe iff oe derived rules oe oe oe oe oe ae ae oe oe oe oe ae ff oe ae ff typing rules constructs dynamic construction values type dynamic constructed pairing expression type 
constraints pairing expression typable type oe type formed oe oe ib oe tv oe tv ib dynamic construction ib hoe ei represents type dynamic expressions dynamic 
note constraint variables ib 
due type dependent functions constraint needed type pattern variables open construct dynamic unpaired open construct value component bound term variable type component type pattern variable 
typing expression may assume term variable typable type pattern variable represented adding ib may term expr represented adding existentially quantified types may outside scope open expression 
particular allowed type open expression depends amounts type rule open expressions dynamic destruction ib ib tv ib open ha xi typecase construct typecase construct enables matching 
requires type matched formed 
branch may assumed type pattern variables wellformed 
typing branch selector type expression may freely substituted type pattern vice versa reflected adding equivalence basis 
auxiliary type rule states types equivalent may substituted ib oe oe substitution rule ib typing rule typecase construct formulated ib ib fail fv ib typecase fail fail open construct variables bound typecase may occur result type equal construct types compared unified equal construct 
required types compared formed 
furthermore typing succ types interchangeable 
results type rule equal expression type equality ib ab succ ae ib fail ae ib equal success succ fail fail ae coerce construct type rule coerce construct analogous equal construct type coercion ib ab succ ae ib fail ae ib coerce success succ fail fail ae function definition function definition standard type pi oe called type correct oe note type variables may occur oe function application pi oe ae ib oe ae ib ae ae ae arity type arity appendix type rules syntactical constructs summarised including defined barendsen smetsers 
decidability type checking section shows decidability type checking presenting algorithm 
definition 
type equation oe distributed type ae notation ae oe inductive definition ae aoe ae oe ae oea ae aoe ae oe ae oe delta delta delta oe ae oe oe ae oe oe ae oe ae type equations oe ii distribution extends naturally bases expressions contain types 
expression typed oe ib fx ff term basis free term variables expression assigned fresh type tenv fa type basis contains free type pattern variables look type checking algorithm complies specification check ib oe general substitution ib oe fail typable implementation appendix auxiliary functions unify function 
function applied types oe yields general substitution oe types unifiable yields fail see robinson 
operator phi concatenates substitutions applies second substitution arguments 
note intuitively clear formal specification 
operational semantics new constructs section presents evaluation rules new constructs formal language 
notation abadi 
definition 
expression canonical form canonical form arity canonical form hoe ei oe canonical form wrong type oe canonical form oe ff oe oe oe oe oe canonical form oe oe oe oe oe canonical form oe wrong wrong value erroneous computations application integer 
value different 
allows distinguish programs loop forever programs crash 
define judgments expression reduces canonical expression type oe reduces canonical type written oe new syntactical construct formal language 
judgments way rules type assignment 
evaluation dynamic construct involves evaluation expression type 
type expression reduces wrong dynamic reduces wrong 
oe hoe ei ht vi oe wrong hoe ei wrong wrong hoe ei wrong evaluation open construct consists evaluation dynamic expression binding resulting canonical forms variables evaluation body expression substituted canonical forms 
dynamic expression reduce canonical dynamic body expression reduces wrong open expression reduces wrong 
ht vi open ha xi form ht vi open ha xi wrong evaluation typecase construct auxiliary function needed unifies canonical types 
unification successful yields substitution type pattern variables occur canonical types fail returned 
typecase expression evaluated evaluating selector type matching patterns 
result evaluation canonical form expression goes pattern unification evaluated selector expression succeeds 
unification succeeds fail expression evaluated 
unify fail unify typecase fail fail unify fail fail typecase fail fail wrong typecase fail fail wrong equal expression evaluated evaluating argument types unified unify function 
successful expression reduces success branch substitution applied result canonical form fail branch 
argument types reduces wrong expression yields wrong 
unify succ equal success succ fail fail unify fail fail equal success succ fail fail wrong equal success succ fail fail wrong wrong equal success succ fail fail wrong evaluation coerce construct differs equal construct auxiliary function 
unifying argument types checked type coerced second second type instance 
successful coercion success branch evaluated substitutions applied 
fail branch reduced 
coerce succ coerce success succ fail fail coerce fail fail coerce success succ fail fail wrong coerce success succ fail fail wrong wrong coerce success succ fail fail wrong operational semantics function application chosen call value 
oe body oe oe related abadi theoretical framework dynamic types complete extensive review history dynamic typing statically typed languages 
mention large number languages restricted dynamic concept 
theoretical framework extended cover polymorphism 
higher order pattern variables introduced able match polymorphic types 
decided deal polymorphism differently ordinary type variables accomplish 
approach taken leroy mauny 
describe simple version dynamic implemented ml 
specify complicated system dynamics universally existentially quantified variables 
system uses existentially qualified types specify dynamic matches incomplete type information 
basically type pattern variables 
systems allow abstraction types dynamics scope function practice shown programmers dynamics strong need powerful tool 
type dependent functions described abstraction possible 
persistent haskell similar restricted form dynamic typing type dependent functions 
haskell operations provide persistent values get persistent io persistent io class persistent comparable class tc clean 
corresponds filename name io comparable input ouput uniquely attributed files 
similarities get operations implemented clean dynamics type dependent functions 
get files name 
error files tc get files name read name files read name files 
error files tc read filename files error dyn files filename files case dyn value error value files bottom files difference clean persistent haskell language typecheck implicit done moment access persistent store clean check postponed 
full system dynamic types type dependent functions implemented clean version 
erik barendsen smetsers rinus plasmeijer valuable remarks discussions 

abadi cardelli pierce plotkin 
dynamic typing statically typed language 
acm transactions programming languages systems 

abadi cardelli pierce emy 
dynamic typing polymorphic languages 
journal functional programming 

barendsen smetsers 
uniqueness typing functional languages graph rewriting semantics 
mathematical structures computer science 

davie hammond 

efficient persistent haskell draft proc 
th international workshop implementation functional languages ifl london england pages 

van eekelen plasmeijer 
functional programming parallel graph rewriting addison wesley 

van eekelen plasmeijer 
concurrent clean language report computing science institute university nijmegen www cs kun nl clean clean html 

leroy mauny 
dynamics ml 
journal functional programming 

pil 
class file proc 
th 
international workshop implementation functional languages ifl bad germany september volume lncs pages 
springer verlag 

robinson 
machine oriented logic resolution principle 
journal association computing machinery 
type rules summarised ib oe oe oe ib oe ib ib oe ib oe ib ib oe oe ib oe ib letrec ib oe ib oe ae ib case ae oe ib oe ib hoe ei ib ib tv ib open ha xi ib oe oe ib ib ib fail fv ib typecase fail fail ib ab succ ae ib fail ae ib equal success succ fail fail ae ib ab succ ae ib fail ae ib coerce success succ fail fail ae pi oe ae ib oe ae ib ae ae ae function definition standard type pi oe called type correct oe type checking algorithm see section check ib oe unify ib oe check ib ae check ib oe phi unify ae oe standard type check ib oe check ib ff oe phi check ib ff ff fresh check ib letrec ine oe check ib ff ff phi check ib ff oe ff fresh check ib case ae check ib oe ae phi unify ff phi check ib ff standard type oe ff fresh check ib hoe ei oe check ib oe phi unify check ib open ha xi oe check ib phi check ib oe check ib typecase fail fail oe check ib oe phi check ib fail oe fail check ib equal success succ fail fail oe check ib ab ab succ oe ab phi check ib fail oe fail check ib coerce success succ fail fail oe check ib ab ab succ oe ab phi check ib fail oe fail 
