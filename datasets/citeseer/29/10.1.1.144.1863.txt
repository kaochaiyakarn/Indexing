bulk types class simon peyton jones university glasgow email simonpj dcs gla ac uk 
www www dcs gla ac uk simonpj october bulk types lists bags sets nite maps priority queues ubiquitous programming 
languages don support received great deal attention especially database community 
haskell currently culprits 
aims identify technical di culties attempt address haskell constructor classes 
read concrete proposal new haskell bulk type libraries 
functional programs lot lists list represent stack queue deque bag set key value pairs priority queue 
nite map way association list lists called bulk types bad programming style reasons 
type object specify invariant set duplicates expected operations lookup nite map 
lack invariants program harder understand harder prove properties harder maintain 

operations lists may cient di erent complexity class operations suitably optimised data type 
example list append takes time linear size rst argument easy implement ordered sequence adt constant time concatenation easy prepared give head tail functions 
possible albeit somewhat complex support append head tail constant amortized time okasaki 
knows uses lists 

lists supported language admit pattern matching built syntax list comprehensions rich library functions operate lists 
experienced functional programmers knowingly write algorithm algorithm just convenient lists append design implement data type 
aren engineered libraries support sets bags nite maps 
decent attempts notably standard template library stl see section technical di culties 
identi es di culties attacks haskell type classes 
problem bulk types central di culty bulk types degree polymorphism 
di erent sorts collections lists sets queues 
second sort may di erent possible representations lists trees hash tables 
lastly representation may di erent element types integers booleans characters pairs 
language supports polymorphism allows programmer write single algorithm essentially similar situations 
example suppose want construct list set bag leaves tree tree de ned data type data tree leaf branch tree tree possible algorithm works tree int leaves constructing set ints tree int leaf branch leaves leaves code assumes existence set construction functions int ways program polymorphic element polymorphism firstly code precisely form required tree booleans 
able generalise leaves tree set leaf branch leaves leaves need set operations set set set set bulk type polymorphism suppose second data type ordset uses di erent representation set set represents set list duplicates ordset uses balanced tree example 
function gather leaves tree ordset just form set 
true want collect leaves bag priority queue list 
ideally leaves polymorphic leaves tree bulk type leaves leaf singleton leaves branch leaves union leaves bulk type constructors singleton bulk type union bulk type trouble generalisations straightforward 
discuss turn 
element polymorphism consider goal making leaves polymorphic elements set 
kind polymorphism parametric polymorphism works source code regardless argument type 
supported modern programming languages including ml haskell collecting leaves tree list parametric polymorphism easily tree leaf branch type just list append commonly written 
trouble arises sets union operation works sets elements arbitrary type 
remove duplicates equality set elements 
furthermore equality may element type admits equality determining element set take linear time 
case ml haskell polymorphism extends executable code executable code works regardless argument type 
case templates single source code function compiler instantiate separately type 
element type supports total order tree balanced may appropriate set membership determined logarithmic time 
element type admits hash function set represented hash table purely functional language persistent data structures rule tree indexed hash key 
element type function mapping elements integers tree representations possible 
way dilemma taken java example decide data type supports equality ordering hash function 
simple crude equality functions example 
cleaner solution adopted ml equality generalised haskell type classes type system allows type variables quali ed operations support 
haskell give type union set data type required equality eq set set set type speci es element type lie class eq class eq de ned class eq bool bool declaration says types instances eq provide operations types 
data type want give instance declaration de nes type 
example instance eq int eqint eqint instance eq eq eq type type inferred eq tree set type required ordering equality wewould simply replace eq ord types 
data structure persistent update old version data structure available okasaki 
strictly speaking semantics union require elimination duplicates postponed set observed membership test enumerating elements 
fundamental changed implementation decision stick naive view union requires equality 
approaches ml equality types built ordered types haskell solution available ml 
restricting equality unreasonable sets equality hopelessly ine cient 
solution adopted ml libraries set functor functor set ord ord sig set set functor ordering argument producing set structure module result 
construct cient set manipulation functions particular element types intset set charset set leaves function mention intset union charset union leaves polymorphic element type 
solve leaves de ned functor takes set structure argument 
bulk type polymorphism consider generalise leaves arbitrary bulk types 
consider types lists queues stacks truly parametric element types 
type classes start union operation collection type quite di erent code queue queue queue 
order generalise leaves earlier informally suggested type leaves tree bulk type suggesting leaves polymorphic bulk type constructor 
polymorphism parametric union operation uses di erent code leaves call di erent union operation type 
exactly type classes 
write leaves bulk tree bulk class bulk types de ned class bulk empty singleton union give instance declaration bulk type instance bulk empty singleton union list type constructor instance bulk queue empty singleton union legal haskell notice variable ranges type constructors types 
sort higher kind quanti cation fairly straightforward powerful extension hindley milner type system jones 
ordinary data type declarations shall see particularly useful haskell system classes generalised type classes constructor classes 
alas things go wrong try deal non parametric element types 
give instance declaration instance bulk set empty emptyset singleton union wrong type 
requires element type eq overloaded union operator 
approaches possible alternative approach hoc polymorphism 
symbol union stand family union operations di erent type 
choice statically compiler local type information 
ml uses sort overloading numeric operators ada languages 
small disadvantage ad hoc overloading may need write type signatures specify type small writing type signatures idea anyway 
big disadvantage write generic operations collections 
example write leaves leaves leaf singleton leaves branch leaves union leaves compiler resolve union 
resolution done implicitly requiring programmer add atype signature done leaves collections type 
exact copy code di erent type signature deal type 
time add new collection type need add new copy 
compiler automatically case issue code size 
adaptive representations third issue adds spice challenge implementing bulk types choosing appropriate representation 
appropriate representation collection depends 
size collection 

relative frequency operations supported bulk type 

operations available underlying element type 
course simply dump problem programmer lap providing large variety di erent set data types leaving choice programmer 
precisely stl 
attractive alternative bulk type choose representation 
items fairly studied 
clever algorithms developed adapt representation data type size usage okasaki chuang hwang okasaki 
obvious item 
build implementation set chose representation operations available elements 
return question section 
summary section reviewed various approaches manipulating bulk types polymorphic fashion 
bottom line quite works 
bulk types quite innocent combination polymorphism element bulk types non parametric nature conspire defeat sophisticated type systems 
design xops route section turn rst solution promising approaches reviewed constructor classes 
solution merit implementable standard haskell shortcomings address second solution section 
stl identify main groups bulk types 
sequences order insertion signi cant extract inserted element operations need performed elements 

collections order insertion unimportant elements admit equality preferably operations sequences sequence contains linear sequence zero elements 
order insertion removal elements signi cant elements added removed 
examples sequences lists catenable lists stacks queues deques 
support set operations di er complexity bounds operations 
figures de nes module seq main declaration type class called seq de nes set operations sequences 
names operations chosen compatible haskell current nomenclature lists 
front back return rst respectively element sequence remaining sequence return null sequence empty 
type return type functions think front back providing head tail view sequence 
fold functions length filter partition reverse straightforward generalisations list counterparts 
readily de ned terms front back 
default method class declaration indicating instance seq may compelled provide method operations 
reason decision instances seq snoc lists say default de nition functions foldr case ine cient 
making functions class methods gives implementor option obligation providing cient de nitions 
standard classes monadplus functor superclasses seq type seq monadplus functor 
de ned haskell prelude 
gives de nitions cons snoc class monadplus 
implemented terms default methods show types ciently implemented directly 
operations standard classes monad monadplus functor sense sequences appends sequences map applies function element ofa sequence zero empty sequence return forms singleton sequence takes function maps element sequence new sequence concatenates results 
stl refers associative containers 
catenable lists support constant time append 
module seq data null cons empty seq empty zero singleton seq singleton return class functor monadplus seq null bool front back 
int update int foldr foldr foldl foldl length int elem eq bool filter bool partition bool reverse sequence class default methods foldr xs case front xs null cons xs foldr xs foldr xs case back xs cons xs foldr xs foldl xs case front xs null cons xs foldl xs foldl xs case front xs cons xs foldl xs length xs foldr xs filter xs foldr zero xs ys cons ys ys partition xs filter xs filter xs reverse xs foldl flip cons zero xs elem xs foldr 
false xs sequence class continued class monad return class monad zero class monadplus cons snoc cons xs return xs snoc xs xs return class functor map monad functor classes sequences lie class monad notation describe sequence valued expressions 
example xs ys return deliver sequence composed pairs drawn sequence xs drawn ys 
applies haskell comprehension notation de nes expression monad 
example comprehension de nes sequence 
xs ys great deal done connection bulk types comprehension syntax especially context database queries optimisation buneman trinder trinder wadler wadler 
lastly seq module contains couple ordinary declarations give names monadic functions zero return empty singleton respectively 
collections observed earlier problem collections union operation may impose di erent constraints element type depending collection dealing 
solution simple give type 
de ne new class xops class element operations class xops bool ordering way comparison int hash function int injection guaranteed ordering standard haskell data type constructors lt eq gt 
point xops tells say compare elements available 
equality operation mandatory wrapped type example particular type instance declaration instance xops just say comparison operation operation 
eq superclass xops having convenient de ne non standard equality collection operations see section confusing non standard instances eq 
de ne class coll collections class coll insert xops 
add operations shortly 
empty avoid name clash sequences anticipate wanting sequences collections scope tiresome quali ed names 
de nitions possible give fully respectable type leaves leaves coll xops tree instances coll suppose datatype ordset implements sets trees making ordering operation set elements 
ordset type ordered sets implementation depends element ordering instance coll instance coll ordset empty insert case just cmp cmp error ordset insert assuming existence suitable data type trees operations insert element 
obvious sadness try build ordset things admit equality get runtime error compile time type error 
whilst undoubtedly sad see shortly design set datatypes fail way 
furthermore worth remembering programs contain quite functions incomplete patterns 
take simple example head head xs head error head course head called think know argument non empty list 
nice type system proved imagine sophisticated type systems freeman pfenning haskell ml certainly rendered unusable possibility runtime errors 
error insert arguably class 
really best avoid possibility run time failure building set data type chooses representation available operations elements 
sketch possible implementation data set empty list duplicates tree tree instance coll set empty insert empty case just cmp tree branch empty empty list insert list xs list xs insert tree case just cmp tree cmp point game insert dynamically selects representation empty case depending comparison operation 
notice crucially extraction cmp nal equation insert fail arguments tree virtue empty equation deciding comparison operation 
eliminated runtime errors delegated data type choice representation 
attractive property 
computing sets programmers want look operations available element type choose set implementation depending answer 
able single type set having implementation choose representation automatically big advantage 
course free particular representation simpler speci set implementation 
ciency generic set implementation sketched just start 
real implementation 
small sets probably represented lists ordering available 
easily programmed 
compiler able create specialised instances insert widely types 
example sees insert type insert string set string set string create specialised version insert xed set xed string comparison operations ought turned inline code 
ciency concerns set turn relatively unimportant implementation insert choose equation constructor nds second argument 
implementations major cost doing pattern matching forcing evaluation little expensive equations constructor 
worry call insert pattern match extract comparison operation carries ciency cost 
done tree rst built data tree tree ordering comparison int size data empty branch probably bad thing 
implementation fetches ordering function tree compiler able prove type int say ordering function bound 
easy compiler generate improved code types known 
collections apart operations collections suggested far insert union deal constructing collections 
collections apart 
obvious thing augment class coll homomorphism constructors collection 
constructors far insert obvious homomorphism add coll class coll fold question course meaning give call fold set 
commutative call nonsense 
way 
specify particular instance coll property fold assumes arguments 
example sets bags fold rst argument left commutative fx may instances coll property need hold ones guarantee apply fold elements sorted order example 
arguments satisfy required properties fold delivers result unspeci ed ordering elements collection 
fold compositional form stl called iterator 
collection order ready operated consuming function 
fold catamorphism regard collection built constructors insert 
equally valid alternative set constructors singleton union leading di erent catamorphism module coll class coll bool size int xops xops fold fold xops bool xops bool xops bool xops insert xops xops xops pr pr union xops xops delete xops xops pr pr lookup xops pr intersect xops collection class default methods part class declaration size fold size insert fold xs xs fold insert fold true false fold union insert insert union fold delete delete error coll intersect standard functions defined class operations xops xs foldr insert xs xs foldr delete xs xops cs foldr union cs cs foldr intersect cs collection class continued fold algebras explored buneman terminology sr add fold sr comb fold 
fold easier fold arguments need provided 
seen fold bit powerful order de ned assume undecidable properties argument 
buneman discusses ways avoid function call ext called 
advantage ext requires particular properties argument de ne bunch useful functions 
finite maps finite maps various guises ubiquitous functional programs 
mathematics function map de ned set ordered argument result pairs 
natural thing represent nite map set ordered pairs type fm set pr data pr deriving show instance eq eq pr instance xops xops pr case just cmp just cmp similarly operations 
value pair read maps 
comparison key value pair done solely basis key 
crucial new data type key value pairs built pair constructor equality ordering instances look components pair just rst 
set key value pairs comparison done basis nite map 
needed complete picture add crucial functions coll class class coll xops xops lookup xops pr variants function combines values compare equal doing insertion union 
important values equal equal keys wish example add second component pairs 
disadvantage approach instance coll principle provide implementation lookup 
doing possible write default declaration lookup fold desirable instances coll lookup wildly ine cient inappropriate 
complete class figures give complete de nition collections module 
points note su functions keep names distinct sequences 
type bit speci default method requires 
allow implementor cient exploits ordering elements 
representation non empty collection included necessary comparison operations see item section possible give operations simpler type omitting xops context 
doing place constraints implementor doing 
pretty looking operation left commutative 
lists ubiquitous albeit libraries place 
may convenient followed list operation single respectable fold 
nal result may independent order fold chose lay collection 
second design multi parameter constructor classes rst design written standard haskell fundamental de ciencies defers run time checks expect statically checked 
separates sequences collections entirely expected share common operations 
separate say lists fifos deques 
class seq provide operations prefer type system express idea fifos operations lists deques fifos 
second design detail rst overcomes objections expense stepping outside standard haskell multi parameter constructor classes 
view author clean way multi parameter constructor classes turn accommodate bulk types persuasive reason extending haskell embrace just monads provide key motivation adding constructor classes 
key idea key idea simple 
suppose re de ne class collections class coll size int empty cons union fold filter bool partition bool notice coll parameters type constructor collection element type 
notice insert xops constraint 
type cons example cons coll interesting part comes de ne instances coll instance coll empty insert instance ord coll empty insert 
exciting thing provide instance speci constraints element type 
rst instance declaration lists constraints placed lists placing constraints element type 
contrast second instance declaration speci es element type class ord just needed allow assumed type ord tree tree de ne insert 
simple extension solves stroke de ciencies rst design things checked statically checked statically 
particular attempt ordset element type ordering provoke error compile time run time 
class embraces collections constraints elements collections termed sequences rst design 
need filter plain filter 
remains possible adaptive representations collections xops class instance xops coll set 
instance declaration clear type set adaptive sets requires element type class xops 
implementation exactly 
notice functor superclasses coll seq instances coll instances monad requires operations polymorphic elements 
particular bulk types polymorphic ones instances monad course giving suitable instance declaration giving possibility monad comprehensions create lter collections 
class hierarchy obvious sequences operations unordered collections 
operations coll apply sequences unordered collections class hierarchy express precisely inheritance want class coll seq snoc foldl reverse quite design decisions 
example want class supports front back supports back front third combines capabilities 
best class seq just de ned 
get element list just ine cient 
cons implying add element front sequences just add element unordered collections coll snoc add element back seq seq subclass coll having neutral insert unordered collections 
similar questions arise fold directional cousins foldr foldl 
collection support union may constant time operation operation 
answers questions obvious collection classes smalltalk provide deal guidance 
example smalltalk collection class hierarchy looks collection bag set dictionary collection interval linkedlist array finite maps finite maps handled exactly described section multi parameter type classes opens intriguing possibility class coll fm extend lookup declares parameter type class fm parameterised type constructor map key type value type 
requires partial application collection type constructor 
collection operations nite maps add new operations extend 
lookup 
advantage approach possible include haskell standard arrays fm nice arrays plainly nite maps instance ix fm array lookup 
course haskell arrays don support extend operations coll change hierarchy class indexable lookup class coll indexable fm extend possible design choices 
summary multi parameter constructor classes just needed clean job bulk types 
done sketch basic idea 
considerable amount design remains concrete design assuming existence multi parameter constructor classes 
related large literature collection types known bulk types 
tannen gives useful bibliography database perspective 
buneman explores algebra expressiveness algebras empty insert empty singleton union 
developed library called standard template library stl specifically aimed collection types stepanov lee 
major di erences described 
collection value combined similar values regarded container new values placed 
equivalent iterators provided specify location container 
handle polymorphism templates collection declared speci es element type comparison operation 
parametric type classes chen hudak odersky similar power multi parameter constructor classes 
chen thesis uses bulk types main motivating example parametric type classes chen 
summary designing suitable signatures bulk types surprisingly tricky 
number di erent kinds collection number possible implementations kind collection unattractive distinct names operations 
furthermore write algorithms algorithms regardless kind collection involved 
rst design proposed exploits type classes obtain substantial amount polymorphism 
algorithms polymorphic elements collection implementation collection nature collection 
apart type classes key design decisions rst sight attractive unify bulk types single class 
propose classes sequences collections 
sequences parametric element type sensitive insertion order reverse holds collections 
solve typing problems collections xops class requiring small amount run time type checking types statically known 
whilst perfect turned advantage allowing programmer design data types choose representation operations available element type 
second design uses multi parameter type classes unify sequences unordered collections single class hierarchy 
noticeably cleaner solution requires sign cant extension haskell 
attractive property designs possibility writing adaptable implementations automatically choose representation operations available underlying data type 
iwould peter buneman laszlo nemeth david watt helpful comments earlier drafts 
mark jones peter thiemann pointed beautiful multi parameter constructor classes bulk types sketched section 
gave particularly useful feedback aspects 
gs okasaki dec optimal purely functional priority queues journal functional programming 
buneman libkin suciu tannen march comprehension syntax sigmod record 
buneman naqvi tannen wong sept principles programming complex objects collection types theoretical computer science 
chen parametric extension haskell type classes phd thesis department computer science yale university 
chen hudak odersky june parametric type classes acm symposium lisp functional programming snowbird acm 
chuang wl hwang may probabilistic approach problem automatic selection data representations proc international conference functional programming philadelphia acm 
pfenning june re nement types ml sigplan symposium programming language design implementation pldi toronto acm 
mp jones jan system constructor classes overloading implicit higher order polymorphism journal functional programming 
may role lazy evaluation amortized data structures proc international conference functional programming philadelphia acm 
oct amortization lazy evaluation persistence lists catenation lazy linking ieee symposium foundations computer science 
stepanov lee dec standard template library hewlett packard laboratories palo alto 
tutorial languages collection types university 
pw trinder aug comprehensions query notation proc rd international workshop database programming languages greece morgan kaufman 
pw trinder pl wadler list comprehensions relational calculus functional programming glasgow workshops computing springer verlag 
pl wadler comprehending monads mathematical structures computer science 

