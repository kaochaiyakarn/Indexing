computer graphics volume number july analytical methods dynamic simulation non penetrating rigid bodies david baraff program computer graphics university ithaca ny method analytically calculating forces systems rigid bodies resting non colliding contact 
systems bodies may motion static equilibrium adjacent bodies may touch multiple points 
analytic formulation forces bodies non colliding contact modified deal colliding bodies 
accordingly improved method analytically calculating forces systems rigid bodies colliding contact 
methods applied systems arbitrary holonomic geometric constraints linked figures 
analytical formulations treat holonomic non holonomic constraints consistent manner 
categories subject descriptors computer graphics computational geometry object modeling computer graphics dimensional graphics realism additional key words phrases dynamics constraints simulation 
focused laws newtonian dynamics simulate motions systems rigid bodies 
realistic simulation rigid bodies demands bodies inter penetrate 
order enforce constraint simulator detect potential inter penetration bodies act prevent bodies penetrating 
keeping laws newtonian dynamics realistic simulation prevent inter penetration arbitrary manner 
simulator calculate forces arise nature bodies inter penetrating forces derive actual motion bodies 
order calculate forces explicit formulation necessary 
traditional techniques engineering physics applicable problem calculating forces bodies resting contact 
techniques assume systems bodies analyzed equilibrium 
simulations computer graphics involve systems bodies equilibrium 
example forces bricks calculated traditional techniques 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 

stack bricks 
focuses specific problem number non colliding rigid polyhedral bodies calculate forces naturally arise prevent bodies 
bodies may constrained satisfy certain geometrical relationships articulated figures 
analytical solution problem uses linear programming techniques formulate heuristically solve system inequality equality constraints forces 
system constraints guarantees contact forces prevent inter penetration satisfy laws newtonian dynamics 
solution generalized yield improved algorithm calculating forces colliding systems rigid polyhedral bodies 

previous analytical methods calculating forces colliding rigid bodies moore wilhelms hahn 
methods calculated impulse single pair bodies collided single point 
moore wilhelms modeled simultaneous collisions slightly staggered series single collisions methods deal bodies resting contact 
hahn prevented bodies resting contact inter penetrating modeling contact series frequently occurring collisions 
model may suitable preventing interpenetration animation applications valid analytical model forces bodies resting contact 
penalty methods introduce restoring forces objects inter penetrate 
platt barr produced highly realistic animations rigid deformable non penetrating bodies 
interpenetration prevented papers introducing arbitrary penalty forces acted separate penetrating bodies natural solution method dynamical correctness forces focus 
moore wilhelms introduced spring forces penalty method prevent bodies resting contact penetrating 
acm oo boston july august penalty methods vs analytical methods analytical methods offer advantages penalty methods 
penalty methods rigid bodies computationally expensive give approximate results may require adjustments different simulation conditions 
spring force heavy 
differing amounts inter penetration penalty method 
undesirable behaviors arise attempt model infinite quantities infinite rigidity bodies infinitely hard surfaces finite values 
particular differential equations arise penalty methods may stiff require excessive number time steps simulation obtain accurate results 
additionally correctness simulation penalty methods difficult verify 
defense penalty methods rigid bodies simple implement easily extendible non rigid bodies 
contrast analytical methods rigid bodies give exact answers produce differential equations require far fewer time steps simulation 
correctness simulation analytical method easily provable analytical solutions directly laws newtonian dynamics 
analytical methods complex derive implement 

simulation analytical methods simulations rigid bodies employing analytical methods treat collision forces resting contact forces differently 
analytically collision forces arc discontinuous impulsive forces exist single instant time dimensions mass times velocity equivalently force times time 
resting contact forces simply contact forces continuous non zero interval time dimensions mass times acceleration 
effects collision forces independent non impulsive forces contact forces gravity 
impulsive forces cause discontinuities body velocity contact forces 
simulator iterates time time steps solving order system coupled ordinary differential equations 
net force torque body differential equations solved yield motion bodies 
adopt usual method solving system differential equations numerical integration procedures fourth order runge kutta adams moulton adaptive time step parameters 
integrator initial conditions form starting orientations positions linear angular velocities bodies 
stated analytical methods introduce discontinuities velocities collisions occur 
unwise integrate collision times 
integrators assume functions integrating continuous functions time 
function integrated discontinuous time integrator integrate restart new initial conditions 
finding time collision occurs viewed root finding problem 
collision time backtracking methods similar described moore wilhelms 
collision time bracketed successively shorter time intervals colliding objects touch suitable tolerance 
collision time calculated integrator stopped collision time collision forces computed 
collision forces may calculated previous methods improved collision method section 
collision forces compute new velocities colliding bodies integrator restarted new initial conditions 
new initial conditions positions orientations time collision newly computed velocities 
call series steps resolving collision 
computation new velocities due collision forces independent contact forces contact forces calculated collisions resolved 
accordingly formulation resting contact problem implicitly assumes bodies contact colliding collisions resolved 

modeling contact terminology 
bodies colliding resting time touch number contact points 
time position arbitrary contact point world space 
define pt positions points satisfy pl 
vertex plane contact side view 
edge edge contact 
contact geometry 
pa ph functions time track motion specific points coincide time 
pa ph vary independent rigid body motions relative motion ph indicates colliding resting separating point time 
contact point contact force possibly zero unit surface normal 
contact body vertex contact point identified body defined outwards unit surface relative displacements inter penetrating bodies implement method results faster convergence simpler bisection method 
tolerance chosen empirically 
computer graphics volume number july normal pb 
edge edge contact body identified body arbitrarily 
defined unit vector mutually perpendicular contacting edges directed away 
absence friction colinear vertex plane vertex edge contacts 
may write ff unknown magnitude contact force 
newton third law force force 
goal calculate contact force magnitudes prevent inter penetration 
degenerate contact points vertex contacts body identified body arbitrarily vertex edge contacts body vertex contact point identified body physically vertex vertex contacts vertex edge contacts indeterminate surface normal defined direction contact force determined 
consequently physically correct behavior may indeterminate interval degenerate contact points occur 
absence degenerate contact points physically correct behavior unique 

indeterminate vertex vertex contact contact side view 
removing indeterminacy choosing contact force direction indeterminate direction chosen 
consistent description vertex plane edge edge contacts set arbitrary unit vector directed away write fn unknown magnitude 
choice degenerate contact points implicitly determines particular behavior usually indeterminate configurations exist instantaneously choice indeterminate configurations little effect simulation 
configuration bodies degenerate contact points calculating correct contact force magnitudes np complete problem 
result follows directly theorem due 
problem remains np complete direction chosen 
solving np complete problems currently requires exponential time considered intractable 
see palmer garey johnson discussion 
np completeness may avoided converting indeterminate contacts determinate contacts 
system imagining locally extended plane normal 
extension converts indeterminate contact vertex plane contact 
henceforth indeterminate contact points assumed resolved manner 
restricting contact points shows regions contact points contacting bodies 
order prevent inter penetration sufficient consider relative motion endpoints vertices system chooses averaging nearby surface normals 
contact region 
contact force assumed zero points marked line segment polygon contact regions shown 
polygonal contact regions motion produced distribution contact forces entire contact region produced equivalent forces acting vertices contact region true line segment contact regions 
interior points contact regions considered contact points 
configuration bodies considered finitely contact points 
number contact points known surface normal unknown force magnitude ith contact point written 
unknown grouped single vector scalar unknowns simplicity shall refer ith element contact force point magnitude contact force 
actual force contact point 

calculating dynamically correct contact forces place exact conditions contact forces wish calculate 
vector contact force magnitudes correct satisfies conditions contact forces allow bodies inter penetrate 
contact forces push pull 
contact forces occur contact points bodies separated contact point force contact point 
viewed function time contact forces continuous 
condition phrased somewhat informally intuitive idea force contact point vary smoothly time time interval successive collisions 
correct vector contact forces produce motion dynamically correct 
note correct may exist configuration 
normally unique solution forces overdetermined structure equations assumption absolute rigidity precludes equations 
correct vectors result dynamically correct motion 
non penetration constraints prevent inter penetration suffices examine relative motions bodies contact point 
time ith contact point position bodies functions pc pb defined section 
characterize geometrical relationship neighborhood time 
define function time indicates time siggraph boston july august separate near touching near inter penetrating near vertex plane contact characteristic function may written zi zi zi zi decreasing time resulting immediate inter penetration 
condition may written 
function locally characterizes vertex plane contacts positive zero negative outside inside ligure 
function may edge edge contacts positive zero negative edge outside inside cases signals inter penetration prevented 
interior ot 
characterization different positions relative time time touch pj xi pj 
signals inter penetration guarantee non decreasing function time equivalently allow relative displacement direction decrease time 
appendix gives derivation 
measures relative velocity direction measure relative acceleration 
contact forces time determine ted independent contact forces exist time 
simulator viewpoint displacement relative velocity time depends contact forces time 
happens zi 
indicates colliding decreasing 
collisions resolved calculating contact forces occur 
conversely zm separating contact point regardless contact forces time 
immediately tn contact point exist contact force condition contact forces vary continuously condition contact force zero time 
contact points may ignored force points zero xi increasing 
wit assume contact points discarded preprocessing step ignore existence 
remaining case 
accelerating interpenetration immediately occur formally characteristic function serves purposes 
possi ble simple correctness proofs methods 
second 
extensible contact higher order surfaces 
third 
allows unified treatment different contact geometries 
calculus continuous function satisfies 
ln practice 
compared zero empirically determined tolerance value 
applies similar numerical comparisons 
corresponding intuition allow accelerate appendix shows relative acceleration hi time linear function contact force dependence clear explicitly write function understanding occurs time 
condition form constraint 
derives constraints point mass resting inclined plane 
refer appendix derivation body rest 
variables contact point force magnitude mass total force gravity vector unit normal relations mg lj cos constraints 
mg di fl 
constraint equations point mass position resting fixed inclined plane derives constraints contact forces block body fixed floor body 
barzel barr derive note acceleration terms absent block rest 
derivations relations goldstein 
matrix formulations conditions preceding section linear function condition may written linear inequality lf condition contact forces push may written inequality conditions written concise matrix notation matrix computer graphics volume number july contact points linear acceleration fl force magnitudes total force mass fib lfl variables body coordinates angular acceleration gravity vector total torque moment inertia relations xf xf pk xr xf constraints xl fil mg mg lf xf xr xf nl 
constraint equations unknown contact force magnitudes block supported fixed floor 
block rest 
vector equation af la comparing left right hand sides componentwise 

xi af bi condition expressed concisely equivalently af 
condition stated 
linear programming finding vector satisfies mx matrix vector minimizes linear function example linear programming problem 
linear programming constraints may mix constraints constraints 
general lower bound form optional 
systems exists satisfy constraints feasible systems vectors means feasible solution 
system 
systems feasible exists minimizes bounded systems optimal solution 
finding feasible necessarily optimal solutions linear programming problem 
satisfies conditions expressed linear programming problem choose subject lhe constraints zy 
linear programming polynomial time problem 
typically sparse linear programs involving expected solution times sparsity exploiting linear programming package 
appendix discusses numerical issues concerning matrix formulating conditions feasible respect equation necessarily correct intuitively satisfies conditions may incorrect solution strong 
correct solution cos 
cos feasible respect equation prevents inter penetration incorrectly accelerating away condition prevent 
recall measure relative acceleration 
ith contact point xi strictly increasing 
assumption separating contact point 
call contact point vanishing contact point call contact points non vanishing contact points 
vanishing contact point time non vanishing contact point time dt 
vanishing contact point lime 
separate point immediately time 
section 
contact force vanishing contact point zero conditions 
condition may formulated statement contact vanishing fi iu non vanishing fi 
constraint needed guarantee correctness equation write constraints form af td df forces term fi summation term equation non negative preventing 

zi non negative correct minimizes sum 
equation written af ra 
siggraph boston july august term quadratic finding correct feasible solution equation example quadratic programming problem 
quadratic programming linear programming np hard problem general 
frictionless contact model turns positive semidefinite psd 
quadratic programs restricted psd matrices theoretically solved polynomial time practical polynomial time algorithms currently known 
reason believe remain psd friction added model 
reasons attempted solve problem finding correct direct methods 
developed successful heuristic algorithm problem 
algorithm heuristic algorithm fail certain pathological examples 

heuristic solution methods determinate configuration bodies physically correct motion correct produces motion 
correct set vanishing contact points configuration unique 
know correct linear programming 
calculating suppose disjoint index sets contact point vanishing 
contact point vanishing 
correct solution je 
ke 
finding correct may phrased choose subject constraints 
constraints new system linear conditions enforced 
condition enforced new system formed original constraint 
non vanishing contact int constraint changed constraint xk equivalent bk 
vanishing contact point set zero constraint retained 
additionally jth column may set zero exploit increased sparsity shows quadratic constraint system contact points linear system formed 
oracle provide set currently unable efficiently determine contact points vanishing 
finding easy configurations 
example try determine vanishing contact points 
frames simulation 
take guess contact points vanishing new linear system test guess 
guess correct new linear system feasible 
feasible solution linear programming routine correct solution 
guess incorrect satisfy new system 
linear programming routine report new system infeasible indicating incorrectness guess 
obvious question guess contact points vanishing 
original system af quadratic new system fl linear lf 
converting quadratic system linear system simplest guess note configuration contains vanishing contact point mathematical sense singular 
mean suggest existence vanishing contact point rare occurrence simulation 
vanishing contact point occurs single instant time contact point transition existence non existence 
contact point vanishing contact point non existent considered 
vanishing contact points dealt isolated instant time 
mind obvious guess set guess contact points vanishing 
linear system constructed choose subject constraints af 
note problem solved standard matrix techniques gaussian elimination inequality solved linear programming problem 
guess correct vast majority cases 
predicting non empty configuration vanishing contact points encountered initial guess results infeasible linear system 
method guessing situation find approximate solution satisfies constraints predict contact points vanishing 
approximate solution define residual vector ai ff 
fact correct solution vanishing contact sa precise statement vanishing contact points occur measure zero 
computer graphics volume number july 
points 
zj non vanishing contact points 
xk 
hope incorrect solution wall residual contact points vanishing contact point guessed vanishing ri 
method section test guess 
finding approximates current heuristic finding approximate solution choose minimize objective function tl subject constraints 
wish find minimum sum force solution satisfies conditions optimal linear programming objective function linear 
hopefully minimizes approximately minimize tt 

approximate correct solution recall minimizer equation correct solution physical intuition choice correct contact forces net chosen little net possible hopefully minimum force solution little net practice residuals formed predictor vanishing contact points consistent formulation linear programming allows equality constraints 
holonomic constraints added system imposing additional linear equality constraints 
elements representing holonomic constraint force added elements subject condition non negativity constraint 
entire system constraints solved section minimum sum force solution takes account non holonomic constraint forces 
justified net done holonomic forces zero holonomic constraint equations satisfied 
contact occurs holonomic constraints remain system equations barzel barr 
sparse linear programming package solve linear system time 
appendix discusses numerical issues involved solving equation 

simultaneous collisions linear programming formulation resting contact improve performance existing collision methods certain configurations 
analytical methods resolving collisions involving multiple contact points bodies impulses contact points calculated applied time impulses calculated applied simultaneously contact points 
call view propagation model collisions simultaneous model collisions papers propagation model collisions 
models collisions single contact point may give give different results multiple contact point collisions 
shows collision equal mass billiard balls loss kinetic energy 
dealing incorrect predictions question vanishing contact points predict correctly 
course test possible guesses contact points different guesses give exponential algorithm 
current implementation exploits fact configurations vanishing contact points occur infrequently 
correct solution approximate obtained minimum sum force solution 

correct contact force adds energy system bodies producing incorrect results 
effect mitigated fact vanishing configurations singular means incorrect applied short time 
shortly applying incorrect simulator reaches configuration correct 
short duration applied coupled fact usually approximate correct solution produces satisfactory results 

additional constraints holonomic constraints express equality constraints bodies articulated figures added nonholonomic inter penetration constraint consistent manner 
barzel barr maintained holonomic constraints introducing constraint forces satisfy linear system af 
propagation cl cl simultaneous 
propagation vs simultaneous collisions 
propagation model results right ball moving away motionless left center balls 
simultaneous model results right center balls moving equal velocity away leftmost ball 
situations models produce result propagation model require excessive number iterations numerically converge 
shows ball mass colliding bali mass resting floor 
collisions totally inelastic propagation method iterates calculating collision impulses balls smaller ball floor 
iterations top ball initial velocity higher mass ratio result slower convergence 
contrast simultaneous model produce limiting result balls rest iteration regardless mass ratio 
siggraph boston july august gv rest ai 
struck pushed away impulse zero 
rest 
convergence behavior propagation model 
indicates collision impulse applied 
calculate collision impulses simultaneous collisions mimic resting contact problem contact point impulse ji ji ti ji unknown magni tude 
goal find satisfies laws classical mechanics final linear angular velocities bodies ultimate goal calculated 
contact point relative approach velocity direction xi section unknown relative recession velocity ni direction linear function 
bodies separating 
bodies resting contact colliding 
coefficient defined single contact collisions iv 
definition readily extend handle simultaneous collisions 
said ci kinetic energy lost collision 
chosen rules simultaneous collisions 
contact point collision required recession velocity occur single contact 
needed body pushed away body third body 
paralleling resting contact problem ji assumed zero exceeds 
routine calculation shows kinetic energy conserved multiple collisions ei single contact point collisions 
linear function ofg constraints written ji ji constraint system form constraints section heuristic methods section solve forg 
note case bodies colliding single point friction system reduces equation unknown 
section contact points discarded bodies separating contact points 
may immediately result round collision resolution excessive iterative behavior occur 
simultaneous collision method enforce holonomic constraints 
holonomic constraints maintained imposing additional linear equality constraints form vi components representing holonomic constraint impulses subject non negativity constraint 
case linked figures colliding single point method equivalent moore wilhelms method system equation third size moore wilhelms 
reduction size system consequence regarding unknown problem final linear angular momenta expressed terms 

analytical method finding forces contacting polyhedral bodies linear programming techniques 
solution algorithm currently heuristic 
generalization formulations yields analytical method finding simultaneous impulsive forces colliding polyhedral bodies 
methods allow holonomic geometric constraints maintained 
simulator constructed variety simulations produced 
major drawback current solution algorithm necessity solving linear systems inequalities 
linear programming software considerably complex software solve systems linear equations software linear equations readily available 
additionally linear equations currently enjoy greater diversity solution techniques linear programming 
major concern heuristic algorithm occasionally fail approximate incorrect solution 
adds energy simulation result unsatisfactory visual effects 
pursued issue error due incorporating incorrect solutions simulator believe premature 
addition friction model render inapplicable 
numerical techniques currently investigation may preclude need heuristic algorithms 
research conducted nsf entitled interactive input display techniques dcr visualization scientific computing asc bell laboratories phd fellowship 
simulation displays performed equipment generously donated hewlett packard digital equipment 
michael cohen preliminary discussions jim cremer talking wrong ideas don greenberg roy hall sound editorial advice encouragement 
computer graphics volume number july appendix derive expressions ph 
ij 
time fi 
fi independent depend linearly linear function 
vertex plane contact fixed 
appendix af purely non holonomic constraint equation af involves singular matrix yielding multiple solutions 
singular physical structure overdetermined chair legs resting floor 
barzel barr note purely holonomic constraint equation af underconstrained overconstrained 
underconstrained systems cases easily handled linear programming methods 
overconstrained systems feasible admit solution handled linear programming methods 
infeasible overconstrained systems require special attention 
note arises holonomic constraint equations 
encountered infeasible systems techniques described barzel barr assemble models 
encounter infeasible constraints assembled models constraints 
barzel barr deal infeasible holonomic constraints selecting squares solution 
find leastsquares solution singular value decomposition svd note exploit sparsity relatively slow 
svd methods nonholonomic constraints maintained 
possibility linear programming find solution minimizes norm opposed norm residual equation choose liar lit ed 
equation convex linear objective function minimization linear programming problem 
purely systems approach faster svd method sparsity exploited linear methods 
complexity relatively performance linear programming methods compared svd methods svd method probably preferable purely holonomic systems 

barzel barr dynamic constraints topics physically modeling course notes vol 
sig graph 

barzel barr modeling system dynamic constraints computer graphics proc 
sig graph vol 
pp 


garey johnson computers intractability 
freeman new york 

mechanics materials wadsworth belmont california 

goldstein classical mechanics addison wesley reading 

golub van loan matrix computations john hopkins university press baltimore 


hahn realistic animation rigid bodies computer graphics proc 
siggraph vol 
pp 


isaacs cohen controlling dynamic simulation kinematic constraints proc 
siggraph vol 
pp 


polynomial solvability convex quadratic programming 
soviet mathematics doklady vol 
pp 


linear programming holt rinehart winston 

macmillan dynamics rigid bodies dover new york 

design xmp linear programming library acm transactions mathematical software vol 
pp 


moore wilhelms collision detection response computer animation computer graphics proc 
siggraph voi 
pp 


murty linear complementarity 
linear nonlinear programming verlag berlin 

palmer computational motion stability polygons phd diss cornell university january 

platt barr constraint methods flexible models computer graphics proc 
siggraph vol 
pp 


gordon computer solution ordinary differential equations initial value problem freeman 

terzopoulos platt barr elastically deformable models computer graphic proc 
sig graph vol 
pp 

boston july august stack bricks 
dominoes 
nl nnn 
destructive chain 
fm chain fixed pivot 
blocks falling chain 
blocks falling chain 

assorted simulations 

