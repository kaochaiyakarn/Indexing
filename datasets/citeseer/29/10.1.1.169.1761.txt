optimization queries user defined predicates surajit chaudhuri microsoft research kyuseok shim bell laboratories relational databases provide ability store user defined functions predicates invoked sql queries 
evaluation user defined predicate relatively expensive traditional method evaluating predicates early possible longer sound heuristic 
previous approaches optimizing queries 
able guarantee optimal plan desired execution space 
efficient techniques able guarantee choice optimal plan desired execution space 
naive optimization algorithm general widely applicable 
optimization algorithm complete rank ordering improves naive optimization algorithm exploiting nature cost formulas join methods polynomial number user defined predicates number relations 
propose pruning rules significantly reduce cost searching execution space naive algorithm optimization algorithm complete rank ordering compromising optimality 
propose conservative local heuristic simpler low optimization overhead 
guaranteed find optimal plans produces close optimal plans cases 
discuss depending application requirements determine algorithm choice 
emphasized optimization algorithms handle user defined selections user defined join predicates uniformly 
complexity analysis experimental comparison algorithms 
categories subject descriptors information systems database management general terms algorithms management performance additional key words phrases query optimization dynamic programming userdefined predicates authors addresses chaudhuri microsoft research microsoft way redmond wa shim bell laboratories mountain murray hill nj 
permission digital hard copy part personal classroom granted fee provided copies distributed profit commercial advantage copyright notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
acm acm transactions database systems vol 
june pages 
chaudhuri shim 
order efficiently support complex database applications major relational database vendors support user defined functions 
functions invoked sql queries making easier developers implement applications significantly greater efficiency 
extensions task execution engine optimizer challenging 
particular user defined functions clause sql predicates henceforth called user defined expensive predicates treated sql built predicates 
evaluation built sql predicates evaluation predicates may involve substantial cpu cost 
cases traditional heuristic evaluating predicates early possible may result significantly suboptimal plans example demonstrates 
consider problem identifying potential customers mail order distribution 
mail order wants ensure customer high credit rating age group resides san francisco bay area purchased worth goods year 
query join person sales relation user defined functions zone high credit rating 
select group name street address zip person sales high credit rating ss age zone zip bay area person name sales buyer name name street address zip having sum sales amount assume user defined predicate high credit rating expensive 
case may evaluate predicate join fewer tuples invoke expensive predicate 
predicate selective better execute high credit rating cost join reduced 
example illustrates traditional heuristic evaluating predicates early possible inappropriate context queries user defined predicates 
known approaches optimizing queries treat user defined predicates special way 
spj query technique ldl treats user defined predicate relation see section exponential number user defined predicates 
technique fails consider class traditional plans user defined predicates evaluated early possible 
second technique known predicate acm transactions database systems vol 
june 
optimization queries user defined predicates migration hellerstein stonebraker polynomial number user defined predicates spj query takes consideration traditional execution space 
algorithm guarantee finding optimal plan situations may need exhaustively enumerate space join ordering 
shows commercial optimizers system style dynamic programming algorithm selinger extended easily optimize queries user defined predicates guarantee optimality plan 
algorithm guarantee optimal evaluation queries user defined predicates assumptions cost model follows principle optimality cormen 
complexity algorithm exponential number user defined predicates 
show broad assumptions cost formulas join methods satisfied common join methods reduce complexity algorithm polynomial number user defined predicates 
required proving nontrivial result assumptions cost model placement predicates execution tree follow rank ordering see section user defined predicates 
discovered powerful pruning techniques reduce search space optimizer compromising optimal 
optimization algorithms guarantee optimality plans satisfactory performance large class queries complexity grows monotonically increasing query size 
explore computationally inexpensive heuristics viable alternatives 
conservative local heuristic little overhead traditional optimizers 
able guarantee optimality chosen plan cases experimental results show typically chooses execution plan close optimal 
heuristic serves excellent alternative query size complexity optimization algorithm concern 
techniques provide optimization algorithms queries containing user defined selections join predicates 
rest term user defined predicate expensive predicate generically refer user defined predicate occurs selection join predicate 
contrast reserve term join predicate refer traditional join predicates queries 
implemented optimization algorithms extending system style optimizer 
worst case complexity analysis experimental results illustrate characteristics optimization algorithms proposed 
rest organized follows 
section cost model execution space traditional framework extensions needed handle user defined predicates selections complexity exponential number joins 
expected traditional join optimization problem np hard 
acm transactions database systems vol 
june 
chaudhuri shim join predicates query optimization 
section review system optimization algorithm selinger basis commercial optimizers 
describe desired execution space review past optimizing queries user defined predicates 
sections optimization algorithms find optimal plan 
section provide complexity analysis algorithms 
pruning techniques extensions optimization algorithms incorporate techniques section 
section presents conservative local heuristic simpler produces nearly optimal plan 
performance results implementation details section 
optimization framework consider select project join queries containing userdefined predicates 
assume clause query consists conjunction built user defined predicates 
techniques extend queries general form 
commercial database management systems adopted framework system optimizer selinger optimization 
framework studying problem optimization queries userdefined predicates 
describe traditional optimization framework cost model execution space explain need extend framework user defined predicates 
traditional framework describe traditional optimization framework spj queries 
execution plan query represented syntactically annotated join tree internal node join operation leaf node scan base relation 
edges tree indicate flow data 
annotations provide details selection predicates choice access paths join methods projection attributes result relation 
set execution plans query considered optimizer execution space query 
cost function determine cost execution plan execution space 
task optimizer choose plan minimal cost execution space 
optimizers commercial database systems restrict search plan subset space annotated join trees 
example execution space may restricted linear join trees 
linear join tree represents execution linear sequence joins 
internal join node child nodes leaf base relation 
join multiple relations represented linear sequence way joins 
contrast bushy join tree operands join nodes may intermediate computed relation 
traditional optimization framework concerned handling conditions clause inexpensive built predicates 
assumed cost evaluating built predicates zero acm transactions database systems vol 
june 
optimization queries user defined predicates conditions evaluated eager fashion 
selectivity associated condition estimate effect applying predicate relation 
assumption commonly traditional query optimization independence conditions predicates selectivity selectivity selectivity 
assumed problem query optimization satisfies principle optimality cormen 
principle optimality forms basis dynamic programming query optimization algorithms commercial optimizers 
words linear join trees optimal plan join relations obtained extending optimal plan subset size relations cardinality noted subplans represent join set relations differ physical properties sort order compared optimal plans physical properties need extended guarantee optimality final plan compromised 
optimization algorithms dynamic programming need estimate sizes intermediate relations choose alternative execution plans 
optimizer estimates size relation represented node execution tree sizes children nodes execution tree 
example compute sizes intermediate relations estimated sizes estimated sizes past optimization need assume cost model consistent sizes resulting relations execution trees result relation estimated 
extensions user defined predicates built predicates associate tuple cost evaluation user defined predicate 
words relation tuples cost evaluating user defined predicate relation rcp cp tuple cost evaluating predicate case built predicates assume user defined predicate selectivity user defined real number sp associated 
applying user defined predicate assumed reduce size relation rsp 
cost model uniformly user defined selections join predicates 
user defined predicate characterized selectivity cost tuple parameter 
case built predicates assumption user defined predicate independent condition clause 
discuss cost tuple parameter estimated see discussion hellerstein 
naturally user defined predicate evaluated intermediate relation contain columns acm transactions database systems vol 
june 
chaudhuri shim fig 

examples unconstrained linear join trees 
predicate defined 
example user defined predicate form predicate may evaluated join taken 
conditions built predicates assumed zero cost predicates evaluated earliest 
user defined predicate associated cost need consider placement user defined predicates execution tree cost way 
consider choice execution space join ordering 
choice natural extension user defined predicates execution space consider placing user defined predicate number including zero joins long placed user defined predicate evaluable point placement 
example user defined selection condition placed immediately scan relation applies number joins scan 
likewise user defined secondary join predicate placed immediately evaluable necessary joins number subsequent joins 
words consider unconstrained placement user defined predicates 
traditional optimization continue restrict join ordering linear 
case refer execution space unconstrained linear join trees 
execution space studied hellerstein stonebraker hellerstein formally defined 
definition unconstrained linear join tree execution tree sequence operators form linear sequence tree user defined predicate may placed sequence provided evaluable point evaluation 
alternatively consider join execution space consisting bushy trees extend similar way user defined predicates 
case refer execution space unconstrained bushy join trees unconstrained join trees 
example shows examples unconstrained linear join trees execution plans query relations user defined selection predicates applicable applicable 
acm transactions database systems vol 
june 
optimization queries user defined predicates fig 

system algorithm linear join trees 

previous approaches section review basics system optimization algorithm 
discuss approaches proposed optimizing queries user defined predicates 
results contain results chaudhuri shim discuss section 
system dynamic programming algorithm adopted ganguly illustrates system dynamic programming algorithm finds optimal plan space linear left deep join trees selinger 
input algorithm select project join spj query relations rn 
function extends plan plan result joined base relation best possible way 
function cost returns cost plan cost function assigns real number plan execution space chosen satisfies principle optimality cormen 
optimization algorithm chooses plan cost execution space 
algorithm proceeds building optimal execution plans increasingly larger subsets set relations join 
order build optimal plan set relations optimal plan subset consisting relations extended invoking cheapest extended plans chosen 
approach guarantees optimal optimization problem satisfies principle optimality optimal plan set relations extension optimal plan subset set 
optimal plans subsets stored array reused recomputed 
algorithm expose important details system optimization algorithm 
selection conditions secondary join acm transactions database systems vol 
june 
chaudhuri shim fig 

system algorithm bushy join trees 
predicates evaluated early possible 
selections relations evaluated join evaluated 
algorithm considers interesting orders 
consider plan uses sort merge join costs plan uses hash join 
cheaper plan sort order may reduce cost plan extends extension may optimal plan sort order reused subsequent join 
system algorithm saves single plan multiple optimal plans subset distinct order termed interesting order selinger 
upper bound number optimal linear join subplans stored query join tables number subsets tables times number interesting orders 
enumeration complexity algorithm 
optimization algorithm space bushy join trees similar algorithm inputs join operator intermediate result 
dynamic programming algorithm space bushy join trees shown 
upper bound number optimal subplans stored query joins tables times number interesting orders 
corresponding enumeration complexity 
ldl approach approach user defined predicate treated relation point view optimization 
approach ldl project mcc subsequently papyrus project hp laboratories chaudhuri shim 
viewing expensive predicates relations advantage system style dynamic programming algorithm enumerating joins expensive predicates 
expensive predicate acm transactions database systems vol 
june 
optimization queries user defined predicates relations extended join enumeration algorithm treat optimization problem ordering dynamic programming algorithm 
approach suffers drawbacks stemming problem generalizing viewing expensive predicate relation 
restrict search linear join trees algorithm consider plans space unconstrained linear execution trees see section definition 
particular algorithm fails consider plans evaluate expensive predicates operands join prior join hellerstein 
example consider spj query join relations having user defined predicates defined respectively 
ldl algorithm treats expensive predicates relations alike consider linear join sequences joins selections 
plan applies takes join relations linear sequence selections joins 
ldl algorithm may produce plans significantly worse plans produced traditional optimization algorithm selections evaluated early possible 
furthermore optimization algorithm exponential number relations number expensive predicates 
look case linear join trees considered execution 
order optimize query consists join relations expensive predicates dynamic programming algorithm need construct optimal subplans 
words cost optimizing query relations expensive predicates high optimizing relations 
show cases exploit properties join methods achieve algorithm polynomial number user defined predicates number relations bounded 
predicate migration approach optimizing queries user defined predicates components 
discuss predicate migration algorithm linear join tree chooses way interleaving join user defined predicates 
describe predicate migration algorithm integrated system style optimizer 
additional details refer reader hellerstein stonebraker hellerstein 
predicate migration algorithm takes input join tree annotated join method join node access method scan node set expensive predicates 
algorithm places user defined predicates optimal position relative join nodes plan considered enumeration extended space bushy joins significantly expensive linear join space 
acm transactions database systems vol 
june 
chaudhuri shim see discussion shortcomings 
algorithm assumes join costs linear sizes operands 
allows assign rank join predicates addition assigning ranks expensive predicates 
notion rank studied previously monma sidney krishnamurthy 
having assigned ranks algorithm iterates stream stream path leaf root execution tree 
iteration potentially rearranges placement expensive selections 
iteration continues streams modified operator tree changes 
shown hellerstein stonebraker convergence occurs polynomial number steps number joins user defined predicates 
discuss algorithm integrated system style optimizer 
steps dynamic programming algorithm followed optimal plan subexpression generated change 
join step option evaluating predicates applicable considered query optimal subplan optimal subplan cost cost algorithm continues step traditional join enumeration 
effect application user defined predicate deferred plan pruned compromising optimal 
contrast plan cheaper predicate migration algorithm needs extend 
note possible discard plan doing may compromise optimal plan 
example possible cheaper optimal placement query succeeds join plan optimal 
predicate migration approach plan cheaper step enumerating plans extend treated separately dynamic programming optimization algorithm 
particular predicate migration algorithm marked plan 
remaining steps dynamic programming algorithm plans ignored 
dynamic programming algorithm terminates plan extended exhaustive enumeration possible ways extending plan considered 
completion plan expensive operation 
contrast approach necessary treat plans separately integrated dynamic programming algorithm seamless fashion 
predicate migration algorithm improves ldl approach important ways 
considers space unconstrained linear trees finding plan considers pushing selections operands join restricting space join ordering linear join trees 
algorithm polynomial number user defined predicates 
unfortunately approach optimization serious drawbacks limit applicability 
algorithm guarantee optimal acm transactions database systems vol 
june 
optimization queries user defined predicates plan uses heuristic estimate rank join predicates influence choice plan 
predicate migration algorithm may force estimations cardinality relations determining rank inaccurate 
migration algorithm requires join predicate assigned rank depends cost join function input sizes relations 
unfortunately input sizes join depend user defined predicates evaluated 
predicate migration algorithm cyclic dependency estimating results joins assuming user defined predicates pushed 
ad hoc assumption sacrifices guarantee optimality see section hellerstein detailed discussion 
predicate migration algorithm satisfy principle dynamic programming difficult integration system style optimization algorithm 
cases algorithm may require exhaustive enumeration 
example consider query relations single user defined selection relation 
assume database traditional plan predicate evaluated prior join optimal plan 
case plans marked 
plans 
distinct join orderings join orderings number join methods 
optimization process may require exhaustive enumeration join space 

naive optimization algorithm discussion previous section shows known approaches guaranteed find optimal plan space unconstrained linear join trees 
section optimization algorithm guaranteed produce optimal plan execution space 
best knowledge algorithm provides guarantee optimality 
techniques section adaptable join execution spaces bushy joins 
algorithm addresses shortcomings predicate migration algorithm sacrificing benefit considering execution space unconstrained linear join trees 
notational convenience indicate ordering operators plan nested algebraic expressions 
example designate plan apply selection relation join relation joining relation reduced application selection condition 
note need necessarily base tables may query expressions 
describing rest section assume traditional interesting orders assumption ease exposition 
acm transactions database systems vol 
june 
chaudhuri shim key observations principles key enumeration algorithm equivalent plan pruning 
strength traditional optimization algorithm join enumeration ability compare costs different plans represent subexpression evaluated different orders 
selection join operations may prune plans queries expensive predicates joins plans represent select project join subexpressions query physical properties cost cost may pruned 
example compare costs plans plan plan 
selection ordering 
consider conjunction set expensive selection predicates applied relation query en expensive predicates 
problem ordering evaluation predicates selection ordering problem 
complexity selection ordering different ordering joins set relations 
known traditional cost models problem np hard 
hand selection ordering problem solved polynomial time assumed cost model user defined predicates 
furthermore ordering selections depend size relation apply 
problem selection ordering addressed hellerstein stonebraker cf krishnamurthy monma sidney whang krishnamurthy 
utilizes notion rank 
rank predicate ratio cost tuple selectivity 
theorem consider query optimal ordering predicates order ascending ranks independent size example consider predicates selectivities costs 
predicate selective rank rank 
evaluation precede technique selection ordering extended broader classes boolean expressions 
particular selection conditions form pure disjunction dual theorem applies predicates ordered ascending values hand selection ordering problem intractable selection conditions arbitrarily complex 
efficient heuristics general case proposed kemper 
ability order predicates ranks called rank order ing key property exploited 
leverage property section note theorem allow acm transactions database systems vol 
june 
optimization queries user defined predicates order user defined predicates joins 
section show relative order ranks predicates exploited joins lead optimization algorithm complete rank ordering 
tags exploiting properties plan representation properties concept extends idea interesting orders selinger addressed graefe dewitt lee graefe mckenna 
properties help describe intermediate result plan 
properties include tables projected columns sort order tuples set predicates applied 
query optimizer keeps single cheapest plan distinct set properties optimization 
traditional optimization algorithms process selection predicates early possible 
order address problem optimizing queries user defined predicates exploit understood notion properties incorporating information application user defined predicate part properties plan 
keep multiple plans represent join set relations differ sets user defined predicates evaluated 
plan record property set evaluated userdefined predicates applicable plan records complement applicable set predicates evaluated plan 
rest refer property tag plan 
course representation tag combined representation properties interesting orders 
definition states formally associate tag unconstrained join tree 
definition unconstrained linear join tree consists join set relations evaluation set user defined predicates set user defined predicates query evaluated subexpression query consists join relations 
tag associated tree ordered set predicates sorted rank order 
example illustrates execution plans subplans need considered relations expensive selection predicates 
possible plans differing tags 
plans 
tags respectively 
unconstrained join trees represent expression iff tag consist join set relations 
notice plans represent join set relations agree tags compared pruned 
acm transactions database systems vol 
june 
chaudhuri shim fig 

search space naive optimization algorithm 
algorithm section naive optimization algorithm widely applicable assumptions nature cost formulas satisfies principle optimality 
algorithm exploits notion tags demonstrates traditional notion properties applied problem optimizing queries user defined predicates produce general solution independent assumptions cost model 
equivalent plan pruning rule allows compare plans represent expression 
observation enables dynamic programming integrates system algorithm 
addition naive optimization algorithm uses result theorem tells ordering user defined predicates relation constrained rank order joins 
optimization algorithm introduces key idea exploiting tags 
section improved algorithm foundational ideas crucial 
algorithm section exploits key ideas aggressively takes full advantage rank ordering joins 
naive optimization algorithm space unconstrained linear join trees shown 
determining access methods choice join methods algorithm behaves exactly traditional acm transactions database systems vol 
june 
optimization queries user defined predicates fig 

naive optimization algorithm linear join trees 
algorithm 
data structure stores plans need retained optimizer steps 
subset relation sj distinct tag optimal plan may need stored 
optimal plan sj tag invoked extend optimal plan sj 
observe takes arguments sets user defined predicates applied plan sj relation rj respectively rank order prior join 
assume tag applicable user defined predicates base relation rj set applicable user defined selections 
function invoked distinct subset predicates invocations 
section show broad assumptions join costs sharply reduce overhead invocations 
choices algorithm uniquely determine tag plan set sorted rank order set additional user defined predicates evaluable due join sj rj 
note theorem assumes sequence user defined predicates applied intervening joins set predicates predicates applied rank order sacrificing optimality 
algorithm described array indexed tag function tag returns tag plan plan acm transactions database systems vol 
june 
chaudhuri shim compared plans set relations stored tag 
expensive plan tag plan pruned iteration combination 
plan added 
final join consider plans relations 
plans may need completed adding step evaluate remainder predicates 
function computes completion cost plan cheapest set completed plans chosen 
store best plan subset user defined predicates distinct set relations total number stored plans distinct set relations increases number plans need stored increases number user defined predicates 
consider example 
tag respectively distinguish keep single plan 
naive optimization algorithm general assumptions cost model 
wide applicability 
complexity algorithm exponential number user defined predicates number relations query shown section 
section show rank ordering user defined predicates may exploited conjunction realistic assumptions cost model develop algorithm polynomial number user defined predicates number relations query 

optimization algorithms complete rank ordering complexity enumeration naive optimization algorithm exponential number user defined predicates 
algorithm rank ordering theorem order execution predicates applied prior application operators 
turns exploit rank ordering irrespective predicates separated join nodes optimization algorithm polynomial number user defined predicates number relations 
section show long join implementations follow assumption regular join defined exploit rank ordering user defined predicates separated join nodes 
provide definition regular join methods section justify definition reflects cost popular join methods practice 
section show join operators follow assumption regular joins restrict enumeration execution trees predicates ordered rank order 
key result immediately leads new algorithm polynomial number user defined predicates section 
results section robust extend execution trees acm transactions database systems vol 
june 
optimization queries user defined predicates containing operators addition join long dependence operators input relation size follows definition 
regular join methods addition magnitude relation sizes cost join method depends variety system parameters prefetching techniques specific algorithms existing indexes 
set system parameters definition captures order dependence join methods input relations large class implementations definition join method called regular cost joining relations sizes depends sizes relations follows br cr dr constants independent sizes relations 
important subtlety definition value factors may depend system parameters available indexes global constants 
particular join node execution tree may different value parameters 
lends significant generality definition 
explain large number join methods satisfy constraints join methods assumed definition regular joins 
furthermore remainder represent cost joins terms cost 
approximation cost predominantly commercial optimizers 
furthermore components cpu costs joins fits form regular join 
consider costs nested loop merge scan hash joins shapiro demonstrate follow assumption regular join 
detailed cost formulas common join methods shim 
note cost writing result join disk depends size result join form sj join selectivity 
cost element fits form regular joins ignore rest discussion 
nested loop join index cost formula buffer size available hold inner relation 
wi tuple width relation ri page size bytes 
number pages occupied relation ri 
available buffer join cost 
block nested join methods cost available buffer size 
join cost formulas nested loop joins indexed inner relation consistent definition 
nested loop join indexed inner relation cost scanning inner relation tuple outer relation replaced cost probing acm transactions database systems vol 
june 
chaudhuri shim index typically constant number page accesses 
cost formula case cost probing index 
observe degenerate form regular join cost formula 
sort merge hash joins cost formula shapiro fits form join cost assuming large buffers 
example simple estimate sorting costs relation terms times cost scanning base table iw merge cost equivalent scanning relations resulting estimate consistent form regular join cost formulas 
similar comments apply cost formulas hash join shapiro 
decreasing costs memory large buffer assumption realistic operating assumption 
note cost formulas regular joins generalize assumption linear cost model hellerstein stonebraker hellerstein 
corresponds special case definition coefficient 
predicate ordering join tree selection ordering rule theorem applies predicates applied relation intervening join nodes 
section powerful generalization selection ordering rule 
show join tree placement user defined predicates violate rank order execution tree execution tree equal cost sequence predicate applications follows rank ordering 
refer execution trees rank ordered defined definition user defined predicates unconstrained execution tree rank ordered user defined predicates rank rank precedes tree orp evaluable tree obtained exchanging positions 
example consider execution plans subplans need considered relations expensive selection predicates 
assume rank rank 
user defined predicates rank ordered 
predicates rank ordered 
theorem central result section asserts sufficient restrict plans correspond rank ordered trees 
prove result contradiction 
assuming execution tree rank ordered call spoiler cost strictly lower trees 
pick set rank ordered trees equivalent syntactically similar exploit syntactic similarity derive constraint costs rank ordered trees spoiler tree 
acm transactions database systems vol 
june 
optimization queries user defined predicates fig 

plans correctness proof 
acm transactions database systems vol 
june 
chaudhuri shim fig 

definitions 
show join operators assumed satisfy constraint regular joins constraint satisfied 
formal proof 
theorem unconstrained execution tree regular join methods exist equivalent unconstrained execution tree cost cost user defined predicates rank ordered 
proof 
prove result contradiction 
contradiction occur number user defined predicates execution tree 
furthermore case cost equivalent rank ordered trees strictly higher 
words unconstrained execution tree user defined predicates rank rank precedes 
user defined predicate evaluable tree obtained exchanging relative positions 
joins separating applications 
cost strictly lower cost equivalent unconstrained rank ordered execution tree 
observe condition true applied intervening joins selection ordering rule theorem implies selections order rank 
unconstrained violation rank order occur predicates separated joins 
exploit condition derive constraint relative costs alternative execution trees 
specifically consider additional execu acm transactions database systems vol 
june 
optimization queries user defined predicates table ci si ri definition parameters correctness proof cost predicate pi tuple selectivity predicate pi number tuples relation ri cost execution tree size output execution tree tion trees equivalent 
shows execution trees including 
execution tree corresponds positioning just execution tree 
tree positions exchanged 
observe theorem follows cost cost 
execution tree tree obtained moving position immediately preceding obtained exchanging positions 
theorem follows cost cost 
encircled query expression single input relation identifies common subexpression execution trees 
refer subexpression parameter refers input relation 
instances common expression different input relations depicted 
identities evident rest proof denote denote 
note relation sizes bear obvious relationship 
relate execution trees 
particular correspondences hold acm transactions database systems vol 
june 
chaudhuri shim estimate costs execution trees parameters defined table notation designate cost size output relation resulting execution trees cost model consistent see section follows 
furthermore 
observe execution trees rank ordered 
assumption cost strictly cost trees 
relationships derive contradiction 
definition cost 

cost assumption cost cost cost 
note cost 
eq 
conclude note cost cost 
estimate cost eqs 
conclude cost follows eqs rest proof shows joins follow constraint regular joins eq 
true 
cost evaluating tree sum costs joins costs applying user defined predicates 
represent cost expression sum components cost evaluating expensive predicates expression denote costs pu sum costs 
assumed cost model user defined predicates pu constant cu cost applying user defined predicate tuple cost cu hu size relation preceding application th application user defined predicate 
cost evaluating join nodes expression ancestors denote cost jv sum costs 
note join binary operation input acm transactions database systems vol 
june 
optimization queries user defined predicates dependent input relation join 
furthermore assumed cost model join methods regular 
assume vm vq vm assumed sizes input relations th join depends input relation far reflecting dependence cost join simplify vm cost evaluating operators affected input relation denote cost apply costing framework instances establish relationship 
rewriting cost components distinguishing respective cost components superscripts lv lv lv difference application predicate 
order estimate mv note cost formula consistent assume size mv predicate applied operator applied predicate applied just th join executed 
method note mv likewise pu extend approach compute arrive equalities mv pu conclude vm eq 
conclude 
words rank rank violates assumption 
comments generality result proof extremely robust explain discussing generalizations 
execution space observe proof assumption structure execution space 
proof technique simply exploits fact violation theorem occur exist nonempty sequence join nodes application predicates 
observation independent assumptions space unconstrained join trees linear acm transactions database systems vol 
june 
chaudhuri shim 
result uniformly applicable linear bushy join trees 
expensive join predicates theorem assumption structure predicates uniformly applicable user defined predicates 
consequences 
theorem applicable user defined predicates may involve columns multiple tables 
specifically note assume execution trees base relation 
represents relation resulting execution subtree parent node 
expensive predicate columns multiple relations subtree include join needed relations admissible execution tree 
cost model user defined predicate constant tuple cost 
internal structure userdefined predicate irrelevant long assumption constant tuple cost appropriate 
example argued hellerstein complex subqueries fit cost model cases 
example user defined predicates disjunctions 
cases may possible associate tuple cost conjunct boolean expression translated conjunctive normal form 
operators join unconstrained join trees consist user defined predicates join trees operators execution tree 
result robust binary unary operators satisfy syntactic condition specified definition regular joins 
proof exploits specific syntactic dependence jj sizes input relations 
relationship results hellerstein explained earlier hellerstein approach hellerstein suffers cyclic dependency compromises correctness approach 
approach requires assign priori rank traditional equijoin predicate rank compared user defined selection join predicates 
unfortunately computation rank traditional equijoin predicate depends sizes input relations turn depends user defined predicates applied prior computing join 
cyclic dependency successfully avoided approach 
theorem ranks user defined predicates need assigned algorithm able correctly order user defined predicates respect traditional join predicates dynamic programming algorithm 
property joins follow constraints regular joins implies executions user defined predicates follow order rank ensure optimality 
need assign rank traditional equijoin predicates hellerstein encounter cyclic dependency 
definition regular join strictly generalizes linearity assumption join cost formula hellerstein 
acm transactions database systems vol 
june 
optimization queries user defined predicates fig 

optimization algorithm rank ordering linear join trees 
algorithm algorithm refer optimization algorithm complete rank ordering shown 
assumes joins follow assumptions regularity 
join methods regular theorem enables restrict sequence user defined predicates may applied reduces complexity enumeration exponential polynomial number user defined predicates 
particular user defined predicates applied rank order intervening joins 
algorithm iteratively considers possibilities corresponds applying predicates predicates sj rj respectively ordered rank change algorithm naive optimization algorithm 

complexity study complexity algorithms terms parameters 
number subplans stored provides measure space requirement optimization 
number enumerations measure reflects time complexity optimization algo acm transactions database systems vol 
june 
chaudhuri shim table ii 
definition parameters complexity proof total number relations number relations user defined selection predicates applicable number pairs relations having user defined join predicates total number user defined predicates maximum number user defined selections applicable relation number user defined join predicates pair relations sum rithms 
define parameter counting number calls step extends existing subplan join create plan larger subquery query 
introduce input parameters complexity analysis 
assume relations 
user defined predicate selection join predicate 
assume relations user defined selections defined types selection predicates 
likewise characterize type user defined join predicate relations predicate defined 
assume types user defined join predicates total number types user defined predicates denote total number user defined predicates 
assume denotes maximum number user defined predicates selection join type 
table ii summarizes parameters 
example consider query represents join relations user defined selections secondary user defined join predicate 
number relations query relations user defined predicates 
furthermore 
number subplans stored section examine number subplans stored naive optimization optimization algorithm complete theorem total number subplans need stored naive optimization algorithm proof 
naive optimization algorithm potentially creates subplan subset relations joined subset userdefined predicates query 
relations user defined predicates total number plans acm transactions database systems vol 
june 
optimization queries user defined predicates contrast optimization algorithm complete rank ordering need store subplans subset user defined predicates 
defining upper bound number distinct tags may need considered optimization complete rank ordering 
lemma number distinct tags stored distinct set relations plan table proof 
distinct set relations partition user defined predicates sets 
user defined predicates belong partition 
application predicates follow order rank 
partition possibilities 
altogether partitions distinct tags altogether 
theorem total number subplans need stored optimization algorithm complete rank ordering query user defined selection predicates user defined join predicates proof 
store distinct plan corresponding join distinct set relations distinct set user defined selections 
userdefined selections apply relations apply joined 
determine number ways relations user defined selections joined user defined selections applied 
pick relations may picked ways 
join relations tags lemma 
number ways pick relations user defined selections consider possible ways pick relations set remaining relations user defined selections 
achieved ways 
upper bound total number plans need stored equals formula derive upper bound queries user defined selection pred acm transactions database systems vol 
june 
chaudhuri shim 
upper bound polynomial exponential number relations query traditional join enumeration 
analysis shows complexity sensitive number relations user defined predicates number predicates may apply single relation 
complexity grows exponentially number relations user defined selection predicates occur increase number tags exponentially 
contrast complexity grows polynomially increase number user defined predicates bounded number relations query occur 
example user defined predicates selections apply relation number plans need stored theorem presents complexity optimization algorithm complete rank ordering query user defined join predicates 
theorem total number subplans need stored optimization algorithm complete rank ordering query user defined selections join predicates proof 
proof similar theorem 
set relations number distinct plans differ tags replacing corresponding expression theorem get upper bound nonnegative integers formula derive upperbound upper bound polynomial number enumerations complexities enumeration left deep join space bushy join space traditional system style optimizer known respectively number relations query 
study complexities enumeration naive optimization algorithm optimization algorithm complete rank ordering linear bushy join trees 
proofs theorems section appendix 
linear join trees theorem total number enumerations space unconstrained linear join trees naive optimization algorithm acm transactions database systems vol 
june 
optimization queries user defined predicates theorem reflects fact restrict execution space linear join trees consider placement user defined predicates base relations intermediate relations 
explains dependence dependence see section 
turn optimization algorithm complete rank ordering show naive optimization algorithm complexity optimization algorithm complete rank ordering polynomial number user defined predicates bound number relations 
providing estimate number enumerations crude intuitive way 
multiplying maximum values factors obtain rough estimate multiplier number enumerations traditional algorithm total number enumerations algorithm approximately description maximum value factor specified inside parentheses 
number tags outer relation number tags inner relation linear join trees bushy join trees number evaluable predicates outer relation number evaluable predicates inner relation linear join trees bushy join trees 
complexity optimization algorithm complete space unconstrained linear join trees approximately times traditional algorithm 
similar crude estimate bushy join space results multiplier theorems provide enumeration complexities optimization algorithm complete rank ordering 
theorem total number enumerations space unconstrained linear join trees optimization algorithm complete rank ordering user defined selections 
user defined selections upper bound polynomial particular user defined selections apply relation complexity 
extension technique optimization algorithm unconstrained linear join trees guarantees complexity enumeration polynomial theorem total number enumerations space unconstrained linear join trees optimization algorithm complete acm transactions database systems vol 
june 
chaudhuri shim rank ordering may user defined selections join predicates gw 
applications expect number expensive userdefined predicates query fewer number joins desirable ensure cost join enumeration increase sharply due presence user defined predicates 
predicate migration algorithm approach able ensure property 
bushy join trees analyze complexity execution space unconstrained bushy execution trees 
idea tags general restricted unconstrained linear trees 
consider step joining unconstrained bushy join trees 
assume predicates applicable respectively order increasing rank 
arguments unconstrained linear trees possibilities pushing selections respectively resulting plans joining trees 
enumerating application user defined predicates join relations unconstrained bushy execution trees similar unconstrained linear execution trees 
turn complexities optimization algorithm complete rank ordering space unconstrained bushy join trees 
show upper bound polynomial theorem total number enumerations unconstrained bushy join trees optimization algorithm complete rank ordering user defined selections theorem total number enumerations searching space unconstrained bushy join trees optimization algorithm complete rank ordering may user defined selections join predicates 
optimization algorithm pruning naive optimization algorithm algorithm rank ordering compare plans tags 
section pruning techniques allow compare prune plans different tags 
pruning techniques sound guaranteed compromise optimality chosen plan 
results section assume queries spj queries 
show pruning techniques integrated optimization algorithm complete rank ordering naive optimization algorithm 
key observations drive soundness strategies application user defined predicate effect increasing size acm transactions database systems vol 
june 
optimization queries user defined predicates input relation application user defined predicate alters physical properties input data stream deferring evaluation user defined predicate locally worse choice globally optimal plan compromised choosing defer evaluation user defined predicate 
udp pushdown rule rule says cost evaluating selections prior join cost join selections applied cost join having applied selections push selections 
example cost cost prune 
optimization algorithm complete rank ordering keep different tags different numbers expensive predicates applied 
definition plan query extension plan occurs subtree definition plan equivalent plan represent plans expression 
lemma represent subplans conjunctive query plan plan cost cost plan extension plan exists equivalent plan extends expensive 
proof 
unconstrained linear join trees prove result contradiction 
proof technique extends plans unconstrained bushy join trees 
extension plan lemma violated 
particular sequence operators extend ai bj operator 
denote cost additional operators 
equality holds cost cost 
consider plan extends sequence operators denote cost additional operators queries conjunctive size output size output 
follows ai cost ai size input relation larger cost selection projection join monotonic sizes input relations 
case operator bi cost execution trees 
follows 
cost cost 
completes proof 
strictly speaking lemma compare plans interesting order 
acm transactions database systems vol 
june 
chaudhuri shim refer lemma udp pushdown rule udp abbreviation user defined predicate 
corollary rule set expensive predicates applied pruned plan set relations cost cost set expensive predicates applied prior join superset 
plans set relations easily check examining tags 
corollary states formally 
corollary conjunctive query 
partial plans set relations tags subset cost cost plan extension plan exists equivalent plan extends expensive 
proof 
argument similar lemma 
key observations size output equal cost cost cost plan conjunctive query monotonic size input relations number operators extension strictly number operators plan set plans corollary allows prune denoted 
example consider plans represent join 
assume applicable applicable 
furthermore assume rank order predicates 
cost plan tag lower tag udp pushdown rule prune plan 
udp rule rule says locally deferring evaluation predicate leads cheaper plan plan evaluates user defined predicate join defer evaluation predicate compromising optimality plan 
example cost plan extending evaluation cost prune 
naive optimization algorithm optimization algorithm complete rank ordering keep different tags different numbers predicates applied plans 
lemma represent subplans conjunctive query represent plans respectively 
cost cost plan extension plan exists equivalent plan extends expensive 
acm transactions database systems vol 
june 
optimization queries user defined predicates proof 
consider plan extends plan sequence operators 
construct new plan extending sequence operators equivalent extending 
cost cost follows cost cost 
refer udp rule plan lemma corresponds case predicate pulled 
generalize consequences rule 
consider plans set relations different tags 
tag subset predicates evaluated evaluated 
diff represent set predicates evaluated proof technique lemma conclude corollary conjunctive query 
partial plans tags set relations superset 
plan obtained applying predicates diff cost plan extension plan exists equivalent plan extends expensive 
construct set plans may prune refer set 
example illustrates corollary 
consider example change cost plan tag higher cost plan tag 
notice tag subset tag 
set diff 
case lemma allows prune plan cost plan added cost evaluating set predicates join cost note pruning strategies udp pushdown rule udp rule applicable execution trees bushy 
algorithm exploits pruning strategies udp pushdown rule conclude optimal plan expensive optimal plan extension plan find extension expensive 
words udp pushdown rule provides sufficient condition predicate pushed need consider plans pulled past joins 
results reducing number plans set relations distinct tags need considered iterations dynamic programming optimization algorithm sacrificing optimality 
scenario udp pushdown rule extremely acm transactions database systems vol 
june 
chaudhuri shim fig 

optimization algorithm pruning linear join trees 
effective user defined predicates relatively cheap built predicates sql 
cases udp pushdown rule effective pin selections soon evaluable helps avoid constructing plans predicates pulled 
similar comments apply effectiveness udp rule 
udp rule allows conclude optimal plan evaluates prior join expensive plan evaluated immediately join need consider extensions plan 
pruning rule helps avoid generating alternative plans push user defined predicates suboptimal 
example consider case user defined predicates expensive join operations decrease cardinality relation 
case optimal plan corresponds case user defined predicates follow evaluation joins 
case udp rule help avoid unnecessary enumeration plans push predicates 
describes optimization algorithm augments naive optimization algorithm complete rank ordering pruning strategies 
choices rank ordering uniquely determines tag acm transactions database systems vol 
june 
optimization queries user defined predicates plan 
plan compared plans set relations stored 
plan pruned iteration steps combination conditions holds expensive plan tag set plans empty udp rule prune predicate addtotable true plan added 
new plan prune plans currently 
algorithm designated set pruned plans 
may stored plan tag exists expensive set plans plans may pruned udp pushdown rule 

conservative local heuristic optimization algorithms propose require tags maintained plans 
potentially subset relations query optimal subplan may need stored distinct tag 
section conservative local heuristic provides simpler alternative implementation 
technique require tags maintained 
incorporating heuristic existing system style optimizer easier 
incorporating heuristic increases number subplans need optimized query factor compared traditional optimization independent number user defined predicates query 
number important cases algorithm guarantees generation optimal execution plan 
conservative local heuristic best described explaining pull rank heuristic proposed inadequate generating plans acceptable quality hellerstein 
pull rank maintains plan set relations 
join step choice set predicates pushed pull rank algorithm estimates sum costs call completion cost components cost evaluating expensive predicates pushed step ii cost join iii cost evaluating remainder user defined functions evaluable join deferred past join 
pull rank chooses plan minimum completion cost 
algorithm greedily pushes predicates 
example pull rank decides evaluating predicate join cheaper evaluating predicate immediately evaluation precede final plan pull rank consider plans evaluated pull rank fails explore plans deferring evaluation predicates past joins significantly better choosing acm transactions database systems vol 
june 
chaudhuri shim fig 

optimization algorithm conservative local heuristic linear join trees 
greedily push predicates local comparison completion costs 
conservative local heuristic guards shortcoming pull rank heuristic retaining intermediate plans different tags set relations 
contrast pull rank heuristic keeps plan set relations 
plans picked conservative local heuristic pull rank 
additional plan set relations considered conservative local heuristic evaluation remaining applicable user defined predicates deferred 
plan compared variants push rule applied plan cheaper cost retained 
conservative local heuristic choose plans result application sequence udp rules 
plans picked conservative local heuristic complement heuristic guard choice poor plan resulting greedily pushing predicate pull rank algorithm 
conservative local heuristic find optimal plans pull rank global heuristics fail acm transactions database systems vol 
june 
optimization queries user defined predicates fig 

search space rank ordering conservative local heuristic 
find due greedy approach incurs low computational overhead 
illustrated example 
example consider query 
assume plan optimal 
note global heuristic pushes pulls selections find optimal plan 
plan cheaper pull rank greedily pushes fails obtain optimal 
algorithm conservative local heuristic uses plan join step obtain optimal 
example followed pushdown optimal algorithm able find 
example example search space explored conservative local heuristic shown 
illustrates parts execution plans need considered query relations expensive selection predicates 
plan additional plan stored conservative local heuristic 
storing plan additionally enumerated 
implement conservative local heuristic traditional system algorithm pick additional plan addition plan picked pull rank join step sum costs components cost evaluating expensive predicates pushed step cost join 
refer sum costs pushdown join cost 
assuming deferred acm transactions database systems vol 
june 
chaudhuri shim predicates evaluated free cost evaluating remaining evaluable predicates zero 
words plans chosen metric favor deferring predicates evaluation predicates helps reduce cost current join 
conservative local heuristic picks plans completion cost pushdown join cost possible consider plan predicate deferred past plan pushed prior chosen pull rank possible candidates optimal plan 
optimization algorithm complete rank ordering conservative local heuristic space unconstrained linear join trees shown 
algorithm works similarly traditional optimization algorithms keep plans 
optimization algorithm complete rank ordering keep plan distinct tag conservative local heuristic retains plans plans minimum pushdown join cost minimum completion cost respectively represented variables push complete algorithm 
final join consider plans stored relations 
case optimization algorithm complete rank ordering plan may need completed adding step evaluate remainder predicates 
cheapest plans chosen 
join subset relations plans stored conservative local heuristic need consider storing plans 
algorithm number subplans need optimized grow increasing number user defined predicates 
conservative local heuristic may optimal plan optimization algorithm complete rank ordering distinctions tags algorithm 
experimental results section indicate quality plan close optimal plan 
furthermore lemma states conservative local heuristic produces optimal plan important special cases 
lemma conservative local heuristic produces optimal execution plan conditions true query single join query single user defined predicate optimal plan corresponds case user defined predicates evaluated soon possible 
proof 
heuristic strict extension pull rank follow property pull rank 
predicate step heuristic considers plans defer push selection 
guarantees optimality case 
way view result case values tags possible heuristic able guarantee optimality 
acm transactions database systems vol 
june 
theorem total number plans enumerated optimization algorithm conservative local heuristic space unconstrained linear join trees may user defined selections join predicates gw 

performance evaluation assess effectiveness optimization algorithms implemented algorithms proposed extending system style optimizer 
section results doing performance evaluations implementations 
particular establish pruning strategies proposed significantly improve performance optimization algorithm complete rank ordering plans generated traditional optimization algorithm suffer poor quality plans generated pull rank algorithm better expensive plans generated traditional optimizer significantly worse optimal conservative local heuristic reduces optimization overhead significantly generates plans close optimal 
experimental framework optimization queries user defined predicates experimental framework similar ioannidis kang chaudhuri shim 
performed experiments sun ultra machine mb ram running solaris 
algorithms run queries consisting 
experiments randomly generated relation catalog relation cardinalities ranged tuples numbers unique values join columns varied corresponding relation cardinality 
selectivities expensive predicates randomly chosen cost tuple expensive predicates represented number page accesses selected randomly 
query generated projection attributes 
page relation assumed contain tuples 
relation attributes clustered 
relation physically sorted clustered attribute ab tree hashing primary index attribute 
alternatives equally 
attributes probability secondary index choice tree hashing secondary index uniformly random 
considered nested loop merge scan simple hybrid hash joins join methods shapiro 
experiments cost number page accesses accounted 
experiments generated join join relations queries join queries join queries 
acm transactions database systems vol 
june 
chaudhuri shim performed sets experiments 
set varied number user defined selection predicates apply relation 
second set varied distribution user defined selection predicates multiple relations query kept number selection predicates fixed varied predicates distributed relations query 
extreme user defined selections applied relation extreme equally distributed relations query 
sets experiments described section section respectively 
candidate algorithms query instance ran optimization algorithms 
plans needed stored enumerated due interesting orders taken consideration reporting results 
traditional algorithm system style optimization algorithm evaluates expensive predicates early possible 
pull rank algorithm algorithm introduced hellerstein considers possible placement expensive predicates locally immediately preceding immediately join picks cheapest plan 
opt rank algorithm optimization algorithm section uses rank ordering 
compares plans tag set relations 
opt rank pruning algorithm extension opt rank algorithm incorporates pruning strategies described section 
opt rank conservative algorithm algorithm uses conservative local heuristic complete rank ordering illustrated section 
experiment effect number user defined predicates experimented see optimization algorithms behave increased number user defined selection predicates 
set experiments number user defined predicates varied 
shows number enumerated plans quality plans generated algorithm 
results data point represents average queries 
queries generated randomly choosing relation user defined predicates apply randomly picking cost selectivities predicates 
number enumerations 
shows average number enumerated plans opt rank algorithm approximately linear number grows rate slower worst case complexity determined section 
join queries relations table iii shows factor worst case complexity enumeration grows acm transactions database systems vol 
june 
optimization queries user defined predicates table iii 
worst case estimates enumerated plans number user defined predicates multiplicative factor opt rank compared number enumerations traditional optimizer 
enumerations necessary case independent number user defined predicates 
results obtained queries fewer joins show similar trend 
comparison performances opt rank algorithm pruning algorithm shows proposed pruning techniques extremely effective 
algorithms guaranteed generate optimal plans gap number enumerated plans opt rank algorithm opt rank pruning algorithm increases significantly number user defined predicates grows 
user defined predicates applied opt rank algorithm generated times plans opt rank pruning algorithm 
pull rank algorithm considers locally possible cases applying user defined predicates 
number enumerated plans slightly traditional optimizer 
expected number enumerations pull rank algorithm smaller opt rank conservative algorithm 
discussed quality plans generated pull rank algorithm significantly worse 
quality plans 
compare relative costs plans generated algorithm 
cost plan generated opt rank pruning algorithm scaled relative cost plotted log scale 
opt rank opt rank pruning algorithms generate optimal plans represents cost plans generated algorithms 
results show quality plan generated traditional optimizer suffers significantly board 
quality plans generated pull rank algorithm gets worse number expensive predicates increases 
noted section pull rank fails explore plans deferring evaluation predicates past joins significantly better choosing greedily push predicates local comparison completion costs 
examined plans considered pull rank algorithm discovered number plans generated user defined predicates applied earlier compared placement corresponding optimal plans increased gradually increased number applicable user defined predicates 
hand opt rank conservative algorithm chooses plans identical close difference optimal 
borne fact graphs heuristic algorithms producing optimal plans practically indistinguishable 
note opt rank pruning algorithm opt algorithm number expensive predicates 
acm transactions database systems vol 
june 
chaudhuri shim fig 

performance varying number user defined predicates 
algorithms pick plan userdefined predicate 
acm transactions database systems vol 
june 
optimization queries user defined predicates table iv 
worst case estimates enumerated plans number relations udf multiplicative factor opt rank experiment effect distribution predicates experiment varied distribution predicates 
quantitatively define distribution fraction relations query applicable user defined predicates 
experiment section assumed predicates evenly distributed relations applicable user defined predicates 
results experiments shown 
number enumerations 
compared traditional algorithm number plans enumerated opt rank conservative algorithm modestly higher 
opt rank conservative algorithm stores plans subquery plan table interesting order 
graphs clearly demonstrate savings opt rank conservative algorithm respect opt rank algorithm significant distributions 
set experiments indicates number plans enumerated opt rank algorithm increases value number relations user defined predicates downward trend begins 
value occurs nearly independent number relations query 
explain observations complexity analysis section 
theorem provides upper bound number plans enumerated opt rank 
upper bound stated theorem notation section function table iv shows worst case estimate number enumerated plans join queries user defined predicates userdefined predicates distributed multiple relations 
relation having user defined predicates number user defined predicates results unique upper bound theorem represented table iv 
table observe expensive predicates applied relation join queries times enumerated plans traditional optimizer 
distribute expensive predicates relations times enumerations generated traditional optimizer 

table iv records worst case upper bound cases 
table apparent worst case upper bound number enumerated plan peaks takes downward turn 
graphs shown average number enumerations random queries complexity directly explain experiment 
experi acm transactions database systems vol 
june 
chaudhuri shim fig 

performance varying distributions user defined predicates 
mental results show trend similar table iv 
trend explained analytically 
leading dependence theorem factor set experiments acm transactions database systems vol 
june 
optimization queries user defined predicates effect factor intuitively grasped analyzing expression assuming upper bound factor 
expression viewed continuous function maxima decreases increased 
experimental result demonstrates variation respect quality plans 
expected results show quality plans generated traditional optimizer continues suffer significantly various distributions user defined predicates comparison quality plans generated opt rank pruning opt rank conservative algorithms 
different distributions opt rank conservative produced plans cost worse opt rank demonstrates robustness heuristic 
contrast pull rank algorithm generated plans expensive generated opt rank conservative algorithm 
justifies algorithmic changes pull rank incorporated opt rank conservative 
graphs indicate distribute user defined predicates relations relative cost plans generated pull rank algorithm decreases slightly 
examined plans obtained pull rank algorithm experiment observed number plans generated user defined predicates applied earlier execution plan comparison application optimal plans reduced increase number relations user defined predicates 
effect increasing number relations user defined predicates effectively reduce number userdefined selections applicable relation 
resulted fewer number alternative plans considered pull rank 
probability pull rank picks plan optimal near optimal increased 

growing popularity object relational database systems problem optimizing queries user defined predicates increasingly important 
user defined predicates query may join selection predicates 
algorithms find optimal plans conjunctive queries user defined predicates 
algorithms extend traditional system style optimization algorithms commercial optimizers 
naive optimization algorithm guarantees optimal plan 
optimization algorithm complete rank ordering demonstrates exploiting special structure cost models find optimal plan time polynomial number user defined predicates query bound number relations 
result depends novel nontrivial proof shows placement user defined predicates linear sequence joins respect rank ordering 
pruning techniques significantly reduce cost searching execution space compromising optimality naive algorithms optimization algorithm complete rank ordering 
described acm transactions database systems vol 
june 
chaudhuri shim efficient conservative local heuristic algorithm 
heuristic guarantee generation optimal plan cases guarantee optimal important cases experimental results show plans generated indistinguishable close optimal 
optimization algorithm complete rank ordering natural choice guarantee optimality desirable cost formulas respect conditions regular joins 
results indicate conservative local heuristic efficient excellent choice suboptimality may tolerated 
naive optimization algorithm suboptimality tolerated assumptions cost model optimization algorithm complete rank ordering acceptable 
note pruning techniques described section circumstances simply speed search plan sacrificing optimality 
described algorithms conjunctive queries algorithms need extended cases spj query complex boolean expression clause 
preprocessing step convert clause conjunctive normal form longer needs atomic independent 
necessary derive costs selectivities take account dependence 
showed optimization algorithm complete rank ordering guarantees optimal common join implementations open problem result extends general cost models 
appendix proofs theorems 
theorem 
consider number plan enumerations proof 
needed outer relation join relations relations user defined predicates defined remaining relations user defined predicates 
note notation table ii prior joining outer relation inner user defined predicates evaluable executed 
user defined predicates number tags size furthermore tag size enumerations corresponds evaluating subset evaluable user defined predicates 
choice outer choice set user defined predicates applied outer choose inner set user defined predicates applied inner relation prior join 
inner relation chosen relations relation user defined predicates consider application predicates inner relations 
maximum acm transactions database systems vol 
june 
optimization queries user defined predicates number user defined predicates applicable relation number enumerations due evaluation user defined selections inner relation inner relation chosen relations user defined predicates predicates may apply inner relation 
outer relation distinct number enumerations join inner relation 
determine upper bound total number enumerations summing 
term considers case expression outer relation relation user defined predicate 
second term considers case outer relation user defined predicate defined 
proof 
theorem 
idea proof similar theorem 
distinct set relations size relations chosen designated relations user defined selections defined relations selected remaining relations user defined predicates distinct tags possible complete rank ordering 
acm transactions database systems vol 
june 
chaudhuri shim furthermore evaluable predicates outer relations applied rank order 
outer relation evaluable user defined predicate distinct tag need enumerations number evaluable predicates inner relation chosen relations consider application predicates inner relation prior join 
enumerations due evaluation user defined predicates prior join 
note relation expression outer relation chosen relations user defined predicate apply user defined predicate outer relation 
similarly apply user defined selection predicate inner relation inner relation chosen relations userdefined predicate 
factor expression corresponds case 
number enumerations upper bounded el gw gw proof 
theorem 
proof similar theorem 
user defined join predicates computation number distinct tags needs modified 
table ii observe number relations having selection predicates number pairs relations having user defined join predicates 
acm transactions database systems vol 
june 
upper bound number distinct tags associated plan optimization obtain upper bound number enumerations replacing earlier proof el gw gw gw gw proof 
theorem 
formulation similar proof unconstrained linear join trees 
inner relation bushy join may consist joins multiple relations number enumerations due application user defined predicates inner relation prior join longer bounded bounded case outer relation 
outer inner relations relation user defined predicate number enumerations due application user defined predicates prior join outer inner index subplan parameters relation chosen relations relation chosen relations user defined predicates applied 
number possible plans inner relations user defined predicates applicable 
corresponds case relations contribute inner relation chosen relations 
number plans inner relations applicable predicates upper bound total number possible plans representing inner relation 
number enumerations upper bounded eb optimization queries user defined predicates acm transactions database systems vol 
june 
chaudhuri shim proof 
theorem 
proof similar theorem 
user defined join predicates computation number distinct tags needs modified 
upper bound number distinct tags associated plan optimization see table ii 
able obtain upper bound number enumerations replacing theorem 
eb proof 
theorem 
proof similar proof theorem store plans corresponding join distinct set relations 
upper bound number distinct tags associated plan 
replace proof theorem 
number enumerations upper bounded ec gw gw gw gw acm transactions database systems vol 
june 
optimization queries user defined predicates acknowledgments indebted joe hellerstein giving detailed feedback draft 
anonymous referees constructive comments helped improve draft 
support chaudhuri shim impossible complete 
chaudhuri shim 
query optimization presence foreign functions 
proceedings th international conference large data bases vldb dublin ireland aug 
morgan kaufmann publishers san francisco ca 
chaudhuri shim 
including group query optimization 
proceedings th international conference large data bases vldb santiago chile sept 
vldb endowment berkeley ca 
chaudhuri shim 
optimization user defined predicates 
proceedings nd international conference large data bases vldb mumbai india sept 
krishnamurthy 
open architecture ldl 
proceedings th international conference large data bases vldb amsterdam netherlands aug van de ed 
morgan kaufmann publishers san francisco ca 
cormen leiserson rivest 
algorithms 
mit press cambridge ma 
ganguly hasan krishnamurthy 
query optimization parallel execution 
proceedings acm sigmod international conference management data sigmod san diego ca june stonebraker ed 
acm press new york ny 
graefe dewitt 
exodus optimizer generator 
proceedings acm sigmod annual conference management data sigmod san francisco ca may dayal ed 
acm press new york ny 
graefe mckenna 
volcano optimizer generator extensibility efficient search 
proceedings th international conference data engineering vienna austria apr 
ieee computer society washington dc 
hellerstein 
practical predicate placement 
proceedings acm sigmod international conference management data sigmod minneapolis mn may snodgrass winslett eds 
acm press new york ny 
hellerstein 
optimization execution techniques queries expensive methods 
ph dissertation 
university wisconsin madison madison wi 
hellerstein stonebraker 
predicate migration optimizing queries expensive predicates 
proceedings acm sigmod international conference management data sigmod washington dc may buneman jajodia eds 
acm press new york ny 
ioannidis kang 
randomized algorithms optimizing large join queries 
proceedings acm sigmod international conference management data sigmod atlantic city nj may garcia molina ed 
acm press new york ny 
kemper 
optimizing boolean expressions object bases 
proceedings th international conference large data bases vancouver aug 
vldb endowment berkeley ca 
krishnamurthy boral zaniolo 
optimization nonrecursive queries 
proceedings th international conference large data bases kyoto japan aug 
vldb endowment berkeley ca 
lee freytag lohman 
implementing interpreter functional rules query optimizer 
proceedings th international conference acm transactions database systems vol 
june 
chaudhuri shim large data bases los angeles ca 
morgan kaufmann publishers san francisco ca 
monma sidney 
sequencing series parallel precedence constraints 
math 
oper 
res 

selinger astrahan lorie price 
access path selection relational database management system 
proceedings acm sigmod international conference management data sigmod boston ma may june 
acm press new york ny 
shapiro 
join processing database systems large main memories 
acm trans 
database syst 
sept 
shim 
advanced query optimization techniques relational database systems 
ph dissertation 
university maryland college park college park md whang 
krishnamurthy 
query optimization memory resident domain relational calculus database system 
acm trans 
database syst 
mar 
received february revised february accepted may acm transactions database systems vol 
june 
