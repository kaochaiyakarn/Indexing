brics basic research computer science brics rs behrmann minimum cost reachability priced timed automata minimum cost reachability priced timed automata gerd behrmann thomas kim larsen paul pettersson vaandrager brics report series rs issn january copyright gerd behrmann thomas kim larsen paul pettersson vaandrager 
brics department computer science university aarhus 
rights reserved 
reproduction part permitted educational research condition copyright notice included copy 
see back inner page list brics report series publications 
copies may obtained contacting brics department computer science university aarhus ny munkegade building dk aarhus denmark telephone telefax internet brics brics dk brics publications general accessible world wide web anonymous ftp urls www brics dk ftp ftp brics dk document subdirectory rs minimum cost reachability priced timed automata gerd behrmann thomas kim larsen paul pettersson vaandrager basic research computer science aalborg university mail behrmann cs auc dk 
basic research computer science aarhus university mail brics dk 
computing science institute university nijmegen mail cs kun nl 
department computer systems information technology uppsala university mail docs uu se 

introduces model linearly priced timed automata extension timed automata prices transitions locations 
model consider minimum cost reachability problem linearly priced timed automaton target state determine minimum cost executions initial state target state 
problem generalizes minimum time reachability problem ordinary timed automata 
prove decidability problem offering algorithmic solution combination branch bound techniques new notion priced regions 
allows symbolic representation manipulation reachable states cost reaching 
keywords timed automata verification data structures algorithms optimization 
real time verification tools uppaal kronos hytech applied synthesize feasible solutions static jobshop scheduling problems 
basic common idea works reformulate static scheduling problem reachability problem solved verification tools 
approach timed automata modeling languages verification tools serve basic input language partially supported european community esprit ltr project vhs verification hybrid systems 
research supported netherlands organization scientific research nwo contract sion 
research partly sponsored ait project ist 
scheduling problem described 
modeling languages proven particularly suited respect allow easy flexible modeling systems consisting parallel components interact time critical manner constrain behavior multitude ways 
introduce model linearly priced timed automata offer algorithmic solution problem determining minimum cost reaching designated set target states 
result generalizes previous results computation minimum time reachability accumulated delays timed automata viewed laying theoretical foundation algorithmic treatments general optimization problems encountered static scheduling problems 
example consider simple static scheduling problem represented timed automaton fig 
contains tasks 
tasks performed precisely task performed 
order tasks timed automaton task commence task finished 
addition timed automaton specifies timing requirements satisfied delay start execution task start execution time units delay start execution start time unit delay start start time units requirements represented clock model 
standard timed model checker able verify location fig 

timed automata model scheduling example 
timed automaton reachable 
demonstrated trace leading location trace may viewed feasible solution original static scheduling problem 
optimization problem satisfied arbitrary feasible solution insist solutions optimal sense 
modeling problem timed automata quadruple vx vy vz denotes state automaton control location vx vy vz give values clocks transitions labelled actual transitions model transitions labelled represents delay time units 
fig 

linearly priced timed automaton 
obvious notion optimality minimum accumulated time 
timed automaton fig 
trace accumulated time duration 
optimal witnessed alternative trace exploiting looping transition reaches total time units algorithmic solutions minimum time reachability problem general problem controller synthesis backward fix point computation :10.1.1.43.6815
alternative solution forward reachability analysis algorithmic solution offered applies branch bound techniques prune parts symbolic state space guaranteed contain optimal solutions 
particular introducing additional clock accumulating time elapses minimum time reachability problem may dealt existing efficient data structures dbms real time verification tools uppaal kronos reachability 
results extends provides algorithm computing accumulated delay timed automata :10.1.1.29.8500
provide basis dealing general optimization problems 
particular introduce model linearly priced timed automata extension timed automata prices transitions locations price transition gives cost price location specifies cost time unit staying location 
model capture passage time way tasks different prices time unit contributes total cost 
gives linearly priced extension timed automaton fig 

price location set price locations set simply accumulating time 
price looping transition set transitions free cost price 
costs traces respectively cheaper exploit looping transition 
costs traces case immaterial looping fact minimum time reaching transition taken 
fact optimal cost reaching general minimum optimal trace include looping transition depending particular values 
deal problem determining minimum cost reaching location linearly priced timed automata 
particular offer algorithmic solution problem contrast minimum time reachability timed automata minimum cost reachability problem linearly priced timed automata requires development new data structures symbolic representation manipulation reachable sets states cost reaching 
put forward data structure priced extension fundamental notion clock regions timed automata 
remainder structured follows section formally introduces model linearly priced timed automata semantics 
section develops notion priced clock regions number useful operations 
priced clock regions section give symbolic semantics capturing sufficiently precisely cost executions basis algorithm solution minimum cost problem 
section give concluding remarks 
linearly priced timed automata section introduce model linearly priced timed automata extension timed automata prices locations transitions 
dually linearly priced timed automata may seen special type linear hybrid automata automata accumulation prices cost represented single continuous variable 
contrast known undecidability results classes reachability computable linearly priced timed automata 
intuitive explanation additional cost variable influence behavior automata 
finite set clocks 
set formulas obtained conjunctions atomic constraints form natural number called clock constraints note timed automaton constraints form exists strongly bisimilar timed automaton constraints form results applicable automata having constraints type cas 
definition linearly priced timed automaton 
linearly priced timed automaton lpta clocks actions act tuple finite set locations initial location act lis set edges assigns invariants locations settling open problem :10.1.1.43.6815
fig 

example lpta 
prices locations edges 
case formally clock values represented functions called clock assignments non negative reals 
set clock assignments ranged define operation assignment ifx rand operation assignment clock valuation satisfies clock constraint ifu atomic constraint nin notice set clock valuations satisfying guard convex set 
semantics lpta defined transition system statespace initial state assigns zero clocks transition relation ifu exists andp 
note transitions decorated labels delay quantity action cost particular transition 
determining cost price location gives cost rate staying location time unit price transition gives cost transition 
remainder states executions transition system lpta referred states executions definition cost 
pn un finite execution lpta cost pi 
minimal cost reaching mincost infimum costs finite executions 
similarly minimal cost reaching location infimum costs finite executions state form 
mincost inf cost run location example 
consider lpta fig 

lpta single clock locations transitions decorated guards prices 
sample execution lpta instance cost execution 
fact executions cost arbitrarily close value obtainable avoiding delaying location delaying just long location due infimum definition mincost follows mincost 
note strict comparison guard second transition execution achieves cost 
priced clock regions ordinary timed automata key decidability results valuable notion region 
particular regions provide finite partitioning uncountable set clock valuations stable respect various operations needed exploration behavior timed automata particular operations delay reset 
setting linearly priced timed automata put forward new extended notion priced region 
providing finite partitioning set clock valuations case ordinary regions priced regions associate costs individual clock valuation region 
shall see priced regions may manipulated symbolic manner suitable algorithmic basis 
definition priced regions 
set set finite sequences elements clock region finite set clocks rk cl element seq seq ri ri rj andi implies ri 
clock valuation region rk ck iff 
agree integer part clock 
iff frac 
ri frac frac 
ri rj frac frac 
priced region rk ck components triple constitute ordinary region rk 
naturals ck costs associated vertices closure region follows 
start left lower vertex exterior region associate cost move time unit direction set rk vertex exterior associate cost vertex move unit direction rk inthis way costs ck span linear cost plane dimensional region 
closure region convex hull vertices 
clock valuation unique convex combination vertices 
cost defined convex combination cost vertices 
gives definition definition cost inside regions 
priced region rk ck clock valuation defined cost frac xk ci ci xj clock rj 
minimal cost associated mincost min ck 
fig 

dimensional priced region 
symbolic state space constructed priced regions costs computed concrete state symbolic state cost associated minimal cost reaching state symbolic path followed 
way minimal cost concrete paths represented symbolic path may symbolic paths leading symbolic state costs different 
note cost clock valuation region computed adding fractions costs equivalence sets clocks clock 
prepare symbolic semantics define number operations priced regions 
operations ones algorithm finding optimal cost reaching location 
delay operation computes time successor works exactly classical regions 
changing dimensions regions cause addition deletion vertices associated cost 
price linear expression ai 
fig 

delay reset operations dimensional priced regions 
argument instantiated price location time passing needed vertex added 
cases operation illustrated fig 
left 
definition delay 
priced region rk ck price function delay defined follows 
empty 
empty delay rk ck delay rk rk ck incremented clocks rk resetting clock priced region may lose dimension 
costs associated vertices collapsed compared minimum taken new vertex 
cases operation illustrated fig 
right 
definition reset 
priced region rk ck clock ri function reset defined follows 
reset rk ck set zero 
ri reset ri rk ck set zero 
ri reset ri ri rk ck ck ck min ck ck set zero reset operation set clocks reset reset reset reset price argument increment operation instantiated price particular transition taken costs updated accordingly 
definition increment 
priced region rk ck price increment respect priced region rk ci region clock fractional part time may pass clock valuation time successor predecessor changing location choose clock valuation delaying previous location reached followed change location changing location immediately delaying new location 
depends price location 
operation self useful 
definition self 
priced region rk ck function self defined follows 
empty self 
empty self rk ck min ck definition comparison 
priced regions may compared versions equal rk ck iff ri ci operations delay self satisfy useful properties proposition interaction properties 

self 
self self self 
delay self delay 
self delay delay 
self self 
delay delay 
self proof 
directly definitions operators 
stated terms cost cost individual clock valuation priced region symbolic operations behave follows proposition cost relations 

rk ck 
ifu rand cost cost ck 

self delay cost delay cost 
cost reset inf cost 
proof 
directly definitions operators cost 
symbolic semantics algorithm section provide symbolic semantics linearly priced timed automata notion priced regions associated operations previous section 
main result shown cost execution underlying automaton captured sufficiently accurately 
algorithm priced regions 
definition symbolic semantics 
symbolic semantics lpta defined transition system states seq seq initial state assigns zero integer part clocks transition relation delay delay 
exists reset 
self remainder states executions symbolic transition system lpta referred symbolic states executions lemma 
lpta execution ends state symbolic execution ends symbolic state cost 
proof 
proof observe prove induction length 
suppose ends state 
base step concerns length consisting initial state valuation assigning zero clocks 
clearly cost 
initial state symbolic semantics state assigns zero integer part clocks fractional part clocks zero take 
clearly valuation valuation assigns zero clocks exactly definition cost trivially 
induction step assume 
execution concrete semantics corresponding execution symbolic semantics cost 
suppose 
transition automaton andp 
implies reset easy show 
cost inf cost cost ih cost cost suppose 
exist sequences ro rm dm price regions delays dm ri delay ri dk ri 
defines sequence regions considering cost 
obtain priced regions optimal cost apply self operation 
self delay infact fori self due proposition ri 
clearly symbolic extension proposition condition proposition satisfied proposition cost cost cost ih cost cost lemma 
reachable symbolic state mincost cost 
proof 
proof induction length symbolic trace reaching 
base case length initial price region associates clocks 
clearly valuation valuation assigns clocks 
obviously mincost cost 
induction step assume reached trace length greater 
particular immediate predecessor 
consider cases depending type symbolic transition 
case suppose symbolic delay transition 
delay andr 
consider sub cases depending self delayable assume self delayable 

frac 
mincost induction hypothesis mincost cost cost cost obtain desired mincost cost 
assume self delayable 

frac ud clearly ud ud 
mincost mincost ud ih cost ud cost cost ud clear cost ud cost particular cost ud cost 
mincost cost desired 
case suppose symbolic action transition 
reset transition automaton 
clearly 
mincost inf mincost ih inf cost cost proposition case suppose symbolic self delay transition 
particular ifr lemma follows immediately applying induction hypothesis 
self delayable identical cost vertex rk ck ck rk ck ck 

clearly ud ud ud 
mincost mincost ud ih cost ud priced region rk ck self delayable 
ii fig 

reachable sets priced regions 
rk ck 
delay andr delay ck 
cost ud cost uu ck converges cost uu 
cost ud cost uu cost 
desired mincost cost 
combining lemmas obtain main theorem symbolic semantics captures sufficiently accurately cost reaching states locations theorem 
location lpta mincost min mincost reachable example 
return linearly priced timed automaton fig 
value look symbolic state space 
shaded area fig 
including lines shaded area represents reachable priced regions location time passed number delay actions taken 
priced regions integer values shown 
numbers cost vertices 
shaded area fig 
ii represents similar way reachable priced regions location time passed 
elaborate explanation reachable state space refer appendix 
priced regions provides step algorithmic solution minimum cost reachability problem 
form integral part cost vertices priced regions may grow bound symbolic exploration 
case growth integral parts dealt suitable abstractions regions maximal constant timed automaton account 
chosen similar approach exploiting fact lpta may transformed equivalent bounded lpta sense reaches locations exact cost 
theorem 
lpta maximal constant max 
exists bounded time equivalent satis fying 
reachable max 
location reachable cost reachable cost proof 
construct follows 
maxa maxa cx maxa 

definition satisfies requirement 
second requirement 
relation states iff maxa maxa 
show state reached cost state reached cost versa 
states respectively induction length execution leading 
base step length execution 
trivially cost execution initial states clearly transition steps observe clock iff maxa 
assume reached cost case distinction 
case suppose 
order time pass alternatingly perform added transition reset clocks reached maxa bound times needed bit time pass 
dm sequence delays dm cand di maxa di di frac di 
easy see pi dm pm di 
cost reaching isc pa dm cost reaching 

maxa maxa reset maxa transitions case maxa reset transitions maxa maxa maxa 
maxa maxa 
maxa touched transitions leading dm 
maxa may reset transitions leading 
maxa maxa sou maxa 
dm maxa 
case suppose 
trivially show 
implies ia observation follows ia trivially cost reaching isc pa cost reaching 
case suppose 
corresponding edge 
pa 
definition pa 
observation implies easy see andu combining observation ia implies 
clearly cost reaching isc pa cost reaching 
case suppose 
corresponding edge 
ea argument goes exactly previous case 
ea thena andx maxa andu maxa 
cost reaching isc suffices show forx follows trivially 
maxa sou maxa maxa maxa 
suggest fig 
branch bound algorithm determining minimum cost reaching target location lg initial state lpta 
encountered states stored data structures passed waiting divided explored unexplored states respectively 
global variable cost stores lowest cost reaching target location far 
iteration state taken waiting 
matches target location lg lower cost previously lowest cost cost cost updated 
state previously explored lower cost add passed add successors waiting 
bounding search line fig 
may optimized adding constraint mincost cost need continue exploration minimum cost current region optimal cost computed far 
due theorem algorithm fig 
yield correct minimum cost value 
theorem 
algorithm fig 
terminates value cost equals mincost lg 
cost passed waiting waiting select waiting lg mincost cost cost mincost add add return cost fig 

branch bound state space exploration algorithm 
proof 
notice reach state reach state 
prove cost equals min mincost lg reachable 
assume hold 
exists reachable state lg cost 
algorithm point discarded state onthe path lg 
happen line exist state passed encountered prior iteration loop 
state lg reachable cost mincost mincost contradicting assumption 
theorem follows theorem 
bounded lpta application higman lemma ensures termination 
short higman lemma says certain conditions embedding order strings quasi order 
theorem 
algorithm fig 
terminates bounded lpta 
proof 
bounded yields finitely regions infinitely priced regions due unboundedness cost vertices 
costs positive application higman lemma ensures infinite sequence cost vectors fixed length ck consequently due finiteness sets locations regions follows infinite sequence li ri symbolic states lj lk rj rk ensuring termination algorithm 
combining theorem follows due theorem minimum cost reachability problem decidable 
theorem 
minimum cost problem lpta decidable 
successfully extended regions operations setting timed automata linear prices transitions locations 
principle basis branch bound algorithm minimum cost reachability problem accurate symbolic semantics timed automata linear prices showing minimum cost reachability problem decidable 
algorithm guaranteed inefficient highly sensitive size constants guards automata characteristic inherited time regions basic data structure algorithm 
obvious continuation investigate practice efficient data structures 
possible candidates include data structures reachability algorithms timed automata dbms extended costs vertices represented zones convex sets clock assignments 
contrast priced extension regions operations notion priced zones obtained direct extensions corresponding operations zones suitable manipulation cost vertices 
need infimum definition minimum cost executions arises linearly priced timed automata strict bounds guards shown fig 
discussed example 
due infimum linearly priced timed automaton able realize execution exact minimum cost automata able realize cost infinitesimally close minimum value 
guards include non strict bounds minimum cost trace realized automaton 
fact shown defining minimum cost problem executions covered symbolic trace linear programming problem 
algorithm computing minimum costs reachability linearly priced timed automata prices constants natural numbers 
slight modification algorithm provides extension parameterized setting prices may parameters 
setting costs priced regions finite collections linear expressions parameters simple natural numbers 
intuitively denotes instantiation parameters minimum concrete values denoted linear expressions cost expressions may compared simply comparing sizes corresponding parameters collections denoting minimums related element smaller element modified version algorithm fig 
cost similarly collection linear cost expressions goal location reached far 
results generalizing higman lemma follows ordering parameterized symbolic states quasi ordering guaranteeing termination algorithm 
currently working extending algorithmic solution offered synthesis minimum cost controllers particular reset operation delay operation 
sense :10.1.1.43.6815
extension priced region conventional region min max expression cost vectors vertices region 
extension follows results generalizing higman lemma orderings symbolic states quasi orderings guaranteeing termination algorithms 
authors lone hansen great creative effort making figures 
authors abdulla sharing expertise knowledge world quasi orderings 

aziz abdulla better better efficient verification infinite state systems 
proc 
th ieee symp 
logic computer science 
ieee 

alur courcoubetis henzinger 
computing accumulated delays real time systems 
proc 
th int 
conf 
computer aided verification number lecture notes computer science pages 

alur dill 
automata modelling real time systems 
theoretical computer science april 

asarin maler 
soon possible time optimal control timed automata 
hybrid systems computation control number lecture notes computer science pages 
springer verlag march 

gerd behrmann thomas kim larsen paul pettersson 
efficient guiding cost optimality uppaal 
accepted tacas 

marius oded maler alfredo olivero stavros tripakis sergio yovine 
kronos model checking tool real time systems 
proc 
th int 
conf 
computer aided verification number lecture notes computer science pages 
springer verlag 

david dill 
timing assumptions verification finite state concurrent systems 
sifakis editor proc 
automatic verification methods finite state systems number lecture notes computer science pages 
springer verlag 


scheduling steel plant timed automata 
proceedings th international conference real time computing systems applications pages 
ieee computer society 

henzinger 
theory hybrid automata 
proc 
th annual symp 
logic computer science lics pages 
ieee computer society press 

thomas henzinger pei hsin ho howard wong toi 
hytech amodel checker systems 
orna grumberg editor proc 
th int 
conf 
computer aided verification number lecture notes computer science pages 
springer verlag 

higman 
ordering divisibility algebras 
proc 
london math 
soc 

thomas kim larsen paul pettersson 
guided synthesis control programs uppaal 
lai editor proc 
ieee icdcs international workshop distributed systems verification validation pages 
ieee computer society press april 

kim larsen paul pettersson wang yi 
uppaal nutshell 
int 
journal software tools technology transfer october 

kim larsen carsten weise wang yi justin pearson 
clock difference diagrams 
nordic journal computing 

ller andersen 
difference decision diagrams 
technical report tr department information technology technical university denmark february 

peter stavros tripakis sergio yovine 
minimum time reachability timed automata 
ieee control conference 

peter sergio yovine 
computing optimal operation schemes multi batch operation chemical plants 
vhs deliverable may 
draft 
example symbolic state space appendix part symbolic state space linearly priced timed automaton fig 
value 
figures viii show priced regions reachable symbolic representation states space 
show priced regions integer value equal 
initially clocks value zero delaying clocks keep having value 
priced regions reachable initial state ones line shown fig 

numbers line costs vertices priced regions represented line 
cost staying location price delay time unit 
cost reaching point 
priced regions fig 
ii ones reachable transition location resetting clock 
performing reset change costs new priced regions dimensional vertices collapsed 
fig 
iii reachable priced regions marked shaded area including lines inside area boundary 
priced regions reachable priced regions fig 
ii 
transition location location causes clocks reset 
resetting priced regions fig 
iii priced regions fig 
iv reachable 
finding cost state reset projection done minimum cost states projecting delaying priced regions priced regions fig 
reached represented shaded area lines surrounding 
left choice take transition location take loop transition back location transition location possible guard satisfied 
vertices fig 
vi marked priced regions vertices marked satisfy guard 
reaching location priced regions delay time units satisfy guard transition location location part symbolic state space shown 
minimum cost reaching location way 
possibility location take loop transition resets clock 
resetting priced regions fig 
priced regions fig 
vii reachable 
priced regions time pass 
dimensional picture dimensional priced regions reachable priced regions fig 
vii hard understand 
chosen focus priced regions satisfy guard transition location priced regions displayed stating cost vertices fig 
viii 
reachable priced regions satisfying guard ones vertices marked cost fig 
viii 
priced regions satisfying guard transition location location satisfies guard transition location vertices value line ii iii iv vi vii viii fig 

sets reachable priced regions 
points 
cost reaching points possible reach location cost 
loop transition location choice 
doing yield priced regions displayed fig 
vii added cost 
new priced regions costly priced regions explored algorithm 
brics report series publications rs gerd behrmann thomas kim larsen paul pettersson vaandrager 
minimum cost reachability priced timed automata 
january 
pp 
appear hybrid systems computation control 
rs pagh jakob 
optimal time space trade offs non comparison sorting 
january 
ii pp 
rs gerth st anna christian pedersen 
complexity constructing evolutionary trees experiments 

rs claude cr fr ric gar louis 
convert flavor quantum bit commitment 
december 
pp 
appear advances cryptology international conference theory application cryptographic techniques eurocrypt proceedings lncs 
rs peter mosses 
casl cafeobj users 
december 
pp 
appears futatsugi nakagawa editors cafe industrial strength algebraic formal method chapter pages 
rs peter mosses 
modularity meta languages 
december 
pp 
appears nd workshop logical frameworks meta languages proceedings 
rs ulrich kohlenbach 
higher order reverse mathematics 
december 
pp 
rs marcin ski jens ge 
discrete improvement algorithm solving parity games 
december 
rs nielsen 
denotational investigation 
december 
th workshop mathematical foundations programming semantics mfps new jersey usa april 
rs yang 
reasoning code generation level languages 
december 
