malcolm atkinson editor orthogonally persistent object systems malcolm atkinson ronald morrison received june revised version received march accepted april 

persistent application systems pass increasing social economic importance 
potential long lived concurrently accessed consist large bodies data programs 
typical examples pass cad cam systems office automation case tools software engineering environments patient care support systems hospitals 
orthogonally persistent object systems intended provide improved support design construction maintenance operation pass 
persistence abstraction allows creation manipulation data manner independent lifetime integrating database view information programming language view 
yields number advantages terms orthogonal design programmer productivity beneficial pass 
design principles proposed persistent systems 
principles languages provide persistence basic abstraction developed 
motivation orthogonal persistence reviewed mentioned design principles 
concepts integrating programming languages databases persistence abstraction benefits 
technology support persistence achievements directions persistence research discussed 
key words 
orthogonal persistence persistent programming languages database programming languages persistent application systems 

presents broad review current research achievements orthogonally persistent object systems 
provides advanced tutorial commencing research advanced study persistence databases database programming languages survey persistent language community con malcolm atkinson ph professor department computing science university glasgow glasgow qq scotland mpa dcs glasgow ac uk ronald morrison ph professor school mathematical computational sciences university st andrews north st andrews ky ss scotland ron dcs st andrews ac uk 
tribution growing research area 
particular goal summarize existing achievements identify current research issues 
orthogonally persistent object systems support uniform treatment objects irrespective types allowing values types longevity required 
motive establishing uniform treatment 
subsequent sections definitions integration concepts technology support persistence achievements 
table identifies major topics covered 
section suggests crucial areas research 
incoherence current technology aim persistent programming support activity applications construction long lived concurrently accessed potentially large bodies data programs referred persistent applications systems pass 
designated persistent application systems application outlives individual components implementation technology 
typical examples pass cad cam systems office automation case tools software engineering environments teitelbaum reps ooi sommerville thomas integrated hospital administration medical systems large scientific databases programs analyze geographic information systems environmental modeling systems object oriented databases bancilhon process modeling systems bruynooghe curtis han welsh 
commission construction pas expect built reasonable cost delivered time serve organization reliably years accommodating change requirements change technology advances 
disappointed frequently proves harder expensive build maintain pas expected evolution invariably problematic 
may illustrated example 
health care management system hospital medical staff fields medical records disappeared 
local support staff diagnosed fault database restored earlier state 
problem persisted earlier restoration losing information 
problem persisted 
suppliers pas called eventually discovered file containing font user interface management system lost 
inconsistent behavior supporting subsystems led expensive service interruption loss information 
restoration functioned identically data lost file restored 
different data treated differently local staff system incomprehensible implementors struggle understand cause failure 
similar detailed inconsistencies stage pas construction maintenance constructed traditional technology 
vldb journal atkinson orthogonally persistent object systems table 
location major topics topic problems conventional technology principles persistence definition orthogonal persistence benefits orthogonal persistence integration databases programming languages types data models persistent type systems binding mechanisms concurrency transactions technology support orthogonal persistence implementation architectures implementing persistence reachability type safe linguistic reflection incremental persistent application system construction hyper programming persistent software engineering research directions extensions persistence exploitation persistence delivering persistence summary section currently technology underlying pas building called support system relies number disparate mechanisms philosophical assumptions support efficient implementation atkinson 
operating systems communications systems bundled operating system designed separately database systems user interface systems command languages editors file systems compilers interpreters linkage editors binders debuggers dbms query languages user interface management systems uims transaction managers concurrency managers machine types 
programmers cope variations different naming type binding schemes components 
hardest challenge programmers face coping different recovery concurrency transactional behavior 
incoherence complexity arising utilizing different diverse application system building mechanisms increases cost 
complex inter dependence current systems communication sy em system ii programs users 
programmers 
uims real world intellectually mechanically building simplest systems 
complexity application builders task hand forcing concentrate mastering multiplicity programming systems application developed 
plethora disparate mechanisms costly machine terms code interfacing redundant duplication facilities contention resources cause execution overheads 
illustrates interconnection system components users system 
moments crisis peaks activity expect pass 
unfortunately precisely moments stress malfunction due complexity inter dependencies components 
solid lines represent data flow translation mappings dashed lines users programmers required understand 
situation shown ideal users required understand minimum 
observations real applications show users find learn aspects operating system database 
hand situation far ideal application programmers deal subsystems programs applications real concern 
individual inconsistencies different underlying subsystems software engineers working pas problems 
pair subsystems presents discontinuities composition complexity multiplicative additive 
recognition cost motivated designers orthogonally persistent object systems propose support computational models allow large scale long lived computation unnecessary sources complexity 
cases inconsistent treatments fundamental accidental atkinson 
various subsystems built different times engineering trade offs different 
consequence provide virtually vldb journal atkinson orthogonally persistent object systems 
target architecture support persistent application systems pss uims ers persistent application systems pass persistent support systems re proposed architecture simplified context programming um services inconsistently designed developed independently 
choosing provide total composition services needed support pas coherent design designers orthogonally persistent object systems eliminated accidental exposed places difficult research issue find integrating concepts 
timely propose new models computation expressed linguistically architecturally response advent new hardware technologies different time space cost trade offs development new application areas office automation cad cam case 
persistent systems proposal 
summary important distinguish carefully pas support system enables operate application programmers build maintain 
cost building support system amortized pass cost application programming dominates software industry appropriate invest improved support systems reduce pas programming costs 
orthogonal persistence provides design principles guide investment 
desired simple relationship pas generic support system shown 
analysis causes incoherence complexity pas intrinsic emanates tasks pas sets support 
argued considerable part complexity extraneous unfortunate artifact independent development essential supporting technologies 
proposing integrated design principles eliminate extraneous complexity origins analyzed 
analysis focuses relationship programming languages database systems reasons typical class problems arises comparing operating systems programming languages reveal similar extraneous differences domain received attention matches interests expected audience 
database programming language communities continued research develop products independently despite having provide similar services 
example provides means naming values allocates space store values provides means constraining values operations provides modeling description mechanisms provides mechanisms extracting values data structures provides concurrency 
inconsistencies originate different philosophies circumstances camps 
database community faced severe engineering problems 
difficult preserve large volumes data reliably support processes operating data efficiently 
difficult accommodate design habits system analyst allow virtually independent teams programmers develop parts pas independently 
consequently technical solutions dominate 
relations query optimization serializable transactions views examples success 
contrast programming language designers typically help programmers precise programs understandable 
sought design principles lead languages regular rules 
rules match programmers intuitions easy define precisely lead programs executed reasonable efficiency 
course exceptions camp 
relations simple formal precise rules unfortunate number programming languages 
responses design difficulties context informative 
programming languages essential requirements ignored example languages predefined treatment functional languages offer mechanism update 
databases solution designed independently simply added long running transactions 
additions may compose existing constructs 
separate development consequent inconsistencies tend grow 
intellectual software investment camp easy adoption ideas 
dichotomy philosophies continues may heightened view caricatures 
programming language designer database world looks mess incomprehensible ad hoc design little underlying philosophy 
hand database designers surprised programming languages unhelpful real problems bulk types persistence concurrency transactions 
vldb journal atkinson orthogonally persistent object systems table 
various life times data values transient results expression evaluation local variables global variables heap items data lasts execution program data lasts executions programs data lasts long program data outlives succession versions program data outlives versions persistent support system challenge show need remain separate pas builders benefit resultant integrated support environment suffer task bridging possibly widening gulf 
persistence introducing persistence may important point approach incoherence lead solution 
approach current underlying technologies gluing glue ware hiding sufficient standard interface 
underlying differences semantics ultimately show example failure semantics combined system stressed 
pas builders wish support nearly continuous availability explain users happening service commitments met understand underlying technology including different behaviors 
concerned complexity seek free 
approach appears minimize effectively taken design provision object systems particularly persistent programming languages 
approach tried language design principles adhered applied deliver complete computational environment 
term persistence variously common parlance defined context mean supporting data values full life times brief long may 
life times data values period creation longer persistent application 
range illustrated table 
typically rows serviced programming languages rows databases file stores 
barrier exists forms data 
short term persistent data user collection base types may aggregated composed constructed forms records variants functions data types 
hand long term persistent data take form byte streams held file system structure relations databases 
orthogonally persistent systems designed treatment data values uniform independent longevity size type 
goal achieve uniformity aspects system services data definition operations integrity concurrency distribution 
noted goal provision orthogonal persistence independent choice example data model type system concurrency control mechanism defines values may occur operations may applied 
choices reasons guided appropriateness application domains 
constraints choice safe system provided pas builder 
engineering challenges building systems choices entirely independent 
issue investigated sections 
similarly choice programming paradigm query language imperative language logic language object oriented language functional language orthogonal issue providing persistence 
appropriateness application guide choice 
simplification achieved orthogonal persistence summarized figures 
fragment pas represented built combination programming language database facilities 
programmers build understand models external real world system pas supports 
furthermore ensure view behavior models remains precisely consistent accessed directly database facilities accessed programs database 
maintenance precise consistency circumstances including stress extremely hard application programmers achieve 
achieve immense effort fail users suffer comprehensible system 
costs construction subsystems 
programmers write translations systems computers execute 
proceeds lowest common denominator base types losing structural information protection 
pas fragment envisaged constructed orthogonal persistent system 
data supported consistently happens programmers need understand model maintain mapping 
reduction complexity programmers obvious 
comprehensible pas behavior users 
vldb journal atkinson orthogonally persistent object systems 
mappings support systems mapping interface programs database jf database program mapping simulation normal programming activity real world 
mapping integrated support system program real world mapping simulation normal programming activity 
principles persistence recognize design accomplished necessary design principles judge result 
constructing persistent systems persistence research community taken view integrated approach pioneered language designers extended computationally complete 
regard necessity subsystem specified specifiable language failure computational completeness 
example file system failure semantics varies context program 
principles developed extending design principles programming languages encompass requirements persistence 
design principles observed expressive power programming languages gained separating concepts allowing combined powerful composition rules mccarthy van wijngaarden strachey tennent 
strachey tennent distilled ideas principles design programming languages 
principle correspondence 
principle abstraction 
principle data type completeness 
principle correspondence states rules governing names bindings programming language consistent 
particular rules introducing names bindings declarations corresponding mechanism abstraction parameters 
ensures formal parameters behave consistently local declarations 
principle abstraction states significant syntactic categories language abstraction mechanism 
allows essential details ignored concentrating general structure 
abstraction consists naming syntactic category allowing parameterized 
widely forms abstractions functions data types 
principle data type completeness states combination construction data allowed types 
consequence data objects language civil rights 
goal principles design languages simple powerful 
simple minimum defining rules exceptions exception rule language complicated terms understandability implementation 
minimization defining rules exceptions contributes power language exception language powerful introduces restriction 
expressive power comes ensuring composition rules complete minimal exceptions 
persistent systems design rules origins 
parsimony concepts orthogonality concepts completeness computational environment 
combination rules yields integrated persistent systems alluded earlier 
constructs required match application domain 
required parsimony concepts focuses attention essential constructs 
absence extra features ensures simplicity 
orthogonality ensures system composed atoms including persistent data may combined powerful ways yield appropriate abstractions 
case completeness language computationally complete implementors designers need combine language facilities build pas 
problems 
constructing persistent systems considerably easier computational environment persistent 
environment programs processes may regarded data manipulated manner allowing transformations traditionally regarded performed separate mechanism executed persistent environment 
example case procedures persistent store may provide uniform library structure manner similar providing library data parts atkinson morrison atkinson kirby 
vldb journal atkinson orthogonally persistent object systems persistence principles general principles lead specific principles concerning persistence 
definition persistence 
persistence data object period time object exists usable atkinson 
aspire systems data orthogonal persistence 
persistence 
principles persistence may achieve design goals 
principle persistence independence 
form program independent longevity data manipulates 
programs look manipulate short term long term data 
principle data type orthogonality 
data objects allowed full range persistence irrespective type 
special cases objects allowed long lived allowed transient 
principle persistence identification 
choice identify provide persistent objects orthogonal universe discourse system 
mechanism identifying persistent objects related type system 
application principles yields orthogonal persistence 
persistence independence 
persistence independence frees programmer burden having explicitly program movement data hierarchy storage devices coding translations long term short term representations 
example persistence independence consider sorting procedure takes input array objects sorted 
parametric array may small large held main store disk 
having identify correct array programmer need concerned size storage details arrays 
user program control movement data long term short term store performed automatically system 
mechanical cost performing movement data disappear intellectual cost 
programmer need specifically write code making application code smaller intellectually manageable 
implementer support system challenge automating data movement translation efficiently 
data type data type orthogonality aid data modeling ensures data model complete independent persistence data modeled 
example bulk data types size commonly persistent programming languages aid manipulation massive collections data scanned data satellites insurance policies sold 
data considered longterm data model allow explicit conversion long short term forms allow creation new bulk data manipulation extracts long term bulk data short term data 
data type orthogonality includes language design principle type completeness 
example bulk data means elements bulk constructor independent persistence data 
programmer faced system set particular element type allowed persistent element type 
identification persistent objects 
number methods investigated identify persistence data 
involve associating persistence storage allocator variable name type declaration 
rule persistence independence disallowed 
inappropriate reasons atkinson 
languages extent data object differ scope limited form persistence exists 
objects normally kept heap depends availability legal names 
kept available long program execution environment contains information refer 
limited persistence extended allow objects persist activation program 
technique extends widely implement principle identification reachability 
identification persistent objects performed system automatically computing transitive closure objects reachable pointers persistent root roots atkinson atkinson cockshott brown cockshott brown morrison :10.1.1.145.2614
data persist activations programs operate 
analogy automatic garbage collection obvious 
loss loss orthogonality persistence occurs disregarding principles section 
serious persistence independence broken hard see persistence system orthogonal way 
programming language designers taken pragmatic approach persistence disregarded data type orthogonality specific types 
pascal schmidt dbpl schmidt matthes rapp hughes connolly persistent programming languages pascal order relations contain pointer types may persistent 
corresponds relational database practice causes difficulty modeling techniques 
restrictions imposed necessary shown persistence added orthogonally pascal berman 
vldb journal atkinson orthogonally persistent object systems 
persistent objects sent persistent store database database database typ value value type non database type 
objects persistent store database type ty reachability languages associate persistence type 
immediately violates principle persistence identification side effect principles 
gives rise dangling problems invalidated persistent objects point non persistent objects 
programming language richardson carey richardson carey persistent extensions language wileden technique 
figures illustrate problem 
shows object preserved persistent store 
type permits residence database holds objects types may stored database value type database residence supported 
shows result saving structure persistent store 
structure preserved remaining non database value lost having replaced dangling nil values available 
persistent store model data consistent main store model position wish avoid adds complexity system programmer master 
example overcome loss data data required exist program executions programmers need 
define surrogate structure shown uses types supported database 
write code translate non database values equivalent database values surrogate 
write code perform inverse translation 
ensure code run appropriate times combined translation exactly consistent 
lack completeness persistent computational environment seen oodbms 
methods held traditional program library linked programs standard linker 
data values objects held database 
garbage collection unwanted data problem model known methods contain objects objects exist require methods 
systems provide garbage collection data solution eventually lead grief 
systems allow explicit deletion object recursive deletion root 
case methods may exist program library data usually causes run time failures 
savings persistence benefits orthogonal persistence described extensively literature atkinson atkinson atkinson morrison morrison atkinson buneman dearie brown brown connor cooper albano 
summarized improving programming productivity simpler semantics avoiding ad hoc arrangements data translation long term data storage providing protection mechanisms environment supporting incremental evolution automatically preserving referential integrity entire computational environment life time pas 
saving persistent systems reduced complexity application builders 
traditionally programmer maintain mappings database model programming language model real world model application 
vldb journal atkinson nally persistent object systems intellectual effort maintaining mappings overcoming complexity support system programmers mastering inherent complexity application 
persistent system number mappings reduced simplifying considerably tasks undertaken pas maintenance construction 
corresponding intellectual savings persistence saving amount code required maintain mappings 
estimated total code typical database application king 
unnecessary code concerned explicit movement data main backing store required change representation data preservation restoration 
example input output code code flatten reconstruct graph output input 
size application code reduced producing savings software life cycle application 
third benefit persistent systems single model protection may operate environment morrison 
programming languages simplest way break protection system output value type input 
security lost persistent store 
single enforceable model reduces complexity increasing protection type checking prevents disallowed operations misuse 
database programmers build large systems incrementally designing subsystems adding data schema existing system 
initially schema defined database populated data programs queries added 
powerful software engineering technique incremental design implementation 
persistent systems paradigm preserved flexibility roles schema data programs 
particular schema longer considered relatively static small data programs dynamic large 
persistent systems schema data programs considered equally may static dynamic large small depending pas construction 
final saving persistence referential integrity objects automatically enforced 
referential integrity object means object persistent environment established object remain accessible long exists 
furthermore identities objects unique comparison identity yields result independently performed 
strongly typed persistent environment means type correctness maintained established type object referenced change 
seen section number consequences source descriptions pass 
provision orthogonal persistence consequences support systems 
example done explicitly programmers non persistent system automated implementors persistent support systems 
abstraction longevity requires accommodation schemata programs data size may grow unpredictably lifetime pas 
important aspect systems mechanisms construct sub systems 
reliability control guaranteed persistent environment control delegated tools loss safety connor 
considerable research devoted concept persistence application integration database systems programming languages atkinson atkinson 
number persistent systems developed including ps algol atkinson ps algol data store powell flex currie stanley stanley drummond galileo albano amber trellis owl schaffert ti persistent memory system thatte tycoon matthes schmidt napier morrison fibonacci albano 
underlying goal achieve engineering sufficiently high quality ensure orthogonal persistence abstraction performs longevity type data programs application programmers program having think data transfers similar issues 

integration concepts integration programming languages databases single computational entity involves number challenges researchers identifying unifying concepts similar purposes domain 
particular interest unification type systems data models binding mechanisms techniques identifying persistent data system architectures concurrency control advantage controlled environment 
progress areas discussed 
types data models long term goal research persistent type systems unify type systems data models developing adequate model type meets computational needs persistent systems connor 
ideally simple set types type algebra succession operations provision parameters data model conceptual data model defined 
call type dream atkinson morrison 
type systems provide data modeling protection facilities databases programming languages 
data modeling performed databases data models types describe form data programming languages classical type system 
cases universe discourse system defined set allowable types turn denoted vldb journal atkinson orthogonally persistent object systems table 
equivalences data models type systems databases data models schema database database extent programming languages type systems type expression variable value set legal expressions language 
data protection provided enforcing explicit implicit integrity constraints databases type checking programming languages 
step unification data models type systems approximate equivalences recognized 
summarized table 
equivalences approximate provide insight integration may possible conceptual level 
issue type checking central type system provides data modeling protection persistent systems 
generally data models databases concerned manipulation data consistent constraints imposed data model 
cases constraints may depend values calculated computation 
dynamic nature require dynamic integrity constraint checking enforcement 
contrast classical type systems programming languages concerned static checking allows assertions proved computation executed 
static checking provides level safety system 
allows efficient code type checking code required run time 
dichotomy checking times databases programming languages appears resolution 
way forward pursue limits static checking accommodating dynamic checking required particular instances 
retains safety efficiency static typing provided programming languages cases accommodating dynamic flexibility data modeling 
approaches currently provide static checking persistent type systems 
constraint specification constraints data particular computation expressed language 
checking requires powerful theorem prover limits currently available 
systems usually undecidable unsuccessful check may caused limitations theorem prover inconsistent constraints 
theorem prover fails may provide useful information form minimal dynamic checks sheard stemple 
clearly delimits points dynamic checking retaining static checking possible 
second approach extend classical type systems specific types 
demonstrated points dynamic checking required bind persistent objects programs data prepared separately combined dynamically 
goal provide dynamic type checking retaining static checking possible 
approaches need pursued section 
final difference semantics associated time checking 
programming languages type checks static dynamic precede operations dynamic database integrity constraint checks may performed operations commitment 
cases strength checking compromised time performed 
persistent type systems 
major challenges type systems persistent programming provide richness expression data models completeness protection required static form 
goals pursued section 
programmer defined type constructors 
important innovation type systems provision programmer defined type constructors milner wegner cardelli 
allows programmers identify introduce new succinct notations corresponding frequently structures 
importantly gives structures name signifies meaning programmers fulfilling requirement types describe data effectively 
sequence examples declarations convince readers programmer defined types provide convenient notation extensible descriptive system comparable power data models 
examples written style close napier notation morrison morrison assumption structural equivalence checking operation conner 
new type name introduced notation type count int declares count type name synonym type int assumed defined 
similarly define date type 
type date record day month year int definitions interesting type parameters introduced type pair type record value date date definition pair describes infinite class record types vldb journal atkinson orthogonally persistent object systems labels type 
definition pair may parameterized type yield concrete type pair int 
strictly latest definitions types type operators parameterized type yield type constructor 
little distinction moment 
second type definition illustrates type defined earlier may definition build succession complex semantically meaningful names structures 
case generate record types combine date stamp value example type image type count declares type instances images date captured instances type hold counts date count 
illustration statements define ordinate types integer real spaces 
type pair int type pair real regular structures occur bulk types defined 
example type sequence element type ring element type set element type bag element type map domain range type tree key value 
readers spared details definitions typically involve data types described section 
definitions composed 
type dom range map dom set range type forest key value sequence tree key value conventional definitions 
type student record int fname sname string date 
type course record title string prerequisites set course type enrollment record student student course course type curriculum record student student completed sequence course type class set student type operator names defined pair set bag forest just supplied existing data models supplied initially language 
similarly types constructors produced named vis count date image class produce instances just types traditional data model 
easy envisage persistent support systems shipped built types constructors extensive libraries additional types corresponding manipulation functions 
traditional libraries procedures available want 
gives simple starting point application builders potentially rich repertoire additions augmented needs identified persistent support system suppliers application builders 
parametric type constructors described section easier associated libraries generic procedures provided atkinson 
possible language provides appropriate forms polymorphism described morrison 
information hiding existentially quantified types 
parameterized type operators introduced previous section define infinite class types 
values created specific type information contained available parts programs correct type descriptions type descriptions structurally equivalent 
values created type operator type equivalent created equivalent parametric types 
type operator mechanism provide information hiding data types 
encapsulating structure data published interface type data internal structure may hidden 
consequence data types equivalent interfaces equivalent irrespective internal type structure 
best illustrated example 
start record type defining counters value increment operation 
type counter record value proc proc int int counter int create counter value 
value increment creates record fields integer value function increment value 
type record equivalent record value int proc int int record useful aggregation protect data outside interference 
example fields may accessed updated vldb journal atkinson orthogonally persistent object systems part system specify equivalent type 
final statement example shows value updated fields consistently intended 
type counter restrict value function second order information hiding cardelli wegner may type data required consistent usage statically enforced 
data type may formed parametric type operator manner create concrete value 
case parametric type witness type called context instantiated 
consider example revised creation counter 
counter int creates data type fields operate type data type created type witness type may re discovered 
consequence functions data type may operate value ones witness type 
witness type abstracted known exist type written formally record value proc second advantage data types formed manner type equivalent 
example counter reals type record value proc witness type abstracted 
types may follows type counters written examples 
proc value value final problem remains data types 
preserve static type checking necessary create context components data type 
necessary restriction possible identify static analysis interface components manner ensures belong witness 
achieved appropriate syntactic mechanism requirement hidden information consistently enforced static analysis program text type checking 
provides safety allows programmers place precise limits ways long lived data may 
details models witness types cardelli macqueen 
generic re usable persistent polymorphic procedures 
statically typed universe trades power expression static safety 
system designer willing trade depends application domain 
albano 
companion articles analysis constitutes persistent type system 
modeling purposes generally agreed form polymorphism required capture expressiveness data models increase component re morrison demonstrated data types 
favored forms polymorphism universal polymorphism parametric inclusion 
parametric polymorphism describes polymorphism ml milner derivatives inclusion polymorphism style polymorphism object oriented languages simula dahl nygaard 
interesting hybrid may database programming language galileo albano derivative ml utilizes inclusion polymorphism implement part semantic data model hammer mcleod 
cardelli wegner shown separately parametric inclusion forms polymorphism may integrated bounded quantification yield forms abstraction available 
parametric inclusion polymorphism give similar power cardelli wegner parametric polymorphism described 
parametric polymorphism functions may defined types 
consider function counts number elements list 
values elements list function lists 
said universally quantified type may written yr 
list int extend example consider functions maintain index store values type keys type equality defined 
functions polymorphic value key types 
specified relatively easily parametric polymorphism 
example index implemented list pairs element key value type function enter value index 
key value list key value list key value advantage type abstraction functions placed persistent store operate indexes types 
software engineering advantages writing concise code generally applicable known 
vldb journal atkinson orthogonally persistent object systems abstraction obtained observing functions able structure data base type 
function written polymorphic procedure heading specifies index implemented list 
may implemented operations list 
possible implement index structures arrays trees 
example type tree 
key value btree key value btree key value combining functions requires parametric types equivalent 
types may yield combination universal existential quantification 
note universal quantification polymorphic form written special cases generated existential quantification existing values described general type allowing general abstraction type 
polymorphism technique retrieving expressive power lost type system place 
abstracting types general computations expressed monomorphic systems 
polymorphism regain power lost statically checked type system 
relational systems highly polymorphic depend dynamic evaluation types expression 
example specification implementation generic natural join function provides example abstraction types capabilities statically typed polymorphic type systems 
details input types particularly names tuple components significantly affect algorithm output type 
type systems accommodate functions natural join generally higher order dynamically checked 
interesting exception case machiavelli type system ohori 
general retain static checking write higher order functions different technique required 
technique linguistic reflection stemple discussed 
persistent type checking 
demonstrate need form dynamic type checking persistent systems show provided 
novelty persistent type system provide type checking computational activity including persistent data 
traditional file system persistent data achieved programs having textual descriptions find data file system 
type checking static description file data program compiler assert data specified type provided file 
implementation run time system perform dynamic type checks enforce assertions 
illustrates point 
type address declared record fields name age gender types string integer boolean respectively 
variable 
dynamic file access type address name string age int gender bool var file address open user ron addresses point system accesses file ensuring exists checks type data file specified type nil error 
eof read declared having type file address 
initialized file path name user ron addresses open statement 
file exists dynamic type check performed ensure data contained file correct type address 
note interpretation path name string open operation example failure computational completeness described determined semantics language 
noticed point dynamic typing open statement 
program compiled assertion file correct type type checking performed statically 
program may read values file performing subsequent dynamic type checks 
form persistence file considered persistent root 
notice type values file guaranteed file system 
overwriting data values different type forbidden strongly typed file system 
nature open statement worthy closer inspection 
statement different types depending values contained file 
case returns type file address case may return example type file employee 
general type open coerced specific type dynamically open statement 
open said dynamic type 
changing type values file entails deleting file replacing file different type 
appears program old values vldb journal atkinson orthogonally persistent object systems coerced new type 
notice coercions performed side effect operation need explicit dynamic type coercion facilities language 
typical implementation example ada operations depend systems independent semantics changed independently 
ex may change type existence file feet programmer 
number typed files persistent space grows programs inevitably wish access file inter file 
major difference typed file store typed object store files self contained inter file objects highly inter connected 
assume typed files extended accommodate inter file 
consequence inter connection file file type knowledge types files connects 
time persistent space highly connected necessitating program near complete description types files 
second problem typed file approach persistence file types fixed file creation time 
files refer newer files type determined restricts evolution system 
programming level inheritance partially overcomes yielding additive evolution atkinson allows values replaced specialized forms 
file provided extra address field postcode 
processing system set ignores achieve correct execution 
accommodate evolution completely necessary allow arbitrary changes data model defined points 
problems outlined partial specification type structure schema evolution data mode solved mechanism performs dynamic type checking persistent data 
integrated solution involves infinite union type type ps algol dynamic amber cardelli env napier morrison examples 
persistent roots infinite union type values injected objects type projected dynamically type re 
points projection dynamic type checking occurs 
illustrates point type napier notation 
standard function ps called 
returns value persistent store dynamic type 
dynamic type allows persistent store change specific type activations particular programs 
value specific type ps projected project clause type 
projection dynamic type check occurs 
projection context value may specific type case address 
program writes age field record 
number types may specified projection correct 
catch default clause trap cases specified types match 
context value type 

projection infinite union type address name string age int gender bool ps ps standard function napier returns persistent root type value specific type projected type project ps address write age type address default catch type mechanism persistent store general dynamically checked type 
values store dynamic type projected specific type store 
method store may change type injection value different type interest fact performed 
mechanism occurs implicitly standard database interfaces 
program opens database specifies schema view 
opening operation schema view program compilation compared database current schema view 
arbitrary changes may database schema editor compilation execution 
schema view longer matches expectations established compilation time error signaled 
internally run time system able treat database having dynamic type perform dynamic verification expected actual types match 
seen dynamic checking limited points projection type 
values dynamic types class may constituent part type 
graph objects object store may root type values type components objects 
specific type projected type 
allows programs specify part schema require point dynamic checking 
consequence schema represented arbitrarily large collection mutually referencing types may scale schema specification bounded dynamic types 
incremental schema changes inject new values type rest specification remains unchanged 
addition encapsulates type type checking postponed required 
excessive type checking costs start avoided 
implement vldb journal atkinson orthogonally persistent object systems 
partial specification types type address record name string age int gender bool extra ps project ps address extra type record int type spouse address programs extra field need specify project type check happens executed write write id number default default delayed checking necessary store potentially large complex types value 
extra field specification type required 
programs extra field type declared 
part type structure need specified part interest program 
dynamic types allows data model evolve recompiling programs refer data 
example type altered programs type need altered 
summarize explicit dynamic types allow partial specification structure data schema facilitate evolution data having alter programs evolutionary changes 
range type checking times 
addition infinite union type facilitates incremental dynamic checking persistent systems 
range checking times includes just dynamic checking 
spectrum presence persistent store allows persistent values bound programs program construction 
programs persistent objects leads concept hyper programming kirby discussed 
sufficient realize persistent values available type checker allowing types value 
leads 
partial types type address record name string ps project ps address write name default age int gender bool extra write name persistent systems able support dependent types types require tests values establish equivalence similar static constraints values traditional database systems 
introduce usefulness dependent types motivating example dependent bulk types taken connor 

semantics bulk type data models depends user defined attributes definitions element equality ordering domain predicates 
attributes intrinsic part data model normally treated part type description 
may lead occurrence data modeling errors union operator accidentally applied sets different semantics equality elements 
directories indexed scottish names provide example inclusion element attributes type may requirement 
people may take different view mcfarlane really different names owners usually protective different forms 
retrieve data retriever wish distinguish 
requirement different types directory dependent domain equality semantics 
directories type depend equality operator value 
persistent value depend value formed different occasions 
dependent types structurally equivalent necessary values depend equal 
equivalence dependent types statically decidable necessary values types depend statically available type checker 
essential requirement values type depends evaluated equivalence testing performed type 
restriction general type description enforced restricting dependencies existing persistent values 
full description language mechanism including explanation necessary restrictions subject polymorphism dependent types connor 

vldb journal atkinson orthogonally persistent object systems range binding mechanisms binding mechanisms user trade safety flexibility morrison 
dynamic binding flexible binding delayed latest possible time choice 
contrast static binding safer static checking may give advice person better able understand programmer eliminate run time binding errors 
programmer choose mechanism suitable particular application range binding available construction system 
persistent systems extend range binding presenting user possibility persistent objects construction application 
traditionally programming languages database systems binding occurs name value strachey 
value bound name period evaluation program query 
extended burstall lampson include type atkinson morrison mutability 
binding mechanism components name value type indication value mutable 
complicate issue bindings may performed statically compiler dynamically run time system case intermediate stages 
nature binding mechanisms 
indicated binding mechanism components binding mutable value immutable value value 
binding performed 
scoping involved 
type checking performed 
bindings may immutable values constant values alter period binding mutable values locations binding change value referred location may change 
kinds bindings traditionally known programming language parlance value value bindings strachey 
manifest constants bcpl richards pascal wirth examples value bindings 
hand pascal variables examples value bindings compiler may bind name location particular value may vary run time 
binding performed particular environment 
binding part particular environment may bindings environment establish 
scope binding determines may 
common forms scoping programming systems static dynamic 
static scoping scope bound name detected static analysis program 
algol derived languages pascal ada utilize static scoping rule allows duplicate bindings detected table 
categorization binding static value static value dynamic value dynamic value static typing static scoping static typing dynamic scoping dynamic typing static scoping dynamic typing dynamic scoping statically 
dynamic scoping binding scope defined dynamic evaluation program 
dynamic scoping seen lisp mccarthy binding file names segment binding mechanism multics organick derived operating systems 
type checking performed statically compiler run time system 
dynamic type checking occurs run time system executes code ensure data correct type 
typically occurs called statically checked languages external data brought computation read statements shown earlier projections infinite unions 
categorization binding table 
different methods binding binding choices table 
static form static value binding static type checking static scoping 
dynamic form dynamic value dynamic type checking scoping 
interesting note particular language binding category 
example pascal category describes const values category variables category variant projections cases pascal category file names 
determining appropriate binding mechanisms particular system designer faced problem balancing safety flexibility manner similar type checking 
safety system derived able say prove program runs statically improve confidence correct 
aspect static checking overlooked programming systems source code acts better program documentation 
compiler statically check program programmer 
statically checked programs better documentation properties consequently better vldb journal atkinson orthogonally persistent object systems cost properties life cycle programs 
range times 
may argued spectrum binding mechanisms required persistent systems facilitate needs prospective programmers 
observations uses bindings creation new objects binding persistent store reuse existing objects program data new objects new combinations existing new objects incremental construction objects 
example programmer may wish bind statically combination objects persistent store case objects assembled new object bound 
hand programmer may wish obtain latest version object delaying binding object 
presence persistent environment programs compiled programs may refer persistent objects gives rise new perspectives binding 
extended scoping bindings need break bindings separation names values persistent bindings 
presence persistent environment programs composed compiled linked run extends scoping bindings persistent values 
source programs values static value bindings may program source persistent values 
source programs may contain evaluated values placed persistent store 
manifest program belong category programming systems 
advantage style binding shown dependent types shown lead concept hyper programming new technology available orthogonally persistent systems kirby 
persistent systems highlight need break bindings recreate context 
consider problem releasing systems 
ship system environment sensible ensure system fits new environment 
unix involves redefining shell variables late binding system calls new environment 
example application uses unix malloc system call unwise take local copy command shipped new environment 
environment persistent value includes graph values reached shipping values persistent system may involve copying complete graph 
usually desirable semantics value utility value new environment efficiency point view 
accommodate rebinding bindings broken dangerous activity 
proposal achieving rebinding safe manner farkas dearie 
allows bindings value broken producing wiring diagram broken bindings 
wiring diagram may rebound new environment value moved 
wiring diagram effectively data type may programmed achieve number varied 
mechanism special case linguistic reflection addressed specifically problem 
flexible binding possible separation concepts names values 
flexibility value may participate bindings names aliases 
importantly persistent systems name space separate value space allowing graph persistent values constitutes persistent store number name spaces layered 
application specific naming schemes supported arrangement 
noted polymorphism allows separation values types structural type equivalence allows separation names types dynamic typing allows separation names values 
example power orthogonal design 
skill persistent system deciding objects statically composed changed objects dynamically composed 
judicious mixture mechanisms provided system eager binding expected preferred style usage appropriate perform binding done safety delayed unnecessarily 
concurrency traditionally database programming language communities taken different approaches concurrency control 
programming languages concurrency control concept ordination set operating processes synchronization 
language constructs semaphores dijkstra monitors hoare mutual exclusion dijkstra path expressions campbell haberman message passing brookes provided support concept 
contrast databases concurrency viewed system efficiency activity allows parallel execution parallel access data 
database process may suffer abortion sustain illusion non interference 
key concept databases serializability eswaran led notion atomic transactions eswaran kung robinson supported locking eswaran optimistic concurrency control methods kung robinson 
cases user attempt understand computations terms global cohesion 
programming languages emphasis synchro vldb journal atkinson orthogonally persistent object systems 
spectrum understandability independent cooperative operation databases programming languages cohesion understood terms conflation synchronizations 
number techniques including ccs milner calculus milner developed help 
database systems global cohesion understood terms concept serializability eswaran includes failure semantics abortion 
taken munro 
illustrates spectrum understandability points view programming language database users 
illustrates databases tend atomic transactions enforce isolation ordinated sharing 
programming languages promote operation 
integrating databases programming languages designer unify established useful positions 
impetus come altogether persistence languages support atomic transactions databases require non serializable designer transactions ellis gibbs sutton nodine zdonik identified necessary respective communities 
camps agree ordinating set computations share data complex undertaking difficult characterize power behavior mechanisms difficult compare 
previous attempts provide concurrency orthogonally persistent systems focused single model morrison morrison provided mechanism extending synchronization provided basic persistent threads 
cps algol notable 
cps algol added constructs ps algol support processes persistent threads 
concurrency model operative synchronization conditional critical regions 
concurrency provided executing procedures separate threads 
primitives higher order functions ps algol range concurrency abstractions constructed including atomic nested transactions cooperative models 
revisited munro matthes schmidt 
goal user understand computations terms global cohesion cacs system stemple morrison morrison proposes mechanism integrating concurrency control programming languages databases :10.1.1.145.2614
takes point view difficulty stems low level nature mechanisms inherent complexity problem 
goal cacs approach control coherence sequences operations shared data understandable flexible manner 
essence system understandability separation concurrency control data formal capture path implementation 
global cohesion action cacs visualized movement data access sets 
visibility data users issue synchronization 
visibility coincides commit time atomic transactions may obtained visibility immediate synchronization 
viewing coordination data coordination movement data access sets data may different manner different times 
data may take part atomic transaction day saga operative computation 
goal allow interaction concurrency control methods 

technology support persistence overview crucial aspects technology needed support orthogonally persistence systems 
explanation intended sufficient trying implement persistence citations intended give entry pertinent literature 
intended readers aware involved convince orthogonal persistence feasible 
implementation architectures support persistent applications stable reliable store hold data execution mechanism execute programs required 
principal categories supporting architecture discriminated way major components provided way 
architectures recognized order increasing commitment persistence philosophy 
reported system fits precisely categories state vldb journal atkinson orthogonally persistent object systems development varies commercial products research prototypes 
combined existing systems 
designers may start existing data model relational object oriented combine existing language fortran cobol 
combination proceeds arranging notation perform bindings 
involves identification types data databases schemata views queries component programs methods 
database component operations manifest extending language providing library 
resulting combination may sympathetic original language varying degrees 
difficulties met limited overlap universes discourse 
type conceptual differences overcome syntactic noise introduced attempting combination 
obvious advantages capitalizing training utilizing polished existing system code continuing legacy code data relatively little re coding permitting multi lingual working database 
language data model reasonably sympathetic acceptable quality integration obtained example integration deux deux 
unrealistic architecture expect features programming language directly persistent data data types stored 
storage large collections objects standard relational system interesting example approach 
programmer full facilities build operate arbitrary group objects full relational facilities store retrieve groups 
programmers permitted store persistent groups 
implementations approach attempt leave language runtime system dbms unchanged 
typically run separate processes communicate messages 
extended existing systems 
approach takes place directions 
designers may start existing database extend complete type computational facilities may start language add persistence 
postgres example stonebraker 
commercial systems microsoft access microsoft fall category start relational model expand computational facility adding program interface generation facilities 
development object oriented facilities sql standard kulkarni corresponds approach 
version ps algol atkinson example second approach began extending algol morrison 
similarly pascal initially described addition relational capabilities long term storage pascal schmidt 
fundamental differences examples set leave language type system unchanged achieve orthogonal persistence set extend type system attempt data type complete persistence 
persistent systems continue developed second approach 
typically persistent versions richardson carey shapiro richardson carey persistent versions straw ml matthews nettles wing ada wileden reported 
persistent language takes form advantage converting existing software persistent behavior minimal effort 
construction persistent system extension existing system usually requires significant modifications original system run time system 
discussion focuses case programming language extended 
tasks automate obtaining type information programs accumulating schema storing representation interpretable values programs may stable transactional store identifying values promoted longevity detecting longer resources re arranging load program active store persistent data 
implementation involves new persistent store technology including recovery transactions space management 
variations regarding extent store technology tuned requirements particular language supported brown extent store builds clustering indexes bulk types 
cluet delobel matthes schmidt cluet moerkotte 
persistent extensions languages accept implement tasks listed 
example texas store singhal provides stable memory programs run 
consequence provides orthogonal persistence languages programs run unchanged store representation carry data changes parts support system automatic management object lifetimes task supported 
limitations consequence supporting language happens run store means isn complete reliable type system derive required information provide services 
systems integrated design 
systems developed integrated design tries experience programming languages databases starts afresh develop single system provides functionality systems 
examples vldb journal atkinson orthogonally persistent object systems napier morrison fibonacci albano tycoon matthes products esprit basic research action fide 
generally advantage conceptually simple compared preceding approaches 
usually manage provide full database facilities demonstrate complete repertoire incrementality transactions recovery concurrency distribution scalability 
appears consequence teams unable effort tackle issues fundamental limits 
support systems provide interface legacy code typically monolingual unique data model type system 
implementation achieve tasks identified 
persistent worlds 
categories discussed typically implemented standard operating systems unix windows nt 
advantage easier export research sites 
disadvantage extremely difficult obtain entirely consistent behavior reasonable efficiency platforms 
leads alternative line research totally new computational platform constructed 
may persistent operating system top languages achieve persistence automatically data consistent persistent behavior new hardware architectures associated operating systems 
typical grasshopper dearie eos gruber gruber fide product rosenberg proposals russell 
pay investing persistent technology apparent large application long period 
difficult properly evaluate technology investment building realistic load writing reasonable volume application software conducting evaluation long period atkinson atkinson 
currently systems build persistence operating system kernel received developmental effort enable support experimentation 
implementing persistence reachability support systems conforming architectures essentially extended systems implement persistence reachability automated data movement re space 
basic algorithms crucial tasks applicable architectures 
followed brief ways algorithms may refined 
table 
action taken de referencing pid discover resident false object fault overwrite pid corresponding la swizzle moss wilson de occur normal computational speed isn object fault read object keep record pid la mapping support steps swizzle overwrite pid la incremental loading swizzling 
persistent system provides means naming loading persistent roots kernel root suffice naming schemes multiple roots implemented persistent data structures code accessed primitive root 
persistent root contain objects contain objects 
data movement active store code operates initiated de referenced attempt object refer 
objects transfers may correspond exactly programmers think compilers may introduce mappings 
value accessed support system arranges loaded computation allowed continue 
typically forms address refer value persistent identifier pid long term reliability logical identification object interpreted mapping index flexibility permanence machine device disk address local address la form executing process current hardware virtual memory address 
different stores utilize different means discriminating forms operate performing roles issues discussed 
desirable arrange la encountered evaluation interrupted 
pid de referenced attempt value refers action table taken 
algorithm arrange long lived data required application automatically available program 
note step algorithm necessary record relationship pid current local address process 
information stored way accessible table called pid local address map 
called resident object table kemper kossmann 
accessed pid vldb journal atkinson orthogonally persistent object systems 
lazy incremental loading algorithm lone term store persistent roots active process store step table algorithm preserve sharing substructures la de swizzling see subsection 
illustrate automatic incremental loading process 
shows intermediate store state execution persistent program 
boxes represent objects may long term short term stores 
lines denote hook corresponding 
consider attached object holds persistent objects obtained starting persistent object pulling hooks emanate objects 
relevant steps program execution lead store state shown table 
promotion persistence checkpoint 
data flow active store long term store automated 
application programs time time request checkpoint part commit 
point objects brought long term store changed written back 
addition new objects reachable persistent root table 
steps incrementally loading data iin obtain persistent root attempt de pid object fault copy active store swizzle replace pid la attempt de pid object fault copy active store swizzle replace pid la obtain persistent root attempt de pid object fault copy active store swizzle pid la attempt de pid false object fault find pid swizzle pid la table 
algorithm promote objects longevity mutated mutated persistent objects promotions new object directly reachable mutated promotions promotions union new object directly reachable promotions repeat step additions allocate pids objects promotions transfer members mutated union promotions long term storage written long term store allocated space pid 
object written las object de swizzled refer pids 
pids allocated advance transfers correctly implement common sub structures cycles 
noted object promoted longevity persistent object updated hold referenced object promoted longevity 
promotion algorithm shown table 
effect algorithm illustrated aid shows part active store computation continued incremental loading 
mutated created new transient objects overwritten contains contains object referenced persistent newly formed object 
vldb journal atkinson orthogonally persistent object systems 
part active store mutation active process store table 
checkpoint store discover mutated set promotions set promotions allocate pids de swizzle pointers copy long term storage processing continue swizzle pointers steps checkpoint store state shown table 
carrying steps efficiently precisely unduly slowing execution checkpoint requires careful engineering 
copying step usually performed way recovery possible machine failure checkpoint 
example logs written agrawal de witt moss shadow pages brown munro 
garbage collection object termination 
persistence reachability implies object unreachable longer useful program execution access 
occupy space long term store opportunity exists reclaim space 
obvious method reachability garbage collection 
long term store usually held devices disk may grow large garbage collections may infrequent incremental 
implementor trades space density useful data garbage collection costs 
garbage collection traditionally solely recover space wilson :10.1.1.142.3082
garbage collections active store interact preceding algorithms important ways 
fail recover sufficient space normal methods release space discarding unmodified objects previously loaded 
requires pointers referenced discarded objects de swizzled major issue kemper kossmann 
discards unmodified objects insufficient space copy modified objects prematurely possibly falsely promote new objects steps checkpoint algorithm applied 
increases complexity subsequent checkpoint algorithms best avoided possible 
incrementally copy data log files recovery purposes kolodner kolodner 
additional operations may invoked garbage collection density objects fallen level thrashing set fenichel 
alternatively dynamic clustering may reduce thrashing benzaken 
engineering issues 
implementing preceding algorithms support conventional operating systems hardware presents challenges store designers 
choices illustrated 
long term form data may exactly required active store 
avoids costs complexity translation swizzling maintaining 
disadvantage scaling guaranteeing data normally code moved new platform hardware architectures change atkinson 
representation prevails small single user systems total copy virtual memory fast adequate 
larger shared systems kind memory mapping techniques koch rosenberg brown singhal munro 
object faults false object faults detected address translation unit protection line code de 
normally overhead transitions operating system boundary costs objects loaded 
data movement parts objects objects physical divisions pages groups disk blocks match hardware 
vldb journal atkinson orthogonally persistent object systems advantage accommodating large objects disadvantage increasing complexity object fault detection part image may need loading raster operation traverses 
second advantage cluttering working set resident objects require intermediate buffering additional copying 
kemper kossmann showed performance benefits 
methods avoid phantom locking checkpointing resident objects complicate implementation resilience 
third method advantage actual transfer exploits disk channel may gain optimizations support paging 
suffers brings active memory resident objects 
detrimental effect increase pas ages dynamic clustering algorithm operational 
swizzling carried various times 
swizzling time pid dereferenced advantage avoiding need overwrite costs look de 
feasible associative hardware supporting russell 
swizzling de pid advantage speed algorithms repeatedly traverse objects loaded involves updates objects may interfere hardware protection discover mutated set record generations generational garbage collectors cook 
object loaded pids swizzled 
wilson uses memory mapping page time wilson 
wilson scheme advantage avoiding costs detecting false object faults avoids system initiated writes objects 
cost allocating virtual address space rapidly restricting variation pid la page number part address preventing objects expanding translated 
translation objects permits longer longevity objects held canonical form derive particular architecture 
translation may combined decompression load compression transfer longer term storage 
performed page object time 
discovering mutated set checkpoint may achieved generating code compilation insert objects mutated set protection system detect update dynamically 
disadvantage incurs execution penalties subsequent updates object compiler clever optimization moss hosking 
disadvantage approximate objects protected region interacts uses protection system initiated updates 
list exhaustive 
major issues include allow objects span pages cluster prefetch allocate space pids promotion shadow paging logging pid encode store location 
designing persistent object store considerable challenge interaction plethora choices understood sampled 
type safe linguistic reflection type safe linguistic reflection defined stemple 
ability running program generate new program fragments integrate execution 
basis system evolution necessary achieve adequate pas longevity 
safety reasons strongly typed reflection considered 
linguistic reflection goal allowing program behavior adjust dynamically provide flexibility high productivity 
extends data modeling type system surprising find tension type systems reflection 
possibility program may significantly change behavior decreases opportunity static type checking compromises benefits typing 
reflective facilities controlled manner designed retain static type checking possible control severe remove benefits 
techniques type safe linguistic reflection evolved compile time linguistic reflection run time linguistic reflection 
compile time linguistic reflection stemple stemple allows user define generators produce representations program fragments 
generators executed part compilation process 
results viewed program fragments type checked part program compiled 
run time linguistic reflection dearie brown kirby kirby concerned construction binding new components existing components environment 
technique involves compiler called dynamically compile newly generated program fragments linking mechanism bind new program fragments running program 
type checking occurs compilation binding 
benefits type safe linguistic reflection database persistent programming consist mainly capabilities 
ability implement highly specifications query languages data models strongly typed programming language 
second ability accommodate continual changes data intensive applications resorting ad hoc restructuring methods 
capabilities involve reflective access types system changing approaches avoid introducing extra levels interpretation 
compile time run time reflection provided previous languages 
compile time reflection appears macro facilities scheme rees clinger pop burstall 
run time reflection appears eval functions lisp mccarthy snobol griswold vldb journal atkinson orthogonally persistent object systems function pop burstall 
type safe linguistic reflection different reasons 
information available reflective computation form systematically acquired types 
information automatically adjust implementation details system evolution 
strong typing linguistic reflection little systematic information available structures involved computation 
type safety newly generated program fragments checked allowed executed 
type discipline highly advantageous database programming environment integrity long lived data maintained 
somewhat ironic strong typing difficult integrate reflection typed programming languages linguistic reflection effective amplifier productivity 
type safe linguistic reflection attain high levels genericity stemple sheard accommodate changes systems dearle brown dearle examples 
implement data models cooper cooper cooper qin optimize implementations cooper fegaras stemple cutts validate specifications fegaras stemple 
importance technique provides uniform mechanism software production evolution 
formal description linguistic reflection stemple 

concentrate uses 
uses type safe linguistic reflection examples type safe linguistic reflection show reflection mechanisms appear level programming language 
examples abstraction types accommodating evolution strongly typed persistent systems 
abstraction types 
indicated earlier generic natural join function provides example abstraction types capabilities polymorphic type systems 
details input types particularly names tuple components significantly affect algorithm output type function determining result type code test tuples input relations match overlapping fields code build relation having tuples aggregation fields input relations copy overlapping fields 
type polymorphic natural join function va vb vc set set set function takes parameters sets returns third set result 
function written statically typed polymorphic procedure requires knowledge type structure explicitly abstracted 
type structure known particular call 
linguistic reflection allows written generic natural join interrogate structure input types 
point natural join called compiler input type structure 
compile time invocation compute specific natural join function input types call specific natural join 
generated code fed compiler checking code generation 
writing involves computing representations input types 
language provide facilities 
ability contrasts reflective language polymorphic systems 
run time reflection possible examine size representation input sets generate optimized algorithm 
evolution strongly typed persistent systems 
type safe linguistic reflection may accommodate evolution strongly typed persistent object stores 
characteristic stores set types existing values store evolves independently program 
means program written generated values may manipulate may exist types may known inclusion program text 
example program persistent object store browser dearie brown displays graphical representation value 
browser may encounter values persistent store static type description 
may occur example values added store time definition browser program 
program able denote values belong infinite union type type described earlier 
program contain static type assertions types may encountered number unbounded 
possibilities construction program may written lower level technology interpretation kirby dearie linguistic reflection 
allow reflective solution program able discover dynamically specific type value union type 
functionality may provided strongly typed language compromising type security defining representations types value space language 
illustrates linguistic reflection define programs operate values type known advance 
generic browser takes specification object type generates program browse 
may store program knowledge base encounter vldb journal atkinson orthogonally persistent object systems 
persistent store browser knowledge base object type 
programs potentially perform different operations type operands type security system invoking extra layer interpretation 
requirement programs typical evolving system new values types incrementally created necessity re define re compile existing programs 

achievements progress persistence research charted examining proceedings regular workshops held practitioners 
series international workshops pos persistent object systems dbpl database programming languages ad hoc events persistence tracks hicss hawaii international conference system sciences 
tabulated table wish scan literature 
contents proceedings cited table apparent large community researchers addressing persistence 
section reports achievements 
persistent languages developed displayed table 
aspects languages 
incremental construction pass long lived construction usually takes place incrementally 
requirement recognized resources available new suites software collections data added operational system 
databases supported incremental addition programs operational pas table 
major international meetings persistence researchers pos pos dbpl hicss pos dbpl security pos dbpl hicss pos dbpl pos hicss date venue organizers aug aug sep jan jan jun may sep aug jan sep aug sep sep jan scotland scotland france hawaii usa newcastle australia usa bremen germany martha vineyard usa greece hawaii usa san pisa italy manhattan ny usa france hawaii usa atkinson buneman morrison atkinson morrison bancilhon buneman atkinson morrison koch rosenberg hull morrison stemple rosenberg dearie shaw zdonik kanellakis schmidt morrison atkinson albano morrison beeri ohori shasha atkinson benzaken maier rosenberg dearie dynamic binding schemata views 
provision incremental growth schemata unrealistic view entire schema designed outset minor modifications need schema editor 
reality schema editor frequent little support change data models 
vldb journal atkinson orthogonally persistent object systems table 
database programming languages pascal schmidt smalltalk goldberg robson ps algol atkinson plain wasserman taxis mylopoulos shipman smith chan galileo albano modula koch persistent procedures atkinson morrison amber cardelli persistent prolog bailey cps algol experiment poly matthews opal dbpl matthes schmidt rapp hughes quest cardelli richardson carey hurst dps algol wai napier morrison quest matthes davie galileo brown deux hyper programming kirby commercial persistent tycoon matthes fibonacci albano napier version morrison persistence technology far developed adequate provision incremental addition collections programs providing dynamic binding constructs atkinson 
widely exploited prevalent persistent programming style dearie connor cutts 
incremental addition replacement program parts tends smaller incremental units traditional database technology 
retention types structure provision persistent bindings reduces complexity cost smaller units 
persistence technology takes different view construction schema 
normal consider design types time programs 
technology bias programs incremental types 
freedom bias appears pay offs 
outline design data completed early stored set type definitions detail postponed dynamic checking points 
programs required associated detailed 
hyper program store procedure hyper source en name pr cedure address name address lis types designed 
advantage requiring perturbation existing types allowing designers programmers concentrate particular subsystem types 
facilitate persistent systems developed mechanisms collecting types record hoped preserve modularity 
example quest modules cardelli napier declaration sets kirby 
hyper programming mentioned earlier presence persistent environment programs composed compiled linked run extends scoping bindings persistent values 
means objects accessed program may available time program composed 
source programs values static value bindings may program source persistent values 
bindings called links case included program traditional textual descriptions find persistent values 
source text program contains text links persistent values non flat representation program 
analogy hyper text program containing text links persistent values called hyper program kirby 
taken kirby 
shows example hyper program 
links embedded represented non textual tokens allow vldb journal atkinson orthogonally persistent object systems distinguished surrounding text 
link class procedure value writes prompt user 
program calls procedure read name finds address corresponding name 
done calling procedure lookup look address table data structure linked hyper program 
address written 
note code objects lookup denoted exactly mechanism data objects table 
note object names description associated objects clarity part semantics hyper program 
taken kirby 
shows example user interface programmer hyper program editing tool 
editor contains embedded light buttons representing hyper program links button pressed corresponding object displayed browser window 
browser select persistent objects linking hyper programs construction 
benefits hyper programming discussed farkas kirby kirby include capacity perform program checking early access path checking type checking linked components may performed program construction ability enforce associations executable programs source programs links source compiled versions may support source representations procedure closures free variables closures may represented links allowing hyper programs source run time representations programs increased program succinctness access path information specifying component located environment may elided 
persistent workshop methodologies persistent programmers need virtually tools programming environment required programmers editors compilers build managers version managers 
important differences requirements exploiting persistent technology provide environment needs met novel ways 
experiment underway building environment called persistent workshop 
experiment purposes demonstrate ease construction new functionality afforded developing workshop orthogonal persistence provide programming environment persistent programmers set example operational pas usage behavior may studied 

aceto hyper ram ri es rin en er name name address name estrin address ri estrin address ev sets tn es source operational code design material held persistent store 
tools communicate persistent store 
dynamically typed interfaces independent tool evolution requires flexibility 
workshop provides set tools extensive library components atkinson kirby 
examples subtly changed requirements tools arising persistence include tools provide means configuring workbench establishing style working particular view persistent store enable programmers limit complexity data choices open relevant task waite tools examine relationship persistent store programs enable programmers quickly appreciate existing structures verify results tools organize build libraries program parts data search libraries information retrieval techniques intended improve component re pas pass brown tools manage large number incremental units including providing aids building installing subsystems verify parts comply methodology tools assist change management 
tools exploit properties persistence 
example leave data structures persistent store accelerate subsequent operations 
vldb journal atkinson orthogonally persistent object systems example build manager store analyzers methodology checker change management aids rely able scan store knowing systems external information vital construction explicitly connected pas representation 
methodologies supported workshop 
closely allied traditional database practice 
pas construction proceeds design system conventional data model cooper qin 
types programs automatically derived 
works reasonably small scale scale incremental construction automated generation research issue 
uses methodology called sets delimit dependencies incremental components accurately 
involves choice particular ways persistent technology advantage build change processes automated 
persistent software engineering concept hyper program containing links persistent objects possible provision strong typing referential integrity number applications software engineering environments 
examples usage napier system flex system currie stanley stanley drummond vesta configuration management system chiu levin levin mcjones 
napier system contains fully functional hyper programming system addition contains prototype versions uses hyper links software engineering context morrison simplification programming model hyper code version control configuration management documentation 
advantages hyper programming ability representation source run time representations programs 
program composition time programmer may construct hyper program tool combination editor browser 
run time hyper program representation may represent active computation 
possible due non flat nature representation 
free values non local objects procedures may represented links inherent sharing values locations referred links preserved 
possible textual representations programs sharing lost 
hyper code abstraction allows single program representation programmer stages software development process 
constructing program programmer writes hyper code 
execution debugging run time error occurs browsing existing programs programmer sees hyper code representation 
programmer need know entities system may support reasons efficiency object code executable code compilers linkers 
maintained underlying system merely artifacts program stored executed completely hidden programmer 
set tools required manipulating hyper code simplifying user interface complexity system implementation 
permits concentration inherent complexity application support system 
software environments safer flexible name binding replaced hyper link 
replacement name bindings traditional software systems links reverse links ensures software component objects links remain accessible consequence persistence defined reachability 
version control configuration management documentation systems software items refer directly components relate 
program documentation may linked directly hyper links 
particular configuration may hyper link configuration script version may direct links related versions 
similar methods advantages accrue activities supported software environments discussed debugging profiling optimization cutts 
flex system currie stanley stanley drummond consists programming language supported persistent file store contains structured data 
flex language complete version algol ingredients required exploitation strongly typed persistent linkage persistent links capabilities case higher order functions strong typing 
flex concept hyper links called user interface representation 
source code may contain point persistent objects case typed files 
notion pairing source code executable code updated lock step flex 
vesta configuration management system chiu levin levin mcjones system allow overwriting place 
system unix inodes unique 
configurations guaranteed refer new file source changed 
support implementors re wrote unix system prevent update place support configuration management persistent links referential integrity 
build avoidance achieved caching function applications 
identities essential recognizing re evaluation argument 
vldb journal atkinson orthogonally persistent objec systems 
directions overview current state persistent system research 
commercial applications greenwood experimental ones grossman 
indicate promise orthogonally persistent object systems technology usable 
remains done achieve full potential persistence establish approach safely adopted industry 
avenues research development headings extensions persistence 
developments facilities integrated orthogonally persistent systems complete exploitation persistence 
persistent methodologies evaluation existing persistent technology delivering persistence 
continuing improvement engineering persistent support systems 
extension persistence extensions persistence fall categories necessary facilitate pas design construction maintenance operation established database context meet new needs currently technology 
meet requirement called database completeness facilities data modeling bulk types transactions distribution autonomy evolution deserve attention 
second requirement overlaps better data models informed research types varieties transactions complex transactions integrate recovery required contexts 
new extensions second category include seeking conceptual simplicity persistence combination programming languages sub systems user interface management systems operating systems communication systems 
conceptual modeling generic interfaces 
types describe data illustrated earlier 
argue type notations insufficiently descriptive fail exploit body knowledge regarding database design example models relational models semantic models object modeling 
remain application domains new group data modeling constructs useful 
utility providing extensible libraries type constructors requires validation realistic pas development environment 
new type constructors defined named pre existing pre defined constructors 
cooper extensively explored process mapping traditional data models types different languages reflection build aids performing mapping automatically cooper cooper qin cooper qin 
systems automatically generate types match data model text diagram schema editor 
generate usual interface components forms generators skeleton application programs relevant library persistent components 
aid transfer existing system design skills new technology migration designs rapid prototyping application construction 
expectation needs validated real applications 
developed specific mappings models persistent type systems stemple sheard hook wetzel albano 
approach mapping type systems reflection prove widely applicable relieve pressure type systems develop levels complexity difficult understand expensive implement 
remains seen code constructs accommodate changes specified terms higher level models generated automatically applied 
achieved provision high levels data independence automated wide range modeling styles atkinson 
probable considerable benefits gained generating code high level notations common orthogonally persistent system 
composite consistent behavior stress recovery 
expected reflective generation allow persistent target language simplified 
authors know exploration potential 
bulk types query languages optimization 
important component data models bulk types atkinson buneman atkinson 
value fold size collections represent allow description important regularities data permit exploitation regularity query notations optimization operations data movement 
shows certain classes bulk types treated consistently ohori trinder wadler breazu tannen buneman 
shown bulk types implemented mapping underlying system cooper qin ghelli matthes 
target system orthogonal persistence bulk values inherit persistence 
long argued mapping traditional database optimizations accomplished cooper 
optimization techniques convincingly demonstrated valid proposition 
potential problem standard primitives appropriate target cost models developed support optimization 
vldb journal atkinson orthogonally persistent object systems issue build add bulk types posed matthes schmidt 
resolution simple 
addition new bulk types required potential requirements anticipated 
definition terms primitives remain skilled craft 
attempt de extent provide appropriate target bulk types mapped generic primitive suggested atkinson 
languages continue designed built bulk types fibonacci 
reason issue query notations 
alternative approach worth exploration support appropriate notations reflection generate code suitable query notation 
query languages bulk types intimately interrelated context object models persistent type systems 
queries effectively expressed collections values objects may represented bulk types 
aspects query selection expressions may require expressions operation type language including bulk types 
transactions typical persistent systems implement recovery 
similarly typical database systems implement recovery effectively context serializable transactions 
show limitations sophisticated form transaction concurrency required 
research needed validate primitives constructors allow range transaction types concurrency models system stemple morrison munro :10.1.1.145.2614
generation translation technology anticipated prevent target complicated relieve programmers detail 
remains challenge develop recovery mechanism comprehensible behavior context full range transactions 
evolutionary constructs mechanisms 
infinite union dynamic types type provide basic requirements permit incremental changes types 
reflection permits software change environment accommodate change ways impossible recourse expensive interpretation operations 
exploration may combined support system evolution progress 
mechanisms changing program parts developed orthogonally persistent systems connor cutts executable code values replaced store updates connor 
challenges remain 
provide configuration version managers 
challenges part complex traditional technology types data associated types programs need consistently versioned configured 
persistent technology may come aid 
provision types data support reliable programming benefits combine assist construction tools morrison morrison 
provide convenient notations specifying change 
line attack schema edit higher level data process models generate underlying changes 
runs programmers provided extra information mappings unfeasible expect re supply change 
strategy support type editing types defined orthogonally persistent system 
pre supposes mappings comprehensible abandons generation high level notations 
change existing instances types 
strategy works stable anchor type accommodate extensions 
similar method commonly implementing object specializations fragments 
costs indirection type projections 
principle automated apart generating new values operated batch incremental mode 
trade offs implementation explored context 
managing change 
requires recording discovering dependencies performing impact analysis identifying localities need changed 
orthogonally persistent systems hold source code regime types data executable code 
possible search dependencies demonstrated 
development change management tools methodologies organizing persistent object stores handling consequences change tractable infancy 
provide appropriate change 
view mechanisms databases act change 
usually manually revised prevent propagation change explicit view identifies rapidly cases program possibly affected schema change 
parsimonious explicit bindings programs stores typified napier provides rapid elimination unaffected programs data types principle provide manually maintained change connor 
automated change absorption possible cases relevant methods mechanisms need development large scale applications atkinson 
unwise enterprise commit seriously technology support persistence confident adequately support schema change 
persistent systems imprecise type knowledge doubtful information safely support change 
vldb journal atkinson orthogonally persistent object systems distribution autonomy 
persistent systems locality data programmer need aware disk ram 
approach distributed orthogonally persistent systems continue location transparency wai koch gruber gruber dearie 
abstraction eventually may satisfy distribution achieve reliability performance distributing computation migrating computation data depends discovery adequate algorithms automating data program movement 
approach offers desirable semantic simplicity scale indefinitely fails accommodate change realistic approach failures mira da silva 
wish exploit knowledge processes network write efficient distributed persistent systems 
requires locality data exposed liskov liskov munro mira da silva 
tidy resolution conflicting requirements sight different researchers pursuing models 
obliq interesting compromise cardelli allows programmers indicate data method migrate explicitly specify locations 
generally providers pass provide high levels availability 
distributed systems prone various forms failure 
appears necessary give programmers access failure information may program availability inform users causes failures recovery expectations appropriate action highly application dependent 
provide information persistence abstraction compromised 
challenge programmers model distribution includes autonomy failure leave handle problems unaided 
important reason distribution ownership 
different parts system belong independent organizations retain right changes see fit 
autonomy fact independent distribution mechanisms support contribute scalability accommodation change atkinson 
crucial input persistence brings general search adequate models distribution autonomy commitment retaining simple combinable primitives raises additional implementation challenges 
scalable systems 
lifetime pas common experience massive growth contraction may difficult predict 
variations scale affect parts pas example meta data data program users accumulate successful parts pas parts may virtually 
technology required adapts possible sizes component collection 
range efficiently accommodated growing specific solutions large bodies data grossman need better adaptive algorithms 
limits performance expected algorithms manage data disk 
example disk garbage collection algorithms store re organization algorithms feasible arbitrarily large bodies interconnected data 
suggested approach introduce logical partitions assist scalability life cycle 
complementary strategy utilize replication parallelism distributed systems 
persistence researchers particularly difficult time verifying approaches scale evolution 
difficult resource experiments required scale realism duration 
integration domains 
safety simplicity orthogonally persistent systems achieved postulating closed world defined universe discourse determined type system defined extent meta data data program determined reachability 
totally worlds unrealistic transition persistence 
persistent systems connections external world example unix files unix shell commands 
sophisticated interfaces obviously needed 
remarked mapping data models supports skill transfer 
automatically generate bulk load unload programs type safe data models 
extended selective loading developed abiteboul 

data type complete rpc technology uses automatic generation interfaces reflection developed mira da silva problems overcome mira da silva 
kind rpc extended automatic translation interface connection processes languages 
long ago buneman demonstrated type safe interfaces generated external data collections buneman 
matthes repeated context persistent system matthes 
current persistent type systems permit external data repositories safely modeled data types 
reflection allows data types automatically generated needed avoiding high set costs large name spaces buneman mechanism 
similarly standard interfaces persistent system external system principle generated 
extensive generated safe interfaces investigated 
expected raise conceptual difficulties raised autonomy distribution 
exploiting persistence ways orthogonally persistent system research may exploited 
methodologies tools developed enhance utility existing envisaged systems 
concepts developed case vldb journal atkinson orthogonally persistent object systems re applied particular programming languages oodbms modified utilize results 
building observing persistent exemplars 
developers orthogonally persistent systems believe systems ready serious evaluation 
wider needed test utility provide feedback implementors engineering issues better understood 
issues apparent usage involves large volumes program data 
crucial effective evaluation generation useful characterizations load usage systems realistic sense operational loads data sets programmers users changes typical real applications 
experiments sufficient resources explore critical issues adequate scale sufficient elapsed time atkinson 
quality engineering depends systematic measurements 
persistent community needs develop system models measurement technology practices pas loads corresponding performance pass accurately described compared design trade offs reliable information atkinson 
type safe linguistic reflection 
reflection especially significant persistent systems program generation costs amortized applications persistent memoization basis system evolution 
important roles allows adaptive behavior programmed facilitates writing processors specialized notations target persistent language 
techniques demonstrated 
lines research identifiable 
research improve notations libraries available writing reflexive programs underway cooper kirby kirby 
elimination noise generated embedding representations program programs probably relatively easily achieved 
challenging task help programmer think simultaneously accurately computations computation form new code computation code eventually perform 
part challenge may apparent way environments computations relate 
research needed explore full potential reflection 
examples mentioned construction optimized strategies computations bulk values observed properties values simplification target persistent languages ready availability reflection 
research provision data models user interface generators underway 
research reflection generating safe external interfaces continue 
reflection automate management consequences change new area ripe exploration 
just possible applications reflection deserving exploration 
advent type safe reflection tools assist programmers explosion applications 
may important important extract identify effective methodologies reflection enable programmers 
methodologies tools 
constructing application systems orthogonal persistence allows new techniques new structures 
example structural information lost obscured left store program trend partitioning applications smaller units 
example libraries application programs built incrementally persistent store transactional mechanisms application uses 
permits incremental construction replacement small units program data system 
experience gained writing pass methodologies appropriate new technology emerging dearie conner 
require development need accessible application programmers variety persistent technologies including oodbms provision tutorials tools exemplars 
crucial making methodologies usable provision appropriate persistent programming environment 
experiments underway direction hyper programming workbench connor pipe programming environment dearie persistent workshop sjoberg 
hyper programming workbench allowing experiments new construction techniques construction time type checking 
persistent workshop provides set tools help programmers including specialized editors automated binding resolution compilers library management tools including aids finding components information retrieval techniques intended help programmers understand state persistent store 
tools continue develop programming aids 
tools derive dependencies automate re compilations re executions development lie boundary supporting individual programming supporting software engineering 
methodology accurately followed tools precise 
consequently facilities verifying consistency methodology development sj berg 
methodology chosen belief facilitate change processes dominate pas life cycle 
verified advice programmers consequences change infancy 
vldb journal atkinson orthogonally persistent object systems influencing technologies 
results achieved applying persistent design principles applied domains 
areas persistence results beneficial influence programming languages oodbms operating systems 
existing commercial programming languages ada commonly building pass 
natural desire produce persistent versions 
persistence results show done safely types value known unambiguously 
probable worthwhile establish persistent dialects languages 
time time new programming languages emerge 
designers languages omitted important feasible facilities fail include orthogonal persistence 
object oriented databases path similar followed persistent technology 
persistent experience guide oodbms design implementation 
example basing persistence reachability identified persistent roots providing orthogonal persistence appears obvious adopted bancilhon 
oodbms benefit properly incorporating stored program methods persistent store consistent bindings code data maintained morrison 
operating systems provide non orthogonal weakly typed persistence form file stores 
apparent complexities environments unix orthogonal persistence better defined models binding persistent store significant advantage 
underway persistent operating systems view having facilities supporting persistent programming generally efficient way 
certainly requirements orthogonal persistence place new demands low level mechanisms provided operating systems 
persistence research influence way operating systems storage facilities facilities offer system implementors 
persistence may role play databases programming languages main focus date applied relationship programs operating systems 
naming binding typing rules operating system facilities files system calls language 
course case databases ultimately evolve meet common requirements 
delivering persistence reasonable scale performance obtained current orthogonally persistent technology continuing search better engineering 
challenge develop persistent object stores provide full range facilities collections data bytes terabytes 
models providing persistence 
provision library standard language 
may useful pragmatic intermediate step believe lead safe comprehensible pas building facilities 
combination era standard language separate store 
commercially active line attack various oodbms vendors combine product various languages 
reality modify implementation language adapt provisions store 
valid intermediary process 
may difficult give satisfactory results long term due lack reliable type information inconsistent behavior system stressed 
certainly potential approach support pas evolution investigated commercially critical 
integrated design provision 
approach taken persistent programming community 
clearly radical risky departure commercial practice 
technology mature relational technology explored commercially 
rebuilding support system 
approach starts construction persistent operating system hardware longer term program research 
results persistent support systems continue conflict operating systems cost performance possibly reliability 
avenue research important develop technology required persistent systems prevalent 
building operational quality systems take forms real potential orthogonally persistent systems verified atkinson 
efficient object stores 
strategies wide provide persistent object stores constructing standard operating systems block transfers files 
advantage portability 
constructing standard operating systems memory mapping technology 
exploits paging hardware locality may suffer slow operating system interfaces inappropriate protection granularity 
advantage running programs written non persistent language persistent mode singhal 
constructing light weight specialized operating systems memory mapping 
cases experiments exploit specialized hardware 
little portability available performance gains unproven 
orthogonal class design decisions extent longterm form object differs active computational form 
example vldb journal atkinson orthogonally persistent object systems pointers radically different koch moss suzuki kemper kossmann code target independent atkinson data may compressed encrypted 
variations detail currently explored example mechanisms recovery 
clear space alternative store designs large poorly charted 
research needed develop reliable information guide store implementors provide high performance stores predictable behavior range loads 
situation complex forms distributed persistent store attempted 
experiments client server technology dearie far authors know little generally distributed stores connected machines 
efficient bulk types 
requirements bulk types established atkinson buneman implementation received attention database community 
key achievements transferable persistent context 
may result pressure change aspects store implementation language primitives 
compromise totally add totally built provision prevail eventually 
full scale optimization implemented better mathematical models store behavior 
need vigorously sought experimentally validated 
code generation reflexive higher order persistent languages 
difficulties code generation higher order languages 
example convenient intermediate target language avoid computer architecture specificity 
requires techniques handling higher order procedures appel 
orthogonal persistence requires generated code reside transactional stable store 
consequently code precisely procedure closures represented objects shipped store garbage collected stabilized atkinson morrison 
furthermore procedures may generated execution consequence run time reflection 
distribution longer term persistence required procedures loadable architecture 
combination requirements challenging 
consequently prototype code generators exist meet requirements 
pre populated stores 
persistent store shipped pre populated form object oriented languages oodbms example smalltalk persistent virtual image 
challenge determine go initial population find ways organizing accessing enable majority programmers facilities 
pre population contain extensive library useful code contain useful data structures tables unit conversion constants cartographic images pictures 
furthermore range code usefully shipped includes access algorithms trees trees tuned match properties shipped store 
development consideration issues conducted wide community researchers eventually pas equivalent numerical algorithms libraries convenient mechanisms 
typically new releases store populations built users earlier version may want preserve avail new libraries 
just example collection problems concerned merging replacing shipping subsets objects store stores 

summary overview orthogonally persistent systems starting motivation design principles 
achieve simplicity consistency regularity 
lack exceptions enhances power reduction issues dealt programmers reduces application design construction maintenance costs 
languages systems achieve orthogonal persistence reported 
crucial achievement integrating database programming requirements recognition close relationship schema types 
challenge obtaining correct balance precision description addressed type operators concomitant polymorphism 
allows adaptable type systems developed power similar existing data models extensibility necessary long term service connor connor morrison :10.1.1.145.2614
dynamic checking points type system serves purposes allows type checking incremental feasible large applications allows incremental binding permits localization schema changes subgraphs delimited points 
support incremental evolution persistent applications requires new binding mechanisms utilize dynamic checking provide consistent naming schemes applications 
development constructs provide concurrency transactions recovery taken lacks unifying concepts cover full range possibilities sought databases available programming languages 
solutions exist important subdivisions space lines research rapidly expanding 
research focused support orthogonally persistent systems 
architectures explored 
committing involves extending existing system libraries possibly pre processors 
provide short term benefits risks fundamental limitations longer term 
common strategy combine existing systems 
operated vldb journal atkinson orthogonally persistent object systems early days databases degree integration advanced considerably advent 
may leave programmers coping models particularly concerned failure semantics symptoms system stress 
may find perform mappings representations diminished 
integrated systems constructed standard computing environments 
achieve desired consistency portable 
necessary intermediary path wider orthogonally persistent systems long term utility 
drawback operate environment tuned different style computation may efficiency problems due mismatch 
may challenges current implementors feasible supporting operating systems hardware evolve meet new needs architecture 
final architecture may viewed prototyping evolution platform radical transition 
architecture underlying operating systems hardware re designed re implemented provide orthogonal persistence systems support 
radical replacement persistent support system eventually adopted benefit ensuring consistent persistent behavior stress software data supported simplifying tasks programmers users 
avenues research effort goes object store design 
challenge find mechanisms object movement representation translation concurrency transactions recovery space management combine available hardware software platforms 
size load parts persistent system vary dramatically applications lifetimes applications 
consequently considerable interest adaptive algorithms 
persistent object store technology quite sophisticated deliver reasonable performance full functionality specific areas design space 
type safe linguistic reflection developed extensively context persistent systems reasons enables systems evolve allows specialized notations equivalent types programs generated persistent language permits safe computations types yielding greater genericity 
technologies substantial applications built 
construction maintenance uses incremental techniques originated database programming finer grain general incrementality possible 
applications tools programming environments support persistent programming exploit potential persistence give reliable access contextual information 
hyper programming supported environment 
new technique program construction forms static bindings source program representation values store source edited 
uses persistence constructing programming environments software engineering tools demonstrate viability persistent technology ability support new tools flexibly coupled store preserves structural information affords continuous type safety 
software engineering tools particularly exploit reliable data modeling tools substantial reflection 
avenues research pursued persistent systems opening 
main avenues research extension persistence results contexts exploitation potential persistence facilitate new applications sophisticated computational requirements search improved engineering persistent support systems 
fifteen years research orthogonally persistent systems reached point wider community 
researchers build applications complex long term data may accelerate experiments mature persistent systems 
designers programming languages operating systems database systems examine results obtained orthogonal persistence view incorporating best relevant designs 
ideally mature research systems commercially supported new technology evaluated seriously realistic 
authors acknowledge support european union fide esprit basic research action british epsrc epsrc gr drastic epsrc gr 
authors grateful generous help preparing graham kirby miguel mira da silva cutts paul ray 
helpful comments peter bailey richard connor richard cooper peter evans stewart dave munro susan spence cathy waite 
abiteboul cluet milo querying updating file 
proceedings nineteenth international conference ry large data bases dublin ireland 
agrawal de witt recovery architectures multiprocessor database machines 
proceedings sigmod international conference management data austin tx 
ooi software development japanese approach 
ieee software 
vldb journal atkinson orthogonally persistent object systems albano ghelli orsini object data model roles 
proceedings nineteenth international conference ry large data bases dublin ireland 
albano ghelli orsini database programming language fibonacci 
vldb journal 
albano cardelli orsini galileo strongly typed interactive conceptual language 
acm transactions database systems 
albano dearie ghelli marlin morrison orsini stemple framework comparing type systems database programming languages 
hull morrison stemple eds database san francisco ca morgan kaufmann pp 

albano morrison eds 
persistent object systems implementation 
berlin springer verlag 
appel compiling continuations 
cambridge uk cambridge university press 
atkinson programming languages databases 
proceedings fourth eee international conference large databases berlin 
atkinson persistent foundations scalable multi systems 
proceedings international workshop distributed object management edmonton canada 
atkinson bailey christie bulk type libraries napier 
esprit bra project fide technical report fide 
atkinson bailey chisholm cockshott morrison approach persistent programming 
computer journal 
atkinson bailey ej chisholm cockshott morrison progress persistent programming 
em atkinson gray eds 
database role structure cambridge uk cambridge university press pp 

atkinson benzaken maier persistent object systems 
proceedings sixth international workshop persistent object systems france 
atkinson jackson measuring persistent object systems 
albano morrison eds 
persistent object systems berlin springer verlag pp 
atkinson buneman types persistence database programming languages 
acm computing surveys 
atkinson buneman morrison proceedings persistence data types workshop 
universities glasgow st andrews technical report 
atkinson buneman morrison persistent object systems design implementation 
universities glasgow st andrews technical report 
atkinson buneman morrison binding type checking database programming languages 
computer journal 
atkinson buneman 
morrison eds 
data types persistence 
new york springer verlag 
atkinson chisholm cockshott ps algol algol persistent heap 

atkinson chisholm cockshott cms chunk management system 
software practice experience 
atkinson richard design issues map language 
kanellakis schmidt eds 
bulk types persistent data san fransisco ca morgan kaufmann pp 

atkinson maier benzaken eds 
persistent object systems 
berlin springer verlag 
atkinson morrison procedures persistent data objects 
acm transactions programming languages systems 
atkinson morrison integrated persistent programming systems 
proceedings nineteenth international conference systems sciences hawaii 
atkinson morrison polymorphic names types constancy magic type secure persistent object store 
proceedings second international workshop persistent object systems scotland 
atkinson morrison coordinators persistent systems track 
proceedings second conference systems sciences hawaii 
atkinson morrison designing persistent information space architecture 
proceedings tenth ifip world congress dublin ireland 
atkinson morrison managing change persistent object systems 
proceedings international symposium object technologies advanced software kanazawa japan 
bancilhon benzaken delobel pfeffer richard velez design implementation object oriented database system 
dittrich ed 
lecture notes computer science berlin springer verlag pp 
bancilhon buneman eds 
advances database programming languages 
reading ma addison wesley acm press 
bancilhon delobel kanellakis eds 
story building object system 
san francisco ca morgan kaufmann 
beeri ohori shasha database programming languages 
proceedings fourth international workshop database programming languages object models languages new york 
vldb journal atkinson orthogonally persistent object systems benzaken delobel harms clustering strategies objectoriented database system 
esprit bra project fide technical report fide 
berman pascal data oriented persistent programming language 
phd thesis university cape town 
bailey ej 
logic languages relational dbmss point convergence 
proceedings second workshop persistent object systems scotland pp 
ed 
eclipse integrated project support environment 
peter 
breazu tannen buneman naqvi structural recursion query language 
proceedings third workshop database programming languages greece 
maier stein williams williams gemstone data management system 
kim lochovsky eds object oriented concepts databases applications reading ma addison wesley acm press pp 
brookes hoare roscoe theory communicating sequential processes 
carnegie mellon university technical report cmu cs 
brown distributed stable store 
universities glasgow st andrews technical report 
brown persistent object stores 
ph thesis university st andrews 
brown cockshott persistent object management system 
universities glasgow st andrews technical report 
brown matthes open system architecture persistent object store 
proceedings fifth international conference systems sciences hawaii 
brown morrison generic persistent object store 
software engineering journal 
brown library explorer napier glasgow libraries 
msc thesis university glasgow 
bruynooghe parker pss system process enactment 
proceedings international conference software process manufacturing complex systems 
buneman hirschberg root integrating high level programming languages 
proceedings second british national conference databases bristol england 
buneman libkin suciu tannen wong comprehension syntax 
acm sigmod record 
burstall collins programming pop 
edinburgh university press edinburgh scotland 
burstall lampson kernel language data types modules 
proceedings international symposium semantics data types sophia antipolis france 
dearie brown vaughan ea 
compiler target language native code generation persistent systems 
proceedings sixth international workshop persistent object systems france 
campbell haberman specification process synchronisation path expressions 
lecture notes computer science berlin springer verlag 
cardelli amber 
lecture notes computer science berlin springer verlag pp 
cardelli typeful programming 
dec technical report 
cardelli obliq language distributed scope 
computing systems 
cardelli macqueen persistence type abstraction 
atkinson buneman morrison eds 
data types persistence berlin springer verlag pp 
cardelli wegner understanding types data abstraction polymorphism 
acm computing surveys 
chan dayal fox ada compatible distributed database management system 
proceedings ieee special issue distributed databases pp 
chiu 
levin vesta repository file system extension software development 
dec systems research center technical report 
schema evolution integration 
distributed 
cluet delobel unification rewrite optimisation techniques object oriented queries 
esprit bra project fide technical report fide 
cluet moerkotte nested queries object bases 
esprit bra project fide technical report fide 
cockshott atkinson chisholm bailey morrison persistent object management system 
software practice experience 
connor types polymorphism persistent programming systems 
ph thesis university st andrews 
connor atkinson berman cutts kirby morrison joy sets 
proceedings fourth international conference database programming languages new york 
connor brown cutts dearie morrison rosenberg type equivalence checking persistent object systems 
proceedings fourth international workshop persistent object systems martha vineyard 
vldb journal atkinson orthogonally persistent object systems connor cutts kirby moore morrison unifying interaction persistent data program 
proceedings second international workshop user interfaces databases 
connor cutts kirby morrison persistence technology control schema evolution 
proceedings computing phoenix az 
connor dearle morrison brown existentially quantified types database viewing mechanism 
proceedings second international conference technology venice italy 
connor morrison subtyping assignment database programming languages 
proceedings third international workshop database programming languages greece 
connor morrison subtyping tears 
proceedings fifteenth australian computer science conference hobart 
cook wolf zorn performance partitioned garbage collection object databases 
university colorado technical report cu cs 
cooper configurable data modeling systems 
proceedings ninth international conference entity relationship approach lausanne switzerland 
cooper utilisation persistent programming environments 
ph thesis university glasgow 
cooper atkinson dearle constructing database systems persistent environment 
proceedings thirteenth international conference ty large data bases location 
cooper kirby type safe linguistic run time reflection practical perspective 
proceedings sixth international workshop persistent object systems france 
cooper qin graphical data modelling program constraint specification management 
proceedings tenth british national conference databases aberdeen 
cooper qin generic data model support multiple user interaction facilities 
proceedings international conference entity relationship approach 
currie filestore modes flex 
proceedings workshop persistent object systems scotland 
curtis kellner process modeling 
communications acm 
cutts delivering benefits persistence system construction execution 
ph thesis university st andrews 
cutts connor kirby morrison execution driven approach code optimisation 
proceedings seventeenth australasian computer science conference christchurch new zealand 
dahl nygaard simula algol simulation language 
communications acm 
davie statically typed applicative persistent language environment manual 
st andrews technical report cs 
gruber customizing concurrency controls graph locking capabilities 
proceedings sixth international workshop persistent object systems france 
dearie construction persistent programming environments 
ph thesis university st andrews 
dearie environments flexible binding mechanism support system evolution 
proceedings second conference systems sciences hawaii 
dearie brown safe browsing strongly typed persistent environment 
computer journal 
dearie cutts kirby browsing grazing persistent data structures 
proceedings third workshop persistent object systems newcastle australia 
dearie di bona rosenberg vaughan grasshopper orthogonally persistent operating system 
computer systems 
dearie marlin dart hyperlinked persistent software development environment 
proceedings hyper oz workshop activities australia adelaide australia 
dearie rosenberg ea vaughan examination operating system support persistent object systems 
proceedings fifth international conference system sciences hawaii 
dearie shaw zdonik eds 
implementing persistent object bases principles 
san francisco ca morgan kaufmann 
deux story 
eee transactions knowledge data engineering 

deux system 
communications 
dijkstra cooperating sequential processes 
ed programming languages 
academic press pp 

dijkstra structure multiprogramming system 
communications 
ellis gibbs concurrency control groupware systems 
proceedings acm sigmod international conference management data portland 
eswaran gray lorie traiger notions consistency predicate locks database system 
communications 
vldb journal atkinson orthogonally persistent object systems farkas dearie octopus reflective language mechanism object manipulation 
proceedings fourth international conference database programming languages new york 
farkas dearie kirby cutts morrison connor persistent program construction browsing user gesture typing 
proceedings fifth international workshop persistent object system san italy 
fegaras sheard stemple uniform traversal combinators properties 
proceedings eleventh conference automated deduction cade saratoga springs ny 
fegaras stemple type transformation database system implementation 
proceedings third international workshop database programming languages greece 
fenichel lisp garbage collector virtual memory systems 
communications 
ghelli orsini paz trinder design integrated query manipulation notation database languages 
esprit bra project fide technical report fide 
goldberg robson smalltalk language implementation 
reading ma addison wesley 
greenwood guy robinson persistent language implementation process support system 
icl technical journal 
griswold snobol programming language 
englewood cliffs nj prentice hall 
grossman qin xu ramamoorthy managing physical objects nodes 
proceedings sixth international workshop persistent object systems france 
gruber eos environment persistent distributed applications shared object space 
ph thesis universit pierre marie curie paris vi 
gruber valduriez eos environment object systems 
proceedings fifth international conference systems sciences hawaii 
hammer mcleod database description sdm semantic database model 
acm transactions database systems 
han welsh methodology modelling combining software processes software products 
university queensland software validation centre technical report 
hoare monitors operating system structuring concept 
communications 
hughes connolly data abstraction transaction processing database programming language bancilhon buneman eds 
advances database 
reading ma addison wesley acm press pp 

hull morrison stemple database programming languages 
proceedings second international workshop database programming languages 
hurst capability language persistent programming 
rosenberg koch eds 
persistent object systems 
berlin springer verlag pp 

kanellakis schmidt eds 
database programming languages bulk types 
menlo park ca morgan kaufmann 
kemper kossmann adaptable pointer swizzling strategies object bases design realization quantitative analysis 

king ibm report contents sample programs surveyed 
san jose ca ibm 
kirby persistent programming strongly typed linguistic reflection 
proceedings fifth international conference systems sciences hawaii 
kirby reflection hyper programming persistent programming systems 
ph thesis university st andrews scotland 
kirby brown connor cutts dearie moore morrison munro napier standard library manual version university st andrews technical report cs 
kirby connor cutts dearie farkas morrison persistent hyper 
proceedings fifth international workshop persistent object systems san italy 
kirby connor morrison start linguistic reflection tool hyper program technology 
proceedings sixth international workshop persistent object systems france 
kirby dearie adaptive graphical browser napier 
university st andrews technical report cs 
koch dearie vaughan marlin barter cache coherence storage management persistent object system 
dearie shaw zdonik eds 
object bases 
menlo park ca morgan kaufmann pp 

koch mall reimer schmidt modula report version 
eth 
kolodner recovery virtual memory 
sc 
thesis university mit 
vldb journal atkinson orthogonally persistent object systems kolodner liskov weihl atomic garbage collection managing stable heap 
proceedings acm sigmod international conference management data portland 
building flexible multilevel transactions distributed persistent environment 
proceedings second workshop persistent object systems scotland 
transactions concurrency 
universities glasgow st andrews technical report 
kulkarni adt type system sql 
freytag maier vossen eds 
query processing advanced database systems 
san francisco ca morgan kaufmann 
kung robinson optimistic methods concurrency control 
acm transactions database systems 
design effective software visualizations persistent programming languages 
esprit bra project fide technical report fide 
visualizing persistent stores 
esprit bra project fide technical report fide 
levin mcjones vesta approach precise configuration large systems 
dec systems research center technical report 
liskov distributed programming argus 
communications 
liskov johnson gruber shrira highly available object repository heterogeneous distributed system 
proceedings fourth international workshop object systems martha vineyard 
matthes generic database programming linguistic architectural framework 
ph thesis university hamburg 
matthes schmidt object stores servers persistent programming environments quest experience 
esprit bra project fide technical report fide 
matthes tycoon language tl 
university hamburg technical report dbis 
matthes schmidt persistent polymorphic programming tycoon 
esprit bra project fide technical report fide 
matthes schmidt type system dbpl 
proceedings second international workshop database programming languages 
matthes schmidt bulk types built add 
third workshop database programming languages greece 
matthes schmidt definition tycoon language tl preliminary report 
university hamburg technical report fbi hh 
matthes schmidt persistent threads proceedings twentieth international conference ry large data bases santiago chile 
matthews poly report 
university cambridge technical report 
matthews persistent storage system poly 
cambridge university 
matthews papers poly ml 
cambridge university 
mccarthy edwards hart levin lisp programmers manual 
cambridge ma mit press 
microsoft 
microsoft access building applications 
microsoft 
microsoft access user guide 
milner theory type polymorphism programming 
journal computer system sciences 
milner lecture notes computer science vol 
calculus communicating systems 
berlin springer verlag 
milner polyadic calculus tutorial 
university edinburgh technical report ecs lfcs 
mira da silva automating type safe rpc 
proceedings fifth international workshop research issues data engineering distributed object management taipei taiwan 
mira da silva atkinson black semantics parameter passing type complete persistent rpc 
esprit bra project fide technical report fide 
morrison development algol 
ph thesis university st andrews 
morrison atkinson persistent object systems 
proceedings fifth international conference systems sciences hawaii 
morrison atkinson dearie flexible incremental bindings persistent object store 
universities glasgow st andrews technical report 
morrison baker connor cutts kirby approaching integration software environments 
university st andrews technical report cs 
morrison barter brown connor dearie hurst language design issues supporting computation persistent environments 
proceedings second international conference systems sciences hawaii 
morrison barter connor kirkpatrick munro stemple concurrency control process models 

morrison brown connor dearie integration object oriented process oriented computation persistent environments 
dittrich ed 
lecture notes computer science 
berlin springer verlag pp 

vldb journal atkinson orthogonally persistent object systems morrison brown connor dearle atkinson polymorphism persistence software reuse strongly typed objectoriented environment 
software engineering journal december pp 

morrison brown connor dearie atkinson napier type system 
proceedings third international workshop persistent object systems newcastle australia 
morrison brown connor cutts dearle kirby munro napier manual release 
university st andrews technical report cs 
morrison brown connor cutts kirby dearle rosenberg stemple protection persistent object systems 
proceedings international workshop security persistence bremen 
morrison brown connor dearle napier manual 
universities glasgow st andrews technical report 
morrison brown dearle atkinson integrated graphics programming environment 
computer 
morrison brown dearle atkinson classification binding mechanisms 
information processing letters 
morrison connor cutts kirby exploiting persistent linkage software engineering environments 
computer journal 
morrison connor cutts kirby persistent possibilities software environments 
proceedings icse workshop intersection databases software engineering sorrento italy 
morrison dearle bailey brown atkinson persistent store enabling technology integrated project support environments 
proceedings eighth ieee international conference software engineering london 
morrison dearle connor brown ad hoc approach implementation polymorphism 
acm transactions programming languages systems 
moss managing persistent data mneme designing reliable shared object interface 
advances object oriented database systems 
berlin springer verlag pp 

moss working persistent objects swizzle swizzle 
coins university massachusetts technical report 
moss hosking expressing object residency optimizations pointer type annotations 
proceedings sixth international workshop persistent object systems france 
munro integration concurrency distribution persistence 
ph thesis university st andrews 
munro connor morrison stemple concurrent shadow paging architecture 
proceedings sixth international workshop persistent object systems france 
mylopoulos bernstein ra wong language facility designing database intensive applications 
association computing machinery transactions database systems 
nettles wing persistence transactions 
proceedings fifth international conference systems sciences hawaii 
nodine zdonik cooperative transaction hierarchies transaction support design applications 

ohori buneman breazu tannen database programming machiavelli polymorphic language static type inference 
proceedings sig mod 
organick multics system examination structure 
cambridge ma mit press 
powell adding programming facilities data store 
proceedings international workshop persistent object systems scotland 
ps algol 
ps algol manual th edition 
universities glasgow st andrews technical report 
rees clinger revised report algorithmic language scheme 
acm 
carey lehman pirahesh srinivasan making real data persistent initial experiences 
proceedings sixth international workshop persistent object systems france 
richards bcpl language compiler 
cambridge uk cambridge university press 
richardson carey persistence language issues implementation 
spe 
richardson carey implementing persistence rosenberg koch eds 
persistent object systems 
berlin springer verlag pp 

rosenberg monads architecture layered view 
proceedings fourth international workshop persistent object systems martha vineyard 
rosenberg dearle proceedings distribution concurrency persistent systems 
proceedings eighth conference systems sciences hawaii 
rosenberg brown morrison munro stability persistent store large virtual memory 
proceedings international workshop security persistence bremen germany 
rosenberg eds 
security persistence 
berlin springer verlag 
vldb journal atkinson orthogonally persistent object systems rosenberg koch persistent object stores 
proceedings third international workshop persistent object systems newcastle australia 
generic logging service 
proceedings eleventh eee symposium reliable distributed systems houston tx 
russell dolphin persistent object oriented networked 
ph thesis university strathclyde 
russell shaw cockshott object addressed processor cache 
proceedings sixth international workshop persistent object systems france 
schaffert cooper trellis object environment language manual 
dec systems research center 
connor morrison moss munro cost model database crash recovery mechanisms 
university st andrews technical report cs 
schmidt high level language constructs data type relation 
acm transactions database systems 
schmidt matthes database programming language dbpl rationale report 
esprit bra project fide technical report fide 
programming opal 

shapiro persistence migration objects 
proceedings european conference object oriented programming 
sheard automatic generation structure operators 
acm transactions programming languages systems 
sheard hook type safe meta programming 
oregon graduate institute 
sheard stemple automatic verification database transaction safety 
acm transactions database systems 
shipman functional data model data language association computing transactions database systems 
singhal kakkad wilson er 
texas efficient portable persistent store 
proceedings fifth international workshop persistent object systems san italy 
thesaurus tool meta data management 
esprit bra project fide technical report fide 
thesaurus methodologies tools maintaining persistent application systems 
ph thesis university glasgow 
atkinson lopes trinder building integrated persistent application 
proceedings fourth international conference database programming languages new york city 
sjoberg atkinson thesaurus software environments 
proceedings icse workshop intersection databases software engineering sorrento italy 
cutts atkinson analysing persistent language applications 
proceedings sixth international workshop persistent object systems france 
ec waite build management database programming language environments 
esprit bra project fide technical report fide 
smith fox manual 
computer america technical report cca 
sommerville potter smart eclipse user interface 
software practice experience 
stanley evaluation flex pse 
defence research agency england technical report 
stanley drummond flexible basis software configuration management 
defence research agency england technical report 
stemple fegaras sheard exceeding limits polymorphism database programming languages 
bancilhon tsichritzis eds 
lecture notes computer science berlin springer verlag pp 

stemple morrison specifying flexible concurrency control schemes operational approach 
proceedings fifteenth australian computer science conference hobart 
stemple sheard fegaras linguistic reflection bridge programming database languages 
proceedings fifth international conference systems sciences hawaii 
stemple stanton sheard morrison kirby fegaras cooper connor atkinson typesafe linguistic reflection generator technology 
esprit bra project fide technical report fide 
stonebraker postgres generation database management system 
communications 
strachey fundamental concepts programming languages 
oxford university press oxford uk 
straw object management persistent smalltalk system 
spe 
sutton flexible consistency model persistent data software process programming 
proceedings fourth international workshop persistent object systems martha vineyard ma 
vldb journal atkinson orthogonally persistent object systems suzuki kitsuregawa takagi efficient pointer swizzling method navigation intensive applications 
proceedings sixth international workshop persistent object systems france 
teitelbaum reps cornell program synthesizer syntax directed programming environment 
communications 
tennent language design methods semantic principles 
acta informatica 
thatte persistent memory storage architecture object oriented database systems 
proceedings cm ieee international workshop object oriented database systems pacific grove ca 
thomas pcte interfaces supporting tools software engineering environments 
ieee software pp 

trinder wadler improving list comprehension database queries 
proceedings bombay india 
van wijngaarden peck koster report algorithmic language algol 
numerische 
wai distributed concurrent persistent languages experimental design implementation 
universities glasgow st andrews technical report 
waite glasgow persistent workshop user documentation 
esprit bra project fide technical report fide 
wasserman kersten van de revised report programming language plain 

wetzel programming style systematic development programming environments 
ph thesis university hamburg germany 
wileden wolf fisher tarr experiment persistent typed object management 
proceedings acm sigsoft third symposium software development environments pp 
wilson er 
pointer swizzling page fault time efficiently supporting huge address spaces standard hardware 
university illinois chicago technical report uic eecs 
wilson uniprocessor garbage collection techniques 
proceedings international workshop management st malo france 
wirth programming language pascal 
acta 
navigation index object store 
proceedings fifth international conference system sciences hawaii 
