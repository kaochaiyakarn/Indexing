inductive approach verifying cryptographic protocols lawrence paulson computer laboratory university cambridge pembroke street cambridge cb qg england lcp cl cam ac uk december minor corrections november informal arguments cryptographic protocols secure rigorous inductive definitions 
approach ordinary predicate calculus copes infinite state systems 
proofs generated isabelle hol 
human effort required analyze protocol little week yielding proof script takes minutes run 
protocols inductively defined sets traces 
trace list communication events comprising interleaved protocol runs 
protocol descriptions incorporate attacks accidental losses 
model spy knows private keys forge messages components decrypted previous traffic 
protocols analyzed otway rees uses shared key encryption needham schroeder uses public key encryption recursive protocol variable length 
prove event ev precedes event ev property holds provided remains secret 
properties proved viewpoint various principals say receives final message session key conveys 
contents contents overview inductive method messages 
operators parts analz synth 
attacker 
modelling protocol 
standard rules 
induction 
regularity lemmas 
secrecy theorems 
finding attacks 
mechanized theory messages agents messages 
defining parts analz synth 
derived laws governing operators 
rewrite rules symbolic evaluation 
events intruder knowledge 
shared key protocol otway rees proving possibility properties 
proving forwarding lemmas 
proving regularity lemmas 
proving unicity theorems 
proving secrecy theorems 
proving session key secrecy theorem 
proving authenticity guarantees 
proving simplified protocol 
public key protocol needham schroeder protocol lowe attack 
modelling protocol 
proving guarantees 
proving guarantees 
glimpse machine proofs 
analyzing strengthened protocol 
recursive protocol recursive authentication protocol 
deviations protocol 
modelling protocol 
modelling server 
ii contents main results proved 
potential attacks 
related cryptographic protocols intended agents communicate securely insecure network 
obvious security goal secrecy spy read contents messages intended 
important authenticity message appears alice alice sent precisely message nonces timestamps give correct indication freshness 
discuss denial service 
typical protocol allows contact delivering key parties exclusive 
may involve messages surprisingly hard get right 
problem combinatorial complexity messages intruder generate 
quite different problem specify precisely properties protocol intended achieve 
anderson needham excellent tutorial presents examples defines terminology 
formal methods analyze security protocols 
popular approaches state exploration belief logics 
state exploration methods model protocol finite state system 
exhaustive search checks reachable states safe 
lowe uses general purpose model checker fdr interrogator specialized tool 
attacks quickly keeping state space small requires drastic simplifying assumptions 
belief logics formalize agent may infer messages received 
original ban logic allows short proofs 
identified protocol flaws missed 
new belief logics address weaknesses ban sacrifice simplicity 
fruitfully borrow approaches concrete notion events sending second idea deriving guarantees message 
protocols formalized set possible traces lists events sends agent may extend trace way permitted protocol see current trace 
agents know true sender message may forward items read 
agent active attacker 
properties proved induction traces theorem prover isabelle 
analyzing new protocol requires days effort exploring effects change existing protocol takes just hours 
laws proof techniques developed protocol applicable generally 
approach oriented proving guarantees absence indicate possible attacks 
way discovered attack variant otway rees protocol suggested burrows page overview inductive method 
time unaware mao boyd earlier attack 
attacks structure proof yields insights protocol 
goes describe method overview detail 
protocols analyzed 
otway rees illustrates shared key model needham schroeder illustrates publickey model recursive authentication protocol demonstrates deal way authentication 
related discussed 
overview inductive method informal arguments protocol correctness conducted terms happen 
hypothetical dialogue salesman 
run alice bob possibly know session key kab 
customer 
eavesdropper 
salesman 
read certificates alice bob long term keys get 
customer 
attacker trick bob accepting key shared 
salesman 
identifying nonces prevents 
customer may find arguments rigorous 
necessary formal tool inductive definition 
inductive definition lists possible actions agent system perform 
corresponding induction rule lets reason consequences arbitrary finite sequence actions 
induction long specify semantics programming languages copes nondeterminism 
plotkin conceived application inductive definitions huet pioneered proof tools 
security protocols model specify capabilities attacker 
inductively defined operators useful 
parts merely returns components set messages 
analz models decryption past traffic available keys 
synth models forging messages 
attacker specified independently protocol terms analz synth 
algebraic laws governing parts analz synth proved induction invaluable reasoning protocols 
inductive protocol definition models behaviour honest agents faithfully executing protocol steps presence attacker 
model agents accidentally revealing secrets 
messages inherent nondeterminism models possibility agent unavailable 
belief logics allow short proofs main reason mechanizing eliminate human error 
contrast inductive verification protocols involves long detailed proofs 
safety property proved induction protocol 
case considers state system reached corresponding protocol step 
simplifying safety property case may reveal combination circumstances leading violation 
cases covered property proved 
customer 
somebody tampering nonce step sending alice wrong certificate 
salesman 
somebody experienced talk 
messages traditional protocol notation ideal mechanization 
expressing concatenation comma ambiguous enclosing braces invites confusion element set 
machine syntax uses fat braces express concatenation 
informal protocol descriptions omit outer level braces indicate encryption notation na kab ka individual protocol descriptions rest common theory message analysis 
message items may include agent names 
nonces na nb 
keys ka kb kab 
compound messages hashed messages hash encrypted messages crypt kx 
public key encryption inverse key equality expresses symmetric key 
theory assumes nonces kinds 
sequence numbers timestamps regarded byte random strings 
encrypted message altered read appropriate key different types components confused 
including redundancy message bodies satisfy assumptions 
overview inductive method published attacks involve accepting nonce key regarding component 
alter model admit type confusion attacks little explicitness protocols cheaply prevent 
operators parts analz synth operations defined possibly infinite sets messages 
defined inductively set closed specified extensions 
extends set messages items derivable typically contains agent initial knowledge history messages sent trace 
set parts obtained repeatedly adding components compound messages bodies encrypted messages 
regard key part crypt kx part 
represents set components potentially recoverable additional keys 
proving parts establishes occur possibly hashed form 
facts proved parts crypt kx parts parts parts parts parts 
set analz obtained repeatedly adding components compound messages decrypting messages keys analz set represents gleaned breaking ciphers 
analz learn listening facts proved analz crypt kx analz analz analz analz analz analz analz parts set synth models messages spy build elements repeatedly adding agent names forming compound messages encrypting keys contained agent names added publicly known 
nonces keys added spy nonces keys facts proved synth synth crypt kx synth synth attacker attacker enemy observes traffic network set sends fraudulent messages drawn set synth analz 
interception messages modelled indirectly message ignored 
protocol demand perfect competence players 
spy get hold somebody key communications agents suffer 
model gives spy control unspecified set compromised agents holds private keys 
protocol descriptions include oops event allow accidental loss session keys 
spy accepted honest agent 
may send normal protocol messages long term secret key sending fraudulent messages 
combination lets participate protocol runs intercepted keys impersonating agents 
spy powerful protocols 
common body laws tactics mechanical proof procedures available 
tactic proves spy case induction automatically 
modelling protocol events trace form says abx means sends message possible event notes ax means stores internally events envisaged replacement long term key 
agent state represented initial knowledge typically private key scan list events 
apart spy agents read messages addressed 
event notes ax visible compromised spy 
consider variant otway rees protocol page 
na na ka 
na na ka nb na kb 
na na kab ka nb kab kb 
na na kab ka informally contacts generating na identify run 
forwards message authentication server adding nonce 
generates new session key kab packages separately decrypts part message checks nonce sent previously forwards rest similarly compare nonces accepting kab 
protocol steps modelled possible extensions trace new events 
server constant variables ranging agents including spy 
transcribe step turn overview inductive method 
evs trace na fresh nonce agent distinct evs may extended event says ab na na ka 

evs trace event form says na nb fresh nonce evs may extended event says na nb na kb 
sender name shown new event know really sent message 
component intended encrypted key shown attempt read 

evs trace containing event form says na na ka nb na kb kab fresh key evs may extended event says na na kab ka nb kab kb 
server know message originated 
decrypt components keys named agents revealing items right form accepts message valid replies 
evs trace containing events says na nb na kb says na nb kb evs may extended event says ba na 
agent receives message expected format decrypts portion checks nb agrees nonce previously sent server forwards component sender message shown knows sent message 
rule specify message holds freshness nb 
standard rules fifth implicit step checks nonce confirms session 
implicit steps modelled necessary 
otway rees suffices prove authenticity certificate receives step 
tls model includes rule session confirmation order support resumption past sessions 
assume message sent step received 
identify sending message step receipt satisfactory message step model forces agents act traces sends responds 
may interpret traces indicating intercepted rejected 
agent may participate protocol runs concurrently trace represents state runs 
may respond past events matter old 
may respond number times 
protocol safe liberal conditions remain safe time outs checks added 
letting agents respond message prevent modelling middle person attacks 
excluding traces ill formed weakens theorems proved traces 
standard rules protocol description usually requires additional rules 
obvious empty list trace 
rules model fake messages accidents 
evs trace synth analz fraudulent message spy evs may extended event says spy bx 
contains messages past trace 
includes spy initial state holds long term keys arbitrary set bad agents 
spy may say plausibly say masquerade bad agents 
tls protocol arrives session keys exchanging nonces applying pseudo random number function 
modelled tls assuming function arbitrary injection 
protocol specification agents apply random number function necessary 
spy additional rule allows apply function message items disposal 
protocols keys computed require analogous rule 
evs trace distributed session key run involving nonces na nb evs may extended event notes spy na nb 
overview inductive method strange looking rule oops rule models loss means session keys 
need assurance lost keys compromise runs 
oops message includes nonces order identify protocol run distinguishing past losses 
protocols yahalom oops rule brings hidden properties light 
clear oops expressed 
induction specification defines set possible traces inductively set closed rules 
appreciate means may helpful recall set natural numbers inductively defined rules suc reasoning inductively defined set may corresponding induction principle 
set usual mathematical induction prove natural number prove prove suc set traces induction principle says evs holds trace evs provided preserved rules creating traces 
prove cover empty trace 
rules prove assertion form evs ev evs event ev contains new message 
ev evs trace extends evs event ev new events added front trace 
rule may resemble list induction considers conceivable messages just allowed protocol 
trivial example induction prove agent sends message trace contains event form says 
holds vacuously empty trace rules specify conditions prevent creation events 
regularity lemmas lemmas concern occurrences particular item possible message component 
theorems form parts set messages available spy 
strong results hold spite spy 
protocols easy prove spy gets hold agent long term key excluding bad agents 
inductive proof amounts examining protocol rules observing involve sending long term keys 
spy send induction hypothesis disposal bad agents 
secrecy theorems unicity results state nonces session keys identify certain messages 
naturally expect server re issue session keys agents nonces 
choose items fresh straightforward prove key nonce part message determines values parts 
secrecy theorems regularity lemmas easy prove stated terms parts operator 
secrecy expressed secret agents see 
secrecy theorems stated terms analz 
proofs long difficult typically splitting cases certain keys compromised 
typical result involving analz states spy holds session keys reveal 
suffice prove sends messages form crypt kab kcd claim false spy send messages agents send 
fortunately learn new session keys possess kcd 
discussion suggests precise form theorem 
obtained help session key previous traffic obtained traffic 
protocol steps introduce new keys proof induction require strengthening formula generalizing set session keys 
session key compromise theorem 
proving theorem form hardest task analyzing protocol 
huge case analysis results 
automated processor time required exponential number different keys encryption single protocol message 
bit creativity yield substantial savings see 
simple key exchange protocols essentially command proof script 
theorem explicit may taken granted agent session keys encrypt keys see gollmann 
generalization theorem prove secrecy nonce yahalom 
session key secrecy theorem states server distributes session key kab spy gets key 
spy treated respect honest agent may conclude agent gets key accident 
theorem stipulates uncompromised oops message session key spy 
forbid oops messages kab just involving current nonces consider protocol vulnerable replay attack 
overview inductive method secrecy properties usually proved commands 
constant problem secrecy proofs gigantic formulas 
need discard just right amount information think carefully induction formulas expressed 
finding attacks secrecy necessary sufficient correctness 
server distributing key wrong pair agents 
receives message otway rees protocol sure really came got 
simplified version protocol outlined answer 
secure part message encrypted part na kab ka need originated encrypted part message 
originated second part received fraudulent message previous na substituted nb 
machine proof leads consider scenario na roles 
easy invent attack 
spy intercepts message records na 
indicated ca causing server issue session key package na key 

cb na na ka nc nc kc cs nc nc kc na nc ka ca nc nc kc na nc ka ca nc nc kc na ka 
cb na na ka replacing nonce na na message eventually causes accept key key talking na original nonce 
attack serious discovered mao boyd server detect repetition nonce 
occur original version otway rees nb encrypted second message 
otway rees uses nonces just assure freshness binding identify principals 
verifying binding complicates formal proofs 
prove corrected protocol na nb uniquely identify messages originate coincide 
prove guarantees agents receive expected messages nonces agree server really distribute session key intended parties 
mechanized theory messages approach mechanized isabelle hol instantiation generic theorem prover isabelle higher order logic 
isabelle appropriate support inductively defined sets automatic tools 
isabelle syntax appears order convey feel proofs conducted 
methodology tailored isabelle heavy classical reasoner 
probably modified suit higherorder logic provers pvs hol 
minimum prover provide simplifier takes conditional rewrite rules perform automatic case splits expressions 
form set theory available algebraic laws parts analz synth lost 
hol predicates satisfactory sets finite lists 
isabelle hol polymorphic type system resembling ml 
item type agent appear type msg expected 
type inference eliminates need specify types expressions 
laws lists sets polymorphic rewriter uses appropriate types automatically 
agents messages kinds agents server friendly agents spy 
friendly agents form friend natural number 
declaration specifies type agent isabelle 
note called server nat type natural numbers 
datatype agent server friend nat spy datatype declaration creates union type injections ranges disjoint 
follows various kinds agent distinct friend spy spy friend friend friend various kinds message items discussed declared essentially shown 
observe type agent recursive type msg 
shown declarations xn xn abbreviate xn xn 
datatype msg agent agent number nat nonce nat non key key msg msg hash msg crypt key msg various kinds message distinct agent nonce forth 
injections agent number nonce key simply type mechanized theory messages coercions 
datatype creates injections hashing collision free hash hash encryption strong 
injectivity yields law crypt kx crypt spy alter encrypted message decrypting relevant key 
exclusive violates assumptions rsa redundancy incorporated :10.1.1.40.5588:10.1.1.40.5588
forms encryption modelled loss complicate theory 
defining parts analz synth operators parts analz synth defined inductively protocols 
set messages parts set including closed projection decryption 
formally defined set closed rules 
parts parts parts crypt kx parts parts parts parts similarly analz defined set including closed projection decryption known keys 
analz crypt kx analz analz analz analz analz analz analz synth defined set includes agent names numbers closed pairing hashing encryption 
agent synth synth number synth synth hash synth synth synth synth synth crypt kx synth illustrate isabelle syntax definitions analz 
derived laws governing operators consts analz msg set msg set inductive analz inj analz fst analz analz snd analz analz decrypt crypt analz key analz analz definition isabelle defines appropriate fixedpoint proves desired rules 
include rules constitute definition case analysis induction 
definition parts part hash part crypt kx 
inconsistency typical protocols private keys included hashes serve signatures encrypted messages 
prove uncompromised private keys part traffic basic lemma prove deeper properties 
derived laws governing operators section laws proved operators protocol verification requires 
examine systematically 
mechanically proved preceding definitions 
operators monotonic parts parts analz analz synth synth idempotent similarly equations parts parts parts analz analz analz synth synth synth parts analz parts analz parts parts building breaking results trivial equations parts synth parts synth analz synth analz synth considered possible combinations involving operators 
remaining combinations synth parts synth analz appear irreducible 
models mechanized theory messages fraudulent messages spy derive prove laws synth analz synth analz synth analz 
generally derive bound enemy say synth analz parts synth analz parts typically set messages sent trace 
rule eliminates fraudulent message yielding upper bound parts 
typically parts bounded induction hypothesis 
analogous rule analz 
rewrite rules symbolic evaluation applying rewrite rules term parts agent nonce na transform equivalent element set agent nonce na agent nonce na 
form evaluation deal partially specified arguments agent agent nonce na symbolic evaluation parts straightforward 
protocol step sends message typically consider subgoal containing expression parts 
previous section discussed case fraudulent 
cases specific nonce na agent agent crypt ka nonce na agent agent 
parts expands big expression involving new elements inserted set parts nonce na agent 
expansion may sound impractical subgoal key parts simplifies key parts particular shown new elements form key isabelle theories represent set insert xh similarly insert insert yh rewrite rules symbolic evaluation element subgoal simplify manageable formula key parts rules symbolic evaluation parts fairly obvious 
straightforward inductive proofs 
parts parts agent agent parts parts nonce nonce parts parts key key parts parts parts parts hash hash parts parts crypt kx crypt kx parts symbolic evaluation analz difficult 
define set keys decrypt messages def crypt kx key pulled analz needed decryption 
analz analz key key analz rewrite rule encrypted messages involves case analysis matching key available 
analz crypt kx crypt kx analz crypt kx analz analz nested encryptions give rise nested expressions 
know relevant key secure letting automatic tools generate full case analysis gives short proof scripts 
impossible cases removed quickly 
redundant case analyses simplify simplified resulting expression enormous symbolic evaluation expresses analz terms analz invoke induction hypothesis 
rewriting rule related idempotence simplifies cases arise agent forwards agent message visible previous traffic 
analz analz analz mechanized theory messages symbolic evaluation synth obviously impossible result infinite 
fortunately necessary 
need simplify assumptions form synth arise considering certain message fraudulent 
inductive definition regards nonces keys giving rise implications nonce synth nonce key synth key crypt kx synth crypt kx synth know rule tells encrypted message replay forgery 
similar rules hash synth synth facts mentioned section theorems proved parts analz synth 
stored way isabelle apply automatically simplification 
logically speaking proofs complex 
need average commands tactic invocations isabelle automatic tools 
full proof script commands executes seconds 
events intruder knowledge trace list events form says abx notes ax 
isabelle hol provides lists events trivial declare datatype 
datatype event says agent agent msg notes agent msg otway rees assumes symmetric key environment 
agent long term key shrk shared server 
spy key shrk spy redundant shrk function initstate specifies agents initial knowledge 
spy knows long term keys agents set bad 
initstate def long term keys initstate friend def key shrk friend initstate spy def key shrk bad function spies models set messages spy see trace 
sees messages sent network 
sees internal notes bad agents regarded control 
empty trace sees initial state 
recall ev evs list consisting ev prefixed list evs 
spies def initstate spy spies says abx evs def spies evs spies notes ax evs def spies evs spies evs bad function spies describes spy view traffic order formalize message spoofing 
agents formal protocol rules mention previous messages directly 
set evs formalizes notion freshness 
set includes parts spies evs parts messages held privately agent 
example key evs fresh evs differs long term keys 
def parts initstate says abx evs def parts evs notes ax evs def parts evs shared key protocol otway rees section discussed modelling protocol informally detail 
consider specification supplied theorem prover fig 

identifiers far left name rules nil empty trace fake fraudulent messages protocol steps oops accidental loss session key 
set traces constant otway 
nil rule trivial examine fake 
condition evs otway states evs existing trace 
synth analz spies evs denotes message forged spy decrypt trace recall holds bad agents private keys 
spy send forged messages agent including server 
rules additional conditions spy ensure agents send messages trivial fact eliminates impossible cases proofs 
rule formalizes step otway rees 
list evs current trace 
calling evs simply evs tells user subgoals arisen rule inductive proof case splitting shared key protocol otway rees nil otway fake evs otway spy synth analz spies evs says spy evs otway evs otway server nonce na evs says nonce na agent agent crypt shrk nonce na agent agent evs otway evs otway server nonce nb evs says nonce na agent agent set evs says server nonce na agent agent nonce nb crypt shrk nonce na agent agent evs otway evs otway server key kab evs says server nonce na agent agent crypt shrk nonce na agent agent nonce nb crypt shrk nonce na agent agent set evs says server nonce na crypt shrk nonce na key kab crypt shrk nonce nb key kab evs otway evs otway says server nonce na agent agent nonce nb crypt shrk nonce na agent agent set evs says nonce na crypt shrk nonce nb key set evs says nonce na evs otway oops otway spy says server nonce na crypt shrk nonce nb key set notes spy nonce na nonce nb key otway specifying otway rees protocol proving possibility properties nonce na fresh contained evs 
agent sure means generating fresh nonces high probability choosing random bytes 
rule set evs denotes set events stripped temporal order 
agent responds past message matter old restrict rule ensure responds message 
current proofs require restriction prevent detection replay attacks 
rules discussed 
translating informal protocol notation isabelle format sufficiently straightforward automated 
proving possibility properties theorems prove protocol description possibility properties 
assure liveness merely message formats agree step 
prove happen agents forced act 
protocol proceed message transcribed incorrectly 
possibility property otway rees 
agents distinct server key nonce trace final message na na kab ka sent 
theorem proved joining protocol rules order showing preconditions met 
proving forwarding lemmas results proved reasoning steps agent forwards unknown item 
rule says agent agent set evs analz spies evs proof trivial 
spy sees message transmitted clear analz find 
spy learn new seeing responds message 
forwarding party removes layer encryption revealing spy 
forwarding lemma weaker stated parts analz useful theorems regularity lemmas stated parts 
otway rees nested encryption oops rule removes layer encryption takes server message gives spy 
forwarding lemma states act add new keys parts spies evs 
says na crypt nb set evs parts spies evs shared key protocol otway rees proving regularity lemmas statements form parts spies evs impose conditions appearance message 
lemmas proved way 

apply induction generating cases protocol step nil fake oops 

step forwards part message apply corresponding forwarding lemma analz parts needed express terms parts 

prove trivial nil case standard automatic tactic 

simplify remaining cases 
isabelle programmable tool user define tactic perform tasks return remaining subgoals 
usually fake case proved automatically 
basic regularity law states secret keys remain secret 
evs otway meaning evs trace key shrk parts spies evs bad commands generate proof 
proving unicity theorems fresh session keys nonces uniquely identify message origin 
exclude possibility spoof messages done different ways 
case session keys typical formulation refers event names server sender evs otway na nb na nb says na crypt shrk nb set evs na na nb nb free occurrence event uniquely determines components shown 
apply theorem requires proof message question really originated server 
alternative formulation nonces presumes existence message encrypted secure key crypt shrk na agent agent parts spies evs proving secrecy theorems evs trace crucially bad 
spy performed encryption lacks key 
free occurrence na message determines identity ban logic obtain guarantees encryption keys known secret 
guarantees built logic proved 
formulations unicity may regarded regularity lemmas 
proofs hard generate 
proving secrecy theorems section discussed session key compromise theorem 
obtained set session keys messages keys obtained messages 
theorem formulated follows arbitrary trace evs evs otway 
analz spies evs analz spies evs arbitrary set session keys necessarily trace 
right hand side equivalence simplification analz spies evs replacing analz parts distributes union render theorem trivial 
right left direction trivial anyway 
prove theorem daunting task 
techniques proving secrecy theorems routine 

apply induction 

step forwards part message apply corresponding forwarding lemma expressed terms analz 

simplify cases rewrite rules evaluate analz symbolically pulling agent names nonces compound messages performing automatic case splits encrypted messages 
fake case usually survives proved standard argument involving properties synth analz 
argument programmed tactic works protocols investigated 
session key compromise theorem effort needed 
secrecy theorems require detailed argument 
chief proving nonce nb yahalom protocol remains secret requires establishing correspondence nonces keys 
shared key protocol otway rees proving session key secrecy theorem theorem states protocol correct server viewpoint 
evs otway bad 
suppose server issues key says na crypt shrk na crypt shrk nb set evs suppose key lost oops event involving nonces notes spy na nb set evs analz spies evs key available spy 
secrecy theorem slightly harder prove previous 
step case possibilities 
new message mentioned theorem statement session key fresh contradiction induction hypothesis yields needed result 
isabelle prove step case automatically 
oops case nontrivial showing oops message involving involve na nb requires unicity session keys theorem discussed previous section 
full proof script consists commands executes seconds generating proof steps 
proving authenticity guarantees session key secrecy theorem described worthless 
holds protocol variant attacked 
correct protocol receive expected nonce server sent message precisely right form 
agents need guarantees subject conditions check confirming certificates authentic 
proving guarantees completes security argument appeal session key secrecy theorem 
correct protocol differs message encrypts nb 
na na ka 
na na ka na nb kb 
na na kab ka nb kab kb 
na na kab ka receiving step message inspect certificate encrypted key forwards runtimes measured mhz pentium ii 
human probably generate shorter proof omitting irrelevant steps 
proving authenticity guarantees guarantee states trace contains event form says na crypt shrk nb key uncompromised previously sent message says na agent agent crypt shrk na nb agent agent server sent correct instance step 
theorem establish component correct message may tampered 
session key secrecy theorem applied 
checking nonce assures key talking subject conditions secrecy theorem 
guarantee follows lemma proved induction 
resembles regularity lemma 
main premise certificate appeared crypt shrk nb key parts spies evs premises guarantee 
proof complex requiring subsidiary lemmas encrypted part message appears suitable version message sent 
nonce nb uniquely identifies components message encrypted part 
discussed 
nonce na nb protocol runs 
bad elements crypt shrk na agent agent crypt shrk na na agent agent parts spies evs 
proof complexity arises nonces binding encrypted messages step identical formats 
consider uncompromised safely conclude receiving message 
trace contains message form says na crypt shrk na key recalls sending message says ab na agent agent crypt shrk na agent agent public key protocol needham schroeder server sent message correct form nb 
similarities statement proof guarantee 
message considered see 
nonces compared message sent proof requires proving induction lemma main premise crypt shrk na key parts spies evs detailed consideration nonces 
proving simplified protocol abadi needham suggest simplifying otway rees eliminating encryption messages 
nonces serve freshness binding 
message explicitly names intended recipients 

na 
na nb 
na na kab ka nb kab kb 
na na kab ka authors claim page protocol efficient conceptually simpler modification machine proofs support claims 
vital guarantees messages trivial prove 
nonces need unique facts need proved 
new proof script smaller runs faster 
new protocol slightly weaker original 
lack encryption message allows intruder masquerade learning session key 
original otway rees protocol assures proved isabelle new protocol 
original version assured anybody replay message burrows noted page 
public key protocol needham schroeder needham schroeder obvious choice demonstrating inductive method public key protocols 
researchers investigated lowe discovered subtle flaw 
protocol lowe attack full needham schroeder protocol consists steps devoted distributing public keys 
burrows identified flaw seconds proof commands 
modelling protocol part protocol guarantee public keys fresh 
assuming public keys universally known reduces protocol steps 
na kb 
na nb ka 
nb kb message assures presence decrypted na kb extract freshly invented nonce na 
similarly message assures presence 
burrows claimed property na nb known 
shared secrets compute session key 
lowe refuted claim noting ran protocol enemy start new run agent masquerading 
argue attack 
agent careless talk enemy expect guarantees 
mechanized analysis reveals protocol guarantees adequate 
rely careful stronger assumption mere honesty 
attack occur talks honest agent private key compromised 
lowe suggests simple fix provides guarantees modelling protocol public key model agent public key pubk known agents private key spy knows bad agents private keys 
private key coincides public key 
respects model resembles shared key described 
start original flawed needham schroeder 
presents inductive definition 
rules protocol steps standard ones identical fig 

oops message protocol distribute session keys 
ask meadows happen nonces compromised 
precisely protocol steps follows 
current trace na fresh nonce agent distinct may add event says ab crypt pubk na 

current trace contains event form says crypt pubk na public key protocol needham schroeder nil ns public fake evs ns public spy synth analz spies evs says spy evs ns public ns evs ns public nonce na evs says crypt pubk nonce na agent evs ns public ns evs ns public nonce nb evs says crypt pubk nonce na agent set evs says crypt pubk nonce na nonce nb evs ns public ns evs ns public says crypt pubk nonce na agent set evs says crypt pubk nonce na nonce nb set evs says crypt pubk nonce nb evs ns public specifying needham schroeder protocol nb fresh nonce may add event says ba crypt pubk na nb 
writing sender means know sent message 

current trace contains events may add event says ab crypt pubk na says crypt pubk na nb says ab crypt pubk nb 
decrypts message checks na agrees nonce previously sent replies challenge sending back nb 
mentioned model implicit fourth step inspects message arriving suffices prove theorems stating infer inspection 
proving guarantees guarantees nonce remains secret spy 
follows spy proving guarantees know na sent message 
proofs require lemmas unicity properties na saying na 
value na nb separate runs 
message form crypt pubk na value nonce na uniquely determines agents traffic 
lemmas assume na secret form part inductive proof na really secret 
hold honest agents specified choose unpredictable nonces negligible probability collision 
guarantee step message originated provided contains expected nonce 
guarantee consistent lowe attack considers runs uncompromised principals 
runs protocol spy guarantee void 
lowe problem protocol viewpoint attack concerns guarantee proving guarantees situation seen symmetrical seen proving induction nb remains secret authenticate isabelle proof scripts theorems trivial alterations 
easy prove nb secret value message form crypt pubk na nb uniquely determines na 
unfortunately nb remain secret 
attempt prove secrecy fails leaving subgoal contains past event sending message compromised agent 
subgoal describes consistent set circumstances lowe attack 
details appear 
weaker properties proved 
sends nb anybody step protocol nb remains secret 
consequence receives nb step sent 
may 
proof follows usual argument proofs assumes says messages form crypt pubk nb additional assumption nb remain secret follows sends crypt pubk na nb step receives crypt pubk nb reply came contradicts assumption receive crypt pubk nb 
result form implies equivalent implies receive crypt pubk nb sent message crypt pubk nb example suggests general strategy prove decrypting message form crypt pubk indicates presence 
prove performs step message decrypted public key protocol needham schroeder crypt pubk nonce na agent parts spies evs nonce na analz spies evs evs ns public crypt pubk na nonce na parts spies evs nonce na analz spies evs evs ns public 
crypt pubk nonce na agent parts spies evs crypt pubk nonce na agent parts spies evs crypt pubk nonce na agent parts spies evs nonce na analz spies evs evs ns public says crypt pubk nonce na agent set evs bad bad evs ns public nonce na analz spies evs says crypt pubk nonce na agent set evs says crypt pubk nonce na nonce nb set evs bad bad evs ns public says crypt pubk nonce na nonce nb set evs guarantees isabelle hol notation item remains secret 
conclude revealed performed decryption 
roundabout procedure necessary mere act decryption gives weaker guarantees exhibiting signed message 
consider protocol 
na 
na kb nb 
nb ka nonces broadcast world signatures obviously assure presence 
glimpse machine proofs give impression isabelle formalization fig 
presents theorems providing guarantees numbered follows 

unicity lemma states na secret nb 
proved induction 
glimpse machine proofs 
unicity lemma states na secret appearance instance message determines components 
follows induction standard proof script 

corollary previous lemma trivial proof 
unicity lemmas refer presence encrypted messages past traffic 
remaining theorems refer events form says abx involving encrypted messages 

crucial theorem guarantees secrecy na 
conditions bad bad express uncompromised 
proof induction relies previous lemmas assume secrecy na induction hypothesis 

theorem final guarantee 
na start run receives message crypt pubk na nb sent message 
subject agents uncompromised 
proof induction relies secrecy unicity na 
proof script theorems comprises commands tactic invocations executes seconds seconds theorem 
guarantees 
attempting prove secrecy nb leads subgoal appears proof 
bad bad bad evs ns public says crypt pubk nonce na agent set evs says crypt pubk nonce na nonce nb set evs says crypt pubk nonce na nonce nb set evs nonce nb analz spies evs false situation arise event instance step tell trace called evs 
agents uncompromised na start run compromised agent somebody sent message crypt pubk na nb 
show circumstances contradictory just false 
simplified form claim nb remains secret sent step message crypt pubk nb message reveals nb spy 
proof states hard interpret 
induction formula require strengthening 
additional lemmas proved 
case easily recognize lowe attack 
assumptions describe events occur nb need remain secret 
recursive protocol analyzing strengthened protocol lowe suggests improving needham schroeder protocol adding explicitness 
step agent includes identity 
na kb 
na nb ka 
nb kb previous proof scripts large version 
isabelle high level automation minor changes seldom interfere existing proofs 
guarantees proved precisely 
proving guarantees naturally seek strengthen 
unicity property nb states nb secret presence step uniquely determines message components recall 
step form crypt pubk na nb 
nonce nb determines na additional fact lets prove secrecy nb 
recall subgoal 
new version protocol somebody sent message agent sent message crypt pubk na nb 
crypt pubk na nb 
unicity theorem nb implies contradiction compromised 
recursive protocol protocol generalizes otway rees arbitrary number parties 
contacts contacts authentication server run resembles otway rees 
may choose contact agent forth chain arbitrary length may form 
round agent adds name fresh nonce growing request message 
sake discussion suppose extend chain contacts authentication server 
server generates fresh session keys kab kbc general case key pair agents adjacent chain 
encloses session key certificates recursive authentication protocol nc nb na nb na na kab na ka kbc nb kb kab nb kb kab na ka nc kc kbc nc kc kbc nb kb kab nb kb kab na ka recursive authentication protocol clients party gives bundle agent removes certificates forwards rest predecessor chain 
receives certificate containing kab 
protocol hard specify analyze 
number steps number parties number session keys vary 
server response agents accumulated requests recursive program 
properties prove obvious 
simplify protocol distribute single session key common agents chain 
security depend honesty agent possibly known may applications weak guarantee acceptable better give separate session key adjacent pair 
proved general guarantee participant 
receives certificate containing session key name agent spy know key 
isabelle proofs modest scale 
fewer results proved commands run minutes 
recursive authentication protocol protocol invented john bull apm description hash hash pair hash 
typically agent long term shared key hash message digest enabling server check originated agent 
shows typical run omitting hashing 
agent starts run sending request 
na recursive protocol ka long term shared key na fresh nonce isa placeholder indicating message started run 
response sends similar message position 
nb na step may repeated times desired 
time new components added message new message digest prefixed 
recursion terminates agent performs step server destination 
step server prepares session keys caller callee pair 
traverses accumulated requests build response 
callers order final request nc nb na 
arrows point occurrences appear outer levels 
called server called server generates session keys kbc prepares certificates nc kc kbc nc kc session key redundant shares kc server 
including allows agent chain treated agents initiator receives session key 
having dealt request server discards 
looking remaining outer levels request message nb na 
server prepares certificates kbc nb kb kab nb kb note kbc appears certificates intended containing nonce nc encrypted key kc iteration request message contains level na 
token indicates requests 
server generates session key certificate kab na ka having processed request message server returning bundle certificates 
example return certificates 
nc kc kbc nc kc kbc nb kb kab nb kb kab na ka deviations protocol step agent accepts certificates forwards rest predecessor chain 
agent performs step started run 

kbc nb kb kab nb kb kab na ka kab na ka description describes special case protocol run clients 
conventional protocol notation cope arbitrary numbers participants recursive processing nested messages 
section specify protocol inductive definition 
deviations protocol corrected flaw original protocol 
formalization protocol differs original respects 
original protocol agent certificates distinguished order arrival intruder easily exchange 
correct flaw added party name certificate 
explicitness engineering practice 
simplifies proofs recall 
bull otway accepted change protocol 
dummy session key avoids having treat agent special case 
agents take certificates 
implementation safely omit dummy certificate 
removing information system information available intruder 
original protocol implements encryption exclusive xor hashing 
verification purposes encryption taken primitive 
correctness protocol depend precise form encryption provided implemented properly original xor flawed see 
protocol certificates accompanied agent names sent clear 
safe simplify specification omitting names 
modelling protocol requests protocol form may contain request 
notation message digests trivially defined isabelle hash hash 
proofs apply definition directly 
default rewrite rules apply appears say argument parts expression simplified 
rules help prevent exponential blowup 
recursive protocol law subject synth analz uncompromised long term key synth analz hash analz synth analz message spoofed iff suitable message digest available circumstance 
nil recur fake evs recur spy synth analz spies evs says spy evs recur ra evs recur server nonce na evs says hash key shrk agent agent nonce na agent server evs recur ra evs recur server nonce nb evs says pa set evs says hash key shrk agent agent nonce nb pa evs recur ra evs recur server says server pb set evs pb rb respond evs says server rb evs recur ra evs recur says xh agent agent nonce nb xa agent agent nonce na set evs says crypt shrk key kbc agent nonce nb crypt shrk key kab agent nonce nb ra set evs says ra evs recur specifying recursive protocol part protocol modelled just fixed length protocols discussed 
presents inductive definition 
rules empty trace spy standard 
rules paraphrased follows 
current trace na fresh nonce agent distinct may add event says ab na 
modelling protocol long term key written shrk token name fixed message 

current trace contains event says bpa pa xa na nb fresh nonce may add event says bc nb pa 
variable xa sees hash value key needed verify 
component run form pa nested depth 
agent server anybody 
specification omits equation defining pa appears unnecessary omission simplifies proofs 
hold weaker protocol agent may react message sending instance step 
ill formed requests may result server ignore 

current trace contains event says pb server build request pb response rb may add event says 
construction rb includes verifying integrity pb process defined inductively shall see 
rule constrain agent allowing server send response anybody 
get right value pb proofs require details 

current trace contains events says bc nb pa says crypt shrk kbc nb crypt shrk kab nb may add event says bar 
decrypts certificates compares nonces value nb forwards remaining certificates 
final step protocol initiator acceptance certificate crypt shrk kab na 
implicit step need modelled certificates proved authentic 
recursive protocol oops message recall 
easily expressed recursive authentication protocol key appears nonces 
spy get hold session keys long term keys compromised agents 
modelling server server creates list certificates inductive definition 
defines set traces set triples request response session key 
triples belong set respond evs evs current trace supplied prevent reuse old session keys 
component returns newest session key caller inclusion second certificate 
server key kab evs hash key shrk agent agent nonce na agent server crypt shrk key kab agent nonce na agent server kab respond evs cons pa ra kab respond evs key kbc evs key kbc parts ra pa hash key shrk agent agent nonce na server hash key shrk agent agent nonce nb pa crypt shrk key kbc agent nonce nb crypt shrk key kab agent nonce nb ra kbc respond evs specifying server occurrences hash definition ensure server accepts requests verify hashes knowledge long term keys 
inductive definition fig 
consists cases 

kab fresh key evs na crypt shrk kab na kab respond evs 
base case handles request list seeks session key 
pa ra kab respond evs kbc fresh evs ra pa na main results proved nb pa crypt shrk kbc nb crypt shrk kab nb ra kbc respond evs 
recursive case handles request list seeks session key contacted respond relation best understood pure prolog program 
argument pa pa ra kab input ra kab outputs 
key kab included response ra included certificates 
inductive definition serve logic program 
concept turing powerful express complex behaviours 
programs easy reason 
coarser model server purposes respond needlessly complicated 
input list requests output list certificates 
routine lemmas hold list certificates form crypt shrk 
inductive relation responses generates set lists 
contains possible server responses impossible ones 
base case simply responses evs recursive case crypt shrk responses evs responses evs evs 
secrecy theorems expressed terms analz occurrence crypt cause case split resulting substantial blowup simplification 
induction responses introduces crypt induction respond introduces 
responses includes invalid outputs theorems proved respond 
main results proved part analysis resembles otway rees protocol 
possibility properties proved regularity lemmas 
secrecy theorems govern session keys leading session key secrecy theorem certificate crypt shrk kab na appears part traffic uncompromised kab reach spy 
theorem guarantees certificates originate server 
recursive protocol possibility properties logically trivial 
tell rules message formats compatible 
machine proofs require significant effort computation due complexity terms arise number choices available 
proved cases corresponding runs agents plus server spy 
general theorems agents proved induction necessary effort hardly justified 
typical regularity lemma states long term keys uncompromised agents form part message 
form part hashed messages recall discussion 
security properties proved induction protocol definition 
protocol main inductive set recur defined terms respond 
trivial proofs require induction definitions 
easily proved result lets reduce responses respond justifying induction responses pa rb kab respond evs rb responses evs results harder prove fixed length protocol 
proving theorem requires commands average quite predictable induction simplification 
outer induction yields subgoals protocol step plus base fake cases 
inner induction replaces step case subgoals server base case inductive step 
subgoals survive simplification 
theorems described difficult proofs 
nonces generated requests unique 
hashed value containing key uncompromised agent bad specified nonce value na 
bp 
hash key shrk agent agent na parts spies evs proofs theorem important 
lets agents identify runs nonces 
theorem applies requests generated step step 
otway rees protocol steps requires theorem 
reasoning similar theorem protocol symmetry 
nesting requests affect reasoning 
session key compromise theorem formulated just otway rees see proof difficult 
inner induction respond leads excessive case splits 
simplify proof defined set responses 
main results proved unicity session keys unusually complicated key appears certificates 
certificates created different iterations respond 
unicity theorem states certificate form crypt shrk na uncompromised certificate containing form crypt shrk nb nb 
pb rb respond evs abn 
crypt shrk key agent parts rb 
theorem quite strong 
agent receives certificate immediately learns agent receive mate subject security agents long term keys 
hope session key secrecy theorem follow ado 
messages containing session keys contain part certificates keys safe spy 
reasoning amounts induction possible messages protocol 
theorem stated stipulating bad proved crypt shrk key agent parts spies evs key analz spies evs induction largely straightforward step case 
inner induction respond leads complications proved lemma 
pb rb kab respond evs aa bad bad crypt shrk key agent parts rb key analz rb spies evs session key appears certificates format 
single set proofs applies certificates 
protocol symmetry halves effort compared otway rees 
related may instructive see theorems isabelle syntax 
session key compromise theorem evs recur kab range shrk key analz insert key kab spies evs kab key analz spies evs session key secrecy theorem crypt shrk key agent parts spies evs bad bad evs recur key analz spies evs potential attacks proofs subject assumptions implicit model 
attacks protocol implementations expected 
attack obvious step agent know message run evidence 
spy masquerade replaying old message read resulting certificate long term key 
allowing type confusion passing nonce key admits attacks form certificate mistaken 
recursive authentication protocol safe attacks form certificate 
encryption secure 
original protocol session key encrypted forming xor hash value time pad 
unfortunately hash value twice session keys kab kbc encrypted kab hash kb nb kbc hash kb nb 
forming xor eavesdropper immediately obtain kab kbc kbc kcd compromise session key reveal 
related researchers inductive trace models 
verification done general purpose theorem provers model checkers hand 
early kemmerer analyzed protocol ina jo specification language order logic 
animation tool identified weaknesses protocol 
modelled system automaton defining initial state state transformations specifying security goals invariants 
proving state transformations preserve invariant style reasoning induction 
gray mclean establish security invariant induction temporal logic proofs done hand 
coq proof checker 
known inh equivalent synth analz models fraudulent messages 
formalizing traces models states agents spy 
morain formalized otway rees protocol 
model server uses function choose session keys participate run server issues 
proved properties 
resembles forwarding lemmas described 
second states secret keys ka kb remain secret similar regularity lemma described 
third property states decrypted traffic help session keys 
model somewhat restrictive 
constants fixed roles initiator responder respectively 
spy starts holding keys gives prospect impersonating honest agents decrypting messages 
note attack works giving spy getting accept key talking lowe approach traces specified process calculus csp examined model checker fdr 
originates roscoe 
models agents spy 
model realistic 
may engage concurrent runs playing role spy identity long term key 
lowe discovered numerous attacks serious 
papers useful developing isabelle model 
meadows needham schroeder direct comparisons lowe examines variants protocol discusses differences speed nrl protocol analyzer fdr faster 
reports experiments example possibility nonces compromised 
attempts successful state space large 
protocol analyzer performs unusual combination search proof 
ostensibly brute force state enumeration prove induction infinite sets states unreachable 
full analysis carries assurance formal proof 
precise relationship meadows uses induction needs examined 
schneider lowe bases csp :10.1.1.44.4593:10.1.1.44.4593
model checker applies laws csp proofs 
rank function describe undesirable event prevented 
proving certain theorems rank function establishes property question 
schneider published detailed hand analyses original protocol lowe version 
considers number authentication properties increasingly general settings ultimately allowing concurrent runs 
schneider mechanized hand proofs revealing errors 
schneider proved simple properties single run recursive authentication protocol 
schneider considered consequences allowing messages satisfy equational laws messages 
protocols attacks exploit algebraic properties encryption method particularly rsa :10.1.1.40.5588
inductive method simple general 
seen handles versions otway rees versions needham schroeder public keys recursive protocol 
analysis needham schroeder reveals lowe attack discovered new attack variant otway rees 
addition protocols discussed analyzed variants yahalom simplified version woo lam shared key version needham schroeder 
bella looked kerberos timestamps session keys encrypt keys complicates analysis 
modelled part internet protocol tls secret nonces exchanged compute session keys 
proofs highly automated 
isabelle command generate thousands inferences 
small changes protocols involve small changes proof scripts 
analyzing needham schroeder took hours time recursive protocol weeks 
figures include time spent extending model public key encryption hashing 
adherence design principles explicitness simplifies proofs 
model checking effective means finding attacks replace theorem proving 
copes finitely states failure find attack says protocol works 
inductive proof symbolic examination protocol 
step analyzed turn 
reasoning explained informally letting understand protocol copes various circumstances 
protocol modified proof scripts old version form starting point analysis 
scripts take minutes run competitive model checking 
methods complement 
protocol designer model checking quick inspection apply inductive approach investigate deeper properties 
formal methods guarantee security 
theorems easily misinterpreted 
needham schroeder correct point view flawed version otway rees correct server point view participants detect tampering recall proof scripts distributed isabelle obtained url www cl cam ac uk research isabelle dist see subdirectory hol auth 

protocol proof contain separate guarantee reasonable assumptions participant 
attack recursive protocol reminder limitations formal methods 
models real world assuming strong encryption 
making model detailed reasoning harder eventually infeasible 
compositional approach necessary different levels abstraction protocol messages cryptographic algorithms transport protocols verified separately 
devising approach challenge 
needham gave valuable advice 
due bull otway explaining protocol gordon suggested simplification treatment freshness 
conversations abadi huet ryan wagner helpful 
bella graham lowe massacci staples anonymous referees commented drafts article 
research funded epsrc gr authentication logics gr mechanizing temporal reasoning esprit working group types 
mart abadi roger needham 
prudent engineering practice cryptographic protocols 
ieee transactions software engineering january 
peter aczel 
inductive definitions 
barwise editor handbook mathematical logic pages 
north holland 
ross anderson roger needham 
programming satan computer 
jan van leeuwen editor computer science today trends developments lncs pages 
springer 
bella lawrence paulson 
isabelle prove properties kerberos authentication system 
meadows 
dominique 
approach formal verification cryptographic protocols 
third acm conference computer communications security pages 
acm press 
dominique val rie morain 
formal verification cryptographic protocols coq 
technical report inria rocquencourt 
stephen 
hol extension automatically analyzing cryptographic protocols 
computer security foundations workshop pages 
jeremy steve schneider 
csp pvs recursive authentication protocol 
meadows 
john bull david otway 
authentication protocol 
technical report dra cis proj corba sc csm defence research agency uk 
press 
burrows abadi needham 
logic authentication 
proceedings royal society london 
john clark jeremy jacob 
security protocols 
information processing letters 
th computer security foundations workshop 
ieee computer society press 
th computer security foundations workshop 
ieee computer society press 
tim christopher allen 
tls protocol version january 
request comments internet ftp ftp isi edu notes rfc txt 
bruno steve schneider 
pvs embedding csp verify authentication protocols 
gunter amy felty editors theorem proving higher order logics tphols lncs pages 
dieter gollmann 
mean entity authentication 
symposium security privacy pages 
ieee computer society 
gordon melham 
hol theorem proving environment higher order logic 
cambridge university press 
james gray iii john mclean 
temporal logic specify verify cryptographic protocols 
computer security foundations workshop pages 
matthew hennessy 
semantics programming languages elementary structural operational semantics 
wiley 
hoare 
communicating sequential processes 
prentice hall 
richard kemmerer catherine meadows jonathan millen 
systems cryptographic protocol analysis 
journal cryptology 
richard kemmerer 
analyzing encryption protocols formal verification techniques 
ieee journal selected areas communications may 
gavin lowe 
breaking fixing needham schroeder public key protocol csp fdr 
margaria steffen editors tools algorithms construction analysis systems second international workshop tacas lncs pages 
springer 
gavin lowe 
new attacks security protocols 
computer security foundations workshop pages 
gavin lowe 
splice case study csp detect errors security protocols 
technical report oxford university computing laboratory 
gavin lowe 
casper compiler analysis security protocols 
journal computer security 
mao colin boyd 
formal analysis security protocols 
computer security foundations workshop vi pages 
ieee computer society press 
catherine meadows 
analyzing needham schroeder public key protocol comparison approaches 
bertino editors computer security esorics lncs pages 
springer 
catherine meadows editors 
workshop design formal verification security protocols 
dimacs september 
sam owre john rushby natarajan shankar friedrich von henke 
formal verification fault tolerant architectures prolegomena design pvs 
ieee transactions software engineering february 
lawrence paulson 
relations secrets formal analyses yahalom protocol 
journal computer security 
press 
lawrence paulson 
isabelle generic theorem prover 
springer 
lncs 
lawrence paulson 
ml working programmer 
cambridge university press nd edition 
lawrence paulson 
generic automatic proof tools 
robert editor automated reasoning applications essays honor larry wos chapter 
mit press 
lawrence paulson 
inductive analysis internet protocol tls 
acm transactions information system security august 
lawrence paulson 
tool support logics programs 
manfred broy editor mathematical methods program development summer school marktoberdorf nato asi series pages 
springer published 
rivest shamir adleman :10.1.1.40.5588
method obtaining digital signatures public key cryptosystems 
communications acm february 
roscoe 
modelling verifying key exchange protocols csp fdr 
computer security foundations workshop pages 
peter ryan 
design verification security protocols 
technical report dra cis cr defence research agency may 
peter ryan steve schneider 
attack recursive authentication protocol cautionary tale 
information processing letters january 
steve schneider :10.1.1.44.4593
verifying authentication protocols csp 
th computer security foundations workshop pages 
ieee computer society press 
