application pattern matching intrusion detection technical report csd tr sandeep kumar eugene spa ord coast project department computer sciences purdue university west lafayette cs purdue edu june report examines classi es characteristics signatures misuse intrusion detection 
cient algorithms match patterns classes described 
generalized model matching intrusion signatures colored petri nets properties derived 
computer break ins misuse common features met bos sto mar rei ssh 
number sophistication attacks computer systems rise 
network intruders easily overcome password authentication mechanism designed protect system 
increased understanding systems intruders skilled determining weaknesses exploiting obtain unauthorized privileges 
intruders patterns intrusion di cult trace identify 
levels indirection breaking target systems rarely indulge sudden bursts suspicious anomalous activity example sto 
account target system compromised intruders may carefully cover tracks arouse suspicion spa 
furthermore threats viruses worms need human supervision capable replicating traveling connected computer systems 
unleashed computer time discovered impossible trace origin extent infection 
tools necessary monitor systems detect break ins respond actively attacks real time 
break ins prevalent today exploit known security holes system software 
solution problems study characteristics intrusions extrapolate intrusion characteristics devise means representing intrusions computer funded division computer science department defense 
intrusion detection break ins detected real time 
report analysis computational framework designed matching signatures ciently 
intrusions di cult de ne terms behavior actions easily understood de ned terms ect computer systems 
de nition section brief description categories intrusion detection justi cation need intrusion detection systems sec 
approaches intrusion detection known 
include statistical methods monitor anomalies system sec pattern matching expert system techniques look de ned patterns attack sec 
techniques proposed inductive generalization means abstracting patterns behavior sec neural networks predicting behavior past behavior sec prediction failure indicative anomalous activity model techniques system continually updating model match observed behavior sec 
intrusions detected statistical methods speci cally watched 
technique monitoring speci patterns attack misuse intrusion detection di cult implement practical system variety reasons sec 
design generic misuse intrusion detection system desirable characteristics de ned outset 
propose set includes generality portability scalability real time performance sec 
system watches de ned intrusion signatures characteristics existing signatures classi ed terms basic characteristics linearity unification occurrence duration sec 
matching model proposed part generic misuse detector 
model colored petri nets lends graphical representation sec details properties sec 
forms matching model shown easy matching xed strings regular expressions matching uni cation shown hard 
possible optimizations model matching outlined 
proposed model matching compared desirable characteristics outlined earlier 
issue scalability matching patterns ciently discussed sec 
applicability compiler optimization techniques speed matching virtual machine forms basis described 
method achieving portability signatures di erent audit trails outlined sec 
realization characteristics better determined experimentally discussed report 
intrusion detection intrusion de ned set actions attempt compromise integrity con dentiality ofa resource 
violation security policy system 
de nition intrusion necessity imprecise security policy requirements translate de ned set actions 
intrusion detection methodology intrusions detected 
intrusion detection methodology divided categories anomaly intrusion detection misuse intrusion detection 
rst refers intrusions detected anomalous behavior computer resources 
example user uses computer ce am pm activity account late night anomalous 
user login outside working hours terminal server 
late night rlogin session host account considered unusual 
technique detecting intrusions attempts quantify acceptable behavior ags irregular behavior intrusive 
contrast second misuse intrusion detection refers intrusions follow de ned patterns attack exploit weaknesses system application software 
patterns precisely written advance 
example exploitation fingerd sendmail bugs internet worm attack spa come category 
technique represents knowledge bad unacceptable behavior sma seeks detect directly opposed anomaly intrusion detection seeks detect complement normal behavior 
mentioned schemes classifying intrusions method detection 
classi cation scheme intrusion types sma breaks intrusions types attempted break detected atypical behavior pro les violations security constraints 
masquerade attack detected atypical behavior pro les violations security constraints 
penetration security control system 
leakage detected atypical usage resources 
denial service detected atypical usage system resources 
malicious detected atypical behavior pro les violations security constraints special privileges 
premise intrusion detection schemes main premise anomaly intrusion detection intrusive activity subset anomalous activity 
reasonable considering outsider breaks computer account notion legitimate user pattern resource usage chance behavior anomalous 
intrusive activity carried sum individual activities anomalous 
ideally set anomalous activity coincides intrusive activity resulting lack false positives 
intrusive behavior coincide anomalous behavior 
possibilities non zero probability intrusive anomalous intrusive anomalous intrusive anomalous intrusive anomalous probabilistic basis intrusion detection see lv lv 
intrusion detection systems built date bk sma lv approaches detecting intrusions audit trail generated ac higher rated computer input 
example hlm analyze intrusions network connections ow information network 
input information appropriate domain intrusive activity needed detect intrusions 
domain information required determine variables accurately re ect intrusive behavior 
intrusion detection systems necessary 
computer systems broken regularly 
intrusions result generic weaknesses result accidental discovery exploitation aws resulting complexity 
words protection model systems theoretically provide adequate security intrusions 
validated software critical components thwart attempts intrude 
computer systems provide access control mechanism rst line defense 
de nes access object system permitted model restrict subject may object access manipulate den chapter 
access control model prevent illegal information ow system ow take place legal accesses objects 
information ow controlled provide security example bell lapadula model bl provide secrecy biba model bib provide integrity 
tradeo security convenience 
models conservative restrict read write operations ensure secrecy integrity system compromised 
consequently models jointly resulting system ag useful operation breach security condition 
secure system may useful 
furthermore access controls protection models help case insider threats compromise authentication module 
weak password broken access control measures little prevent stealing corruption information legally accessible compromised user 
general static methods assuring properties system overly restrictive simply insu cient cases 
dynamic methods example behavior tracking needed detect prevent breaches security 
approaches detecting intrusions systems built date anomaly misuse intrusion detection 
advanced techniques predicting patterns input seen far reactive keyboard intrusion detection systems built neural nets sec 

approaches example statistical approach resulted systems tested extensively research stage 
proposed methods intrusion detection systems include model approach sec 
included nides 
promising areas application systems discussed include bayesian clustering sec 

intrusion detection system approach designed date 
merits shortcomings current intrusion detection systems discussed 
dod security classi cation requiring auditing unavailability encrypted passwords 
approaches detecting intrusions statistical approaches intrusion detection anomaly intrusion detection ltg serves illustrate generic process anomaly detection large statistical nature 
anomaly detector observes activity subjects generates pro les captures behavior 
pro les require space storage cient update 
updated regularly older data appropriately aged 
input audit records processed system periodically generates value indicative abnormality 
value function abnormality values individual measures comprising user pro le 
example sn represent abnormality values pro le measures mn respectively higher value si indicates greater abnormality combining function individual values may ans ai general measures mn may mutually independent resulting complex function combining 
types measures comprising pro le example 
activity intensity measures measure rate activity progressing 
usually detect abnormalities bursts behavior detected longer term averages 
example number audit records processed user minute 

audit record distribution measures measure distribution activity types audit records 
example relative distribution le accesses activity entire system usage particular user 

categorical measures measure distribution particular activity categories example relative frequency logins physical location relative usage compiler shell editor system 
ordinal measures measure activity outcome numeric value example amount cpu particular user 
current user behavior stored current pro le 
regular intervals current pro le atomically merged stored pro le anomalous behavior determined comparing current pro le stored pro le 
pros cons statistical id advantage anomaly intrusion detection statistical techniques applicability 
example data points lie factor standard deviation side average considered anomalous 
integral absolute di erence functions time indicator deviation function 
statistical intrusion detection systems disadvantages 
statistical measures de ned capture computer usage patterns unique user nature measures true ltg systems pro les static change determined 
approaches detecting intrusions insensitive order occurrence events 
sequential interrelationships events 
intrusions re ected ordering patterns purely statistical intrusion detection system intrusions 
purely statistical intrusion detection systems disadvantage statistical measures capturing user behavior trained gradually point intrusive behavior considered normal 
intruders know monitored train systems length time 
existing intrusion detection schemes combine statistical part measure aberration behavior misuse part watches occurrence prespeci ed patterns events 
di cult determine right threshold anomaly considered intrusive 
apply statistical techniques formulation anomalies assume underlying data comes quasi stationary process assumption may hold 
misuse intrusion detection refers detection intrusions precisely de ning ahead time watching occurrence 
misuse component intrusion detection systems statistical techniques su cient detect types intrusions 
purely statistical methods prevent users altering pro les gradually period time point activity previously considered anomalous regarded normal 
furthermore step intrusion may anomalous aggregate may 
intrusion signatures usually speci ed sequence events conditions lead break 
conditions de ne context sequence intrusion 
abstracting high quality patterns attack scenarios extracting virus signatures infected les 
patterns con ict general capture variations basic attack simple keep matching computationally tractable 
patterns simple detection process automated 
primary technique misuse intrusion detection uses expert system 
proposes technique pattern matching viable option misuse intrusion detection sec 
example ss encodes knowledge attacks implication rules clips gia asserts facts corresponding audit trail events 
rules encoded specify conditions requisite attack part 
conditions left side rule satis ed actions right side performed 
primary disadvantage expert systems working memory elements fact base match left sides productions determine eligible rules ring essentially sequence 
hard specify natural ordering facts ciently natural framework expert system shells system directly pattern matching reported date 
objective frame intrusion detection problem pattern matching devise cient algorithms matching 
bene cient solution expert systems originally meant solve problems di erent domain 
frame matching problem easier rst classify patterns increasing order matching complexity example sec ensure facts numbered consecutively current expert system shells introducing fact numbering constraints rules enforce order rete match procedure ine cient 
approaches detecting intrusions fall set classes cient algorithms known devised 
rete match procedure expert system shells incorporated solution worse expert systems detect misuse intrusions 
misuse intrusion detector simply ags intrusions pattern input events assumes state transition system computer leads state exercised intrusion pattern regardless initial state system 
simply specifying intrusion signature state speci cation insu cient capture intrusion scenario fully 
security model de nition intrusion pattern oriented approach detection see sg 
primary disadvantage approach looks known vulnerabilities little detecting unknown intrusions 
feature selection measures detecting intrusions 
set possible measures chosen heuristically bearing detecting intrusions determine subset accurately predicts classi es intrusions 
exercise determining right measures complicated fact appropriate subset measures depends types intrusions detected 
set measures adequate types intrusions 
prede ned notions relevance particular measures detecting intrusions intrusions unique particular environment 
set optimal measures detecting intrusions determined dynamically best results 
consider initial list measures potentially relevant predicting intrusions 
results possible subsets measures presumably subsets result high predictability 
clearly search large space exhaustively 
genetic approach searching space right subset metrics 
learning classi er scheme generate initial set measures re ned rule evaluation mode genetic operators crossover mutation 
subsets measures consideration having low predictability replaced applying genetic operators yield stronger measure subsets 
method assumes combining higher predictability measure subsets allows searching metric space ciently heuristic techniques 
survey feature selection techniques see doa 
combining individual anomaly measures get composite picture intrusion 
measures determine intrusion occurring system moment 
ai measures di erent aspect system example amount disk activity number page faults system measure ai values implying measure anomalous 
hypothesis system currently undergoing intrusive attack 
reliability sensitivity anomaly measure ai determined numbers ai ji ai 
combined belief ija approaches detecting intrusions require joint probability distribution set measures conditioned huge data base 
simplify calculation expense accuracy assume measure ai depends independent measures aj yield leads ija ija aij aij determine odds intrusion values various anomaly measures prior odds intrusion likelihood measure anomalous presence intrusion 
order realistic estimate ija wehave take interdependence various measures ai account 
ltg covariance matrices account interrelationships measures 
measures represented vector compound anomaly measure determined covariance matrix representing dependence pair anomaly measures ai aj 
systems bayesian belief networks combine anomaly measures 
bayesian networks pea allow representation causal dependencies random variables graphical form permit calculation joint probability distribution random variables specifying small set probabilities relating neighboring nodes 
set consists prior probabilities root nodes nodes parents conditional probabilities non root nodes possible combinations direct predecessors 
bayesian networks dags arcs representing causal dependence parent child permit absorption evidence values random variables known provide computational framework determining conditional values remaining random variables evidence 
example consider trivial bayesian network model intrusion shown gure 
users intrusion disk intensive jobs 
cpu intensive jobs disk cpu net thrashing fragmentation newly available program net 
trivial bayesian network modeling intrusive activity approaches detecting intrusions box represents binary random variable values representing normal abnormal condition 
observe values variables bayesian network calculus determine 
general trivial determine priori probability values root nodes link matrices directed arc bayesian networks see cha 
conditional probability scheme predicting misuse intrusions method predicting intrusions outlined preceding section minor di erence evidence sequence external events anomaly measures 
interested determining conditional probability pattern applying bayes law equation get pattern event intrusion event pattern consider domain conditional probability predicted campus network university 
security expert associated campus able quantify prior probability occurrence intrusion campus intrusion experience 
intrusion reports campus tabulated determine type event sequence comprising intrusion event nding relative frequency occurrence event sequence entire intrusion set 
similarly set intrusion free audit trails determine inspection tabulation probability event intrusion 
conditional probabilities easily determine lhs simple bayesian arithmetic prior probability sequence event sequence es stands event sequence stands intrusion 
expert systems intrusion detection expert system de ned jac computing system capable representing reasoning knowledge rich domain view solving problems giving advice 
main advantage separation control reasoning formulation problem solution 
signi cant problems ective application expert systems intrusion detection voluminous amount data handled inherent ordering audit trail 
chief applications expert systems intrusion detection classi ed types 

deduce symbolically occurrence intrusion data misuse intrusion detection 
chief problems expert systems natural handling sequential order data expertise incorporated expert system security cer expertise modeled comprehensive lun technique detect known vulnerabilities software engineering concerns maintenance knowledge base lun 
approaches detecting intrusions 
combine various intrusion measures put cohesive picture intrusion short uncertainty reasoning 
limitations expert systems doing uncertainty reasoning known lun pea 
see sec 
page list limitations 
bayesian classi cation intrusion detection technique unsupervised classi cation data implementation autoclass cks chs searches classes data bayesian statistical techniques 
technique attempts determine process es generated data 
partition data classes de nes probabilistic membership function datum determined classes 
advantages approach 
autoclass automatically determines probable number classes data 

ad hoc similarity measures stopping rules clustering criteria required 

real discrete attributes may freely mixed 
statistical intrusion detection concerned classi cation observed behavior 
techniques till concentrated supervised classi cation user pro les created user observed behavior 
bayesian classi cation method permit determination optimal probabilistic sense number classes users similar pro les lumped yielding natural classi cation group users 
clear autoclass handles inherently sequential data audit trail statistical distributions built autoclass handle user generated audit trails 
lastly sure technique lends online data autoclass classi cation incremental basis new data available requires input data 
predictive pattern generation intrusion detection assumption sequences events random follow discernible pattern 
approach time inductive generalization che tcl uses inductive generated time rules characterize normal behavior patterns users 
rules modi ed dynamically learning phase rules rules low entropy remain system 
example rule generated tim tcl may security events 
rule says pattern observed events followed followed probability seeing previously observed data 
tim generate general rules incorporate temporal relationships events 
set rules generated inductively observing user behavior comprises pro le user 
deviation detected observed sequence events matches left hand rule events deviate signi cantly predicted rule statistical sense 
approaches detecting intrusions primary weakness approach unrecognized patterns behavior recognized anomalous match left hand side rule 
strengths approach 
claims better handling users wide variances behavior strong sequential patterns 

focus relevant security events entire login session labeled suspicious 

claims better sensitivity detection violations 
cheaters attempt train system learning phase discerned easily meaning associated rules 
neural networks intrusion detection basic approach train neural net sequence information units referred commands may level audit record 
input net consists current command past commands 
size window past commands neural net takes account predicting command 
neural net trained set representative command sequences user net constitutes pro le user fraction incorrectly predicted events measures sense variance user behavior pro le 
neural net conceptually looks ls chmod pwd vi predicted command output layer input layer ls chmod pwd vi conceptual neural nets intrusion detection neural networks learning neural nets back propagation see win 
drawbacks approach 
right topology net weights assigned element net determined considerable trial error 
approaches detecting intrusions 
size window independent variable neural net design 
low net poorly high su er irrelevant data 

approach induce patterns samples 
neural net trained exhaustively pattern instantiations 
advantages approach 
success approach depend statistical assumptions nature underlying data 

neural nets cope noisy fuzzy data 

automatically account correlations various measures ect output 
model intrusion detection approach proposed gl variation misuse intrusion detection combines models misuse evidential reasoning support occurrence misuse 
database attack scenarios comprises sequence behaviors making attack 
moment system considering subset attack scenarios ones system currently attack 
seeks verify seeking information audit trail substantiate refute attack scenario 
generates behavior veri ed audit trail current active models passes behaviors planner 
planner determines hypothesized behavior show audit data translates system dependent audit trail match 
mapping behavior activity easily recognized audit trail high likelihood appearing behavior 
say behavior high 
evidence scenarios accumulates drops active models list updated 
evidential reasoning calculus built system permits soundly update likelihood occurrence attack scenarios active models list 
advantages model intrusion detection 
mathematically sound theory reasoning presence uncertainty 
contrast expert system approaches dealing uncertainty retraction intermediate easy evidence contrary accumulates 
expert systems di culty explaining away facts contradicting earlier asserted facts known 
problems avoided graphical approach evidential reasoning 

potentially reduce substantial amounts processing required audit record monitoring coarser grained events passive mode actively monitoring ner grained events coarser events detected 
approaches detecting intrusions 
planner provides independence representation underlying audit trail representation 
disadvantages model intrusion detection 
approach places additional burden person creating intrusion detection models assign meaningful accurate evidence numbers various parts graph representing model 

proposed model suggest behaviors speci able sequential chain events limitation model 

clear model behaviors compiled ciently planner ect run time ciency detector 
weakness model se 
mentioned model intrusion detection replace statistical anomaly portion intrusion detection systems complements 
thorough treatment reasoning presence uncertainty see pea 
dorothy denning generic intrusion detection model den established model intrusion detection independent system type input speci intrusions monitored 
brief description generic model help relating speci examples intrusion detection systems viewing systems enhance 
fig 
describes generic intrusion detection system works 
event generator generic actual events may come audit records network packets observable monitored activity 
events serve basis detection abnormality system 
activity pro le global state intrusion detection system 
contains variables calculate behavior system prede ned statistical measures 
variables smart variables 
variable associated pattern speci cation matched generated event records matched records provide data update value appropriately 
example may avariable representing statistical measure sum calculates total number errors committed subject single login session 
variable associated statistical measures built system knows update information contained matched event records 
activity pro le generate new pro les dynamically newly created subjects objects pattern templates 
new users added system new les created templates instantiate new pro les 
generate anomaly records statistical variable takes anomalous value example takes inordinately high value 
rule set contains set expert system rules triggered event records anomaly records time expirations 
rules re antecedents satis ed inferences may trigger rules inferences 
interacts activity pro le updating rules 
variations rules comprising rule set determined rule set coded priori adapt modify depending nature interaction activity pro le environment learning classi er 
basic theme approaches detecting intrusions audit trail network packets event generator assert new rules modify existing rules update profile activity profile rule set gen anomaly rec clock generate new profiles dynamically generic intrusion detection model formulating statistical metrics identifying intrusions computing value recognizing anomalies values appears systems built date 
conceptually activity module anomaly detection rule set module performs misuse detection 
di erent techniques methods substituted modules altering conceptual view substantially 
newer techniques anomaly detection map internal details activity pro le outlined 
example neural net approach anomaly detection easily framework smart variables calculation number anomaly value 
clear module tim tcl placed 
detects behavioral anomalies candidate placed activity pro le generating rules ring conditions part rules satis ed expert systems 
approaches model approaches di erent framework directly 
shortcomings current intrusion detection systems general cost building intrusion detection system immense 
speci cation rules expert system choice underlying statistical metrics security expert familiar expert system rule speci cation language 
intrusion detection systems written environment di cult environments policies concerns 
system rule set speci environment monitored 
system sense ad hoc custom designed target 
reuse di cult system designed generic manner may ine cient limited power 
lastly easy way test existing intrusion detection systems 
potential attack scenarios di cult simulate known attacks di cult duplicate 
lack common audit trail format hampers experimentation comparison ectiveness existing systems common attack scenarios 
intrusion detection pattern matching summary intrusion detection techniques intrusion detection systems proposed implemented 
derive statistical intrusion detection model den 
example bk sma lv audit trail generated higher rated computer input 
example hlm try analyze intrusions analyzing network connections ow information network 
elaborated report expanded scope detection distributing anomaly detection heterogeneous network centrally analyzing partial results distributed sources piece picture potential intrusion individual analysis source 
non statistical approaches id teng tcl analyzes individual user audit trails attempts infer sequential relationships various events trail neural net modeling behavior 
promising approach intrusion detection systems involve bayesian classi cation cks chs 
issues including audit trail reduction browsing intrusion detection wet non parametric pattern recognition techniques lan audit trail reduction techniques permit compression audit data coarser higher abstraction events queried security cer retrieve information rapidly ciently 
non parametric techniques anomaly detection advantage assumptions statistical distribution underlying data useful assumptions hold 
interested reader advised follow information 
intrusion detection pattern matching previous section overview various types intrusion detectors commonly today techniques detecting intrusions 
section examines depth particular method detecting intrusions misuse intrusion detection pattern matching 
rst examine generic problems encountered misuse intrusion detection pattern matching notably amount data matched generality signatures matched 
state believe important goals system attempts misuse intrusion detection 
attempt lay metrics misuse intrusion detector measure ectiveness model misuse intrusion detection pattern matching 
implying completeness criteria hope captured signi cant requirements system 
focusing pattern matching means intrusion detection include brief overview relevant string matching results section 
results approximate string matching applicable misuse intrusion detection instances approximate string matching provides general solution needed misuse intrusion detection 
provide generic framework understanding characteristics intrusion signatures propose set orthogonal characteristics signatures signatures studied terms simpler basis properties 
partitioning discussed section section illustrates basis set classifying attack classes terms set 
section describes proposed model misuse intrusion detection 
intrusion detection pattern matching di culties intrusion detection pattern matching di culties doing misuse intrusion detection pattern matching 
generic problem far dominant sheer rate data generated modern processor 
typical audit mechanism ll gb disk hour multiuser system sun sparc cpu system saturate cpus disk channel logging activities cpus 
amount data substantially increases networked environment 
major problem nature matching 
attacker may perform actions di erent user identities di erent times ultimately leading system compromise 
intrusion signature speci cation nature requires possibility arbitrary events successive events signature generally interested rst occurrence signature partial matches signature moment requiring substantial overhead time space keeping track partial match 
scenarios may events 
di erent portions attack scenario executed login sessions system required keep track partial matches login sessions 
signature may specify arbitrary permutations sub patterns comprising pattern separately making recognition problem di cult 
attempt solve problems particular misuse intrusion detection pattern matching problems place larger context generic solution misuse intrusion detection 
bene providing yardstick general solutions compared serve qualify success solution propose criteria 
propose key design goals nal system matching detection model possess large measure possible 
generality 
model capture known hypothesized generation attacks 
ciency common case 
model fast common case unduly penalize common case uncommon case 
real time behavior 
portability signature representation existing audit trail formats 
portability considered ascending security rating implementations security rating di erent manufacturers 
embeddability 
desirability embeddability free signature representation language clutter providing general language constructs best left general purpose languages embedded 
scalability model increasing number signatures added system 
low resource overhead 
system consume inordinate amounts memory cpu run ectively 
intrusion detection pattern matching approach designing model misuse intrusion detection start classi cation resulting hierarchy intrusion scenarios devise cient algorithms detect intrusions category 
matching model tailored misuse detection show mentioned goals generality ciency common case portability scalability realized model 
remaining characteristics ciency real time behavior low resource overhead determined implementation model running tests 
results implementation report 
partition intrusion signatures orthogonal characteristics shown section illustrate classify categories attacks terms characteristics section 
fundamental assumption requirement matching audit trails intrusion pattern speci cations common case representing intrusion scenarios weighs heavily exclusively speci cation patterns embodying follows semantics immediately follows semantics 
example follows semantics pattern ab speci es occurrence event followed occurrence event immediately followed intervening event 
unix regular expression syntax means adjacent sub patterns pattern separated implicit 
assumption reasonable current mechanism audit trail generation modern user interfaces allow users login simultaneously windows audited events multiple processes overlap audit trail 
overwhelming requirement matching arbitrary number type intervening events speci ed events eld approximate pattern matching relevant detection 
outline related results eld section 
sections compare results obtained model 
brief overview relevant results pattern matching class pattern matching algorithms interest misuse intrusion detection discrete approximate matching 
basic requirement allowing arbitrary number events adjacent sub patterns 
discrete approximate matching broad scope detecting intrusions specialization interest termed matching follows semantics report 
longest common subsequence problem see wf fuller treatment referred lcs illustrate applicability approximate matching misuse intrusion detection 
consider input stream events matched pattern intrusion signature 
pattern occur input exact match immediately follows semantics desired 
approximate match desired pattern matches input sense indicates input event match pattern 
misuse intrusion detection question framed terms edit distance converting input pattern deletion costs insertion costs mismatch costs determine minimum cost converting input pattern 
insertions mismatches input pattern disallowed 
example problem linear time algorithm stated observation page 
general lcs problem solved dynamic programming mn intrusion detection pattern matching time size pattern input 
holds line online versions match 
line matching input known advance online case matching proceeds input character available 
results approximately matching various classes patterns summarized table 
time bounds hold arbitrary values deletion insertion mismatch costs optimized special case misuse intrusion detection 
restricted online matching primarily concerned real time intrusion detection 
re stands regular expressions sequence refers type patterns example xed linear patterns de ned page 
column match denotes type match determined corresponding algorithm 
entry denotes algorithm detects positions input match pattern ends reconstruct match sequence denotes algorithm construct match 
nding matches pattern input paths source sink problem computationally hard 
pattern time space match comment sequence mn wf dynamic programming 
sequence mn mn wf dynamic sequence byg wm pattern ts word computer 
small integer values costs 
re mn mm dynamic programming 
re mn mn mm dynamic include time enumerating matches may exponential approximate pattern matching useful misuse intrusion detection general problem misuse intrusion detection reasonably solved current pattern matching techniques 
example requires matching partial orders context free context sensitive structures matching presence time notion inherent audit trail generation important specifying intrusions 
traditional pattern matching restricted sequences subsumed notion time 
results pattern matching useful starting points investigation 
specialized classes patterns results directly applicable improved appendix 
attempt unify disparate algorithms pattern classes generalized model sacri cing ciency individual classes 
complexity matching requirement misuse intrusion detection partition intrusion signatures set orthogonal characteristics section intention classifying terms characteristics 
orthogonal characteristics patterns model attacks linearity 
linearity patterns mean speci ed sequence events comprising signature pattern strict chain event conjunction disjunction examples foo time time 
capitalized variables intrusion detection pattern matching denote arbitrary events occurrences capital variable refer value bound rst occurrence 
non linearity hand mean patterns specify partial orders 
say follows follows connection ab cd 
example attack scenario 
cp bin sh usr spool mail root 
chmod usr spool mail root 
touch 
mail root 
usr spool mail root speci ed partial order touch init cp chmod mail representing partial order events dependency touch occur mail 
states marked indicate initial states elaborated partial order 
uni cation 
characteristic patterns instantiate variables earlier events match events occurring events 
instantiation meant nite space pattern written set ors representing possibilities instantiation 
example specify pattern means event followed event followed stored available variable followed followed refer style intrusion signature speci cation matching pattern matching uni cation 
example attacks type 
ln setuid shell script 
intrusion detection pattern matching generalized pattern file file execute file 
name file 
owner file user 
permitted suid file 
shell script file 
permitted file permitted file 
user pattern illustrating uni cation capitalized identi ers file file variables take corresponding audit record pattern matched 
bound identi ers referenced retrieve values bound 
instantiated identi er values change 
occurrence 
characteristic speci es relative placement time event respect previous events 
example gure occurrence speci cation event transition occur transition 
event previous events placement constraint speci ed respect event 
example event mail transition previous events chmod touch 
complex constraint specify tt tt tt tt 
total time pattern matched easily speci ed imposing constraint event respect rst 
constraint speci ed event 
speci cation tt tt satis ed event att units event att earlier units 

speci es absolute time match pattern 
signi cant detection certain signatures meaningful certain times 
example invalid logins night signi cant daytime 
constraint permits ranges 
duration 
characteristic places constraints time duration event active 
speci ed range 
characteristics determine signi cantly kinds theoretical bounds placed matching solution 
dynamic input 
case input known advance matching begins input generated dynamically 
referred string matching literature online matching opposed line matching input known advance 
algorithm static case cient dynamic case intractable window previous input may considered application static algorithm concomitant loss accuracy detection 
dynamic patterns 
patterns added deleted matching proceeds 
useful model intrusion detection 
intrusion detection pattern matching match 
requirement nding matches pattern input stream simply nding pattern occurs stream 
order show relevance pattern characteristics resulting simpli cation examining intrusion signatures terms simpler characteristics take categories attack show represented orthogonal characteristics mentioned 
examples attack scenario classi cation previous section examined characteristics intrusion patterns breaking simpler independent properties 
properties build classi cation signatures section 
classi cation strictly hierarchy easy match levels classi cation intractable upper levels 
characteristics levels dropped higher levels 
classi cation meant illustrative outlined summarized table 

existence 
fact existed su cient detect intrusion attempt 
simple existence static scanning le system ala cops fs tiger ssh systems 
means looking changed permissions certain special les 

sequence 
fact things happened strict sequence immediately follows follows semantics su cient specify intrusion 
vast majority known intrusion patterns fall categories 
partial order 
events de ned partial order example 
duration 
requires existed happened certain interval time 

interval 
things happened exact plus minus clock accuracy interval apart 
speci ed conditions event occur earlier units time event 
table stands 
linearity column lin stands linear nl non linear 
means existence limiting case linearity sequence length tends 
note choice particular values lin unif corresponding types attack arbitrary re ects belief promising direction investigation cient algorithms 
type attack lin unif occ beg dur 
existence 
sequence 
partial order nl 
duration 
interval table classi cation attack types terms simpler pattern characteristics 
intrusion detection pattern matching model pattern matching overview section introduces pattern matching model proposed matching intrusion signatures 
colored petri nets 
intrusion signature represented petri net notion start states nal state de ne matching model 
notion linearity non linearity easily subsumed model generality unification introduced globally visible variables occurrence duration constraints introduced guard expressions net 
subsequent section analyze model see criteria speci ed earlier ideal misuse detector 
computation models considered suitability detecting intrusions pattern matching 
premise investigating models intuitively directly possible representing intrusion signatures 
example attribute grammars known turing complete program model computation mapped equivalent attribute grammar 
ag recognize set sentences underlying structure lend represented cfg intuitive useful human responsible writing intrusion signatures 

regular expressions 
traditional matching regular expressions fast linear input immediately follows semantics understood 
approximate matching polynomial input 
regular expressions represent simple attack scenarios including non linearity uni cation duration 

deterministic context free grammars lr lalr easily subsumed attribute grammars 
limited handle uni cation occurrence duration 
easy way extend match follows semantics 

attribute grammars provide powerful representation mechanism provide natural human understandable graphical model representation 
graphical models imposed similar cp nets 
furthermore useful humans writing intrusion signatures attribute grammars underlying signature speci cation need context free cient matching deterministic context free 
cfg easy way extend match follows semantics 

colored petri nets 
main advantage model conceptually general extensions change substantially 
naturally represented graphs de ned semantics 
adapted cp net model jen pattern matching generality conceptual simplicity graphical representability 
model represents form patterns internally stored matched 
externally language designed represent signatures programmer natural framework programs language compiled internal representation matching 
direction planned coast underlying matching model validated thoroughly tested 
recall brie attempt match incoming events audit trail records higher abstractions patterns representing intrusion scenarios 
consider example representation attack intrusion detection pattern matching scenario page represented gure 
initial states net nal state 
net model requires speci cation initial states represent partial orders events exactly nal state 
circles represent states thick bars transitions 
start match token placed initial state 
called initial marking net 
state may contain arbitrary number tokens 
arbitrary distribution tokens net referred marking 
net associated set variables prolog sense assignment variables tantamount uni cation globally visible pattern 
variables cp nets local transitions 
variables local transition simulated global variable name space 
allowing global variables dilute expressiveness model 
feel choice local global variables user interface issue rests domain language design language designed alternative representation model 
local variable speci cations language easily translated described model choosing separate part global variable name space done imperative language compilation 
related uses language front underlying matching model intrusion detection see wb 
token maintains local copy globally visible variables depending pattern token associated reason token variable bindings ows nal state 
cp net terminology token colored color thought cross product variable types associated pattern 
net contains set directed arcs connect places places transitions net 
arcs connect places places transitions tokens ow nondeterministically place triggered 
transition associated type event called label occur transition re 
example gure transition labeled event cp labeled event touch 
nondeterminism speci ed labels transitions labeling outgoing transition state label 
concurrency net event re transition 
transition said enabled input states contain token 
optional expressions called guards placed transition 
expressions permit assignment global variables pattern example values matched event elds variable testing equality calling built functions variables guards boolean expressions evaluate true false 
compare pk guards placed states transitions 
guards evaluated context event matches transition label set consistent tokens enable transition 
example gure order transition re token states enabling pair tokens consistently bound uni able pattern variables uni ed token event oftype satisfy guard 
transition res enabled event type label occurs satis es guard transition 
transition res input tokens caused transition re merged token copies uni ed token placed output place transition 
process merging resolves con icts bindings uni es rejects combination tokens tokens merged stores complete description path token traversed getting transition 
token represents binding composite path intrusion detection pattern matching token encountered way state 
example consider signature raises alarm number unsuccessful login attempts user kumar exceeds minute 
example serves illustrate idea bearing signature representation format 
login user kumar exception time failed login due exception login user kumar exception login user kumar exception login user kumar exception time corresponding cp net login login login login init final failed login attempts minute 
global variables associated pattern 
example consider xed partial order pattern gure init fixed pattern simulation intrusion detection pattern matching event sequence abac 
way pattern matched pattern consumed comment abac fs bac fs transition re concurrency 
nondeterminism allowed 
ab ac fs aba fs abac fs tokens merged 
token reconstruct path individual token initial marking 
note merging tokens occurs step con ict resolution 
example illustrates nondeterministic search pattern tokens removed states placed tokens right choice transitions 
deterministic exhaustive search hand tokens moved state duplicated copies moved states 
case matching absence guards duplication probably required events tagged data elds sense event unique tokens carry bindings permissible lose binding token moving transition previous binding preserved match duplicate created current match 
guards allowed transitions grouped categories file test operations example testing le readable writable executable ective real user id existence le testing size le set manipulation operations adding deleting testing presence element set system interaction functions system raising lowering audit levels interacting processes instantiated transition signature action 
may empty null 
provides hook event audit record matched transition 
event transition input returns set events audit records matched immediately previous event 
speci cation expressions refer values tokens 
logical arithmetic matching operators note process matching generate audit records response computation 
sake ciency average time exercise token analysis matching model patterns average time generation successive events system 
nature events events general tagged data 
particular time stamp event occurred special importance monotonicity properties time 
events arbitrary number usually small number tag elds 
exact number nature elds dependent type event 
mathematically think events tuples special eld indicating type event 
example think event occurring time tuple denotes type event 
analysis matching model previous section described matching model detail section presents theoretical properties 
complexity matching model increases rapidly increasing complexity patterns 
simplest linear patterns guards known algorithms discrete approximate matching mm wf byg wm applicable 
matching done deterministically ciently requiring preprocessing patterns 
pattern fixed regular partial order features preprocessing yield equivalent deterministic automaton expensive 
takes exponential time worst case convert nfa dfa asu pp 

converting nondeterministic partial order pattern equivalent deterministic automaton expensive appendix 
forbids preprocessing realistic set partial order patterns matching 
adding uni cation xed linear patterns problem matching np complete claim appendix 
expense preprocessing pattern types mentioned necessitates simulation non deterministic pattern representation 
structures input may exploited improve matching special cases 
structures outlined observation claim appendix 
reduce exhaustive search input matching certain conditions 
observation exploits monotonicity audit record elds example time stamp non decreasing 
monotonic expression fails monotonic eld particular audit record fails subsequent records depending directions expression eld 
claim observation single match pattern ab follows semantics satis ed choice subsequent signi cant results appendix sections consider important practical aspects scalability portability inthe model 
measure scalability lack degradation performance increased number patterns 
ideally degradation sub linear linear increase number patterns albeit linear increase preprocessing time 
common subexpression elimination techniques exploit commonality guard subexpressions placed various pattern transitions reduce degradation appendix sec 
portability considered sec concerned ensuring intrusion signatures moved sites rewriting accommodate ne di erences vendor implementation analysis matching model security rating 
ensures transparent movement higher security rated systems 
audit record de nition standard de nition virtual machine represent guards ensures patterns precompiled intermediate representation moved systems minimal overhead theoretical results de nitions fixed linear pattern matching denotes matching kmp kmp moore bm sense pattern consists sequence known events symbols kmp bm forming chain event conjunction disjunction regular features 
examples abc foo 
contrast patterns events xed prespeci ed pattern linear may partial order features 
example pattern speci cation gure init states states final state non linear xed pattern xed linear 
numbers represent states vertices directed graph alphabets representing events label edges 
patterns denoted fixed 
linear pattern matching denotes matching patterns speci ed sequence events comprising pattern may xed allowing uni cation sec example pattern strict chain event conjunction disjunction example time time 
key result note complexity matching model exception generalized partial orders exponential obs 
pg 
appendix 
matching results specialized classes summarized 
derivation details appendix attack classi cation listed properties terms pattern characteristics similar table 
size pattern input 
analysis matching model attack lin un occ beg dr time space match ref existence sequence obs 
pg 
sequence ii cl pg 
reg 
expr 
nl mn obs 
pg 
partial order nl nm pg 
duration interval log aa table summary matching algorithms di erent attack classes 
legend dr duration characteristic associated events comprising pattern 
match refers match 
ref lists explaining result detail 
comment existence patterns may associated clock event specify evaluation condition speci ed intervals 
number initial states partial order 
rarely desirable convert type pattern deterministic matching automaton 
general linear pattern matched exponential time trying possible sequences input 
unaware better bounds case 
ap occurrences symbol pattern occurrences input yields line upper bound mn log 
intrusions determined testing condition classi ed class existence 
class uni cation instantiated variables referenced transitions 
includes representation condition 
evaluating condition requires time direct proportion size conditions loop free see example appendix 
pattern speci ed sequence events classi ed sequence 
matching sequence conditions uni cation done ciently time single match desired 
matches desired takes mn space exponential time 
finding matches transformed nding distinct paths source node set sink nodes may exponential paths appendix 
uni cation desired sequence problem matching np complete 
di cult match linear patterns require uni cation matching general linear patterns obs 
pg 

majority scenarios common today belong existence sequence class 
np completeness bound holds arbitrary patterns input 
practice factors signi cantly reduce bound 
arbitrary general uni cation rarely desired 
example uni cation event type seldom required 
uni cation done audit record elds audit record type signi cantly reduces computation required matching 
uni cation nite space patterns written alternation signi cantly reduce matching complexity 
result linear pattern non analysis matching model linear little non determinism resulting pattern matching takes time general result mn time 
patterns deterministic including regular expression partial orders number initial states partial order small 
practically matching regular expressions done time partial orders time worst case bound 
multiple instances intrusion pattern rarely overlap carefully written ensure 
means successful match tokens ancestors matching combination destroyed 
need look overlapping matches 
rest categories associated time space bounds self explanatory 
optimizations matching categories 
outlined appendix matching general case improved exploiting monotonicity audit record elds 
optimizations detailed appendix practical system order control space requirements tokens lead match garbage collected 
example tokens may variables bound process numbers system objects 
objects destroyed corresponding tokens may garbage collected 
machinery required add conceptually model matching 
machinery obviates need specify explicit exclusion events pattern resulting simpler pattern speci cations 
shown multiple patterns matched model 
scalability matching patterns ciently problem scalability controlling complexity matching number patterns matched increases 
section investigates approaches matching patterns audit trail 
matching xed linear patterns takes time regular expression formed alternation patterns worst case 
case regular expressions subsumed matching single regular expression 
matching partial orders discussed matching general patterns 
virtual machine instruction set de ned represent evaluate guards common subexpression elimination techniques compiler design asu improve evaluation 
example see appendix shows asymptotic runtime reduction multiple guard evaluation 
scalability results derived model summarized 
classes attack table 
number patterns matched simultaneously 
patterns size mk respectively mk total pattern size 
size input largest mi 
details appendix function grows faster itis grows rate analysis matching model attack lin unif occ beg dur time space mat ref existence sequence mn obs 
pg 
sequence ii exp re nl mn obs 
partial order nl duration exp interval kr log obs 
aa table summary matching multiple patterns attack category 
classes approach matching patterns match independent 
observation matching general patterns reduces complexity matching 
input audit event transitions labeled event type need exercised 
event types uniformly distributed pattern input substantial savings may result 
table take account presence guards transitions 
approach matching presence guards ignore matching success verify satis ed 
chief di culty approach techniques space cient approximate matching store entire dynamic programming matrix current previous columns column equals size pattern 
means positions input approximately match pattern determined matches 
way verify guards satis ed determining exact match guard evaluation dependent audit record elds 
approaches matching multiple general patterns general case pattern cp net involving multiple patterns approaches simplest exercise pattern input event 
pictorially looks pat pat input event approach handling multiple patterns analysis matching model lled dots represent tokens corresponding enabled transitions patterns may exercise current event guards transitions evaluate true 
pattern keeps track tokens may need duplicated moved control exercise tokens pattern may return control immediately transition res input event 
slightly improved approach compute input event tokens patterns possibly exercised 
approach looks pat pat input event approach handling multiple patterns box takes input event computes tokens patterns corresponding enabled transitions possibly transition event 
unnecessary hand control patterns enabled transition exercised current event avoids lookup done pattern individually determine enabled transitions may cient coalescing individual lookups 
better approaches 
approaches disregard evaluation guards transitions computing list active tokens evaluate guard enabled transition guard expressions similar 
common subexpression elimination techniques compiler theory applied avoid re evaluation guards 
idea combined representing match patterns network 
amount common subexpression elimination realized depends number nature guards 
expression elimination achieved guards broken simpler primitive expressions similar case compiling code 
done de ning virtual machine simple instructions evaluate guards 
standard de nition machine instruction set help portability compiled guards patterns machines 
virtual machine needs extensible newer information sophisticated audit trails easily incorporated 
instruction types supported 
assignment uni cation 

indexing retrieve elds audit record 

useful operations interact operating system general purpose utility functions 
analysis matching model 
regular expression matching 

testing conditionals 
example machine see appendix portability portability mean portability signatures di erent interpretations auditing level different manufacturers underlying operating system 
similarity underlying operating systems dictates similarity aws versions 
example di ering interpretations security sunos svr 
representing signatures machine independent format standard de nition virtual machine matching patterns extensible audit trail independent speci vendor implementation portability signatures ensured 
levels translation native audit trail audit trail read process trail internally matching avoided appropriate description native audit trail format backend virtual machine 
virtual machine speci audit trail architecture look native audit trail format description generic vm tx vm specific audit trail signatures usable ascending auditing level os 
achieved appropriate de nition audit trail signatures written lower security auditing level moved higher security auditing level 
converse true general may information higher security auditing lacking lower 
case appropriate error agged 
generically signatures thought equivalent ways program speci cations data matching program 
program speci cation compiled audit trail matching program compiled speci audit trail 
dependence speci audit trail architectures removed de ning intermediate standardized audit trail results extra level indirection matching 
extensions guards corresponding transitions label merged cse clear order merged 
semantics expressions forming guard ideally expressions guards merged order achieve maximum overlap expressions account probability occurrence expression 
rete network generation applicability problem compile guards order achieve better performance 
interesting determine certain audit records omitted exercised token pattern ecting accuracy detection class intrusions interest 
accuracy ected useful characterize relationship types amount omission accuracy detection di erent classes intrusions 
mentioned section states arbitrary 
may possible practice 
interest determine matching ected capacity states hold tokens restricted replacement scheme put ect determine token discarded adding newer generated tokens 
class intrusions common today follow locality attack rule respect tokens 
directly related useful design bayesian belief network incorporates interdependence various anomalies intrusions common today suggested section 
model useful combining observed data system assigning belief hypothesis intrusion occurring observed data 
summary followed broad outline studied formalized problem applying pattern matching solution misuse intrusion detection sec 

proposed set metrics evaluate generic misuse intrusion detector 
simple engineering solution problem sec 

analyzed solution derive theoretical properties outlined limitations 
suggested methods heuristics improve solution practice sec 
appendices 
model interesting appealing theoretical standpoint 
true test evaluation implementation running live conditions 
hope implement model get experimental results near 
results reported report 
model implemented goal sample intrusion patterns available wants 
users add libraries signatures deal intrusions speci site 
interested parties invited contact authors current status availability information 
division department defense funding 
chandrasekaran provided valuable comments structuring 
discussions dr demillo dr young dr atallah provided insight problem 
appendix appendix appendix presents results matching various categories attack patterns model 
results speci ed derived case matching follows semantics 
arguments lieu formal proofs substantiate claims 
formal proofs appear subsequent report 
results claims observations 
claims signi cant observations regarded corollaries 
matching fixed linear patterns observation online xed linear pattern matching follows semantics done linear time man ex 
pg 

example determine pattern ba occurs input follows sense requires single scan input 
compare result approximately matching sequence xed linear pattern arbitrarily speci ed penalties deletion insertion substitution pairwise symbols 
result requires mn time space section online case 
size pattern input 
primary reason time follows semantics insertion substitution edges approximate matching graph matching deletion edges 
compare graphs matching ba input general case follows semantics 
opposed fuller graph general case graph follows semantics sparse 
pattern state pattern signifying source source match input input alignment graphs representing matching arbitrary insertion deletion substitution costs left follows semantics right 
matching ba follows semantics matching immediately appendix follows semantics determination presence absence pattern input desired pattern equivalent matching input 
directly represented deterministic automaton require simulation non deterministic automaton representing conversion equivalent dfa 
converting nfa encoding xed linear pattern matched follows semantics dfa immediately follows semantics results chain states back edges earlier states 
obviates need backtracking failure functions 
previous discussion matching single pattern follows semantics match su ce 
matches desired alignment graph pattern input yield matches exponential time polynomial space 
pattern size small word length computer matching done matches determined linear time algorithm baeza yates gonnet byg augmented wildcard case manber wu wm 
algorithms determine character position input ends match pattern conceptually sliding pattern input 
result correct number possible matches ways matching terminating input character coalesced single match 
procedure reconstruct exact match sequence 
determine matches match sequences entire alignment graph preserved paths source sink states marked determined 
observation exponential paths source sink node alignment graph matching xed linear pattern follows semantics 
graph allows kinds edges matching deletion 
size pattern input exactly matching deletion edges required 
implies pick events input corresponding matching edges rest deletion edges 
order input preserved cm choices 
choices 
matching regular expressions ci matching fixed non linear patterns involved matching considered regular expressions partial orders 
xed linear patterns 
cases observation regular expressions matched follows semantics polynomial time 
appendix approximate matching regular expressions solved wagner ws myers miller mm 
approach taken mm followed 
solution constructs non deterministic nite automaton regular expression special way 
states automaton label input symbols graph reducible state having maximum degree degree 
alignment graph pattern input consists copies automaton similar row states representing xed linear pattern replaced automaton graph 
approximate matching solution result applying dynamic programming recurrence states alignment graph 
recurrence relation state evaluated topological sweeps copy automaton 
time required mn 
permits arbitrary values speci ed insertion deletion substitution costs pair symbols 
single match follows semantics desired simulation procedure asu page adapted follows closure fs eof closure move return endif single match regular expr follows semantics 
key di erence algorithms shaded 
follow subset construction form set possible states automaton examining symbol input 
di erence algorithm states reached input ignoring symbols 
states reached input subset states reached input ignored automaton 
simulation procedure combined automaton construction procedure mm optimizations single match case 

back edges need taken 
optimization follows reducibility graph 
match necessarily longest desired revisiting states advantageous 

output states state set state removed consider sets states fsg fsg 
input performing sets denoted fsg fsg results fsg fsg outgoing edge leads states amount resulting observations determined simulation 
appendix regular expression ts word length machine matching done matching may done linear time wm 
regular expressions matched simultaneously combined yield single regular expression 
matching partial orders complex matching regular expressions considered 
observation event symbols occur equally frequently pattern matching xed mn linear regular expression patterns done time size pattern input number distinct event symbols 
construction matching regular expressions obs 
xed linear pattern trivial regular expression maximum size set uniformity assumption input event match elements exercising input events takes time mn gives positions input match pattern 
matching partial orders adaptation asu page match xed partial orders 
ii initial states partial order 
simplicity transitions assumed enabled 
enabling incorporated function move 
set initialized cross product closure sets initial state 
input symbol augmented include ways exercising thread partial order 
pattern matched threads reach nal state cross product denote kth element 
function move described asu 
appendix closure fi closure eof add move tos return endif move state input return closure move 
closure move single match partial order follows semantics 
similar optimizations mentioned matching regular expressions revisiting states may 
translate easily skipping set edges automaton 
cross product represents possible combination threads partial order 
represent possibilities 
input symbol may exercise thread deterministic matcher exercise turn 
cross product results cross products exercised 
starting number cross products added step thread may take size pattern exercised total time required mi mi mi observation fixed partial order pattern matching immediately follows semantics done time jqj jij set states set initial states partial order size input 
example jqj jij gure 
discussion term denote non deterministic nite state automaton recognizes xed partial order pattern speci cation dpfa corresponding deterministic nite state automaton 
follows straightforward subset construction pattern outlined 
di erence case subset construction nfas threads input event matched corresponding thread begun corresponding initial state partial order 
furthermore non determinism possible thread just case nfa 
external event discarded match transition thread nondeterminism appendix prevents knowing 
exercise turn represent composite transition information set individual thread transition 
state matching partial order looks thread state thread ig consider exercising particular string reaches state state embodies information possible way matching set states reached input represents possible ways exercising input state transition symbol leads states state corresponding exercising ith thread 
converted dpfa straightforward subset construction automata theory 
number states possible number states corresponding dpfa matching uni cation claim pattern matching uni cation np hard 
show type pattern linear pattern uni cation np complete 
reduction arbitrary hamiltonian circuit problem 
arbitrary graph hamiltonian cycle determined vertices edges 
generate graph description description edges input events description directed edges emanating vertex written 
node edge description written rst 
edge written tail head 
ctitious tuple type elements simply cast hamiltonian cycle problem matching problem 
done time 
generate pattern matched edge description input time follows line pattern represents edge graph 
pattern represents hamiltonian cycle graph 
pattern matches successfully necessarily di erent successive elements pattern matched matched group edges emanating ifz matched node previously matched matching proceed group directed edges emanating node skipped input rolled back 
shows pattern matching uni cation np hard 
problem np polynomial time bounded oracle guess values matched 
example graph appendix possible edge description corresponding pattern edges emanating edges emanating edges emanating edges emanating edge description pattern matching simpli ed occurrence constraints observation sequence input xed linear pattern polynomial time algorithm decide entire pattern detected certain amount time 
example consider pattern bca matched time units events time event xed sequence input simple example time bounded pattern match 
follows semantics determine minimum time occurrence pattern bca starting determine occurrence followed occurrence minimum time occurrence bca starting 
minimum time occurrence pattern bca starting compute value minimum time occurrence pattern bca min time occurrence bca worst case time algorithm events potential instances pattern matched event require matched instance 
appendix observation xed sequence input xed linear pattern exponential time line algorithm decide pattern match maximum time successive events 
construction label input events type subscripts starting increasing sequentially see 
construct tree labeled events successive levels tree correspond successive events pattern 
pictorial representation input edges labeled corresponding event illustration 
pattern abc time event label example pattern constraints successive events 
illustration entire tree depicted reality edges satisfying maximum time criterion successive events real tree 
construction tree requires worst case time events pattern size depth tree branching factor worst case 
nodes depth correspond matched patterns 
space requirement exponential maximum number possible matches cm note addition maximum time events maximum time speci ed handled straightforward manner 
construction requires event sequence prespeci ed 
converting input tree matching 
aa shown better bounds generalized version problem 
solution requires log time number input events ap occurrences pattern occurrences input yields line upper bound mn log 
matching general patterns having considered complexity matching xed linear patterns regular expressions partial orders matching uni cation investigate structures input reduce complexity matching mentioned problems general case 
results previous appendix section show deterministic matching requires considerable expense space time conversion non deterministic patterns deterministic recognizing automaton 
expense precludes precompilation time 
matching requiring possible matches expensive general case match 
single match algorithms applied matches non overlapping 
case automaton restarted initial state reached nal state 
structures input useful detecting particular types intrusions 
observation exhaustive search avoided matching guards pattern speci cation monotonic 
example consider gure guards transition cutting edge transition cutting edges matching consider token state duplicated state awaiting merging state 
assume transition re combination tokens ft guard pair satis ed 
indicates need duplicated duplication result larger value resulting failure guard 
possible time stamps successive events non decreasing operator monotonic 
false false 
observation applicable non monotonic data elds 
property apply 
exactly part search space excluded 
formalized claim claim matching monotonic data token may destroyed node dominating eld gets de ned state nal state path monotonic expression involving satis ed 
consider pattern path appendix initial states nal state dominates darkened path path token ows monotonic data eld audit record gets bound pattern variable state dominates token pass reaches reaching merge tokens intermediate transitions 
step movement oft copies token copies copies moved states 
monotonic condition involving satis ed copy oft rst reaching condition satis ed copies occupy states path including state monotonicity expression involving combinations set tokens resulted may prohibited yield non increasing non decreasing value depending type monotonicity expression continue result failure 
observation easily generalized multiple monotonic elds 
elds monotonic expressions involving claim single match case tokens moved duplicated states lead single input transitions involve uni cation additional bindings variables 
consequence conditions pattern variable associated token changes 
duplications alter token bindings 
result expressions evaluated transitions ected 
duplicated tokens traverse path new solutions discovered 
observation single match case matching soon variables associated pattern instantiated token token need duplicated 
result holds concerned nding matches pattern input rst match su ce 
follows fact variables assigned modi ed 
token variables bound values unique duplicating simply identical copies token 
matches desired single copy 
note imply preservation number tokens token moved transition output arcs input arc number tokens exact type increase 
current section discussed theoretical results obtained model 
results focused cient matching single pattern 
section discusses patterns may matched ciently 
observation matching general patterns exclusion partial orders done exponential time 
general pattern size including guards input size matching pattern input immediately follows semantics done time mn simulation appendix non deterministic matching 
exponential number choices selecting subsequence necessarily substring input events yielding time mn 
appendix matching multiple patterns appendix matching multiple patterns matching multiple fixed linear patterns observation matching time patterns xed linear patterns follows semantics done size input 
follows obs 
pg 
running matching procedure pattern simultaneously 
compare ac multiple xed linear patterns matched immediately follows semantics linear time 
primary reason di erence ac set states maintained algorithm matches set states reachable input nfa matching follows semantics requires maintenance set states reachable pre input characters deleted 
way automaton constructed set states represented single state 
regular expression patterns say re rem written regular expression re matched approximately mn page total length patterns 
optimizations mentioned approach applicable 
appendix example subexpression elimination guards appendix example subexpression elimination guards consider example attacks see description guards 
ln setuid shell script 
ln setuid shell script foo foo rm foo ms ln favorite shell script foo considerable similarity sub signatures 
event oftype link evaluated may need 
signatures may compiled show 
representative translation may di erent nal form speci cation virtual machine instruction set semantics continuing evolve 
translation process discussed report scope 
compilation 
obj link 
transition transition numbered transitions 

obj src file indexing primitive polymorphic operation 

file global variables assigned temporaries 
file file 
obj dest file variables global pattern 

file temporary variables named number 

obj uid 
global pattern 

owner file owner built function returns owner le 

ifm exit matches jump exit 

name file built function giving portion full path name 

ifm exit matches jump exit 

shell script file built function test le shell script 

iffalse exit jump exit 

file built function giving permissions le 

constant determine le group executable 
iffalse 
res signals successful evaluation guard 

return return guard 


constant determine le executable 

iffalse 
res appendix example subexpression elimination guards 
return 
exit 
res signals unsuccessful evaluation guard 

return compilation 
obj link 
transition transition numbered transitions 
obj src file temporary variable numbers reset 

file 
obj dest file 
file 
shell script file 
iffalse exit 
file 

iffalse 
res 
return 


iffalse 
res 
return 
exit 
res 
return superscripted numbers instructions correspond value numbers outlined cs 
expression obj src file single value number indexing primitive operation virtual machine 
guard expression begins instruction form obj audit variable obj special automatically instantiated audit record currently analysis possible match 
instruction serves limit types audit records tried possible match instruction sequence 
audit record type link possibly evaluate expressions successfully 
variables special meaning res value determines guard evaluated successfully transition refers particular guard transition currently compiled 
number index vector transitions element denotes corresponding transition res 
combining set compiled instructions transitions labeled event type non trivial 
guard expression may involve resulting conditional jumps compiled code 
complicates static subexpression elimination jumps guards 
common subexpression elimination basic block useful small little redundancy 
appendix example subexpression elimination guards important decision method combining guard expressions 
guards combined chain common subexpression elimination performed composite sequence organized network similar rete networks improve running time evaluation account dynamic evaluation 
organizing network con guration needs determined duplication rearrangement guards historical statistics truthful evaluation 
approach taken combine guards chain arbitrary order perform elimination basic blocks guards introducing notion active inactive regions code 
notion similar commonly data driven simd architecture machines force processors execute instructions remaining ignore vector mask enable disable processor 
virtual machine de nition instructions treated di erently depending type region code 
active region code region executed virtual machine enabled 
rest code part inactive region 
determined statically evaluation conditional expressions uences boundaries 
expressions evaluated inactive region termed inactive 
lack loops jumps guard expressions enable translation forward jumps 
virtual machine executing composite code treats un conditional jumps specially 
jumping speci ed label stores address disables setting condition code register 
processor disabled certain types instructions evaluated 
jumps forward machine enabled correctly jump address reached point resumes normal operation evaluates instruction encounters 
arti ce ensures expressions evaluated available expressions evaluated 
regardless expressions active inactive 
assignments pattern variables associated token occur temporaries assignment non temporary variables disabled inactive region 
prevents undesired side ects ensuring subexpressions evaluated reside appropriate temporary variables 
procedure common subexpression elimination outlined cs code guard expressions looks shown 

obj link 
transition enabled transitions transition set processor state disabled jump ect processor state disabled 
obj src file 
file assignment global variables ect 
obj dest file processor disabled 
file 
obj uid 

owner 
ifm exit conditional jumps ect processor 
transitions transition 
jump pattern return 
enabled transitions vector element indicates particular transition enabled 
transitions vector elements indicate corresponding transition 
percentage reduction number instructions 
instructions compiled away added 
case guards 
note instructions compiled away second expression 
asymptotic case rst expressions result subexpression eliminations example asymptotically result reduction statements tends 
gures reduction number instructions imply corresponding decrease execution time code depends run time behavior conditionals 
simplify analysis assumption uniform elimination basic block implies corresponding decrease evaluation time guards 
order determine tokens initial states gures need duplicated moved succeeding state need evaluate code audit record type link 
leads question ciency approach 
possible guards true require expression guard evaluated 
approach worse evaluating guard individually case short circuiting result fewer expressions evaluated 
believe savings approach amount dependent type guard expressions commonality 
nature matching process transitions enabled continue remain enabled 
guard evaluated evaluated 
approach provides mechanism pro right set signatures 
actual system incorporate types approaches subexpression elimination heuristics run time statistics approach 
summary properties ensure semantic consistency expressions simplify cse generated code 

pattern variable values referenced guard set outside value propagated patterns re evaluated token rst time referenced guard 

jumps compiled code forward 
arranged compiler loops guard expressions 
implies structure guard expression dag forward edges 
consequence dead variables detected simply examining rest code 
treatment compiler optimization issues see asu fl 
aa mikhail atallah alberto apostolico 
personal communication 
ac aho corasick 
cient string matching aid bibliographic search 
communications acm june 
asu alfred aho ravi sethi je rey ullman 
compilers principles techniques tools 
addison wesley 
bib biba 
integrity constraints secure computer systems 
technical report esd tr usaf electronic systems division bedford massachussetts april 
bk david bauer michael 
expert system real time network intrusion detection 
proceedings computer networking symposium pages 
ieee new york ny april 
bl bell lapadula 
secure computer systems mathematical foundations model 
technical report mitre bedford massachussetts may 
bm boyer moore 
fast string searching algorithm 
communications acm 
bos computer puts virus computers 
boston herald page nov 
byg baeza yates gonnet 
new searching 
proceedings th annual acm sigir conference information retrieval pages cambridge ma june 
cha eugene charniak 
bayesian networks tears 
ai magazine pages winter 
che chen 
inductive engine acquisition temporal knowledge 
phd thesis university illinois urbana champaign 
chs peter cheeseman robin hanson john stutz 
bayesian classi cation correlation inheritance 
th international joint conference onarti cial intelligence august 
cks peter cheeseman james kelly matthew self john stutz taylor don freeman 
autoclass bayesian classi cation system 
proceedings fifth international conference machine learning pages 
morgan kaufmann june 
cs cocke schwartz 
programming languages compilers preliminary notes second revised version 
courant institute mathematical sciences new york 
den dorothy denning 
cryptography data security 
springer verlag london 
den dorothy denning 
intrusion detection model 
ieee trans 
software engg number page feb 
doa justin 
intrusion detection application feature selection comparison algorithms application wide area network analyzer 
master thesis university california davis dept computer science 
kevin fox henning jonathan reed richard 
neural network intrusion detection 
proceedings th national computer security conference pages washington dc october 
fl charles fischer richard leblanc 
crafting compiler 
benjamin cummings menlo park california 
charles forgy 
rete fast algorithm object pattern match problem 
arti cial intelligence volume 

fs daniel farmer eugene spa ord 
cops security checker system 
technical report csd tr purdue university department computer sciences september 
gia joseph 
clips version user guide 
nasa lyndon johnson space center information systems directorate software technology branch march 
gl garvey lunt 
model intrusion detection 
proceedings th national computer security conference pages october 
le charlier mathieu 
software architecture rule language universal audit trail analysis 
proceedings esorics toulouse france november 
hlm heberlein levitt mukherjee 
method detect intrusive activity ina networked environment 
proceedings th national computer security conference pages october 
maccabe 
architecture network level intrusion detection system 
technical report university new mexico department computer science august 
ilgun 
ustat real time intrusion detection system unix 
master thesis computer science department university california santa barbara july 
jac peter jackson 
expert systems international computer science series 
addison wesley 
jen kurt jensen 
coloured petri nets basic concepts springer verlag 
jagannathan teresa lunt debra anderson chris dodd fred hal javitz peter neumann ann alfonso valdes 
system design document generation intrusion detection expert system nides 
technical report sri international march 
kmp knuth morris pratt 
fast pattern matching strings 
siam computing 
lan linda 
non parametric pattern recognition anomaly detection 
phd thesis tulane university dept computer science 
teresa lunt jagannathan lee alan sherry 
knowledge intrusion detection 
proceedings annual ai systems government conference washington dc march 
ltg lunt jagannathan neumann javitz valdes garvey 
real time intrusion detection expert system ides final technical report 
technical report sri computer science laboratory sri international menlo park ca february 
lun teresa lunt 
survey intrusion detection techniques 
computers security june 
lv liepins vaccaro 
anomaly detection purpose framework 
proceedings th national computer security conference pages october 
lv liepins vaccaro 
intrusion detection role validation 
computers security pages 
man udi manber 
algorithms creative approach 
addison wesley reading mass 
mar marko author computer virus son electronic security expert 
new york times page nov 
met metz 
computer break ins 
communications acm july 
mm eugene myers webb miller 
approximate matching regular expressions 
bull 
math 
biol volume pages 

real time audit log viewer analyzer 
pea judea pearl 
probabilistic reasoning expert systems 
morgan kaufman 
pk phillip porras richard kemmerer 
penetration state transition analysis rule intrusion detection approach 
eighth annual computer security applications conference pages 
ieee computer society press ieee computer society press november december 
rei brian reid 
re ections widespread computer break ins 
communications acm february 
dias heberlein ho levitt mukherjee 
dids distributed intrusion detection system motivation architecture early prototype 
proceedings th national computer security conference pages october 
sg winston gligor 
pattern oriented intrusion model applications 
proceedings ieee computer society symposium research security privacy pages 
ieee ieee service center piscataway nj may 
sma stephen 
haystack intrusion detection system 
fourth aerospace computer security applications conference pages applied science austin tx dec 
sma steve 
questions 
proceedings workshop directions computer misuse anomaly detection march 
spa eugene spa ord 
internet worm program analysis 
technical report csd tr department computer sciences purdue university west lafayette november 
spa eugene spa ord 
crisis 
communications acm june 
ss steven stephen 
signature analysis model de nition formalism 
proc 
fourth workshop computer security incident handling denver august 
ssh david sa ord douglas david hess 
tamu security package outgoing response internet intruders academic environment 
proceedings fourth usenix security symposium 
usenix association 
hanna 
expert systems intrusion detection case study 
proceedings th national computer security conference october 
sto cli ord stoll 
hacker 
communications acm may 
tcl henry teng chen stephen lu 
security audit trail analysis inductively generated predictive rules 
proceedings th conference onarti cial intelligence applications pages 
ieee ieee service center piscataway nj march 
wb weiss baur 
analysis audit protocol data methods arti cial intelligence 
proceedings th national computer security conference october 
wet bradford 
paradigms reduction audit trails 
master thesis university california davis 
wf robert wagner michael fischer 
string string correction problem 
journal acm volume pages january 
win patrick henry winston 
arti cial intelligence 
addison wesley reading massachusetts rd edition 
wm sun wu udi manber 
fast text searching errors 
technical report tr university arizona department computer science 
ws robert wagner joel 
correcting counter automaton recognizable languages 
siam computing volume pages august 
