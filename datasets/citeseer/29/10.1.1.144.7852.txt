comput 
society industrial applied mathematics vol 
pp 
october quantum complexity theory ethan bernstein umesh vazirani 
study quantum computation complexity theoretic viewpoint 
result existence efficient universal quantum turing machine deutsch model quantum turing machine qtm proc 
roy 
soc 
london ser 
pp 

construction substantially complicated corresponding construction classical turing machines tms fact simple primitives looping branching composition straightforward context quantum turing machines 
establish familiar primitives implemented introduce new purely quantum mechanical primitives changing computational basis carrying arbitrary unitary transformation polynomially bounded dimension 
consider precision transition amplitudes quantum turing machine need specified 
prove log bits precision suffice support step computation 
justifies claim quantum turing machine model regarded discrete model computation analog 
give formal evidence quantum turing machines violate modern complexity theoretic formulation church turing thesis 
show existence problem relative oracle solved polynomial time quantum turing machine requires superpolynomial time bounded error probabilistic turing machine class bpp 
class bqp languages efficiently decidable small error probability quantum turing machine satisfies bpp bqp possibility giving mathematical proof quantum turing machines powerful classical probabilistic turing machines setting major breakthrough complexity theory 
key words 
quantum computation quantum turing machines reversibility quantum polynomial time fourier sampling universal quantum turing machine ams subject classifications 
pii 


just theory computability foundations church turing thesis computational complexity theory rests modern strengthening thesis asserts reasonable model computation efficiently simulated probabilistic turing machine efficient simulation running time bounded polynomial running time simulated machine 
take reasonable mean principle physically realizable 
models computation interesting reasons meet criterion 
example clear computers operate arbitrary length words unit time exactly compute infinite precision real numbers realizable 
argued tm polynomial time equivalent cellular automaton model inevitable choice assume implement finite precision computational primitives 
widespread belief np bpp put wide range im received editors march accepted publication revised form december 
preliminary version appeared proc 
th annual acm symposium theory computing association computing machinery new york ny pp 

www siam org journals html microsoft microsoft way redmond wa microsoft com 
author supported nsf ccr 
computer science division university california berkeley ca vazirani cs 
berkeley edu 
author supported nsf ccr 
ethan bernstein umesh vazirani portant computational problems np hard problems capability computers 
tm fails capture physically realizable computing devices fundamental reason tm classical physics model universe current physical theory asserts universe quantum physical 
get inherently new kinds discrete computing devices quantum physics 
early computational possibilities quantum physics asked opposite question quantum mechanics insistence unitary evolution restrict class efficiently computable problems 
concluded far deterministic computation concerned additional constraint imposed quantum mechanics computation reversible bennett follows quantum computers powerful classical computers 
issue extra computational power quantum mechanics probabilistic computers raised feynman 
feynman pointed curious problem natural simulation quantum physical system probabilistic tm requires exponential slowdown 
unclear carry simulation efficiently 
view feynman observation re examine foundations computational complexity theory form church turing thesis study computational power computing devices quantum physics 
precise model quantum physical computer referred qtm formulated deutsch 
ways thinking quantum computers 
way may appeal computer scientists think quantum tm quantum physical analogue probabilistic tm infinite tape transition function actions machine local completely specified transition function 
probabilistic tms qtms allow branching complex probability amplitudes impose requirement machine evolution time reversible 
view elaborated section 
way view quantum computer effecting transformation space complex superpositions configurations 
quantum physics requires transformation unitary 
quantum algorithm may regarded decomposition unitary transformation product unitary transformations simple local changes 
view elaborated section 
formulations play important role study quantum computation 
important concern qtms really analog devices involve complex transition amplitudes 
instructive examine analogous question probabilistic tms 
worry probabilistic machines discrete reasonable allow transition probabilities real numbers 
extensive showing probabilistic computation carried way insensitive transition probabilities allowed vary arbitrarily large range 
show similar sense qtms discrete devices transition amplitudes need accurate log bits precision support steps computation 
lipton pointed crucial number bits log early version bits precision require pinning transition amplitude part transition amplitude physical quantity angle quantum complexity theory length pulse assume specify better part polynomial precision log 
basic question may ask possible define notion general purpose quantum computer 
classical case question answered affirmatively showing efficient universal tm 
prove efficient qtm 
input specification arbitrary qtm input time bound accuracy universal machine produces superposition euclidean distance time superposition 
simulation time bounded polynomial deutsch gave different construction universal qtm 
simulation overhead deutsch construction exponential issue deutsch interested computability computational complexity 
structure efficient universal qtm constructed simple 
just deterministic tm single type quantum operation quantum coin flip operation performs rotation single bit 
existence simple universal qtm bearing physical realizability qtms general establishes sufficient physically realize simple quantum operation single bit addition maintaining coherence carrying deterministic operations course 
adleman huang solovay yao clarified point showing quantum coin flips amplitudes sufficient universal quantum computation 
quantum computation necessarily time reversible quantum physics requires unitary evolution 
quite complicated correctly implement simple primitives looping branching composition 
described section 
addition require programming primitives changing computational basis purely quantum mechanical 
described section 
important primitive ability carry specified unitary transformation polynomial dimension specified degree accuracy 
section show build qtm implements primitive 
pieces put section construct universal qtm 
ask qtm general model computing device quantum physics 
approach arguing affirmatively consider various reasonable models show qtm efficiently simulate 
earlier version left open question standard variants qtm machines multiple tapes modified tape access powerful basic model :10.1.1.144.7852
yao showed models polynomially equivalent basic model quantum circuits introduced 
efficiency yao simulation improved show simulation overhead polynomial degree independent number tapes :10.1.1.144.7852
arguably full computational power quantum physics discrete systems captured quantum analogue cellular automaton 
open question quantum cellular automaton powerful qtm issue correct definition quantum cellular automaton 
difficulty decomposing unitary transformation represents overlapping sites activity product simple local unitary transformations 
problem solved special case linearly bounded quantum cellular automata 
researchers explored computational power qtms 
early deutsch jozsa showed exploit inherently quan ethan bernstein umesh vazirani tum mechanical features qtms 
results conjunction subsequent results brassard established existence oracles computational problems qtms solve polynomial time certainty require classical probabilistic tm produce correct answer certainty take exponential time inputs 
hand computational problems bpp class problems solved polynomial time probabilistic tms allowed give wrong answer small probability 
bpp widely considered class efficiently computable problems results left open question quantum computers powerful classical computers 
give formal evidence quantum turing machines violate modern form church turing thesis showing relative oracle problem solved polynomial time quantum turing machine solved log time probabilistic turing machine fixed error probability 
detailed discussion implications oracle results section 
simon subsequently strengthened result time parameter proving existence oracle relative certain problem solved polynomial time quantum turing machine solved steps probabilistic turing machine simon problem np np address nondeterminism issue 
importantly simon introduced important new technique ingredients remarkable result proved subsequently shor 
shor gave polynomial time quantum algorithms factoring discrete log problems 
problems studied presumed intractability forms basis modern cryptography 
results injected greater sense urgency actual implementation quantum computer 
class bqp languages efficiently decidable small error probability quantum turing machine satisfies bpp bqp rules possibility giving mathematical proof quantum turing machines powerful classical probabilistic turing machines setting major breakthrough complexity theory 
natural ask qtms solve problem np polynomial time 
bennett bernstein brassard vazirani give evidence showing limitations qtms 
show relative oracle chosen uniformly random probability class np solved qtm time 
show relative permutation oracle chosen uniformly random probability class np np 
bound tight grover shows accept class np relative oracle quantum computer time 
designs proposed realizing quantum computers 
number authors argued fundamental problems building quantum computers notably effects decoherence quantum superpositions entanglement system environment 
sequence important results showing implement quantum error correcting codes codes quantum algorithms quite robust effects decoherence 
quantum computation touches foundations computer science quantum physics 
nature quantum physics clarified einstein podolsky rosen paradox bell inequalities discussed demonstrate quantum complexity theory difference statistical properties classical model 
computational differences quantum classical physics striking expected offer new insights nature quantum physics 
example naively argue impossible experimentally verify exponentially large size hilbert space associated discrete quantum system observation leads collapse superposition 
experiment demonstrating exponential speedup offered quantum computation classical computation establish exponentially large hilbert space exist 
important feynman pointed clarify computational overhead required simulate quantum mechanical system 
simple form universal qtm constructed fact single nontrivial quantum operation defined single bit suggests simple quantum mechanical systems capable universal quantum computation hard simulate classical computers 
organized follows 
section introduces mathematical machinery notation 
section introduce qtm natural extension classical probabilistic tms 
show qtms need specified unreasonable amount precision 
sections demonstrate basic constructions allow build large complicated qtms subsequent sections 
actions quite easy classical machines completing partially specified machine running machine repeating operation machine number times require nontrivial constructions qtms 
section show build single qtm carry unitary transformation provided input 
section simulation unitary transformations build universal quantum computer 
section give results positive negative 

preliminaries 
denote field complex numbers 
denote complex conjugate 
vector space inner product complex function satisfies 





inner product yields norm addition triangle inequality norm satisfies schwarz inequality 
inner product space vector space inner product 
inner product space hilbert space complete induced norm complete cauchy sequence converges 
example xn sequence xn limn xn xm limn xn 
inner product space vector defines linear functional 
set linear functionals inner product space referred vector dual denoted case hilbert space called dual set continuous linear functionals dual space hilbert space 
dirac notation vector inner product space identified ket notation symbol placed inside distinguish vector ethan bernstein umesh vazirani 
denote elements dual space bra notation 
dual inner product vectors result applying functional vector denoted linear operator dirac notation denote result applying acts linear operator dual space mapping linear functional dual space linear functional applies followed 
denote result applying inner product space consider usual vector space basis hamel basis vector expressed finite linear combination basis vectors 
case fori refer basis orthonormal basis 
respect orthonormal basis write vector similarly dual vector written element thought column vector element thought row vector similarly linear operator may represented set matrix elements arranged square matrix rows columns indexed column index vector row index dual vector hilbert space hilbert space basis maximal set orthonormal vectors vector expressed limit sequence vectors expressed finite linear combination basis vectors 
linear operator inner product space linear operator satisfies called adjoint hermitian conjugate linear operator inner product space adjoint unique 
adjoint linear operator hilbert space inner product space exists 
easy see adjoints exist operator called hermitian self adjoint adjoint 
linear operator called unitary adjoint exists satisfies uu represent linear operators square matrices indexed orthonormal basis represented conjugate transpose dirac notation convenient identity recall inner product space tensor product inner product spaces pair vectors associated tensor product dirac notation denote norm defined sup 
linear operator called bounded finite 
freely standard facts bounded linear operators exists 
notice unitary operator satisfy 
fact tells approximate series unitary transformations unitary transformations error increases additively 
quantum complexity theory fact 
unitary transformations inner product space 
fact follows statements 

miscellaneous notation 
direction opposite probability distributions domain total variation distance equal 
refer cardinality set card length string 

qtms 

physics view randomized computation 
formally define qtm introduce necessary terminology familiar setting probabilistic computation 
bonus able precisely locate point departure definition qtm 
quantum mechanics distinction system evolution measurement 
absence measurement time evolution probabilistic tm described sequence probability distributions 
distribution step gives likelihood possible configuration machine 
think probabilistic tm specifying infinite dimensional stochastic matrix rows columns indexed configurations 
column matrix gives distribution resulting corresponding configuration single step machine 
represent probability distribution time step vector distribution step product quantum physics terminology call distribution step linear superposition configurations call coefficient configuration probability amplitude stochastic matrix referred time evolution operator comments order 
stochastic matrix associated probabilistic tm 
stochastic matrices obtained probabilistic tm finitely specified map configuration making local changes 
second support superposition exponential running time machine 
third need constrain entries allowed transition function probabilistic tm 
possible hard compute quantities transition amplitudes instance letting ith bit indicate ith deterministic tm halts blank tape 
common restriction allow amplitudes set 
generally allow real number interval computed deterministic algorithm desired time polynomial easily shown possibility computationally restrictive second 
recall matrix stochastic nonnegative real entries sum column 
ethan bernstein umesh vazirani returning evolution probabilistic tm observe machine number steps see linear superposition probability distribution just sample 
observe entire machine see configuration sampled random superposition 
holds observe just part machine 
case superposition collapses corresponds probability distribution conditioned value observed 
linearity law alternatives mere act making observations times earlier change probability outcome observation time unobserved superposition may support grows exponentially running time need keep track constant amount information simulating probabilistic tm observed step 
computational possibilities quantum physics arise fact observing quantum system changes behavior 

defining qtm 
model randomized computation surprisingly close deutsch model qtm 
major change required quantum physics amplitudes system linear superposition matrix elements system time evolution operator allowed complex numbers just positive reals 
observation probability associated configuration configuration amplitude superposition squared magnitude amplitude 
having linear superposition entries sum linear superposition euclidean length 
means qtms defined time evolution preserves euclidean length superpositions 
making changes model arrive definitions 
completeness recall definition deterministic tm 
standard variations definition deterministic tm affect computational power 
choices consistent deutsch consider tms way infinite tape single tape head move left right square step 
give standard definitions interpreting input output running time deterministic tm 
note usually restrict discussion tms tape head movements consider generalized tms tape head movements means head movement 
definition 
deterministic tm defined triplet finite alphabet identified blank symbol finite set states identified initial state final state qf deterministic transition function function 
tm way infinite tape cells indexed single read write tape head moves tape 
configuration instantaneous description tm complete description contents tape location tape head state finite control 
time finite number tape cells may contain symbols 
law alternatives says exactly probability event doesn change check see event happened 
quantum complexity theory configuration tm successor configuration defined applying transition function current state currently scanned symbol obvious way 
write denote follows step 
convention require initial configuration satisfies conditions tape head cell called start cell machine state 
initial configuration input written tape positions tape cells blank 
tm halts input eventually enters final state qf number steps tm takes halt input running time input tm halts output string consisting tape contents leftmost symbol rightmost symbol empty string entire tape blank 
tm halts inputs computes function give slightly modified version definition qtm provided deutsch 
case probabilistic tm limit transition amplitudes efficiently computable numbers 
adleman huang solovay yao separately shown restricting qtms rational amplitudes reduce computational power 
fact shown set amplitudes sufficient construct universal qtm 
give definition computation qtm particular string input defer discussing means qtm halt give output section 
usually restrict discussion qtms tape head movements consider generalized qtms tape head movements 
pointed case deterministic tms choices greater difference case qtms 
point discussed 
definition 
call set consisting deterministic algorithm computes real imaginary parts time polynomial qtm defined triplet finite alphabet identified blank symbol finite set states identified initial state final state qf quantum transition function function qtm way infinite tape cells indexed single read write tape head moves tape 
define configurations initial configurations final configurations exactly deterministic tms 
inner product space finite complex linear combinations configurations euclidean norm 
call element qtm defines linear operator um called time evolution operator follows starts configuration current state scanned symbol step superposition configurations ici nonzero corresponds transition ci new configuration results applying transition extending map entire space linearity gives linear time evolution operator um note defined giving orthonormal basis configurations terms standard basis superposition represented vector complex numbers indexed configurations 
time evolution operator um may represented countable dimensional square ethan bernstein umesh vazirani matrix columns rows indexed configurations matrix element column row gives amplitude configuration leads configuration single step convenience overload notation expression denote amplitude definition provides extremely important condition qtms satisfy consistent quantum physics 
introduced condition form stated expository purposes 
shall see section equivalent formulations condition familiar quantum physics 
definition 
say formed time evolution operator um preserves euclidean length 
wellformedness necessary condition qtm consistent quantum physics 
shall see subsection wellformedness equivalent unitary time evolution fundamental requirement quantum physics 
define rules observing qtm familiar quantum mechanics state definition restricts measurements computational basis actual basis measurement performed efficiently computable may loss generality perform rotation basis computation 
definition 
qtm superposition ici observed measured configuration ci seen probability superposition updated ci 
may perform partial measurement say cell tape 
case suppose cell may contain values suppose superposition ic ic configurations cell configurations cell 
measuring cell results pr observed new superposition pr ic part superposition consistent answer amplitudes scaled give unit vector 
note wellformedness condition qtm simply says time evolution operator qtm satisfy condition successive superposition sum probabilities possible configurations 
notice qtm differs classical tm user decisions just choosing input 
priori clear multiple observations increase power qtms point discussed detail shown may assume loss generality qtm observed :10.1.1.144.7852
shall simplifying assumptions measurement final result qtm 
fact assumptions result loss generality follows results :10.1.1.144.7852
general output qtm sample probability distribution 
regard qtms functionally equivalent practical purposes output distributions sufficiently close 
formal definition means qtm simulate :10.1.1.144.7852
case classical tms formal definition quite unwieldy 
actual constructions easy see sense simulations 
replicate formal definitions :10.1.1.144.7852
give informal definition 
quantum complexity theory definition 
say qtm simulates slowdown accuracy holds distribution observing input steps produces sample distribution observing input steps produces sample 
say simulates accuracy 
find convenient measure accuracy simulation calculating euclidean distance target superposition superposition achieved simulation 
shows variation distance resulting distributions times euclidean distance 
lemma 

total variation distance probability distributions resulting measurements 
proof 
observing gives probability observing gives probability probability expressed total variation distance distributions 
note unit superpositions 

quantum computing unitary transformation 
preceding sections introduced qtms extensions notion probabilistic tms 
stated qtm formed preserves norm superpositions 
section explore different extremely useful alternative view qtms terms properties time evolution operator 
prove qtm formed iff time evolution unitary 
unitary time evolution fundamental constraint imposed quantum mechanics chose state wellformedness condition section mainly expository purposes 
understanding unitary evolution intuitive point view quite important comprehending computational possibilities quantum mechanics 
explore setting quantum mechanical system consists parts states labeled particles spin state 
classical system instant single configuration described bits 
quantum physics system allowed linear superposition configurations instantaneous state system described unit vector dimensional vector space basis vectors correspond configurations 
describe instantaneous state system specify complex numbers 
implications quite extraordinary small system consisting particles nature keep track complex numbers just remember instantaneous state 
update numbers instant evolve system time 
amount effort larger standard estimates number particles visible universe 
nature puts amounts effort evolve tiny system level quantum mechanics sense design computers take advantage 
ethan bernstein umesh vazirani unitary evolution rules measurement quantum mechanics place significant constraints features exploited computational purposes 
basic primitives allows features exploited respecting unitarity constraints discrete fourier transform described detail section 
consider simple cases interesting phenomenon supported unitary evolution interference computational paths 
probabilistic computation probability moving configuration sum probabilities possible path 
true probability amplitudes quantum computation necessarily probabilities observations 
consider example applying transformation twice sequence tape cell contains symbol 
observe cell application see symbol probability observe applying second time symbols equally 
identity observe see probability 
computational paths lead initial final symbol interfere destructively cancelling 
paths leading probability observe twice probability reaching observe 
boosting probabilities exponential factor lies heart qtm advantage probabilistic tm solving fourier sampling problem 
constraint inherent computation unitary transformations reversibility 
show section qtm corresponding qtm time evolution operator conjugate transpose time evolution operator undoes actions sections devoted defining machinery deal feature qtms 
prove appendix qtm formed time evolution operator unitary 
establishes definition mention unitary evolution expository purposes satisfy fundamental constraint imposed quantum mechanics unitary evolution 
ask consistent quantum mechanics space finite linear combinations configurations hilbert space complete 
see doesn problem notice dense subset hilbert space just finite linear combinations configurations 
unitary operator unique extension unitary inverse proof quite simple 
continuous extensions sequences xn yn xn yn yn xn yn 
limits get desired 
aside briefly mention resolution issue achieved feynman suggested quantum mechanical system hamiltonian resulting system local time invariant hamiltonian 
easy probabilistically recover computation original system computation new 
quantum complexity theory interesting note theorem true defined qtms way infinite tape 
case trivial qtm moves tape head right formed time evolution unitary start configuration reached configuration 
theorem 
qtm formed iff time evolution operator unitary 

precision required qtm 
important concern qtms really analog devices involve complex transition amplitudes 
issue accurately transition amplitudes specified ensure correctness computation compromised 
earlier version showed bits precision sufficient correctly carry steps computation accuracy constant 
lipton pointed device regarded discrete device require transition amplitudes specified part opposed accurate bits precision 
transition amplitude represents physical quantity angle length pulse assume specify better part polynomial number bits precision log 
exactly proved shortly lipton observation proof section 
theorem shows unitary time evolution errors superposition sequence steps worst case add 
theorem 
time evolution operator qtm superpositions 
proof 
theorem follows triangle inequality unitary 
definition 
say qtms close state set alphabet difference pair corresponding transition amplitudes magnitude 
note close formed 
theorem shows qtms close sense give rise time evolution operators close qtms formed 
simple consequence time evolution operator qtm bounded qtm formed 
theorem 
qtms alphabet state set close difference time evolutions norm card card 
statement holds machines formed 
proof 
qtms alphabet state set close 
time evolution time evolution 
ethan bernstein umesh vazirani consider unit length superposition configurations cj express difference machines operations follows cj set configuration ci lead cj single step amplitudes ci leads cj 
applying triangle inequality fact square sum reals times sum squares card card close card card card card card card configuration cj card card configurations lead cj single step card card card card card card unit length superposition card card 
corollary shows log bits precision sufficient transition amplitudes simulate steps qtm accuracy constant 
corollary 
formed qtm card card close 
simulates qtm time accuracy 
statement holds formed 
proof 
card card loss generality assume consider running initial superposition 
formed theorem time evolution operator unitary 
theorem time evolution operator applying expressed applying adding perturbation length times length current superposition 
length superposition time length appealing theorem difference superpositions time superposition norm lemma tells observing time gives sample distribution total variation distance distributions sampled observing time quantum complexity theory 
input output conventions qtms 
timing crucial operation qtm computational paths interfere take number time steps 
equally important position tape head alignment tape contents 
subsection introduce input output conventions qtms deterministic tms help maintain relationships manipulating combining machines 
think qtms finishing computation reach final state qf unclear regard machine reaches superposition configurations state qf 
try avoid difficulties saying qtm halts particular input reaches superposition consisting entirely configurations state qf definition 
final configuration qtm configuration state qf qtm run input time superposition contains final configurations time superposition contains final configuration halts running time input superposition time called final superposition run input polynomial time qtm formed qtm input halts time polynomial length define output qtm halts superposition tape contents configurations machine final superposition 
careful note position tape head alignment relative start cell configuration details determine paths interfere 
recall output string final configuration tm tape contents leftmost symbol rightmost symbol 
means giving output string leaves unspecified alignment string tape location tape head identified 
describing input output behavior qtm describe additional information 
additional information clear context 
example build machines final configurations output string start cell tape head scanning symbol 
definition 
qtm called behaved halts input strings final superposition configuration tape head cell 
cell start cell call machine stationary 
similarly deterministic tm called stationary halts inputs tape head back start cell 
simplify constructions build qtms combine simple ways running iterating varying number times 
able add new transitions initial state machine 
may transitions resulting machine may reversible 
certainly redirect transitions final state qf reversible tm behaved qtm affecting behavior 
note formed qtm qf leads back transitions 
case redirecting transitions qf allow add new ones violating reversibility 
say machine property normal form 
note behaved qtm normal form halts transition qf transition 
means altering transitions alter relevant part machine computation 
simplicity arbitrarily ethan bernstein umesh vazirani define normal form qtms step right leave tape unchanged go state qf 
definition 
qtm deterministic tm normal form qf need consider qtms special property particular state entered machine tape head steps direction 
qtms unidirectional show qtm efficiently simulated critical concept reversing qtm completing partially described qtm building universal qtm 
describe advantages unidirectional machines theorem section 
definition 
qtm called unidirectional state entered direction words nonzero 
find convenient common tool thinking tape qtm deterministic tm consisting tracks 
definition 
tm tracks tm alphabet form special blank symbol blank 
specify input specifying string track optionally specifying alignment contents tracks 
tm run input xk started superposition consisting initial configuration portion ith coordinate tape containing string xi starting start cell 
generally input xk xi yi portion ith track aligned symbol yi start cell 
input xk xl xk abbreviated xl 

programming qtm 
section explore fundamentals building qtm simpler qtms 
implementing basic programming primitives looping branching reversing computation straightforward deterministic tms 
constructions difficult qtms careful maintain reversibility 
fact difficulties arise building reversible deterministic tms 
building reversible tms simpler reversible tms necessary 
bennett showed efficiently simulate deterministic tm reversible 
build reversible tm building desired computation machine bennett construction 
constructions section special quantum nature qtms fact techniques required analogous construction reversible tms 
show section reversible tms special case qtms 
deutsch noted bennett result allows desired deterministic computation carried qtm 
bennett result sufficient allow deterministic computations building qtms different computation paths qtm interfere properly provided take exactly number steps 
carry modified version bennett construction show deterministic computation carried quantum complexity theory reversible tm running time depends length input 
different computation paths qtm take number steps provided carry deterministic computation inputs length 

reversible tms 
definition 
reversible tm deterministic tm configuration predecessor 
note altered definition reversible tm bennett reversible tms special case qtms 
restricted reversible tm move head left right allowing stay 
second insist transition function complete function partial function 
consider reversible tms single tape bennett worked machines 
theorem 
reversible tm formed qtm 
proof 
transition function deterministic tm maps current state symbol update triple 
think giving unit superposition amplitude triple quantum transition function qtm 
time evolution matrix corresponding qtm contains entries 
corollary proven appendix tells configuration reversible tm exactly predecessor matrix permutation matrix 
tm reversible row 
superposition configurations ci mapped time evolution matrix superposition configurations time evolution preserves length qtm formed 
previous bennett shows reversible machines efficiently simulate deterministic tms 
course deterministic tm computes function reversible machine simulate exactly 
bennett showed generalized reversible tm best thing take input compute output input deterministic tm computes function generalized reversible tm computes function 
constructions tm suggested simulation carried single tape machine 
morita bennett ideas techniques show deterministic tm simulated generalized reversible tm symbol alphabet 
give slightly different simulation deterministic tm reversible machine preserves important timing property 
describe timing critical 
sections build qtms interesting complex interference patterns 
computational paths interfere reach configuration time 
want paths interfere run computation different inputs 
sure interfere know computations carried exactly running time 
want show function computable deterministic polynomial time computed polynomial time reversible tm way running time determined entirely length input 
provided computation paths carry deterministic algorithms inputs length take exactly number steps 
prove theorem appendix page ideas constructions bennett morita 
ethan bernstein umesh vazirani theorem synchronization theorem 
function mapping strings strings computed deterministic polynomial time length depends length polynomial time stationary normal form reversible tm input produces output running time depends length function strings strings computed deterministic polynomial time length depends length polynomial time stationary normal form reversible tm input produces output running time depends length 
programming primitives 
show carry programming primitives reversibly 
branching reversal looping lemmas frequently subsequent sections 
proofs lemmas straightforward omitted 
quite useful build complicated machines allow build series simpler machines ignoring contents tracks currently 
lemma 
qtm reversible tm set qtm reversible tm behaves exactly leaving second track unchanged 
lemma 
qtm reversible tm permutation qtm reversible tm behaves exactly tracks permuted 
lemmas straightforward stating separately lemma easy prove 
deals swapping transitions states qtm 
swap outgoing transitions states transition function defining forp 
similarly swap incoming transitions states defining 
lemma 
formed qtm reversible tm swapping incoming outgoing transitions pair states gives wellformed qtm reversible tm 
lemma 
formed qtms reversible tms alphabet disjoint state sets 
union machines arbitrarily chosen start state formed qtm reversible tm 
preceding lemmas insert machine place state 
perform insertion computations machines disturb 
easily seen case 
example insertion dovetailing lemma insert machine final state behaved qtm computation original machine completed inserted machine begins 
rest insertions carry machines operate different tracks possible disturbance involves position tape head 
lemma 
normal form qtms reversible tms alphabet state normal form qtm acts time enter state runs machine 
quantum complexity theory proof 
stated initial final states state 
construct desired machine follows 
take union lemma page start state final state 
lemma swap incoming transitions outgoing transitions get formed machine normal form final state leads back initial state matter initial state final state 
show take machines form third dovetailing 
notice dovetail qtms second qtm started final superposition machine input superposition 
second machine differing running times various strings superposition machine halt original machines behaved 
qtm built dovetailing behaved qtms may behaved 
lemma dovetailing lemma 
behaved normal form qtms reversible tms alphabet normal form qtm reversible tm carries computation followed computation 
proof 
behaved normal form qtms reversible tms alphabet start states final states construct simply insert final state lemma page 
complete proof need show carries computation followed 
see recall normal form transitions respectively 
means transitions changed state behaved prematurely enter state machine started state compute exactly halt 
point reach superposition configurations state 
transitions changed proceed exactly started superposition outputs computed 
show build conditional branch existing qtms reversible tms 
branching machine run machines track input depending second track input 
tm final state rejoin branches 
join reversibly write back bit determined machine 
construction simply build reversible tm accomplishes desired branching insert machines states branching machine 
lemma branching lemma 
behaved normal form qtms reversible tms alphabet behaved normal form qtm reversible tm second track empty runs track leaves second track empty second track start cell cells blank runs track leaves tape head ends 
case takes exactly time steps appropriate mi 
ethan bernstein umesh vazirani proof 
behaved normal form qtms reversible tms alphabet 
construct desired qtm follows 
show build stationary normal form reversible tm br takes time steps leaves input unchanged superposition consisting single configuration states properties 
br run start cell blanks br visits blank tape tape head start cell doesn visit 
similarly br run blank tape br visits blank tape tape head start cell doesn visit 
extend second track alphabet br extend br track common alphabet insert state state br desired qtm complete construction exhibiting reversible tm br 
machine enters state depending start cell contains steps left enters corresponding stepping back right 
enters state stepping left state qf stepping back right 
br alphabet state set qf transition function defined table qf qf verified transition function br enter state moving direction 
appealing corollary page completed give reversible tm 
show take unidirectional qtm reversible tm build reverse 
computational paths qtm interfere reach configurations differ way 
means building qtm careful erase information differ paths want interfere 
lemma constructing qtm allow completely erase intermediate computation 
time evolution formed qtm unitary reverse qtm applying unitary inverse time evolution 
transformation time evolution qtm acts configuration changing tape symbols left right tape head 
state unidirectional qtm entered moving direction reverse head movements step ahead reversal tape state 
reversal tape head proper cell time symbol changed 
definition 
qtms alphabet say reverses computation identifying final state initial state initial state final state gives 
input halts cx initial configuration final superposition input halts initial superposition final superposition consisting entirely configuration cx 
quantum complexity theory lemma reversal lemma 
normal form reversible tm unidirectional qtm normal form reversible tm qtm reverses computation extra time steps 
proof 
prove lemma normal form unidirectional qtms argument proves lemma normal form reversible tms 
normal form unidirectional qtm initial final states qf dq direction move entering state define bijection set configurations follows 
configuration state configuration derived moving tape head square direction dq opposite direction dq 
set superpositions form give orthonormal basis space superpositions extend act linear operator space superpositions defining easy see unitary transformation space superpositions new machine alphabet state set new initial final states statements suffice prove reverses computation extra time steps 

final configuration configuration state qf replaced state single step takes superposition superposition 

single step takes superposition superposition support configuration state single step takes superposition superposition 

initial configuration configuration state replaced state single step takes superposition superposition see input halts sequence superpositions input cx cx initial superposition support final configurations time evolution operator linear statement tells form initial configuration replacing state qf state takes single step 
normal form support superposition state 
statement tells steps lead superpositions 
statement tells single step maps superposition cx superposition define transition function give formed satisfying statements transition rules 

qf 
dq dp 
dq 
third rules easily seen ensure statements 
second rule seen ensure statement follows normal form maps superposition superposition support ethan bernstein umesh vazirani configuration state support configurations state qf time evolution defines unitary transformation space superpositions configurations states set qf space superpositions configurations states set 
fact tells second rule defines linear transformation space back space 
takes configuration state amplitude configuration state takes configuration configuration amplitude time evolution space composition inverse conjugate transpose time evolution conjugate transpose unitary second rule gives unitary transformation space space satisfies statement 
clearly normal form complete proof showing formed 
see just note rules defines unitary transformation set mutually orthogonal subspaces spaces superpositions 
synchronization theorem allow take existing qtm put inside loop machine run specified number times 
building reversible machine loops indefinitely trivial 
want loop finite number times need carefully construct reversible entrance exit 
branching lemma construction proceed building reversible tm accomplishes desired looping inserting qtm particular state looping machine 
difficulties 
construction opposed branching construction reversible tm leaves intermediate computation written tape qtm runs 
means inserting nonstationary qtm destroy proper functioning reversible tm 
second insert stationary qtm second subsequent time qtm run may started superposition inputs different lengths may halt 
general statement able behavior machine insertion carried 
describe reversible looping tm constructed appendix page argue specific qtms resulting machine constructed 
lemma looping lemma 
stationary normal form reversible tm constant properties 
input positive integer written binary runs time log halts tape unchanged 
special state input visits state exactly times time tape head back start cell 

changing basis qtm computation 
section introduce fundamentally quantum mechanical feature quantum computation changing computational basis evolution qtm 
particular find useful change new orthonormal basis transition function middle computation state new state set linear combination states original machine 
allow simulate general qtm unidirectional 
allow prove partially defined quantum transition function preserves length extended give formed qtm 
start showing change basis states qtm 
give set conditions quantum transition function necessary sufficient quantum complexity theory qtm formed 
conditions called separability allow construct basis states qtm allow prove completion lemmas 

change basis 
take formed qtm choose new orthonormal basis space superpositions states translating transition function new basis give formed qtm evolves just change basis 
note construction new qtm time evolution operator original machine 
states new machine differ old 
change basis allow prove lemmas 
lemma 
qtm set vectors cq forms orthonormal basis cq qtm evolves exactly change basis proof 
orthonormal basis cq orthonormal basis establishes unitary transformation space superpositions states space superpositions states specifically mapping similarly unitary transformation space superpositions configurations states space configurations states second transformation configuration state mapped superposition configurations corresponding configuration state appears amplitude see time evolution look change basis 
configuration state reading evolves single time step superposition configurations corresponding superposition change basis superposition right hand side state symbol pair corresponds superposition behave exactly change basis define saying ethan bernstein umesh vazirani vectors contained amplitude contained note time evolution preserve euclidean length exactly time evolution formed change basis 

local conditions qtm wellformedness 
discussion reversible tms appendix find properties deterministic transition function necessary sufficient reversible 
similarly theorem gives properties quantum transition function necessary sufficient formed 
property ensures time evolution operator preserves length applied particular configuration 
adding second ensures time evolution preserves length superpositions configurations tape head cell 
third property concerns restricted update superpositions handles superpositions configurations tape heads differing locations 
third property critical constructions lemmas 
definition 
refer superposition states resulting restricting pieces writing symbol moving direction direction going restricted superposition denoted 
theorem 
qtm formed iff conditions hold unit length orthogonality separability 
proof 
time evolution proposed qtm 
know formed iff exists gives identity equivalently iff columns unit length mutually orthogonal 
clearly condition specifies exactly column unit length 
general configurations tapes differ cell heads tape heads cell exactly cells apart yield configuration single step 
pairs columns guaranteed orthogonal need consider pairs configurations case 
second condition specifies orthogonality pairs columns configurations differ state reading state reading 
consider pairs configurations tape heads cells apart 
pairs interfere single step differ states symbol written cells 
third condition specifies orthogonality pairs columns configurations identical second tape head cells left state quantum complexity theory cell tape head cells left 
consider unidirectional qtms state entered moving direction 
considered property deterministic tms meant looking deterministic transition function ignore direction update think giving bijection current state tape symbol new symbol state 
unidirectional quantum transition function certainly satisfies separability condition left going right going restricted superpositions state common 
update triples share direction share state 
unidirectional formed iff ignoring direction update gives unitary transformation superpositions current state tape symbol superpositions new symbol state 

completion lemmas 
separability condition theorem allows simulate qtm unidirectional qtm applying change basis 
change basis allow complete partially specified quantum transition function preserves length 
straightforward simulate deterministic tm unidirectional 
simply split state states qr ql transitions edit transition function transitions moving right enter qr transitions moving left enter ql 
resulting machine clearly reversible transition function operates ql 
simplify construction show interleave series quantum transition functions 
lemma 
state sets qk qk transition functions mapping state set qi qi preserves length formed qtm state set qi alternates stepping transition functions 
proof 
suppose state sets transition functions stated 
qtm alphabet state set union individual state sets qi transition function clearly machine alternates stepping 
easy see time evolution preserves length 
superposition configurations squared length subspace configurations states qi maps superposition squared length subspace configurations states qi 
lemma lemma 
qtm simulated slowdown factor unidirectional qtm 
furthermore behaved normal form 
proof 
key idea separability condition formed qtm allows change basis state set state entered direction 
ethan bernstein umesh vazirani separability condition says 
means split mutually orthogonal subspaces cl cr span cl cr cd 
shown lemma change basis state set state set new transition function defined 
choose orthonormal bases bl br spaces cl cr bl br qtm constructed lemma evolves exactly change basis state set state set bl br 
state entered direction 
see note bd separability condition implies bd 

state entered traveling direction 
unfortunately new qtm able simulate problem start state final state correspond change basis isomorphism superpositions states meaning unable define necessary start final states fix problem time steps simulate step interleave transition functions lemma page 

step right leaving tape state unchanged 
change basis stepping left quantum complexity theory 
carries step computation just quantum transition function qtm constructed 

change basis back stepping left 
step right leaving tape state unchanged construct qtm state set lemma page start final states qf simulates slowdown factor 
show transition functions obeys wellformedness conditions lemma interleaved machine formed 
transition function certainly obeys wellformedness conditions formed qtm 
obey wellformedness conditions deterministic reversible 
transition functions satisfy unit length orthogonality conditions implement change basis obey separability condition move direction 
show behaved normal form behaved normal form 
suppose behaved normal form 
time superposition includes configurations state qf tape head back start cell time superposition contains configuration state qf means run input superposition time includes configurations state qf tape head back start cell superposition time contains configuration state qf 
behaved 
input enters series superpositions configurations states qf enters superposition configurations state qf tape head back start cell 
input enters series superpositions configurations states qf enters superposition configurations state qf tape head back start cell 
behaved 
swapping outgoing transitions qf puts normal form change computation input construct qtm concerned subset transitions 
luckily partially defined transition function preserves length extended give formed qtm 
definition 
qtm quantum transition function defined subset called partial qtm 
defined entries satisfy conditions theorem page called formed partial qtm 
lemma completion lemma 
suppose formed partial qtm quantum transition function 
formed qtm state set alphabet quantum transition function agrees defined 
ethan bernstein umesh vazirani proof 
noted unidirectional quantum transition function formed iff ignoring direction update gives unitary transformation superpositions current state tape symbol superpositions new symbol state 
partial qtm unidirectional easily fill undefined entries extending set update superpositions orthonormal basis space superpositions new symbol state 
general technique lemma page change basis away state entered moving direction extend transition function rotate back basis formalize follows formed partial qtm defined subset 
denote complement 
proof lemma separability condition allows partition mutually orthogonal subspaces cl cr span cl cr cd 
choose orthonormal bases bl br cl cr consider unitary transformation superpositions configurations states space configurations states bl br configuration state mapped superposition configurations corresponding configuration state appears amplitude call partial function followed unitary change basis preserves length followed unitary transformation preserves length 
enter state moving direction 
see note bd separability condition implies bd 
bd 
state entered traveling direction 
direction implied new state think mapping current state symbol superposition new symbol state 
preserves length set set orthonormal vectors expand set orthonormal basis space superpositions new symbol state 
adding appropriate direction updates assigning new vectors arbitrarily completely defined preserves length 
assigning followed inverse basis transformation gives completion preserves length 
quantum complexity theory 
efficient qtm implementing unitary transformation 
suppose tape head qtm confined region consisting contiguous tape cells tape blank outside region 
time evolution qtm described dimensional unitary transformation card section show conversely qtm dimensional unitary transformation input carries transformation region tape 
claim precise say dimensional unitary transformation specified 
assume approximation unitary transformation specified complex matrix entries approximations entries actual unitary matrix corresponding desired transformation 
show theorem page qtm input dimensional transformation distance unitary transformation carries transformation approximation desired unitary transformation 
running time qtm bounded polynomial single step qtm map single configuration superposition bounded number configurations 
order carry approximation arbitrary unitary transformation qtm show approximate product simple unitary transformations simple transformation acts identity dimensions 
show particular simple unitary transformation simple transformation expressed product permutation matrices powers fixed simple matrix 
put show design single qtm carries arbitrary unitary transformation qtm deterministic single kind quantum coin flip 
decomposition arbitrary unitary transformation product simple unitary transformations similar carried deutsch 
deutsch phrased terms quantum computation networks viewed showing dimensional unitary transformation decomposed product transformations applies particular unitary transformation dimensions acts identity 
consider issues efficiency addressed deutsch 
concerned decomposition contains number transformations polynomial dimension unitary transformation desired accuracy 
second desire decomposition efficiently computed desired unitary transformation input 
efficient simulation unitary transformation quantum computation network see 

measuring errors approximated transformations 
section deal operators linear transformations finite dimensional hilbert spaces 
convenient fix orthonormal basis hilbert space describe operator finite matrix respect chosen basis 
ed orthonormal basis hilbert space cd represent operator complex matrix jth entry mi ei 
ith row matrix ei denote mi 
denote mi conjugate transpose mi 
jth column 
adjoint represented matrix unitary iff mm follows unitary rows columns orthonormal 
ethan bernstein umesh vazirani recall bounded linear operator hilbert space norm defined sup ux 
represent matrix define norm matrix norm re working finite dimensional space max mv 
fact 
unitary 
proof 
ux ux ux ux similar reasoning shows 
find useful keep track far approximations unitary 
simple measure transformation distance unitary 
definition 
bounded linear operator called close unitary unitary operator 
represent matrix equivalently say close unitary unitary matrix 
notice appealing statement section close unitary 
converse true 
example linear transformation norm away unitary 
show close unitary rows close unit length close orthogonal 
lemma 
dimensional complex matrix close unitary mi proof 
unitary matrix 
know mi ni 
ni mi 
mi 
unitary follows mi 

expanding sum terms get mi ni mim min nim nin schwarz inequality tells min nim nin triangle inequality conclude mim standard fact matrix small entries small norm 
lemma 
dimensional square complex matrix mi 
proof 
entry magnitude clearly row mi norm 
dimensional column vector mv miv inequality follows schwarz inequality 

quantum complexity theory 
decomposing unitary transformation 
describe class exceedingly simple unitary transformations able carry single qtm 
near trivial transformations apply phase shift dimension apply rotation dimensions acting identity 
definition 
unitary matrix near trivial satisfies conditions 

identity diagonal entries ei 
example mj ei jmk 
identity submatrix pair distinct dimensions cos sin sin cos rotation angle 
transformation near trivial exists mei cos ei sin ej sin ei cos ej mek ek 
call transformation satisfies statement near trivial phase shift call transformation satisfies statement near trivial rotation 
write near trivial matrix way 
phase shift ei dimension write rotation angle dimensions write 
convention guarantees matrix specifying near trivial matrix unitary matrix precision reasons write approximation matrix really wish specify 
feature substantially simplify error analyses 
show near trivial transformations carry arbitrary unitary transformation show map particular vector desired target direction 
lemma 
deterministic algorithm input vector cd bound computes near trivial matrices unit vector coordinate direction 
running time algorithm bounded polynomial log length input 
proof 
phase shifts map space ir want apply phase shift vi dimension vi 
pi matrix applies dimension phase shift angle vi cos re vi vi cos re vi vi depending im vi positive negative 
vector ith coordinate vi 
rotations move weight vector dimension 
ri near trivial matrix applies rotation angle dimensions vi cos vj sum denominator 
rd 
producing values exactly compute time polynomial log length input values ethan bernstein umesh vazirani desired values 
call near trivial matrices corresponding pi ri approximations 
distance points angle unit circle real plane ri 
thinking inequality unit circle complex plane matrix pi ri pi 
unitary fact page gives rd pd dv 
show ability map particular vector desired target direction allows approximate arbitrary unitary transformation 
theorem 
deterministic algorithm running time polynomial log length input input complex matrix close unitary com dimensional near trivial matrices un polynomial un 
proof 
introduce notation simplify proof 
complex matrix 
say simple rows columns dimensional identity 
notice product dk simple matrices simple 
simple desired computation trivial 
general algorithm approximate simple 
algorithm proceed phases ith phase remaining problem reduced approximating matrix simple 
suppose start approximate simple series near trivial matrices product approximate need produce series near trivial matrices product satisfies uv reduce problem compute near trivial matrices product uv close simple 
accomplish algorithm lemma 
simple close unitary lower right submatrix invoke procedure lemma inputs zt vector corresponding row 
output sequence dimensional near trivial matrices product property 
suppose extend vi back dimensional simple matrices uv clearly unitary simple 
fact unitary close unitary close unitary 
close simple desired 
show st row satisfies wk entries st column satisfy wj 
quantum complexity theory simple matrix xj forj forj xj wj 
follows bounds norm row entries column 
close unitary conclude close unitary 
unfortunately compute entries uv exactly 
appealing lemma page compute obtain matrix 
entries define matrix analogous triangle inequality easy see close unitary 
willing incur error left problem approximating simple product near trivial matrices 
reduced problem approximating simple matrix near trivial matrices problem approximating simple matrix near trivial matrices incurring sources error 
error approximating 
new matrix close unitary 

clearly upper bound sources error cited 
total error approximation just 
inequality follows sum bounded geometric series 
total error approximation bounded assumption close unitary easy see algorithm runs time polynomial log algorithm consists iterations calling algorithm lemma page compute computing matrix iteration takes time polynomial log calls take total time polynomial log show required st row satisfies wk entries st column satisfy wj 
see recall lower dimension satisfies row lower right submatrix higher dimension satisfies uk ek 
uk follows ek 
st row satisfies wk 
show implies entries st column satisfy wj 
see notice unitary delta close unitary close unitary 
means 
statement lemma page wk condition wk 
implies wk 
denote wj dimensional row vector arrived dropping wj wj 
condition wk close implies wk 
fact close unitary implies wj 
putting wk wk wk wj wk wk wj 
wk wk wj 
wj may assume wehave wj 
ethan bernstein umesh vazirani 
carrying near trivial transformations 
section show construct single qtm carry approximately specified near trivial transformation 
near trivial transformation apply arbitrary rotation dimensions phase single dimension show fixed rotation efficiently approximate arbitrary rotation 
note single copy fixed rotation gives nonclassical amplitudes transition function universal qtm constructed 
see adleman huang solovay yao constructions universal qtms amplitudes restricted small set rationals 
lemma 

deterministic algorithm time polynomial log length input input produces integer output bounded polynomial kr mod 
proof 
describe procedure computing start calculating suchthat 
approximate fraction denominator words find integer mod log mod log mod log mod nr mod 
quantum complexity theory point clear single qtm carry sequence near trivial transformations desired accuracy 
formalize notion showing qtm accepts input descriptions sequence near trivial transformations error bound applies approximation product transformations superposition 
formalization quite tedious reader encouraged skip rest subsection statement convincing 
give formal definition means qtm carry transformation 
definition 
alphabet track qtm complex vector space superpositions length strings 
transformation xu string encodes approximately 
say xu causes carry cell transformation accuracy time input xu halts exactly steps tape head back start cell final superposition unitary transformation 
family transformations say carries transformations polynomial time bounded polynomial length input 
case contains transformations unitary say carries set transformations closeness factor close unitary unitary transformation xu causes carry transformation time polynomial length input 
recall near trivial transformation written calls rotation dimensions angle phase shift dimension 
want build stationary normal form qtm takes input transforms near trivial transformation described accuracy 
need qtm running time depend length value 
case machine halt initial superposition form superposition equal length strings lemma 
stationary normal form qtm track alphabet carries set near trivial transformations track polynomial time 
proof 
encoding near trivial transformations described section show construct qtms track alphabet carries set near trivial rotations track polynomial time carries set near trivial phase shifts track polynomial time 
branching lemma page machines construct qtm behaves correctly provided extra track containing phase shift perform containing rotation perform 
construct desired qtm dovetailing machines compute erase extra bit synchronization theorem lets construct stationary normal form qtms running times depend lengths additional computation disturb synchronization computation 
show construct qtm carry near trivial rotations 
ethan bernstein umesh vazirani easy construct qtm input applies rotation angle leaving 
lemma tells achieve rotation applying single rotation polynomial number times 
step process allow apply near trivial rotation 
careful apply rotation computational paths differ interfere 

calculate 

transform ifw ifw andb empty string 

run rotation applying machine times bit 
reverse step transforming transforming transforming 
reverse step erasing build desired qtm constructing qtm steps dovetailing 
notice length desired output steps computed just length input 
lemma page synchronization theorem page build polynomial time stationary normal form qtms steps run time depend lengths particular values 
complete construction build machine rotation properties 
stationary normal form qtm alphabet state set qf transition function defined cos sin sinr cos qf qf runs constant time applies rotation start cell contents leaving inputs unchanged 
inserting special state reversible tm looping lemma construct normal form qtm applies rotation kr inputs leaving input unchanged 
machine loop stationary takes constant time regardless input resulting looping machine stationary takes time depending appropriate lemmas page dovetail stationary normal form qtms achieve stationary normal form qtm implements desired computation 
phase application machine run time independent andy run time depends length andy running time depends length particular values 
halts proper output run input single string run initial superposition different strings near trivial transformation 
qtm carry near trivial phase shifts replace transition function simple qtm applies phase shift quantum complexity theory rotation angle follows giving stationary qtm applies phase shift ir phase shift 
eir qf qf proof gives desired identical proof omitted 

carrying unitary transformation qtm 
approximate unitary transformation product near trivial transformations qtm carry build qtm apply approximation unitary transformation 
theorem unitary transformation theorem 
stationary normal form qtm track alphabet carries set trans formations track polynomial time required closeness factor transformations dimension proof 
transformation dimension close unitary carry cells track steps 

calculate write clean tracks list near trivial un un polynomial 
apply list transformations un 
erase un construct qtm accomplish steps follows 
theorem page synchronization theorem page build polynomial time stationary normal form qtms steps run time depend 
build stationary normal form qtm accomplish step time polynomial follows 
stationary normal form qtm constructed lemma page apply specified near trivial transformation bound 
dovetail machine constructed synchronization theorem page rotates list transformations 
resulting qtm stationary takes time depends ui insert special state machine looping lemma give desired qtm step 
appropriate lemmas page dovetailing qtms steps gives desired 
running times qtms independent contents track running time 
notice run apply cells track apply unitary transformation un un desired 

constructing universal qtm 
universal qtm inevitably decompose step simulated machine simple steps 
step ethan bernstein umesh vazirani simulated qtm mapping computational basis new orthonormal basis 
single step universal qtm map computational basis vectors desired destinations 
general partial transformation unitary destination vectors orthogonal computational bases operated 
key construction enables achieve unitary decomposition lemma 
applying lemma get qtm mapping computational basis property decomposition space subspaces constant dimension subspace gets mapped 
specifically saw previous section construct qtm carries close approximation specified unitary transformation 
hand noted transition function unidirectional qtm specifies unitary transformation superpositions current state tape symbol superpositions new symbol state 
means unidirectional qtm simulated repeatedly applying fixed dimensional unitary transformation followed reversible deterministic transformation moves simulated tape head new state 
universal machine convert input unidirectional qtm construction lemma simulate new qtm repeatedly applying unitary transformation reversible deterministic transformation 
wish construct single machine simulate qtm build way qtm provided input 
definition qtm easily encoded write size alphabet symbol assumed blank symbol write size state set state assumed start state 
complete specification need describe transition function giving card card amplitudes form 
restricted definition qtm include machines rational transition amplitudes write amplitude explicitly ratio integers 
restricted definition qtm include machines amplitudes means amplitude deterministic algorithm computes amplitude real imaginary parts time polynomial specify giving deterministic algorithm computes transition amplitude time polynomial universal qtm construct returns tape head start cell simulating step desired machine incur slowdown linear conjecture care universal qtm constructed slowdown polylogarithmic theorem 
normal form qtm formed qtm simulate accuracy steps slowdown polynomial proof 
described approach construction lemma build unidirectional qtm simulates slowdown factor simulate 
describe simulation return describe easily computable preprocessing needs carried 
suppose unidirectional qtm wish simulate universal qtm 
quantum complexity theory start reviewing standard technique representing configuration target tm tape universal tm 
track tape universal qtm simulate current configuration alphabet state set fixed size series log card cells tape referred simulate cell holds pair integers card represents contents corresponding cell andp card represents state tape head scanning corresponding cell 
tape head move distance away start cell time need cells center tape place markers denote ends 
know ignore update direction gives unitary transformation dimension card superpositions current state tape symbol superpositions new state symbol 
properly update superposition simulation tracks apply current state symbol move new state specification left right direction state entered 
build qtm step carries step simulation follows 
addition simulation track machine provided input desired accuracy specification guaranteed close unitary string card gives direction state entered 
machine step operates follows 

transfer current state symbol empty workspace near start cell leaving special marker places 

apply transforming superposition new state symbol 

reverse step transferring back marked empty emptying workspace 

transfer state specification right left depending qth bit isa 
synchronization theorem page construct stationary normal form qtms steps take time polynomial fixed depend step carried time polynomial card card unitary transformation applying qtm constructed unitary transformation theorem 
appropriate lemmas page dovetailing normal form qtms gives desired normal form qtm step 
qtms takes time depends fixed 
insert step special state reversible tm constructed looping lemma provide additional input resulting qtm step halt time polynomial simulating steps accuracy 
construct desired universal qtm dovetailing step qtm carries necessary preprocessing 
general universal machine simulate qtms unidirectional 
preprocessing desired qtm desired input desired simulation accuracy consists carrying construction lemma build unidirectional qtm ethan bernstein umesh vazirani simulates slowdown factor 
inputs computed step 
proper representation initial configuration input 
dimensional transformation entry written accu racy 
string directions 
desired number simulation steps desired accuracy verified inputs computed deterministic time polynomial length input 
transformation computed specified accuracy transformation provided step desired unitary close unitary required operation step 
time step runs accuracy applied unitary transformation runs step applied unitary transformation step transformation means observing simulation track completed give sample distribution total variation distance distribution sampled observing input time 
computational power qtms 
section explore computational power qtms complexity theoretic point view 
natural define quantum analogues classical complexity classes 
classical complexity theory bpp regarded class languages efficiently computable classical computer 
quantum analogue bpp bqp bounded error quantum polynomial time similarly regarded class languages efficiently computable qtm 

accepting languages qtms 
definition 
stationary normal form qtm track alphabet 
string track empty string wait halts observe track start cell see probability say accepts probability rejects probability consider language say qtm exactly accepts accepts string probability rejects string probability 
define class exact error free quantum polynomial time set languages exactly accepted polynomial time qtm 
generally define class set languages exactly accepted qtm running time input length bounded 
qtm accepts language probability accepts probability string land rejects probability string define class bqp set languages note transition function specified deterministic algorithm depends algorithm transition function accomplished performing measurement check machine final state qf making partial measurement effect computation qtm 
quantum complexity theory accepted probability polynomial time qtm 
generally define class set languages accepted probability qtm running time input length bounded 
limitation considering stationary normal form qtms definitions easily seen limit computational power appealing stationary normal form universal qtm constructed theorem page 

upper lower bounds power qtms 
clearly bqp 
reversible tms special case qtms bennett results imply bpp bqp 
include simple proofs completeness 
theorem 

proof 
language polynomial time deterministic algorithm input produces output land 
appealing synchronization theorem page stationary normal form qtm running polynomial time input produces output ifx 
machine accepting theorem 
bpp bqp 
proof 
language bpp 
polynomial polynomial time deterministic tm output satisfy 
string length call sx set bits computed inputs proportion sx land 
qtm decide string language breaking superposition split equally running deterministic algorithm 
dovetail stationary normal form qtm takes input output stationary normal form qtm constructed theorem applies fourier transform contents second track 
gives stationary normal form qtm input produces superposition dovetailing synchronized normal form version built synchronization theorem page gives polynomial time qtm input produces final superposition proportion sx land observing bit third track give proper classification string probability bqp machine accepting language clearly bqp exponential time 
result gives nontrivial upper bound bqp 
theorem 
bqp pspace proof 
machine running time 
theorem page qtm card card close simulate steps accuracy 
simulate accuracy success probability need ethan bernstein umesh vazirani qtm transition amplitude computed log card card bits 
amplitude particular configuration time sum amplitudes possible computational path length start configuration desired configuration 
amplitude path computed exactly polynomial time 
maintain stack intermediate configurations carry depth search computational tree calculate amplitude particular configuration polynomial space exponential time 
determine string length accepted computing sum squared magnitudes time configurations sum clearly reachable accepting configurations blanks cells distance start cell 
polynomial space step configurations computing running sum squared magnitudes 
valiant suggestion upper bound improved proof simplified theorem shows bqp machine turned clean version input produces final superposition weight isa ifm accepts 
means need estimate amplitude configuration final superposition amplitude single configuration broken sum amplitudes computational paths reach sum positive real contributions sum negative real contributions sum positive imaginary contributions sum negative imaginary contributions 
show pieces computed machine 
recall set functions mapping strings integers exists polynomial language string value number strings length xy contained theorem 
language contained class time constructible qtm accepts probability property 
run input length runs time bounded ct polynomial log produces final superposition withl land squared magnitude 
theorem 
bqp proof 
machine observation time 
appealing theorem conclude loss generality clean bqp machine example input time squared magnitude final configuration output appeal theorem page tells qtm amplitude computed log card card bits run input squared magnitude time final configuration output carry proof showing oracle class efficiently compute error magnitude amplitude final configuration ofm time true amplitude magnitude quantum complexity theory squared magnitude approximated amplitude squared magnitude true amplitude 
see just note true amplitude success probability comparing squared magnitude approximated amplitude lets correctly classify string show approximate amplitude described 
notice amplitude configuration time sum amplitudes computational path length start configuration desired configuration 
amplitude particular path product amplitudes transition function step path 
amplitude consists real part imaginary part think product consisting sum terms purely real purely imaginary 
amplitude desired configuration time sum terms path 
break sum pieces sum positive real terms sum negative real terms sum positive imaginary terms sum negative imaginary terms compute error magnitude aid algorithm 
difference give amplitude desired configuration error magnitude desired 
compute sum positive real contributions paths follows 
suppose fixed constant polynomial inputs length polynomial specification step computational path specification terms integer ct easy see decide deterministic time polynomial really path start configuration desired final configuration term real positive tth term amplitude path greater ct term satisfying constraints number algorithm accepts divided ct ct value tth path fix path satisfying constraints number algorithm accepts divided ct sum positive real terms path number algorithm accepts divided ct sum positive real terms step paths start configuration desired configuration 
card card possible successors configuration legal path log card card log choosing gives desired 
similar reasoning gives algorithms approximating remaining sums terms 

oracle qtms 
subsection assume loss generality tm alphabet track 
initially tracks blank input track contains actual input surrounded blanks 
denote 
classical setting oracle may described informally device evaluating boolean function arbitrary arguments unit cost evaluation 
allows formulate questions efficiently computable tm functions languages efficiently computed ethan bernstein umesh vazirani tms section define oracle qtms equivalent question asked quantum setting 
oracle qtm special query track machine place questions oracle 
oracle qtms distinguished internal states state qq state qa 
query executed machine enters state single nonempty block cells query track 
assume region query tape state state entered denotes concatenation 
boolean function computed oracle 
result oracle call state query tape denotes exclusive addition modulo machine internal control passes state 
query tape internal control parts oracle qtm change query 
target bit supplied initial state final state just classical oracle machine 
conversely target bit state calling oracle reset process known essential proper interference take place 
power quantum computers comes ability follow coherent superposition computation paths 
similarly oracle qtms derive great power ability perform superpositions queries 
example oracle boolean function called query tape state complex coefficients corresponding arbitrary superposition queries constant target bit 
case query query string left entangled state definition oracle qtms yields unitary evolutions self evident restrict machines formed respects particular evolving enter state leave state 
define sets languages accepted probability oracle qtm running time bounded 
bound running time applies individual input just average 
notice bqp machine depend oracle bqp machine 
carefully defined oracle qtms technique reverse qtm reversal lemma reverse oracle qtm 
lemma 
normal form unidirectional oracle qtm normal form oracle qtm oracle reverses computation extra time steps 
proof 
normal form unidirectional oracle qtm initial final states qf query states qq qf qa 
construct exactly proof reversal lemma 
give query states qq roles reversed 
normal form qq qf 
recall transition function defined dq dp qtm careful avoid leaving intermediate computations tape requiring query track contains query string adds difficulty construction oracle qtms 
quantum complexity theory state qq state qa qq oracle qtm 
note tape head position irrelevant functioning oracle operation oracle reverses operation oracle argument reversal lemma prove formed reverses computation extra time steps 
definition quantum oracle arbitrary boolean function suffice purposes ability quantum computers perform general unitary transformations suggests broader definition may useful contexts 
example oracles perform general non boolean unitary operations considered computational learning theory obtain large separations quantum classical relativized complexity classes 
see discussion general definitions oracle quantum computing 

fourier sampling power qtms 
section give evidence qtms powerful bounded error probabilistic tms 
define recursive fourier sampling problem input program boolean function takes value 
show recursive fourier sampling problem bqp 
hand prove boolean function specified oracle recursive fourier sampling problem log 
result provided evidence qtms powerful classical probabilistic tms bounded error probability :10.1.1.144.7852
ask relevance oracle results view results probabilistically checkable proofs 
arora impagliazzo vazirani case fact versus np question imply question resolved current techniques complexity theory hand oracle results subsequent results key property oracles exploited black box nature reasons sketched results provide strong evidence bqp bpp course results gave stronger evidence 
assumes np existence way functions hypotheses unproven widely believed complexity theorists reasonable assume general impossible efficiently function computed program just looking text explicitly running various inputs 
program treated black box 
course assumptions question hand np 
fourier sampling 
consider vector space complex valued functions zn natural inner product space standard orthonormal basis vector space set delta functions forx expressing function zn basis equivalent specifying values point domain 
characters group zn yield different orthonormal basis consisting parity basis functions 
ethan bernstein umesh vazirani function zn may write new parity basis zn 
function called discrete fourier transform hadamard transform name refers fact linear transformation maps function fourier transform hadamard matrix hn 
clearly transformation unitary just effecting change basis orthonormal basis delta function basis parity function basis 
follows discrete fourier transform zn written kronecker product transform copies transform case matrix fact write simple efficient qtm affects discrete fourier transformation sense suppose qtm tape alphabet cells initially tape contain symbols 
express initial superposition isthe amplitude configuration cells 
qtm affects fourier transformation applying transform bits cells 
takes steps results final configuration theorem 
notice fourier transformation place vector space dimension hand result fourier transform resides amplitudes quantum superposition directly accessible 
perform measurement tape cells obtain sample probability distribution shall refer operation fourier sampling 
shall see powerful operation 
reason value depends exponentially values possible anticipate values large probability constructive interference carrying exponential search 
boolean function zn may define function zn norm letting deutsch jozsa polynomial time computable function qtm produces superposition time polynomial combining fourier sampling operation get polynomial time qtm samples certain distribution related polynomial time computable function theorem 
shall call composite operation fourier sampling respect theorem 
normal form qtm run initial superposition bit strings halts time tape head back start cell produces final superposition hn proof 
construct desired machine alphabet set states qa qb qc qf 
machine operate follows started string length input 
state machine steps right left enters state qb 
state qb machine steps right input string reaches enters state qc stepping back left string symbol 
rightward scan machine applies transformation quantum complexity theory bit cell 
state qc machine steps left reaches left start cell point steps back right halts 
gives quantum transition function desired machine 
qa qa qb qa qb qc qb qb qb qc qf qc qc qf qb easily verified completion lemma extend machine formed qtm machine desired behavior described 
theorem 
polynomial time computable function polynomial time stationary qtm observing final superposition input gives bit string probability proof 
build qtm carry steps 

apply fourier transform produce 
compute produce 
apply phase applying machine produce 
apply reverse machine step produce 
apply fourier transform produce desired 
constructed fourier transform machine steps 
computed deterministic polynomial time synchronization theorem page lets construct polynomial time qtms steps take input output vice versa running time independent particular value apply phase step extending tracks stationary normal form qtm alphabet defined qf qf qf qf dovetailing stationary normal form qtms gives desired machine 
remarkably quantum algorithm performs fourier sampling respect calling algorithm twice 
see clearly remarkable consider special case sampling problem function unnormalized parity functions 
suppose corresponds parity function result fourier sampling respect call promise problem parity problem input program computes unnormalized parity function determine notice qtm fourier sampling extracts bits information value just invocations subroutine computing boolean function hard show specified oracle probabilistic setting extracting bits information require invocations boolean function 
show amplify advantage quantum computers ethan bernstein umesh vazirani probabilistic computers defining recursive version parity problem recursive fourier sampling problem 
ready problem recursion need turn parity problem problem range 
easily done adding second function requiring answer 
problem recursive 
problem instance size replace values independent recursive subproblems size stopping recursion function calls bottom 
qtm needs calls solve parity problem able solve instance recursive problem size recursively time poly poly 
needs calls solve parity problem straightforward recursive solution recursive problem require time nt log allow prove separation quantum classical machines replace functions oracle 
legal oracle oracle satisfying special constraints described define language ro 
show qtm access legal oracle accepts ro time log success probability legal oracle ro contained log language consist strings length power 
call strings candidates 
decision candidate contained language depend recursive tree 
candidate length children tree general node level counting bottom leaves level convenience children 
root tree candidate length identified string children identified string general descendent tree level identified string form xm xm notice string form andl log defines node tree 
consider oracles map queries alphabet answers define function vo value 
language ro contain exactly candidates vo 
define vo leaves level nodes directly oracle xis leaf vo 
define vo nodes looking answer particular query chosen depending values vo children 
consider node level 
insist oracle kx children values determined parity kx vo kx give vo value kx 
say oracle legal process allows successfully define vo nodes level 
quantum complexity theory query form andk form leaf called query node query located recursive tree node subtree rooted called outside notice candidate values vo nodes tree rooted decision ro depend answers queries located nodes tree rooted theorem 
oracle qtm legal oracle runs polynomial time accepts language ro probability 
proof 
built language ro accepted efficiently recursive quantum algorithm 
avoid working details required implement recursive algorithm reversibly implement algorithm machine writes iteration desired recursion 
looping lemma build qtm carry iteration 
consider recursive algorithm compute vo node leaf value vo querying string 
calculate vo follows 

split equal superposition children 
recursively compute vo children superposition 

apply phase child child value vo 

reverse computation step erase value vo 

apply fourier transform converting superposition children superposition consisting entirely single string kx 

query kx find value vo 
reverse steps erase kx leaving vo 
notice number steps required iteration obeys recursion discussed polynomial length synchronization theorem page construct polynomial time qtm particular writes list steps carried 
complete proof constructing polynomial time qtm carry list steps 
algorithm requires recursively run algorithm reverse need see handle step reverse 
start fill node description leaf adding strings steps just require applying fourier transform qtm bit string level current node description 
fourier transform reverse machine reverses steps 
step handled phase applying machine constructed part fourier sampling qtm theorem 
transformation step reverse machine reverse step 
step reverse handled reversible tm copies relevant part current node description queries oracle returns node description query tape 
notice machines takes time depends length input 
stationary normal form qtms handle step level reverse time bounded polynomial branching lemma construct stationary normal form qtm carry specified step computation 
dovetailing machine rotates step list inserting resulting machine reversible tm looping lemma gives desired qtm 
ethan bernstein umesh vazirani computing function vo takes time log probabilistic computer allowed bounded probability error 
see intuition 
consider asking set queries legal determine value vo node described string xm level ways asked queries fix value queries outside subtree rooted happens say vo constraint 
example asked queries subtrees rooted siblings fixed vo siblings fixing string vo xm equals way value node fixed 
queries fix value vo children restrict possible values string kx vo equals kx vo kx 
query kx possible kx asked answers fixes value vo query kx correct kx asked call hit 
notice fixing values set children level node restricts value kx set possibilities maximum size linearly independent subset children values fixed 
prove log intuition interested arguing probabilistic tm deterministic tm 
argue just takes log queries fix value candidate length fewer log queries fixed choosing random legal oracle consistent queries gives candidate length value probability extremely close give desired result 
see call set queries asked answers queries run probabilistic tm 
log shown take run candidate length fewer queries probability random legal oracle agreeing run assigns value extremely close means probabilistic tm running time log fail probability accept ro random legal oracle definition 
run size defined pair set query strings map legal oracle agreeing run node level legal oracle agrees determines string ky vo ky 
ky query say hit suppressing dependency notation define probability hit choose legal oracle uniformly random set oracles agree similarly ancestor define px probability hit legal oracle chosen uniformly random set oracles agree lemma 
px 
proof 
set legal oracles agree write disjoint union sh sn set oracles hit splitting sh sn value vo write disjoint union sets sh sh sn sn 
quantum complexity theory card sh notation card sh card sn easy see oracles sn hit card sn card sn card sn consider set legal oracles defined outside agree oracle determines constraint value vo leaves string ky completely undetermined 
write disjoint union constrained value vo notice set legal oracles exactly 
px card card sh card card sh card card card card card card sh card card sh card card sh card card sh card card sn loss generality card card 
increases wehave card card sh px card card sh card card sn card card sh card card sh card card sn card sh 
card sh card sn positive integer define 
notice log theorem 
suppose run node level queries ancestor px 
proof 
prove theorem induction fix run node level queries hit 
certainly probability hit desired 
perform inductive step 
assume theorem holds true level 
fix run node level queries 
show theorem follow lemma 
remainder proof probabilities taken choice legal oracle uniformly random set legal oracles agree suppose queries clearly condition hits children ky chosen uniformly bit strings probability hit condition exactly hits children probability hit probability hit bounded sum probability children hits 
consider child applying inductive hypothesis roles know qz queries py expected number hits children qz means probability children ethan bernstein umesh vazirani hits 
corollary 
log relative random legal oracle probability ro contained 
proof 
fix log show probabilistic tm pick random legal oracle probability fails run time log fails accept ro error probability bounded countable number probabilistic tms intersection countable number probability events probability conclude probability ro contained log 
prove corollary showing large probability runs time greater error greater input way fixing oracle answers trees tree rooted probability taken random choices oracle tree rooted arbitrarily fix legal behavior trees rooted consider picking legal behavior tree rooted uniformly random run input classify runs input run lists queries machines asks answers receives 
take probabilities randomness choice oracle probability correctly classifies time pr pr correct pr probability run pr correct probability answer correct run ranges runs queries 
theorem tells condition run fewer queries probability hit means probability algorithm correctly classifies conditioned particular run fewer queries large probability correctly classifies time sufficiently large probability fails run time success probability input appendix qtm formed iff time evolution unitary 
note time evolution operator qtm exists 
note true qtm formed 
lemma 
qtm time evolution operator adjoint operator inner product space superpositions machine quantum complexity theory proof 
qtm time evolution operator adjoint operator operator matrix element pair dimensions complex conjugate matrix element dimensions operator defined fashion maps superpositions superpositions finite linear combinations configurations particular configuration reached nonzero weight finite number configurations 
easy see superpositions desired 
include proofs standard facts completeness 
proof theorem 
fact 
linear operator inner product space exists preserves norm iff proof 
square norm ux ux ux ux 
clearly follows preserves norm 
converse preserves norm ux 
bx 
follows implies useful fact 
fact 
suppose linear operator inner product space exists 
ux ux uy 
proof 
ux ux ux direction follows substituting direction preserves norm fact ux uy uy 
need establish additional fact norm preserving operators prove theorem 
fact 
countable inner product space orthonormal basis norm preserving linear operator exists 
unitary 
proof 
preserves norm uu 
projection uu norm uu 
norm preserving uu 
hand projection uu norm 
follows projection uu norm 
uu 
follows uu finite dimensional implies uu operator norm preserving unitary 
infinite dimensional imply uu time evolution operators qtms special structure fact conditions equivalent time evolution operator qtm 
theorem 
qtm formed iff time evolution operator unitary 
proof 
norm preserving time evolution operator formed qtm 
consider standard orthonormal basis superpositions consider example space finite complex linear combinations positive integers linear operator maps ethan bernstein umesh vazirani set vectors ranges configurations superposition amplitude configuration 
may express action respect standard basis countable dimensional matrix th entry uc matrix special properties 
row column matrix finite number nonzero entries 
second finitely different types rows rows type entries just permutations 
shall show row matrix norm fact unitary 
identify set columns matrix arbitrarily large restrict attention finite matrix consisting chosen rows columns nonzero entries rows 
matrix matrix construction satisfies properties square arbitrarily small 
constant distinct row type times rows infinite matrix occurs sum squared norms rows equal sum squared norms columns 
quantity just columns infinite matrix orthonormal fact 
assume row infinite matrix norm choose sufficiently large sufficiently small sum squared norms rows gives required contradiction rows infinite matrix norm fact unitary 
construct finite matrix fix contiguous set cells tape 
consider set configurations tape head located cells tape blank outside cells 
easy see number configurations card card 
columns indexed configurations define finite matrix referred 
nonzero entries columns restricted rows indexed configurations rows indexed configurations tape head cell immediately left right special cells tape blank outside cells 
number additional configurations card card 

choose large 
recall row infinite matrix corresponding operator indexed configurations 
say configuration type state adjacent tape cells centered tape head contain symbols 
entries row indexed permutation entries row indexed configuration type transition qtm depends state symbol tape head tape head moves adjacent cell transition 
configuration yields configuration nonzero amplitude result single step tape contents identical cells 
follows finite number configurations row indexed finite number nonzero entries 
similar argument shows column finite number nonzero entries 
consider rows finite matrix indexed configurations type tape head located cells 
card row indexed quantum complexity theory configuration property configuration yields nonzero amplitude single step row indexed finite matrix nonzero entries row indexed infinite matrix 
sense say row type row infinite matrix 
rows type constitute fraction rows substituting bounds get fraction card card card constant card card card 
establishes properties matrix proof 
appendix reversible tms powerful deterministic tm 
appendix prove synchronization theorem section 
simple facts reversible tms 
give necessary sufficient conditions deterministic tm reversible show just qtms partially defined reversible tm completed give formed reversible tm 
give aside easy proof reversible tms efficiently simulate reversible generalized tms 
theorem 
tm generalized tm reversible iff conditions hold 

state entered moving direction 
words 

transition function direction ignored 
proof 
show conditions imply reversibility 
suppose tm generalized tm satisfying conditions 
procedure lets take configuration compute predecessor 
state entered moving direction state configuration tells cell tape head previous configuration 
looking cell see tape symbol written step 
know update rule previous step allowing reconstruct previous configuration 
show property necessary reversibility 
example consider tm generalized tm 
easily construct configurations lead configuration configuration machine state reading symbol cells left tape head identical changed machine state tape head cells left 
reversible 
similar arguments apply pair distinct directions condition theorem necessary reversibility 
show second condition necessary reversibility 
suppose tm generalized tm 
pair configurations differ state symbol tape head lead configuration reversible 
corollary 
reversible tm configuration exactly predecessor 
proof 
reversible tm 
definition reversibility configuration predecessor 
ethan bernstein umesh vazirani configuration state theorem tells enter state moving tape head direction dq 
theorem tells ignoring direction inverse state symbol direction dq tells transform predecessor 
corollary 
partial function satisfying conditions theorem extended total function satisfies theorem 
proof 
suppose partial function satisfies properties theorem 
dq direction entered dq arbitrarily 
fill undefined values unused triples form dq maintain conditions theorem 
number triples card card exactly fully define 
theorem 
generalized reversible tm reversible tm simulates slowdown 
proof 
idea replace transition tape head stand transitions 
updates tape moves right remembering state enter 
second steps back left enters desired state 
generalized reversible tm identical state transition form add new state add new transition rule 
replace transition transition 
clearly simulates slowdown factor 
complete proof need show reversible 
consider configuration 
need show predecessor 
state enters moving left right transitions identical reversible predecessor 
similarly new states transitions exactly tape head moves right staying 
reversibility implies predecessor 
suppose state enters standing 
theorem tells transitions enter direction removed transitions entering new ones form means predecessor 
prove synchronization theorem way 
ideas constructions bennett morita show deterministic tm reversible tm input produces output running time depends sequence head movements input deterministic computation simulated efficiently oblivious machine head movements depend length input able construct desired synchronized reversible tm 
idea bennett simulation run target machine keeping history maintain reversibility 
output copied simulation run backward history exactly erased input recovered 
target tape head moves back forth history steadily grows bennett uses tm simulation 
quantum complexity theory idea morita simulation simulation tape tracks simulate tape desired machine keep history 
provided machine move reversibly current head position target machine history carry bennett simulation quadratic slowdown 
morita tms way infinite tapes simulating machine move simulation history moving left tape searching back right 
simulation write history step target machine takes just steps 
means history right simulation allowing way infinite tapes 
reversible tms move head directions generalized reversible tms bennett morita 
definition 
deterministic tm oblivious running time position tape head time step depend length input 
carrying single tape bennett constructions find useful build simple reversible tms copy string track exchange strings tracks 
copy strings delimited blanks single tape bennett construction copy strings delimiters section 
lemma 
alphabet normal form reversible tm alphabet property 
run input max steps returns tape head start cell outputs proof 
alphabet state set qf transition function defined qf qf state entered direction transition function reversible 
verified performs desired computation stated number steps 
lemma 
alphabet normal form reversible tm alphabet property 
run input outputs run input outputs case runs steps leaves tape head back start cell 
proof 
alphabet state set qf transition function defined transition duplicated qf qf ethan bernstein umesh vazirani state entered direction transition function extended reversible tm 
verified performs desired computation stated number steps 
theorem 
oblivious deterministic tm input produces output embedded blanks tape head back start cell start cell 
reversible tm input produces output input produces output cases halts tape head back start cell takes time depends lengths bounded quadratic polynomial running time input proof 
oblivious deterministic tm stated theorem qf initial final states simulation run stages 

simulate maintaining history simulation reversible 

copy track shown lemma 
runs reverse simulation erasing history restoring input 
construct normal form reversible tm stages dovetail 
machines track tm alphabet 
track alphabet simulate tape second track alphabet store single locating tape head third track alphabet write list transitions taken starting marker 
help find start cell enter leave copying phase 
fourth track alphabet write output describing machine give partial list transitions obeying conditions theorem appeal corollary 
machines usually reading writing track time 
convenience list transition occurrences symbols form vi stand possible transitions vi replaced symbol appropriate special marker replaced symbol 
phase simulation handled machine state set union sets qa qb 
start state qa final state qf transitions defined follows 
mark position tape head start cell mark start history cell enter state 
qa qb qb pair qf transition inm include transitions go state state updating simulated tape adding history 
carry update simulated tape remembering transition taken move history deposit information transition 
middle history reach history walking right hit blank 
left history walk right blanks reach start history 
quantum complexity theory machine reaches state standing blank history 
state include transitions move history back left head position enter walk left state writing history tape 
maintain reversibility enter second left walking state look tape head marker past left history 
reach tape head position step left right entering state 
put normal form including transition qf qa simulation alphabet 
verified state entered direction transitions relying fact normal form don simulate transitions qf back verified partial transition function described 
corollary says extend transitions give reversible tm 
notice operation independent contents fourth track leaves contents unaltered 
second third machines simply copying machine constructed lemma reverse constructed lemma page 
operated independently fourth track reversal 
dovetailing tms gives reversible tm input produces output tape head back start cell input produces output notice time required simulate step bounded polynomial running time depends current head position direction moves step steps carried 
running time phase depends series head movements fact oblivious running time ethan bernstein umesh vazirani depends length true third phase reversal takes exactly extra time steps 
running time copying machine depends length 
running time input depends lengths bounded quadratic polynomial running time theorem 
oblivious deterministic tm input produces output embedded blanks tape head back start cell start cell length depends length bean oblivious deterministic tm alphabet input produces output tape head back start cell start cell 
reversible tm input produces output 
input halts tape head back start cell takes time depends length bounded polynomial running time input running time 
proof 
stated theorem common alphabet 
idea construct desired run compute run exchange routine produce run erase string phases starts ends tape head start cell 
construction theorem build normal form reversible tms accomplish third phases times depend lengths bounded polynomial running times input input 
lemma page constructed reversible tm performs exchange time depending lengths strings 
dovetailing machines gives desired function computable deterministic polynomial time computed polynomial time oblivious generalized deterministic tm theorems theorem give 
theorem synchronization theorem 
function mapping strings strings computed deterministic polynomial time length depends length polynomial time stationary normal form qtm input produces output running time depends length function strings strings computed deterministic polynomial time length depends length polynomial time stationary normal form qtm input produces output running time depends length appendix reversible looping tm 
prove looping lemma section 
lemma looping lemma 
stationary normal form reversible tm constant properties 
input positive integer written binary runs time log halts tape unchanged 
special state input visits state exactly times time tape head back start cell 
proof 
mentioned section difficulty construct loop reversible entrance exit 
accomplish follows 
synchronization theorem build track stationary normal form reversible tm running time polynomial log input quantum complexity theory outputs opposite ork 
calling initial final states machine qf construct reversible loops machine follows 
give new initial final states qa qz ensure properties 

started state qa track steps left back right changing entering state 

state qf track steps left back right state 

state qf track steps left back right changing halts 
input km step left right state changing tape contents machine run time changing halting state qf state qf track run 
machine run times produces point changes tape contents halts 
input visits state qf exactly times time tape head back start cell 
means construct desired identifying qf dovetailing reversible tms constructed synchronization theorem transform back complete proof constructing normal form reversible satisfies properties 
give alphabet additional states qa qb qy qz 
transition function states qf depends track leaving unchanged table qa qb qb qf qb qy qy qz qz qa qa qa easy see normal form satisfies properties stated 
reversible obeys conditions theorem verified transition function obeys conditions theorem 
theorem transition function completed giving reversible tm 

greatly benefited careful reading useful comments richard jozsa bob solovay 
wish gilles brassard charles bennett noam nisan dan simon 
ethan bernstein umesh vazirani adleman huang quantum computability siam comput pp 

arora impagliazzo vazirani role cook levin theorem complexity theory manuscript 
arora lund motwani sudan szegedy proof verification intractability approximation problems proc 
rd annual ieee symposium foundations computer science ieee press piscataway nj pp 

babai moran arthur merlin games randomized proof system hierarchy complexity classes comput 
system sci pp 

bennett cleve margolus shor sleator elementary gates quantum computation phys 
rev pp 

quantum hamiltonian models turing machines statist 
phys pp 

bennett logical reversibility computation ibm res 
develop pp 

bennett time space tradeoffs reversible computation siam comput pp 

bennett bernstein brassard vazirani strengths weaknesses quantum computing siam comput pp 

bernstein quantum complexity theory ph dissertation univ california berkeley may :10.1.1.144.7852
bernstein vazirani quantum complexity theory proc :10.1.1.144.7852
th annual acm symposium theory computing acm new york pp 

brassard quantum challenge structural complexity theory proc 
th ieee conference structure complexity theory pp 

brassard oracle quantum computing modern optics pp 

deutsch jozsa stabilisation quantum computation proc 
workshop physics computation dallas tx ieee computer society press los alamitos ca 
jackson learning dnf uniform distribution quantum example oracle proc 
th annual acm conference computational learning theory acm new york pp 

calderbank shor quantum error correcting codes exist phys 
rev pp 

quantum computation trapped cold ions phys 
rev lett pp 

chuang shor zurek quantum computers factoring decoherence science dec pp 

cohen quantum mechanics longman scientific technical essex pp 

deutsch quantum theory church turing principle universal quantum computer proc 
roy 
soc 
london ser 
pp 

deutsch quantum computational networks proc 
roy 
soc 
london ser 
pp 

deutsch jozsa rapid solution problems quantum computation proc 
roy 
soc 
london ser 
pp 

bit gates universal quantum computation phys 
rev pp 

rr decision procedure unitary linear quantum cellular automata proc 
th ieee symposium foundations computer science ieee press piscataway nj pp 

feynman simulating physics computers internat 
theoret 
phys pp 

feynman quantum mechanical computers 
phys pp 
optics news february 
fredkin toffoli conservative logic internat 
theoret 
phys 
grover fast quantum mechanical algorithm database search proc 
th annual acm symposium theory computing acm new york pp 

quantum complexity theory landauer quantum mechanics useful phil 
trans 
soc 
pp 

lipton personal communication 
lloyd potentially realizable quantum computer science pp 

phase information quantum oracle computing physics department university massachusetts amherst ma manuscript 
morita tape symbol reversible turing machine ieee trans 
ieice pp 

von neumann various techniques connection random digits notes forsythe national bureau standards applied math series pp 

reprinted von neumann collected works vol 
ed pergamon press ny pp 

palma quantum computers dissipation proc 
roy 
soc 
london ser 
pp 

shamir ip pspace proc 
nd acm symposium theory computing acm new york pp 

shor algorithms quantum computation discrete log factoring proc 
th annual ieee symposium foundations computer science ieee press piscataway nj pp 

shor fault tolerant quantum computation proc 
th annual ieee symposium foundations computer science ieee press piscataway nj pp 

simon power quantum computation proc 
th annual ieee symposium foundations computer science ieee press piscataway nj pp 
siam comput pp 

solovay yao manuscript 
toffoli extensions invertible combinatorial functions math 
systems theory pp 

unruh maintaining coherence quantum computers phys 
rev 
valiant personal communication 
vazirani vazirani random polynomial time equal semi random polynomial time proc 
th annual ieee symposium foundations computer science pp 

watrous dimensional quantum cellular automata proc 
th annual ieee symposium foundations computer science ieee press piscataway nj pp 

yao quantum circuit complexity proc 
th annual ieee symposium foundations computer science ieee press piscataway nj pp 

zuckerman weak random sources ph dissertation univ california berkeley 
