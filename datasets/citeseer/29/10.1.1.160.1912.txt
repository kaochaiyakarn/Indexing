swift distributed disk striping provide high data rates luis felipe cabrera computer science department ibm almaden research center darrell long computer information sciences university california santa cruz architecture called swift addresses problem data rate mismatches requirements application storage devices interconnection medium 
goal swift support high data rates general purpose distributed systems 
swift uses high speed interconnection medium provide high data rate transfers multiple slower storage devices parallel 
scales multiple storage devices interconnections appropriate storage technology including high performance devices disk arrays 
address problem partial failures swift stores data redundantly 
unix operating system constructed simplified prototype swift architecture 
prototype provides data rates significantly faster access local scsi disk limited capacity single ethernet segment case multiple ethernet segments ability client drive 
constructed simulation model demonstrate swift architecture exploit advances processor communication storage technology 
consider effects processor speed interconnection capacity multiple storage agents utilization components data rate system 
show data rates scale number storage devices replacing highly stressed components powerful ones data rates entire system increase significantly 
keywords high performance storage systems distributed file systems distributed disk striping high speed networks high speed client server model video server multimedia data resiliency 
goal architecture support high data rates general purpose distributed system 
architecture called swift addresses problem data rate mismatches requirements application maximum data rate storage devices supported part national science foundation nsf ccr institute scientific computing research lawrence livermore national laboratory faculty research funds university california santa cruz 
interconnection medium 
swift accomplishes goal high speed interconnection medium provide high data rate transfers multiple slower storage devices parallel 
swift flexibility appropriate storage technology including highperformance devices disk arrays 
adapt technological advances provide increasing demands 
current generation distributed computing systems support intensive applications 
particular incapable integrating high quality video data general purpose environment 
example multimedia applications require level service include scientific visualization image processing recording play back color video 
data rates required applications range megabytes second dvi compressed video megabits second cd quality audio megabytes second uncompressed full frame color video 
advances vlsi data compression processors communication networks storage capacity mean systems capable integrating continuous multimedia soon emerge 
particular emerging ansi fiber channel standard provide data rates excess gigabit second switched network 
contrast advances positioning time seek time rotational latency transfer rate magnetic disks kept pace 
architecture solves problem storing retrieving large data objects slow secondary storage high data rates 
goal support high data rates general purpose distributed storage system 
stripes data disks raid driving disks parallel provide high data rates 
swift raid designed distributed storage system 
provides advantages easy expansion load sharing provides better resource utilization resources necessary satisfy request 
addition swift flexibility appropriate storage technology including disk array high performance storage devices array tapes 
conducted studies validate swift architecture 
concept prototype simplified version swift implemented ethernet unix operating system 
prototype provides unix file system interface includes open close read write seek 
uses distributed disk striping multiple servers achieve high data rates 
case synchronous writes prototype single ethernet segment servers achieves data rates double provided access local scsi disk 
cases reads asynchronous writes data rates achieved prototype scale approximately linearly number storage agents saturation ethernet segment 
second study discrete event simulation simplified local area instance swift architecture 
constructed evaluate effects technological advances scalability architecture 
simulation model shows swift exploit highspeed gigabit second local area network faster processors currently available 
simulation locate components limit performance 
simulation includes processor utilization account data transmission cost computing parity blocks data 
remainder organized follows swift architecture described unix trademark bell laboratories client interconnection medium storage agents distribution agent storage mediator components swift architecture ethernet local area prototype 
measurements prototype 
simulation model 
consider related 
description swift architecture swift builds basic notion striping data multiple storage agents driving parallel 
principle architecture simple high speed interconnection medium aggregate arbitrarily slow storage devices faster logical storage service making applications unaware aggregation 
concurrent architectures cfs raid observation 
mainframes super computers exploited approach 
swift client server distributed architecture independently replaceable components 
advantage modular approach component limits performance replaced faster component available replicated parallel 
describe architecture general terms detailed description components 
swift distributed architecture independent components partial failures important concern 
precautions taken failure single component particular storage agent hinder operation entire system 
example object data failed storage agent unavailable object data written failed storage agent damaged 
accepted solution problem redundant data including multiple copy computed copy erasure correcting codes 
choice compatible architecture plan computed copy redundancy form parity version prototype 
simple approach provide resiliency presence single failure parity group low cost terms storage expense additional computation 
swift assumes objects created clients managed components swift 
particular objects stored storage agents 
implementation swift operates follows client issues request store retrieve object storage mediator reserves resources necessary storage agents communication subsystem session oriented manner 
storage mediator presents distribution agent transfer plan 
swift assumes sufficient storage data transmission capacity reserved available negotiations client behave data producer data consumer storage mediator allow preallocation resources 
resource preallocation implies storage mediators reject request requirements unable satisfy 
request delayed reissued resources available 
transmit object client distribution agent stores retrieves data storage agents transfer plan intervention storage mediator 
components swift architecture depicted 
swift storage mediator selects striping unit amount data allocated storage agent stripe data rate requirements client 
required transfer rate low striping unit large data spread storage agents 
required data rate high striping unit chosen small spread data sufficient storage agents exploit parallelism needed satisfy request 
allowing variable striping units swift architecture achieves better resource utilization resources needs satisfy request 
subsections distribution agent storage mediator storage agent detail 
distribution agent distribution agent acts behalf clients data producer data consumer storage retrieval data 
strictly required expect practice data producer data consumer resident distribution agent serving 
distribution agent interacts storage mediator obtain directory service access rights objects encryption keys transfer plans 
addition computed transformations data encryption erasure correcting codes done distribution agents 
authentication accomplished secure exchange keys storage mediator obtain trusted communication channel 
primary task distribution agent implement striping data storage agents 
retrieving object storage distribution agent assembles object incoming data streams transfer plan 
storing object distribution agent distributes object storage agents 
cases distribution agent performs necessary redundancy computations provide fault tolerance 
shall see computations put significant burden processor 
fortunately mitigated availability increasingly powerful processors 
storage mediator storage mediator central establishing administering storage communication resources system 
determines size transfer unit request hand 
storing object transfer unit size data block computing parity blocks transmission interconnection medium 
second storage mediator negotiates storage agents reserve sufficient space communication capacity 
third storage mediator determines best meet resiliency requirements returns part transfer plan 
transfer plan contains information necessary store retrieve object administered system 
particular contains transfer unit request list storage agents hold data list storage agents act checks data internal handles transferring data storage agents 
storage mediator sole repository encryption keys 
encryption mechanism provide authentication access control security data 
storage mediator secure key exchange protocol authenticate distribution agents 
order achieve high performance pessimistic storage allocation strategy 
resources preallocated requests exceed current storage communication capacity denied 
requests reissued time resources available 
storage mediator call back mechanism provide cache coherency 
distribution agent requests access object may exist cache client storage mediator cause cache flushed part resource allocation protocol 
resource preallocation allows swift effectively support sequential write sharing alternative access data find data cache making invalidation simple 
storage mediator available metadata maintains fault tolerant 
example directory entry contains name object protection status list data segments storage agents hold object 
loss directory information implies objects referenced directory 
integrity storage mediator data insured ways 
preferred method swift administer metadata specify high degree redundancy 
approach standard data base techniques write ahead log 
storage agents storage agents administer aspects secondary storage media including data layout optimization line data alignment 
storage agent may administer storage devices 
storage devices disks high speed devices including arrays disks tapes 
sparcstation slc servers local scsi disks laboratory ethernet departmental ethernet sparcstation client sparcstation slc servers local scsi disks ethernet implementation swift architecture 
swift architecture intended objects larger cache believe caches staging data transfer units storing complete objects 
small objects expect caches beneficial systems 
swift achieves reliability appropriate redundancy 
example object descriptors store redundant information allows reconstruction objects scavenging data storage agents catastrophic failure software error render storage mediator 
error detecting capabilities disks single parity disk sufficient tolerate single failure 
way disk fails reconstructed information disks 
higher level erasure correcting codes failure tolerated 
ethernet prototype swift simplified prototype swift architecture built set libraries standard filing interprocess communication facilities unix operating system 
unix file system facilities name store objects making storage mediators unnecessary 
need explicitly build transfer plans library interleaves data uniformly set identical storage agents service request 
objects administered prototype striped servers local scsi disk act storage agent ethernet local area network 
clients provided unix file system interface includes open close read write seek operations 
structure prototype depicted 
swift distribution agent embedded libraries invoked client 
storage agents represented unix processes servers standard unix file system 
request client communicates storage agents involved request simultaneously perform operation striped file 
file may striped number storage agents important performance limiting factors rate client servers send receive packets maximum transfer rate ethernet 
current prototype allowed confirm high aggregate data rate achieved swift architecture 
data rates earlier prototype data transfer protocol built tcp network protocol proved unacceptable 
prototype tcp connection established client server 
connections multiplexed select 
tcp delivers data stream message boundaries significant amount data copying necessary 
data rates achieved capacity ethernet 
initially select point congestion 
closer inspection revealed tcp appropriate buffer management problems prevented prototype achieving high data rates 
current prototype built light weight data transfer protocol top udp datagram protocol 
avoid unnecessary data copying possible scatter gather kernel deposit message directly user buffer 
current prototype client sun sparcstation megabytes memory megabytes local scsi disk unused experiments 
list hosts act storage agents 
storage agents placed sun slc megabytes memory identical local scsi disks capacity megabytes 
client storage agents dedicated udp ports transfer data dedicated server process handle user requests 
data transfer protocol swift client uses unique udp port connection 
done effort allocate buffer space possible client 
client services open request contacting storage agent advertised udp port address 
swift storage agent waits open requests known udp port address 
open request received new secondary thread control established private port communication regarding file client 
thread remains active communications channel remains open close request received client primary thread continues await new open requests 
secondary thread receives read write request receives additional information type size request 
additional information thread calculate packets expected sent received 
case read request client sends requests blocks client 
ahead allows blocks various states transmission client resulted significant data rate benefits 
client servers implement simple sliding window protocol assure packets lost assembled correct order client 
write request client sends data written block time receiving explicit acknowledgment 
explicit acknowledgments necessary prevent client flooding servers packets performing synchronous writes 
experiments extra acknowledgments significant impact measured data rate faster network sophisticated protocol 
receipt close request client expires file handle storage agents release ports extinguish threads dedicated handling requests file 
measurements swift prototype measure performance swift prototype sixteen megabytes read written swift objects 
order calculate confidence intervals samples measurement taken 
analogous tests performed local scsi disk nfs file service 
data rate measurements section kilobytes denote thousands bytes second 
order maintain cold caches file mapped virtual address space flushing process 
pages file invalidated requires disk file accessed 
mappings removed delete pages file 
methods disk partition containing file tried yielded similar results 
calibrate performance prototype measured performance local scsi disk sun act server 
measurements similar host results hosts table 
results local scsi measurements indicate sun quantum local disk capable reading data approximately kilobytes second 
measured values decrease slightly amount data read increases drop file megabytes length 
experiments synchronous write measure rate local scsi disk write data actual device kilobyte blocks 
rate approximately kilobytes second decreases length file 
probable reason increased complexity accessing data blocks length file increases 
experiments asynchronous write measure rate writes file system memory written disk file system efficiently 
performance user perceives writing local disk 
data guaranteed written disk file closed 
measurements reveal rate local file system sun asynchronously write data approximately kilobytes second large files 
significant drop performance relatively small file megabyte kilobytes second large file sixteen megabytes kilobytes second 
reason drop performance buffer space exhausted file system forced writing data disk 
performance single swift server table 
prototype performs table measured performance local scsi disk kilobytes second 
read synch write write request confidence confidence confidence megabytes low high low high low high table swift performance single server kilobytes second 
read synch write write request confidence confidence confidence megabytes low high low high low high nearly accessing local scsi disk prototype slightly slower due data transmission protocol processing delays 
prototype sends requests case allows server ahead file processing accesses local disk data transmitted 
enables prototype read approximately kilobytes second single sun server 
synchronous writes considered prototype performs identically local file system prototype slightly slower due transmission delays 
asynchronous writes considered performance prototype single server comparable local file system 
prototype able write approximately kilobytes second large files 
slightly slower local file system attributed transmission delay introduced ethernet 
performance prototype servers single ethernet segment summarized table 
cases prototype servers performs approximately twice prototype single server 
reads considered prototype performs slightly twice servers single server 
primary reason disparity see increasingly issue servers employed ability sparcstation receive data ethernet 
case synchronous writes data rate prototype servers exactly doubles data rate single server 
noticeable degradation ethernet lightly loaded approximately kilobytes second transferred 
case asynchronous writes prototype servers approximately doubles table swift performance servers ethernet kilobytes second 
read synch write write request confidence confidence confidence megabytes low high low high low high table swift performance servers ethernet kilobytes second 
read synch write write request confidence confidence confidence megabytes low high low high low high data rate prototype single server 
results experiments prototype servers single ethernet segment table 
case reads data rate approximately times single server 
data rate increase strictly linear ethernet increasingly saturated ability sparcstation receive data quickly ethernet limited 
synchronous writes considered data rate continues scale approximately linearly number servers 
asynchronous writes increase data rate muted ethernet 
performance better reads transmitting data ethernet requires fewer context switches data copying receiving puts load sparcstation 
purposes comparison measurements data rates provided high performance nfs file server 
server sun megabytes memory gigabytes disk space ipi drives 
server connected sparcstation client prototype experiments second network interface 
network shared departmental ethernet measurements conducted late night minimize interference tasks 
results experiments table 
case reads high performance nfs file server performs approximately better prototype single server 
surprising sun designed act file server ipi disks times faster local scsi disk prototype 
synchronous writes considered nfs file server performs approximately better table nfs performance sun client sun server 
read synch write write request confidence confidence confidence megabytes low high low high low high prototype single server 
multiple swift servers prototype provides significantly better performance nfs file server 
asynchronous writes considered swift server provides significantly better performance single server employed 
careful comparing swift nfs swift prototype provide features nfs support 
example nfs stateless provide guarantees asynchronous writes stronger provided swift 
measurements prototype single ethernet segment demonstrate swift architecture achieve high data rates local area network aggregating data rates slower data servers 
prototype validates concept distributed disk striping local area network 
demonstrated prototype providing data rates higher local scsi disk nfs file server 
measurements second ethernet segment determine effect doubling data rate capacity interconnection added second ethernet segment client added additional storage agents 
case storage agents sun slc faculty offices megabytes memory local scsi disks hosts laboratory 
second ethernet segment shared groups department 
measurements performed late night period load departmental ethernet segment seldom capacity 
interface second network segment placed bus client 
bus interface known achieve lower data rates board interface expect obtain data rates twice great dedicated laboratory network 
expected see network subsystem client highly stressed 
results storage agents separate ethernet segments table 
compared results storage agents single ethernet segment apparent case reads having storage agents networks slightly worse having single network 
reasons anomaly 
network interfaces interrupts fielded client 
second second network shared entire department slight load late night 
hosts departmental ethernet segment table swift performance servers ethernets kilobytes second 
read synch write write request confidence confidence confidence megabytes low high low high low high memory laboratory 
results synchronous writes comparable obtained single ethernet segment data rate scales linearly 
measurements asynchronous writes comparable obtained single ethernet segment 
reason difference scaling write puts stress sparcstation read 
write requires fewer context switches data copied 
write require interrupt signal completion 
results storage agents separate ethernet segments table 
reads considered apparent data rate scale linearly comparable storage agents single ethernet segment 
due complexity ethernet interfaces 
case synchronous writes data rate continues scale linearly performing twice storage agents 
asynchronous writes perform ceased scale linearly client approaching capacity transmit data ethernet interfaces 
table effect adding pair storage agents considered 
data rate read improves proportion number storage agents 
client highly stressed fielding interrupts copying data 
case synchronous writes data rate continues scale linearly 
unexpected low base data rates local scsi disks stress network 
case asynchronous writes essentially change storage agents client reached limits ability transmit data 
measurements prototype validate concept distributed disk striping demonstrate scales component saturated 
faster components processors interconnection media swift architecture able immediate data rates scale accordingly 
simulation performance study modeled hypothetical high speed local area token ring implementation swift architecture 
primary goal simulation show architecture exploit network processor advances 
second goal demonstrate distributed disk striping viable technique provide data rates required intensive table swift performance servers ethernets kilobytes second 
read synch write write request confidence confidence confidence megabytes low high low high low high table swift performance servers ethernets kilobytes second 
read synch write write request confidence confidence confidence megabytes low high low high low high applications 
third goal confirm scaling properties swift 
necessary network technology available simulation appropriate exploration vehicle 
token ring local area network assumed transfer rate gigabit second 
clients modeled disk hosts single network interface connected token ring 
storage agents modeled hosts single disk device single network interface 
evaluate possible effect processor bottlenecks simulated processor types instructions second processors 
structure simulator simulator implemented simplified version swift architecture designed address goals stated 
modeled caching preallocation resources providing performance guarantees 
required appropriate traces file system activity traces unavailable 
addition simulator model storage mediator 
storage mediator path data transmitted clients consulted start session part critical path data rate evaluation 
system modeled client requests drive storage agent processes 
generator process creates client requests exponential distribution govern request interarrival times 
client requests differentiated pure read pure write conservative read write ratio 
modeling overlapping execution requests modeled serially request complete issued 
simulation swift read operation small request packet multicast storage agents 
client waits data transmitted storage agents 
write operation client transmits data storage agents 
blocks write request transmitted client awaits acknowledgment storage agents data written disk 
simulator models parity computations 
computing data parity important factor processor utilization 
simulator charges instructions compute parity byte data 
consider processor expensive way computing parity errs conservative side 
expensive implementations require processor power achieve results simulated 
disk devices modeled shared resource 
requests allowed complete resource relinquished 
time transfer block consists seek time rotational delay time transfer data disk 
seek time rotational latency assumed independent uniform random variables pessimistic assumption advanced layout policies 
block read disk scheduled transmission network 
model disk access time conservative advanced layout policies considered attempt order requests schedule disk arm caches modeled 
staging data cache sequential preallocation storage greatly reduce number seeks significantly improve performance 
model provides lower bound data rates achieved 
transmitting message network requires protocol processing time acquire token transmission time 
protocol cost packets estimated instructions plus instruction byte packet 
time transmit packet network transfer rate 
estimated costs remain adequate newer hardware technology decrease total software overhead accessing network 
simulation results simulator gave ability determine data rates possible configuration processors interconnection medium storage devices 
modeling parameters varied processor speed intervening computing nodes number disk devices representing storage agents size transfer unit 
clear obtainable data rate sufficient interconnection capacity available data rate linearly related number storage agents size transfer unit 
cost computing parity non negligible processor clear bottleneck write requests directed large numbers storage agents 
instructions second processor utilization storage agents increases high loads processor client bottleneck 
simulation model chosen disk parameters typical highperformance disk commonly file servers 
disk assumed read read write busy number disks fraction processor byte blocks 
spin revolutions minute yielding average rotational latency milliseconds 
specific knowledge file system structure available rotational latency accurately modeled uniform distribution 
average seek time assumed uniformly distributed mean milliseconds 
assumption simplifies seek time distribution actual disk drives acceleration deceleration phase modeled uniform distribution 
reason transfer unit large impact data rates achieved system seek time rotational latency enormous compared speed processors network transfer rate 
shows value careful data placement indicates resource preallocation may beneficial performance 
small transfer units require seeks order transfer data large transfer units significantly positive effect data rates achieved 
small numbers disks seek time dominated extent effect performance significant number disks 
message network data transfer processing costs important factor effect transfer unit 
example assumed protocol processing required instructions plus instruction byte packet 
size packet increases protocol cost decreases proportionally packet size 
cost instruction byte packet part unavoidable reflects necessary data copying 
see demands processor significant case pure reads 
read costs due cost protocol processing necessary cost copying data system user address space 
having hardware network interface merge striped data directly user address space significant busy read read write number disks fraction disk byte blocks 
amount copying saved simulation instruction byte 
case writes processor seen significant performance limiting factor 
due cost computing parity code exclusive 
conservatively estimated cost instructions byte compute parity operation 
case highly optimized implementation believe brought approximately instruction byte average 
see utilization disks decreases disks 
due saturation processor especially writes increased load interconnection network 
notice correspondence processor utilization processor utilization writes high corresponding utilization disks low 
fraction network capacity 
network capacity close saturation significant load large number disks 
high load effect data rate system utilization disks 
read write ratio considered 
processor disk utilization ratio reads writes significant effect data rate system 
increased load processor compute redundancy code writing data 
considering large requests writes penalized multiple access costs associated small writes 
preserve parity function small writes necessary read parity block block modified write block parity block 
illustrate effect block size data rate 
expects larger read read write busy number disks fraction network capacity byte blocks 
read read write megabytes second number disks data rate byte blocks varying read write ratio 
blocks blocks blocks blocks megabytes second number disks effect block size throughput 
block size higher data rate 
data rate continue increase cylinder boundary reached forcing disk seek logical request transfer rate capacity device reached 
illustrates rotational latency seek time significant sources delay system 
effect doubling processor speed modeled effect doubling processor speed evaluate effect processor bottleneck 
see highest number disks percent busy processor decreased pure read load pure write load 
simulation showed client achieve pure read data rates order megabytes second disks contrast megabytes second depicted 
pure writes system achieve data rates megabytes second disks versus megabytes second depicted 
disk simultaneously utilized capacity pure reads capacity pure writes 
corresponding utilization percentages respectively 
substantial increase data rate pure writes highlights effect cost computing error correcting parity codes software 
faster processor bottleneck shifted serial nature data transmission protocol modeled 
explains pure read data rates increase write data rates network interconnection medium disk storage subsystem read read write busy number disks mips fraction processor byte blocks 
spare capacity 
related research notion disk striping formally introduced salem garcia molina 
technique years subsystems super computers high performance mainframe systems 
disk striping versions unix operating system means improving swapping performance 
knowledge swift disk striping distributed environment striping files multiple servers 
examples commercial systems utilize disk striping include super computers cm airline reservation system ibm cfs intel 
hewlett packard developing system called uses array storage processors connected high speed network 
maximum data rate limited interconnection medium channel 
higher data rates achieved multiple channels 
aggregation data rates proposed swift architecture generalizes proposed raid disk array system ability support data rates single disk array controller 
fact swift concurrently drive collection raids high speed devices 
due distributed nature swift advantage raid having single point failure disk array controller power supply 
swift improves traditional disk striping systems important areas scaling reliability 
interconnecting communication networks swift scalable centralized systems 
higher performance required additional storage agents added swift system increasing performance proportionally 
selectively hardening system components swift achieve arbitrarily high reliability data metadata communication media 
cfs example mechanism metadata tolerant storage failures 
cfs repository descriptor multi repository object fails entire object unavailable 
third difference traditional disk striping systems swift advantages sharing decentralized control distributed environment 
independent storage mediators may control common set storage agents 
distributed nature swift allows better resource allocation sharing centralized system 
resources required satisfy request need allocated 
swift incorporates data management techniques long centralized computing systems distributed environment 
particular viewed generalization distributed systems channel architectures mainframe computers 
areas intend address enhancing current prototype simulator extending architecture 
enhancements prototype current prototype needs implement data redundancy 
prototype enhanced code computes check data read write operations modified accordingly 
enhancement place plan measure effect computing check data data rates 
plan incorporate mechanisms resource preallocation build transfer plans 
mechanisms place plan study different resource allocation policies goal understanding handle variable loads 
enhancements architecture goal research develop high speed distributed storage system provides general purpose file system integrated storage retrieval large data objects digital audio video guaranteed data rates 
applications system range visualization scientific computations real time recording editing play back color video 
support integrated access continuous media digital audio video difficult current computing systems 
lack necessary capacity provide data sufficient rate support necessary performance guarantees 
interest fields scientific visualization require addressed 
intend extend architecture techniques providing data rate guarantees magnetic disk devices 
problem real time processor scheduling extensively studied problem providing guaranteed communication capacity area active research problem scheduling real time disk transfers received considerably attention 
second area extensions scheduling services 
past analog storage transmission techniques able meet stringent demands multimedia audio video applications 
support integrated continuous multimedia resources central processor peripheral processors audio video communication network capacity allocated scheduled provide necessary data rate guarantees 
meta scheduling studied anderson 
presents studies conducted validate swift scalable distributed architecture achieves high data rates striping data storage agents driving concurrently 
prototype validates concept distributed disk striping local area network 
prototype swift architecture built unix ethernet network 
demonstrated prototype architecture achieve high data rates local area network aggregating data rates slower data servers 
servers single ethernet segment prototype achieved double data rates provided access local scsi disk achieved times nfs data rate asynchronous writes double nfs data rate synchronous writes twice nfs data rate reads 
performance local area network prototype limited speed ethernet local area network 
second ethernet path added client storage agents data rates measured demonstrated swift architecture immediate faster interconnection medium 
data rates writes doubled 
reads improvements pronounced client absorb increased network load 
simulations architecture show swift exploit powerful components components limit performance 
simulations show data rates swift scale proportionally size transfer unit number storage agents sufficient interconnection processor capacity available 
swift designed large objects mind handle small objects encountered normal file systems 
penalties incurred round trip time short network message cost computing parity code 
swift suited swapping device high performance stations data redundancy 
distributed nature swift leads believe able exploit current hardware trends increases processor speed network capacity decreases volatile memory cost secondary storage inexpensive correspondingly faster 
swift architecture flexibility alternative data storage technologies arrays digital audio tapes 
lastly system prototype installed easily existing operating system needing modify underlying networking hardware file specific software 
exploit emerging high speed networks large installed base current file servers 
acknowledgments grateful contributed research including aaron dean long prototype laura haas mary long thoughtful comments manuscript john wilkes stimulating discussions distributed file systems 
simulation results obtained aid simulation language developed supported products la jolla ca 
luther digital video pc environment 
hill 
salem garcia molina disk striping proceeding nd international conference data engineering pp 
ieee feb 
patterson gibson katz case redundant arrays inexpensive disks raid proceedings acm sigmod conference chicago pp 
acm june 
technology controller 
thinking machines incorporated connection machine model cm technical summary may 
pierce concurrent file system highly parallel mass storage subsystem proceedings th conference hypercubes monterey mar 
pratt french janet comparison architecture performance parallel file systems proceedings th conference hypercubes monterey mar 
stonebraker schloss distributed raid new multiple copy algorithm proceedings th international conference data engineering los angeles pp 
ieee computer society feb 
ng pitfalls designing disk arrays proceedings ieee compcon conference san francisco feb 
ibm concepts structure manual 
clark application system performance characteristics ibm systems journal vol 
pp 

johnson dimensional wave equation computations vector computers proceedings ieee vol 
jan 
davidson garcia molina skeen consistency partitioned networks computing surveys vol 
pp 
sept 
gray notes database operating systems operating systems advanced course bayer graham ller eds pp 
springer verlag 

cabrera wyllie quicksilver distributed file services architecture horizontal growth proceedings nd ieee conference computer workstations santa clara ca mar 
nelson welch ousterhout caching sprite network file system acm transactions computer systems vol 
pp 
feb 
garcia molina salem impact disk striping reliability ieee database engineering bulletin vol 
pp 
mar 
gibson hellerstein karp katz patterson failure correction techniques large disk arrays proceedings rd international conference architectural support programming languages operating systems pp 
apr 
comer internetworking tcp ip principles protocols architecture 
prentice hall 
baker hartman kupfer shirriff ousterhout measurements distributed file system proceedings th acm symposium operating systems principles pp 
association computing machinery sigops october 
rosenblum ousterhout design implementation log structured file system proceedings th acm symposium operating systems principles pp 
association computing machinery sigops october 

cabrera hunter karels user process communication performance networks computers ieee transactions software engineering vol 
pp 
jan 
wilkes project definition document tech 
rep hpl csp hewlett packard laboratories feb 
ng design issues disk arrays proceedings ieee compcon conference san francisco feb 
shum architecture mvs mvs xa transactions vol 
pp 

zhao heuristic approach scheduling hard real time tasks resource requirements distributed systems 
ph 
dissertation university massachussetts amherst 
zhao ramamritham stankovic preemptive scheduling time resource constraints ieee transactions computers vol 
pp 

anderson schaefer srp resource reservation protocol guaranteed performance communication internet tech 
rep ucb csd university california berkeley sept 
anderson meta scheduling distributed continuous media tech 
rep ucb csd university california berkeley oct 

