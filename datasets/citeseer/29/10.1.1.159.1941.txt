incremental interpreter high level programs sensing giuseppe de giacomo dipartimento di informatica sistemistica universita di roma la sapienza salaria rome italy dis uniroma hector levesque department computer science university toronto toronto canada hector cs toronto edu classical planning execution high level agent programs requires reasoner look way final goal state single action taken world 
deferral serious problem practice large programs 
furthermore problem compounded presence sensing actions provide necessary information executed world 
deal propose characterize formally situation calculus implement prolog new incremental way interpreting high level programs new high level language construct loss generality allow control exercised actions executed 
argue scheme practical way deal large agent programs containing nondeterminism sensing 
argued comes providing high level control autonomous agents robots notion high level program execution offers alternative classical planning may practical applications 
briefly looking sequence actions goal planned look se quence high level program formula stating may legally terminate state started state high level program mean primitive statements domain dependent actions agent robot tests involve fluents caused hold hold primitive actions contains nondeterministic choice points reasoned non random choices execution proceed 
high level agent program different deterministic script execution problem solving task planning 
interpreter needs knows prerequisites effects actions find sequence right properties 
involve considerable search nondeterministic search deterministic 
feasibility approach ai purposes clearly depends expressive power programming language question 
language called addition nondeterminism contains facilities sequence iteration conditionals concurrency prioritized interrupts 
extend expressive power language providing finer control nondeterminism making provisions sensing actions 
way practical large programs requires introducing different style line program execution 
rest section discuss line line execution informally show sensing actions nondeterminism problematic 
section formally characterize program execution language situation calculus 
describe incremental interpreter prolog correct respect specification 
final section contains discussion 
line line execution compatible planning interpreter executes line manner sense find sequence actions constituting entire legal execution program ing world 
consider example program 

primitive actions indicates nondeterministic choice large deterministic program tests fluent holds 
legal sequence actions start followed sequence state holds 
executing agent robot wait interpreter considers determines initial action eventually leads single nondeterministic choice occurring early large program result unacceptable delay 
assumed action taken need backtracking world option 
see problem compounded presence sensing actions 
small amount nondeterminism program remain practical suggested need able choose local criterion necessarily having go 
line interpreter settle leads state holds 
need able commit choice satisfies understanding responsibility programmer appropriate local criterion program simply fail option backtracking hold 
convenient handle type commitment changing execution style line line including special line search operator 
line execution nondeterministic choices treated random ones action selected executed immediately 
program executed line selected executed immediately process continues happens hold entire program fails 
new operator search program means consider line searching globally successful termination state 
operator control nondeterminism handled 
execute line search successfully leads execute immediately continue boldly 
scheme left programmer decide cautious 
loss expressive power execute program old way need put entire program operator 
sensing actions line style execution suited programs containing sensing actions 
described sensing actions actions taken agent robot obtain information state certain fluents change 
motivation sensing actions involves applications initial state world incompletely specified hidden exogenous actions agent sensors sort determine value certain fluents 
suppose example known state fluent binary sensing action uses sensor tell robot holds 
execute program endif interpreter get robot execute world get execute information returned decide continue 
consider program 
endif line interpreter commit advance determine hold action 
option available see lead values requires considering executed 
similarly attempt generate low level robot program suggested planning presence sensing having consider 
situation worse loops 
consider 
endwhile line interpreter way knowing advance iterations loop required false decide necessary reason effect performing arbitrary number times discovering loop invariants 
commitment local grounds determine actual value necessary reason deterministic loop 
appears line execution style practical large programs containing nondeterminism sensing actions 
characterizing program execution technical machinery define line program execution presence sensing essentially predicates trans final define single step semantics programs 
adaptation necessary deal line execution sensing results operator 
situation calculus starting point definition situation calculus :10.1.1.85.5082
go language note components special constant denote initial situation situation actions occurred distinguished binary function symbol denotes successor situation resulting performing action relations truth values vary situation situation called relational fluents denoted predicate symbols situation term argument special predicate poss state action executable situation special predicate sf state action return binary sensing result situation language formulate domain theories describe world changes result available actions 
possibility action theory form axioms describing initial situation :10.1.1.54.7045
note fluents known initial state 
action precondition axioms primitive action characterizing poss 
successor state axioms fluent stating conditions holds function holds situation take place socalled effect axioms provide solution frame problem :10.1.1.54.7045
unique names axioms primitive actions 
foundational domain independent axioms 
include sensed fluent axioms primitive action form sf characterizing sf 
sensing action sf ordinary action involve sensing sf true histories describe run includes actions sensing results notion history 
history mean sequence pairs primitive action sensing result 
intuitively history 
actions 
happen starting initial situation action returns sensing value assumption ordinary action sensing 
notice empty sequence history 
histories terms situation calculus 
convenient abbreviation situation term called situation history defined inductively 
useful sensed abbreviation formula situation calculus sensing results history defined sensed true inductively sensed sensed sf sensed sensed sf 
formula uses sf tell true sensing come specified starting trans final predicates line execution program consists sequence legal single step transitions 
special predicates final trans axiomatized final intended say program may legally terminate situation trans intended say program situation may legally execute step situation program remaining 
example transition axiom sequence trans final trans trans says single step program terminates single step single step ing left sequence 
account include axioms trans final details omit add new ones operator 
axioms characterize formula line execution sensing values define line execution 
absence sensing action legal step program situation trans remaining program sensing existence may depend values sensed far 
history actions sensing values sensed trans general history starting situation look action satisfying sensed trans suc similarly allowed terminate program sensed final history taken account 
know specification appropriate 
easy see sensing result history happens sensing information specification correctly reduces specification legal single step 
see corresponds intuitively line execution get take account sensing information returned current action deciding 
happened sensing action returned value situation looking legal action assume sf true held situation 
correct branch taken action 
noted change require axioms trans final operator 
final final configuration program get axiom final final trans configuration evolve provided evolve possible reach final configuration finite number transitions 
get axiom trans trans trans final fluent current value determined sensing normally successor state axiom 
attempt deal subtleties arise search performed programs executing concurrently 
axiom trans trans defined reflexive transitive closure trans 
ellipsis stands trans selects possible transitions exists sequence transitions leading final configuration operator propagated chosen transition restriction performed successive transitions 
words operator take transition path eventually terminate successfully 
desired line search committing transition 
incremental interpreter section simple incremental interpreter prolog 
line execution task characterized longer requires search final state remains fundamentally theorem proving task certain trans final formula follow logically axioms action theory assertions sensing results 
challenge writing practical interpreter find cases theorem proving done ordinary prolog evaluation 
interpreter earlier designed handle cases known initial situation represented set atomic formulas closed world assumption :10.1.1.54.7045
presence sensing simply apply closed world assumption blindly 
see avoid full theorem proving willing assume program executes appropriate sensing actions prior testing performs 
words interpreter depends dynamic closed world assumption assumed test required line interpreter point complete knowledge fluents question evaluate test having reason cases emphasize assumption important prolog implementation required formal specification 
main loop turns subtlety writing interpreter concerns evaluation tests program 
rest interpreter derives directly axioms final trans described 
convenient implementation predicates defined encodings histories actions situations 
get program history initially act final 
act execute act sv act sv 
trans 
act trans act 
execute act sv write act senses act write read sv nl sv 
incrementally interpret program line terminate successfully find transition involving action commit action execute world obtain sensing result continue interpretation remaining program updated history 
looking action skip transitions involving successful tests action required history change 
execute action world connect sensors effectors robot agent 
simplicity just write action read back sensing result 
assume user declared senses described actions sensing action declaration immediately return value 
implementing trans final clauses trans final needed program constructs 
example sequence trans seq final trans 
trans seq seq trans 
corresponds axiom earlier 
omit details constructs search final search final 
trans search search trans ok 
ok final 
ok trans ok 
ok trans act senses act ok act ok act ok act 
auxiliary predicate ok handle trans final part axiom searching forward final practice want history list get long form rolling forward :10.1.1.54.1465
configuration 
note transition involves action sensing result need program terminate successfully sensing values 
clearly explosive general sensing line search mix 
precisely deal issue flexible way taken line approach putting control hands programmer 
handling test conditions rest interpreter concerned evaluation test conditions involving fluents history actions sensing results 
assume programmer provides clauses poss action possible condition holds senses action de termine truth fluent initially fluent holds initial situation condition holds performing action causes fluent hold condition holds performing action causes fluent hold 
absence sensing clauses provide convenient specification successor state axiom fluent roughly words holds causes hold held cause hold 
sensing additional possibilities 
handle fluents completely unaffected primitive actions leaving clauses just sensing 
handle fluents partially affected 
example elevator controller may necessary sensing determine button pushed pushed assume corresponding light stays perform reset action causing go 
handle cases initial value fluent needs determined sensing value changes result actions note action provide information fluent cause fluent change values 
clauses transitions primitive actions tests specified follows trans prim act nil act poss act cond holds cond 
trans test cond nil holds cond 
practice breadth search may preferable 
want cache results search possibly avoid repeating transition 
specification allows sensor linked arbitrary formula sf implementation insists fluent 
nil empty program 
holds predicate evaluate arbitrary conditions 
making dynamic closed world assumption problem reduces fluents omit reduction 
fluents initially 
act senses act 
mind cut act act cond holds cond 
act act cond holds cond 
observe final action history sensing action action causes fluent hold hold regress test previous situation 
dynamic closed world assumption comes scheme properly programmer ensure sensing action result appear history necessary establish current value fluent 
correctness completes incremental interpreter 
interpreter correct sense goal final succeeds axioms sensed final goal succeeds axioms sensed trans despite close correspondence axioms trans final clauses trans final proving correctness trivial need show axioms background action theory derive user supplied prolog clauses listed dynamic closed world assumption 
leave research 
discussion framework number limitations noted deals sensors binary noise free explicit mention sensing influences knowledge agent interaction line search concurrency left unexplored implementation finite way dealing search program loops 
main advantages high level agent language containing nondeterminism allows limited keep implicit translation prolog terms programs histories terms situation calculus versions runtime planning included pro gram 
simple planner written directly acceptable 
endwhile ignoring acceptable program says repeatedly perform nondeterministically selected action condition holds 
line execution search legal sequence actions leading situation holds 
precisely planning problem acceptable forward filter style :10.1.1.45.7847
presence sensing clear limited forms planning handled line interpreter single nondeterministic choice cause problems saw earlier 
formalism far know chance practical large programs containing nondeterministic action selection sensing 
concern move line execution nondeterministic choice defaults random reasoning courses action programs just plans 
systems normally search line sequence actions eventually lead goal execution relies user supplied plan library achieve goals 
case get advantages worlds write agent programs span spectrum scripts look ahead search done little needs known properties primitive actions executed way full planners 
formal framework allows considerable generality formulation action theory allowing disjunctions existential quantifiers prolog implementation described considerably general systems allowing value fluents determined sensing intermingled context dependent effects actions 
serious concern involves guarantee line execution agent program 
line execution may fail instance proper sequence actions provably exists 
difficult tradeoff shows called incremental planning 
important goal needs achieved distant place time want choices worrying 
decide travel agent pick car airport amsterdam month 
answer practice clear decide locally cross bridges get exactly motivation approach 
pays large dividends assume default routine choices distant consequences chaos flapping butterfly wings notwithstanding 
far know remains open problem characterize formally agent know able quickly confirm action immediately step challenging distant goal 
steel 
integrating planning execution monitoring 
proc 
aaai saint paul minnesota 
bacchus kabanza :10.1.1.45.7847
planning temporally extended goals 
proc 
aaai portland oregon 
firby 
investigation reactive planning complex domains 
aaai seattle washington 
de giacomo lesp rance levesque 
reasoning concurrent execution prioritized interrupts exogenous actions situation calculus 
proc 
ijcai nagoya japan 
golden weld 
representing sensing actions middle ground revisited 
proc 
kr cambridge massachusetts 
hennessy 
semantics programming languages 
john wiley sons 
ingrand georgeff rao 
architecture real time reasoning system control 
ieee expert jonsson backstrom 
incremental planning 
proc 
rd european workshop planning 
levesque 
planning presence sensing 
proc 
aaai portland oregon 
levesque reiter lesp rance lin scherl :10.1.1.54.7045
golog logic programming language dynamic domains 
journal logic programming special issue actions pp 

lin reiter :10.1.1.54.1465
progress database 
artificial intelligence pp 

mccarthy hayes :10.1.1.85.5082
philosophical problems standpoint artificial intelligence 
machine intelligence vol 
edinburgh university press 
plotkin 
structural approach operational semantics 
technical report daimi fn computer science dept aarhus univ denmark 
reiter :10.1.1.54.7045
frame problem situation calculus simple solution completeness result goal regression 
artificial intelligence mathematical theory computation papers honor john mccarthy pages 
academic press 
scherl levesque 
frame problem knowledge producing actions 
proc 
aaai pp 
washington dc july 
aaai press mit press 
operator nondeterministic choice value 
