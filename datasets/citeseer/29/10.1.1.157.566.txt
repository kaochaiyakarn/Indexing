symbolic computation deductive inductive synthesis equational programs nachum dershowitz reddy department computer science university illinois urbana champaign 
received june equational approach synthesis functional logic program taken 
context synthesis task involves nding executable equations speci cation holds standard model 
synthesize programs induction necessary formulate procedures aswell program synthesis framework ordered rewriting 
propose heuristics generalizing sequence equational consequences 
heuristics handle cases deductive process inadequate coming program 

seminal burstall darlington showed functional programs expressed equations transformed cient ones equational reasoning 
speci cation new function synthesized original program equations forward unfolding backward folding controlled fashion obtain recursive program new function 
method come called fold unfold method forms important reasoning functional programs 
see bird wadler :10.1.1.100.9674
signi cant ort devoted building automated systems methodology see example darlington feather adapted reasoning logic programs hogger tamaki sato deville 
partial evaluation systems increasingly successful times bjorner acm fold unfold method 
building reliable general purpose program synthesis systems issues arise determine transformed programs correct 
soundness immediate technique termination completeness remain concerns 
author research supported part national science foundation ccr ccr visiting weizmann institute science 
second author research supported part national science foundation ccr nasa nag motorola 
academic press limited dershowitz reddy control application equations 
na application equations leads large search spaces 
controlled application burstall darlington restrictive 
method generalize forms programs logics equational ones conditional equations horn clauses rst order clauses 
role mathematical induction play synthesis process 
method relate methodologies deductive synthesis manna waldinger bibel smith 
attempting answer questions led framework term rewriting best known technique controlled equational reasoning 
term rewriting rst automated reasoning knuth bendix solving word problems equational theories 
fundamental operations underlie technique rewriting superposition 
rewriting uses terminating system oriented equations called rewrite rules rewrite term normal form 
superposition uses existing rewrite rules deduce new equation 
combination techniques achieves extremely high performance equational reasoning 
term rewriting techniques extended deal unoriented equations hsiang rusinowitch bachmair martin nipkow peterson bachmair dershowitz appear conditional equations bergstra klop kaplan kounalis rusinowitch ganzinger rst order reasoning hsiang dershowitz hsiang rusinowitch zhang kapur reddy nieuwenhuis orejas 
see huet oppen dershowitz dershowitz jouannaud klop accessible surveys rapidly developing area 
contributions threefold enrich basic equational reasoning techniques burstall darlington additional structure obtain rewrite reasoning 
second propose mathematical induction techniques de ne ensure correctness synthesized programs 
third demonstrate inductive generalization techniques supplement basic deductive techniques achieve automated program synthesis system 
extends previous reported dershowitz dershowitz reddy reddy dershowitz 
cited treated rewrite systems generalize techniques mix oriented unoriented equations notion ordered rewriting 
method complete class deductively veri able programs 
application ordered rewriting program synthesis inductive proofs considered bachmair gramlich bellegarde similar ideas 
furbach compare rewriting techniques plain equational methods burstall darlington 
early kapur srivas ideas closely related 
overview program synthesis 
followed section description basic properties equational programs 
sections respectively deal deductive inductive reasoning 
details formal methods synthesis section 
section describes heuristic techniques conjunction formal ones 
conclude brief discussion 
synthesis equational programs 
overview suppose wish synthesize program function speci cation axiomatization problem domain 
ways think program synthesis process try generate interesting logical consequences hope eventually obtaining set equations serves program try reduce speci cation simpler equations hope eventually obtaining equations simple serve program forward reasoning approach underlie burstall darlington backward reasoning approach basis manna waldinger 
interestingly context equational reasoning approaches produce similar results view set deductions forward backward reasoning points view 
example consider axiomatization append reverse functions lists append nil append nil append append append append append append reverse nil nil reverse append reverse nil suppose want program function revap reverses appends second argument 
speci ed equation rst argument revap append reverse synthesize program speci cation rst note subterm reverse simpli ed de ning equations reverse instantiated nil respectively 
fairly straightforward derive equations revap nil append reverse nil append nil revap append reverse append append reverse nil append reverse append nil append reverse append nil append reverse revap steps axioms replace equals equals step uses original speci cation smaller instance 
original speci cation termed folding burstall darlington :10.1.1.19.4684
equations derived form program revap revap nil revap revap similar write pattern directed functional programming language ml paulson 
dershowitz reddy calculations viewed forward reasoning process 
derived equations evidently logical consequences speci cation 
entirely clear equations form correct terminating complete program revap 
synthesis procedure forward reasoning approach mechanism ensure correctness derived program 
need heuristic guidance navigate space logical consequences interesting consequences 
view calculations backward reasoning process speci cation acts theorem proved program consists axioms necessary prove theorem synthesis process provides backward proof theorem 
note equational replacement steps equivalence preserving 
viewed forward backward steps 
initial instantiation step justi ed noting prove inductive theorem adequate prove instances 
nal folding step justi ed inductive hypothesis applied smaller instance proving hypothesis holds larger instance reasons prefer backward reasoning view forward reasoning view 
eliminates need navigating possible logical consequences search program giving better control search process 
integrates inductive reasoning deductive process derived programs guaranteed correct 
adopt backward reasoning view rest 
synthesis revap function just part general task nding cient program reverse 
program represented axioms takes time quadratic length list 
nd cient program eliminate append synthesis achieved deduction 
amount replacing equals equals eliminate append successfully synthesize program need insight eureka step burstall darlington termed 
recognize need auxiliary function compute quantity append reverse extra variable introduced hold partial result reversal 
having synthesized program revap function speci cation simplify program reverse follows reverse nil nil reverse revap nil eliminate append automatic synthesis procedure nd eureka step 
number heuristics postulate auxiliary functions similar postulating lemmas inductive proofs 
problem hand simple generalization heuristic boyer moore su ces 
rst attempt perform derivation starting speci cation reverse append reverse nil manner revap function 
notice subterm reverse simpli ed de ning equations reverse instantiated synthesis equational programs table 
equational axiomatization propositional calculus false true true false true true nil gives equations reverse nil append reverse nil nil append nil nil nil reverse append append reverse nil nil append reverse append nil nil append reverse nil point successful derivation able apply folding step 
unable attempt nd general speci cation expression enable folding step 
expression append reverse generalizes original speci cation expression current 
fact generalization append reverse works 
algorithm nd 
gives auxiliary function needed complete synthesis 
program synthesis tasks involve conditional reasoning addition equational reasoning 
term rewriting techniques extended conditional equations rst order clauses get technical areas 
equational axiomatization boolean algebras 
denotes equality truth values logical equivalence 
predicate symbols treated function symbols logical connectives 
table gives equational axiomatization propositional calculus notation compare hsiang dershowitz 
consider axiomatization addition subtraction multiplication equality natural numbers successor notation number represented dershowitz reddy true equality comparison operator naturals 
notice specify equations true case want view equations logic programs false cases simply fail 
see dershowitz discussion logic programs treated equational framework 
suppose goal produce program natural number division speci ed div predicate div meaning dividing gives quotient remainder stating remainder divisor quotient remainder related divisor dividend appropriate equation 
revap example instantiate simplify subterm axioms 
possibility simplify choice lead program 
equations obtained div div rst case instantiate domain fact applicable 
gives compact version div second case apply axiom substitution fx 


gives div div step folding step speci cation 
equations div div div viewed logic program division 

equational programs brie explain notation 
alphabet function symbols mean set function symbols arity associated symbol 
set variable free terms respecting arities denoted called ground synthesis equational programs terms set terms allowing variables set denoted called free terms simply terms 
equation pair terms written set equations terms terms tn tn replacing equals equals relation denote syntactic identity 
sequence exhibited called equational proof 
standard relational notations denote transitive re exive transitive closures respectively equational programs replacing equals equals 
done arbitrary fashion program progress evaluating terms 
specify notion progress founded order certain extra properties stated section 
order 
fact denoted writing omit write idea equation rewriting direction direction achieves reduction order founded rewrite sequence nite results term called normal form need unique 
equational programs executed rewriting ground terms normal forms 
form rewriting reduces term applied founded order execution terminating 
equation said proof terms tn sm tn sm relational inverse rewrite proof equational proof rewrites common normal form 
respectively denote transitive re exive transitive closures equation matter terms substituted variables equation may alternatively write equation idea equation direction rewrite instances corresponding instances equation called rewrite rule emphasize fact note equations rewrite rules general sense rewriting reducing direction direction instance instance 
conventional term rewriting theory knuth bendix huet oppen deals rewrite systems sets equations oriented particular direction 
idea unoriented equations rewriting provided reducing direction developed hsiang rusinowitch bachmair 
form rewriting called ordered rewriting 
results generalize previous results dershowitz dershowitz dershowitz reddy reddy dershowitz framework ordered rewriting 
mixing programs program synthesis termination issues requires explanation 
demanding rewrite relation included founded order consequences ensures programs terminate evaluation paths 
reasonable requirement common programs applications require programs terminate progress inde nitely 
programs lazy functional languages bird wadler exhibit prop synthesis equational programs ti precedence order si ht tmi greater hs smi left right lexicographic extension addition si practice speci es sequence arguments function symbol compared lexicographically obtains exibility ordering arguments function symbol :10.1.1.100.9674
extension ordering free terms computed comon approximate de nition free terms 
partial precedence extended complete reduction order 
illustrate path order examples 
consider precedence reverse append nil equations 
corresponding lexicographic path order left hand side greater corresponding right hand side 
example append nil subterm append nil 
equation append append append append zi greater hx append lexicographic order subterm property left hand side term greater append application de nition 
equation reverse append reverse nil reverse append precedence order reverse reverse reverse nil reverse reverse reverse 
handle speci cation revap wemust extend precedence order include revap 
heuristic choosing precedences symbol greater symbols evaluation tn 
evaluation revap introduce reverse append may introduce nil order reverse append revap nil append reverse revap extended term ordering speci cation left terms form revap 
de nes problem program synthesis procedure nd simpler equations evaluate revap 

programs rewrite relation said con uent rewrite proof con uent property holds ground terms say con uent ground con uent respect properties hold 
con uence implies terms unique normal forms ground con uence implies ground terms unique normal forms 
dershowitz reddy definition 
equational program nite set equations computable complete reduction order ground con uent 
ground con uence requirement means results programs deterministic 
ground con uence decidable property kapur 
hand con uence rewrite rules decidable forms su cient condition ground con uence 
practice method 
divide equational theories parts axioms inductive theorems 
axioms serve de ne function symbols evaluation terms 
inductive theorems form additional knowledge problem domain program synthesis 
set axioms ground con uent full theory inductive theorems ground con uent 
see section 
ground con uence axioms ensured checking con uence 
equations inductive theorems 
de ne functions append reverse 
standard results rewriting form con uent system greater side uni es non variable subterm greater side 
system ground con uent 
equational program said complete respect set ground input terms set ground output terms normal form belongs output terms typically formed constructor symbols case list axioms 
want model equivalences constructor terms case subset constructor terms may included example considering axioms unary number system includes terms reducible 
set input terms set terms occasionally want model partial functions partial axiomatizations functions 
example natural number axiom models true case comparison 
axiomatization total set input terms includes terms 
call partial 
general possible specify sets mechanically veri able fashion dershowitz give methods important cases 

superposition deriving cases important component informal synthesis procedure outlined section instantiation equations various cases variables 
questions answered formalization procedure nd instantiations useful synthesis chosen instantiations complete 
informal procedure gives indication answer rst question choose instantiations simpli cations possible 
example synthesis revap instantiations enable simpli cation axioms 
second question general method assume initial axiomatization complete sense sect 
assumption nd complete sets instantiations 
issues elaborated section 
consider speci cation normal form append reverse revap program synthesis task derive program equations ground instance speci cation covered ground instance equational synthesis equational programs proof 
sake argument assume necessary program equations part domain theory 
ground instance speci cation equational proof focus rst step proof 
domain equation contains instance say position equational proof form exists general proof schema form structure rst step mgu general uni er subterm equation new speci cation equation program part program 
equation called equations operation deriving called paramodulation robinson wos brand 
example revap speci cation subterm reverse equations derive append nil revap nil append append reverse revap equations su ce derive program revap 
instance obtained right left append reverse append append append reverse revap append fact domain theory 
cut search space rst note need variables peterson 
leaves 
ideas ordered rewriting 
domain theory ground con uent requiring equational proof equivalent requiring rewrite proof form allows place restrictions proof schema rst step rewrite step 
results loss generality founded order rewrite proof eventually reduce term smaller equal irreducible 
terminating grounding substitution normal form rewrite proof rewrite proof 
lifting considerations paramodulation proof schema impose restrictions nonvariable position reducing dershowitz reddy satisfying restrictions called critical pairs 
definition 
critical pair equations variables renamed apart equation mgu nonvariable position inference rule deriving critical pairs called ordered superposition 
notion critical pair knuth bendix special case equations participating inference rewrite rules case conditions automatically satis ed 
applying ideas revap speci cation nd critical pairs 
include essential critical pairs comes overlap append reverse nil 
reverse revap nil critical pair reverse revap nil necessary synthesizing program revap useful equation 
serve program reverse elaborate program 
superposition essential part program synthesis procedure di ers conventional usage completion theorem proving hsiang rusinowitch bachmair martin nipkow 
conventionally superposition forward inference mechanism deduce equational consequences theory 
superposition backward inference reduce goal smaller goals 
important di erence conventional framework superposition symmetrically premises 
equations chosen contrast case speci cation equation domain fact 
overlap domain fact subterm speci cation way 
general program synthesis procedure completion procedure 
noted critical pairs speci cation equation necessary deriving program 
question subset critical pairs forms su cient set subgoals 
looking back cases equations form su cient set subgoals obtained speci cation instantiations fx 
fx 
ug instantiations complete 
de nition captures notion completeness definition 
set substitutions said inductively complete ground substitution exist ground substitution variables 
domain hold substitutions input terms 
example domain theory substitutions fx 
fx 
ug form inductively complete set ground substitutions reduce instance 
synthesis equational programs notice adequate restrict attention irreducible de nition substitutions reduce irreducible ones 
simplify condition notion de ne rule reasoning cases follows cases rk fli rigi mgu li li ri igi inductively complete 
set critical pairs overlapping substitutions form inductively complete set infer equation 
soundness property inference follows lemma 
cases inference ground instances premises rewrite proofs ground instances rewrite proofs cases rule considers superposition single position equation 
possible choose position side equation critical pairs ideas bachmair 
definition 
set equations said set equation respect irreducible ground substitution exists equation max max substitution max maximum respect complete reduction order 
general rule cases uses cover set premises 
cases rk sk fri cover set members cover set simply instances equation incorporate step reduction order satisfy condition max max ri si 
de nes notion progress inference 
formalize notion de ne complexity measure proofs bachmair bachmair dershowitz appear 
consider ground proof domain theory set equations 
associate complexity measure extension reduction order 
ground terms complexity proof step complexity max 
complexity proof maximum complexity proof steps 
essentially complexity tn maximum term ti participates step term 
lemma 
cases inference form ground instance proof premises equational system complexity strictly dershowitz reddy proof 
induction max 
reducible substitution inductive hypothesis irreducible de nition cover set equation ri si ri si max ri si 
equation ground proof form ri ri si si complexity max ri si max 
important question test set critical pairs cover set 
methods possible 
set terms called test set may computed irreducible ground term instance member test set plaisted 
check set critical pairs cover set see combination terms test set covered overlap substitutions 
instance domain theory fnil ug test set 
veri es critical pairs form cover set 
method ground reducibility test 
equation said ground reducible ground instance identical reducible 
case set critical pairs cover set 
reducible larger suppose larger term 
reducible domain equation covered critical pair domain equation set critical pairs large cover set 
critical pair reverse revap nil need cover set revap speci cation 
extraneous critical pairs included cover set generate critical pairs lead nontermination 
example situation section 
useful optimization suggested fribourg 
term ground reducible ground instance reducible 
su ces consider subterm ground reducible 
superposition subterm obtain cover set 
optimization suggested kapur restrict attention irreducible substitutions de nition ground reducible 
ground reducible equates pair irreducible ground terms 
irreducible ground term test set devised detect situation 
form test set property equation reduces irreducible ground term reduces member test set 
advantage method test set computed reused cases inference 
method requires critical pairs computed cover set 
methods testing ground kounalis zhang jouannaud kounalis 

induction synthesizing program speci cation ensure derived program satis es speci cation 
speci cation inductive theorem derived program 
inductive reasoning integral part program synthesis 
section brie outline inductive reasoning procedure term rewriting induction 
method rst reddy inductive completion proof consistency methods studied musser synthesis equational programs huet dershowitz dershowitz kapur musser jouannaud kounalis fribourg bachmair 
equation said inductive consequence equational system written ind ground instance follows ground con uent respect equivalent requiring rewrite proof adding inductive theorem ect ground con uence 
way build ground con uent equational theories 
proof ind involves kinds steps simplify equations instantiate cases rule previous section inductive hypothesis proving cases 
notice cases rule reduce instances complexity 
simpli cation cases reduce ground instances equation original equation simpli cation cases ordinary equation 
method referred inductionless induction di ers conventional induction needs check inductive hypothesis smaller instance proved 
proof method takes care condition 
implicit application induction may variety program veri cation methods hoare logic especially treatment recursion hoare xed point induction manna scott 
ideas precise inference procedure pairs equation sets write pair set conjectures proved set induction hypotheses assumed proof pair may read judgment assuming induction hypotheses see theorem precise statement 
inference rules procedure follows axiom cases delete simplify subsume hypothesize feg feg ft tg fe feg ft feg set procedure starting goal form inference rule backwards step 
eventually goal form obtained initial theorems proved contains useful representation theorems lemmas generated process 
simplify allows conjecture simpli ed equations induction hypotheses conjectures 
denotes disjoint union subsume allows induction hypothesis applied concomitant reduction 
note contrast simplify form application done conjecture 
hypothesize allows postulate dershowitz reddy new lemmas eureka steps may help proof theorem 
lemmas introduced heuristics manual intervention 
consider proving associativity property rewrite program suppose arguments append compared left right lexicographic path order 
start goal append append append cases reduce append append append append append nil append append append append append rst equation simpli es identity append append deleted 
second simpli es append append append append inductive hypothesis simplify subsume reduces identity deleted 
inductive hypothesis inductive theorem added underlying equational theory domain fact 
example assume program revap revap nil revap revap prove satis es correctness condition revap nil reverse start conjecture goal 
immediately notice require general inductive hypothesis 
hypothesize conjecture proved lemma revap append reverse postpone section issue may 
assume function symbols ordered revap reverse append nil precedence 
cases reduce equation goal append reverse append reverse nil revap append reverse revap nil reverse rst equation simpli es identity deleted 
second equation simpli es revap append append reverse nil append reverse sides equal inductive hypothesis 
third equation reduces inductive hypothesis really inductive theorem stage append reverse nil reverse reduces identity 
proof complete obtain general synthesis equational programs version original equation useful rewrite rule added domain theory program 
prove soundness induction proof procedure need show ground instances equations proofs inference rules instances general rule provable proof step complex alternative proof equation 
theorem 
derivable judgment 
ground instances equations proofs complexity smaller ground instances proofs proof 
simplify argument weintroduce terminology 
equation strictly bounded proofs ground instance proof complexity strictly equal 
note means replacement property ground application form proof complexity equal 
proofs ground instance proof statement theorem strictly bounded proofs proofs 
proof induction derivation trivial axiom 
suppose inference 
plan show hypothesis theorem holds strictly bounded proofs holds strictly bounded proofs holds proofs holds proofs 
inferences delete hypothesize proof trivial 
consider cases inference cases feg feg cover set assume equations strictly bounded feg proofs 
lemma strictly bounded proofs 
equations strictly bounded proofs 
equations proofs proofs lemma 
consider simplify inference simplify ft sg ft sg assume equations strictly bounded ft sg proofs 
bounded ft sg proofs 
show bounded ft sg proofs 
bounded ft sg proofs 
cases equations strictly bounded ft sg proofs 
ft sg proofs proofs essentially argument 
dershowitz reddy bounded ft sg proofs case consider ground instance induction max 
instance proof second step note max max 
rst step assumption replaced proof ft sg complexity strictly max proof contains step max max 
max max subterm property conclude induction proof ft sg complexity equal max 
replacement property proof ft sg complexity equal max turn strictly max 
instances subsume ed similarly 
goal form obtained 
means equation rules cases subsume applicable 
means particular cover set wehave seen ground reducible set critical pairs set 
conclude ground reducible ground instance distinct normal forms assumed ground con uent follow inductive theorem 
equation eliminated disproved equation 
induction proof procedure robust 
fails conjectures inductive theorems 
inductive theorems procedure may go inde nitely 
postulating appropriate lemmas hypothesize help complete proof 

program synthesis section return problem program synthesis 
start speci cation alphabet equational axiomatization complete reduction order ground terms ground con uent 
synthesis problem speci ed terms new target alphabet equational speci cation extension reduction order ground terms 
reduction order extended away new symbol term containing greater terms constructed primitive operations smaller terms containing speci cation symbols may appear program 
example considering synthesis problem revap initial alphabet consists reverse append nil listed decreasing order precedence alphabet consists revap precedence order extended reverse append revap nil 
indicates nil may appear program revap reverse append synthesis task derive program pis consistent enrichment ecting ground equivalences follow ind seen section ind infer run inductive proof procedure unknown 
axioms xed goal nd constructed primitive operations ind equations tha eliminated inference rules called persisting equations require knowledge accepting set persisting equations trivially satisfy requirement synthesis equational programs ind course satisfy consistent enrichment condition 
return issue 
consider synthesizing revap 
speci cation revap append reverse right hand side greater left hand side append reverse higher precedence revap 
equation program revap 
synthesis procedure reduce simpler equations instances revap greater side 
consider superposition subterm reverse derive cover set cases revap nil append nil revap append append reverse nil stage speci cation inductive hypothesis cases simplify revap nil revap append reverse inductive hypothesis simplify reduce second right hand side revap 
corresponds folding step terminology burstall darlington 
rules applicable equations 
orientable equations revap nil revap rev form candidate program revap 
check consistent enrichment condition result theorem 
ground con uent sets equations alphabets respectively 
consistent enrichment ground instance equation contains target symbols ort speci cation language reducible proof 
show induction max ground instance equation proof assume loss generality reducible ground con uence equation rewrite proof steps proof necessarily complexity equal max 
max conclude induction step proof proof proof result follows candidate program calculate completion 
axioms need completion 
inductive theorems ect ground con uence 
suppose completion generates set 
equations contains target symbols acceptable program 
ensure equation contains target symbols substitutions speci cation language ground terms 
speci cation language need verify inductive theorem ift speci cation language term dershowitz reddy target symbols speci cation continue derive program 
synthesis iterative process 
nding candidate program adding axioms generates certain equational consequences 
consequences may involve problems program synthesis 
nd iteration needed 
instance adding candidate program revap axioms generates new critical pairs 
nal program revap 
somewhat intricate example synthesis process consider problem checking binary trees equality fringes 
problem considered burstall darlington 
start axioms tip constructors binary trees denotes fringe tree equality comparison lists tip nil tip nil nil true nil false nil false list axioms propositional axioms table 
fringe equality trees speci ed problem synthesize direct program order function symbols precedence tip nil order arguments left right 
axioms orientable left right order 
synthesis proceeds follows nd cover set considering superposition subterm larger right side speci cation 
gives cases shown possible simpli cation steps tip nil tip cases need synthesis 
time choose larger side superposition 
gives cases tip tip tip tip nil tip tip tip tip nil synthesis equational programs tip tip tip tip stage inductive hypotheses component procedure 
hypothesis simplifying simplifying 
remaining cases need 
program equations synthesized process get clearer program manually postulate lemmas nil false nil false proved standard fashion 
simplify equations results nal program tip tip tip tip false tip tip tip tip false tip tip tip tip obtain inductive theorems products nil tip tip nil false nil false example interesting need instantiate variables original speci cation controlled fashion obtain valid program 
note need postulate auxiliary function calculate fringe list trees done burstall darlington :10.1.1.19.4684

generalization auxiliary procedures section describe heuristics applied hypothesize program statements inductive lemmas 
suppose wish synthesize program doubles natural number successor notation recourse addition function 
running synthesis procedure domain equations speci cation dershowitz reddy generates nite set equations course little resultant program nite table lookup fd 
needed way guessing general equation 
processes generate hypotheses 
rst involves generating critical pairs equations second syntactic form generalization ala boyer moore 
intuition ed computational point view equations generated look new equations terms containing de ned function symbol hope discovering pattern 
approach suggested dershowitz 
rst step overlap smaller sides equations current partial program 
purpose ordering constructor terms larger terms containing de ned function applied non base cases equations direction brings patterns involving fore 
overlapping right hand sides get critical pair 
get 
second step generate speci generalizations pairs equations replacing con icting subterms new variable see plotkin 
process called anti uni cation terms computes greatest lower bound glb subsumption lattice 
critical pairs generate hypothesis 
applying gives simpli es equation knowing inductive theorem 
note assuming purposes veri cation opposite direction synthesis 
equation provable deductive means nished inductive proof method continues manner generating nite sequence hypotheses clearly need substitute missing lemma instances 
employ generalization methods synthesis see jantke lange 
additional helpful technique cancellation deduction example stickel 
particular constructors replacing hypotheses sn tn hypotheses si ti constructor free huet 
case free strip matching outer generated hypotheses synthesis equational programs generalizing leads hypothesis exactly looking 
added speci cation recursive program nally proved correct 
rst equation deductive consequence speci cation second inductive consequence 
having succeeded producing program doubling recursive program halving generated implicit de nition sequence equations produced equations suggest hypotheses generalizes equations disproved implies 
second hypothesis obtained looking di erent pairs equations rst third second fourth generalizes equations proved immediately induction yielding correct complete program programs require auxiliary procedures addition speci ed top level program 
heuristics come play rst subterm appearing dershowitz reddy program creating subprogram compute cf 
picard bellegarde 
second compute functions function arguments expanding unfolding de nition leads multiple applications function cf 
burstall darlington feather reddy bellegarde :10.1.1.19.4684
example suppose equations addition wish manufacture program squaring equations multiplication synthesis procedure precedence generate facts noting repeating left hand side subterm pattern suggests ancillary function synthesizing manner synthesized gives letting smaller operator symbol right de ned terms get equation left right equations simplify away 
equations constitute program squaring 
alternatively suppose know associative left side greater right 
consequences suggest auxiliary function leaves squaring program synthesis equational programs 
discussion rewriting powerful tool equational reasoning orderings terms play central role 
ordered rewriting orderings determine direction computation providing suitable concept term simpler 
ordered rewriting exible standard rewriting allows equation direction 
theorem proving orderings crucial incorporating powerful simpli cation rules complete inference systems 
orderings supply basis inductive proofs essential proving properties programs 
approach described comprises formal informal aspects 
equational reasoning mathematical induction guarantee correctness synthesized programs 
hand apply heuristics suggest equations incorporation developing programs forming lemmas needed inductive proofs 
considered rewriting equations 
conditional rewriting goal solving may provide better combination functional logic programming purely equational programs see instance dershowitz plaisted 
conditional synthesis necessitate powerful deductive inductive methods handling conditional equations kounalis rusinowitch ganzinger reddy 
elaborate generalization methods required 
interactive program transformation system called focus implemented university illinois techniques 
system incorporates oriented rewriting techniques special case ordered rewriting techniques considered extensions conditional rst order reasoning 
synthesize interesting examples including reasonably large programs reddy reddy reddy 
acm 
symp 
partial evaluation semantics program manipulation 
sigplan notices 

techniques recursion removal recursive functions 
acm trans 
program 
lang 
systems 
bachmair 
proof consistency 

logic comp 
science 
ieee 
bachmair dershowitz appear 
equational inference canonical proofs proof orderings 
acm bachmair dershowitz plaisted 
completion failure 
kaci nivat eds resolution equations algebraic structures volume rewriting techniques chapter pages 
academic press 
bellegarde 
program transformation rewriting 
book ed fourth intern 
conf 
rewriting techniques applications volume lect 
notes comp 
science pages 
springer verlag 
bergstra klop 
conditional rewrite rules con uency termination 
computer system sciences 
bibel 
system approach program synthesis 
biermann eds automatic program construction techniques chapter pages 
new york macmillan pub 
bird wadler 
functional programming 
london prentice hall international 
bjorner jones eds 
partial evaluation mixed computation 
north holland 
boyer moore 
lemma driven automatic theorem prover recursive function theory 

joint conf 
arti cial intelligence pages cambridge ma 
dershowitz reddy brand 
proving theorems modi cation method 
siam computing 
reddy 
conditional rewriting focus 
kaplan okada eds conditional typed rewriting systems second international ctrs workshop volume lect 
notes comp 
science pages 
springer verlag 
reddy 
reduction techniques rst order reasoning 
rusinowitch remy eds conditional term rewriting systems volume lect 
notes comp 
science pages 
springer verlag 

computing ground reducibility inductively complete positions 
dershowitz ed rewriting techniques applications volume lect 
notes comp 
science pages 
springer verlag 
burstall darlington 
transformation system developing recursive programs 
acm 
comon 
solving inequations term algebras preliminary version 
fifth ann 
symp 
logic comp 
science pages philadelphia pa ieee 
darlington 
structured description algorithm derivations 
de bakker van vliet eds algorithmic languages pages 
north holland 
dershowitz 
applications knuth bendix completion procedure 
proc 
informatique paris pages 
technical report atr information sciences research ce aerospace el segundo ca 
dershowitz 
computing rewrite systems 
information control 
dershowitz 
synthesis completion 
proc 
ninth intern 
joint conf 
arti cial intelligence pages 
dershowitz 
termination rewriting 
symbolic computation 
dershowitz 
completion applications 
resolution equations algebraic structures volume rewriting techniques pages 
san diego academic press 
dershowitz jouannaud 
rewrite systems 
van leeuwen ed handbook theoretical computer science formal methods semantics chapter pages 
amsterdam north holland 
dershowitz 
inductive synthesis equational programs 
eighth national conf 
arti cial intelligence pages boston ma 
aaai 
dershowitz plaisted 
equational programming 
hayes michie richards eds machine intelligence logic acquisition knowledge chapter pages 
oxford oxford press 
reprinted logical foundations machine intelligence horwood 
deville 
logic programming systematic program development 
wokingham addison wesley 
feather 
system assisting program transformation 
acm trans 
program 
lang 
systems 
fribourg 
strong restriction inductive completion procedure 
symbolic computation 
furbach 
knuth bendix completion versus fold unfold comparative study program synthesis 
horn eds proc 
tenth german workshop arti cial intelligence pages 
ganzinger 
completion procedure conditional equations 
symbolic computation 

method rewrite programs knuth bendix completion techniques 
report technische hochschule leipzig leipzig germany 
gramlich 
induction theorem proving re ned unfailing completion techniques technical report sr universitat kaiserslautern germany 
hoare 
procedures parameters axiomatic approach 
ed symp 
semantics algorithmic languages volume lect 
notes math pages 
springer verlag 
hogger 
derivation logic programs 
acm 
hsiang dershowitz 
rewrite methods clausal non clausal theorem proving 
th intern 
colloq 
automata languages programming volume lect 
notes comp 
science pages 
springer verlag 
hsiang rusinowitch 
word problems equational theories 
ottmann ed th intern 
colloq 
automata languages programming volume lect 
notes comp 
science pages 
springer verlag 
hsiang rusinowitch 
new method establishing completeness theorem proving 
acm 
huet 
proofs induction equational theories constructors 
comp 
system sciences 
huet oppen 
equations rewrite rules survey 
book ed formal language theory perspectives open problems pages 
new york academic press 
synthesis equational programs jantke 
algorithmic learning incomplete information principles problems 
kelemen eds machines languages complexity selected contributions th international meeting young computer scientists czechoslovakia november volume lect 
notes comp 
science pages 
springer verlag 
jouannaud kounalis 
automatic proofs induction equational theories constructors 
information computation 
kamin levy 
generalizations recursive path ordering 
unpublished note department computer science university illinois urbana il 
kaplan 
simplifying conditional term rewriting systems uni cation termination con uence 
symbolic computation 
kapur musser 
proof consistency 
arti cial intelligence 
kapur srivas 
rewrite rule approach data types 
intern 
joint conf 
theory practice softw 
development tapsoft volume lect 
notes comp 
science pages 
springer verlag 
kapur narendran otto 
ground con uence term rewriting systems 
technical report general electric center new york 
appear information computation 
kapur narendran zhang 
automating inductionless induction test sets 
symbolic computation 
klop 
term rewriting systems 
abramsky gabbay maibaum eds handbook logic computer science volume chapter 
oxford oxford university press 
knuth bendix 
simple word problems universal algebras 
leech ed computational problems algebra pages 
oxford pergamon press 
picard 
completion de systemes de synthese de programmes partir speci cations 

kounalis rusinowitch 
word problems horn theories 
kaplan jouannaud eds conditional term rewriting systems volume lect 
notes comp 
science pages 
springer verlag 
kounalis rusinowitch 
inductive reasoning conditional theories 
kaplan okada eds conditional typed rewriting systems second international ctrs workshop volume lect 
notes comp 
science 
springer verlag 
kounalis zhang 
general completeness test equational speci cations 
conference computer science 
available tech 
report university nancy nancy france 

inductive completion ground proof transformation 
kaci nivat eds resolution equations algebraic structures volume rewriting techniques pages 
san diego academic press 
lange 
set inference rules solving divergence knuth bendix completion 
jantke ed proceedings international workshop analogical inductive inference volume lect 
notes comp 
science pages 
springer verlag 
manna 
mathematical theory computation 
newyork mcgraw hill 
manna waldinger 
deductive approach program synthesis 
acm trans 
program 
lang 
systems 
martin nipkow 
ordered completion 
stickel ed conf 
automated deduction lect 
notes comp 
science pages 
musser 
proving inductive properties data types 
acm symp 
princ 
program 
lang pages 
acm 
nieuwenhuis orejas 
clausal rewriting 
kaplan okada eds conditional typed rewriting systems second international ctrs workshop volume lect 
notes comp 
science pages 
springer verlag 
paulson 
ml working programmer 
cambridge cambridge univ press 
peterson 
technique establishing completeness results theorem proving equality 
siam computing 
peterson 
complete sets reductions constraints 
stickel ed th intern 
conf 
automated deduction lect 
notes comp 
science pages 
plaisted 
semantic con uence tests completion methods 
information control 
plotkin 
lattice theoretic properties subsumption 
technical report mip university edinburgh edinburgh scotland 
reddy 
transformational derivation programs focus system 
sigsoft software engineering notes 
proceedings acm sigsoft sigplan softw 
eng 
symp 
practical software published sigplan notices feb 
dershowitz reddy reddy 
rewriting techniques program synthesis 
dershowitz ed rewriting techniques applications volume lect 
notes comp 
science pages 
springer verlag 
reddy 
formal methods transformational derivation programs 
software engineering notices 
proceedings acm sigsoft workshop formal methods software development 
reddy 
term rewriting induction 
stickel ed th intern 
conf 
automated deduction volume lect 
notes arti cial intelligence pages 
springer verlag 
reddy 
design principles interactive program derivation system 
lowry eds automating software design chapter 
aaai press 
robinson wos 
paramodulation theorem proving rst order theories equality 
meltzer michie eds machine intelligence pages 
edinburgh scotland edinburgh university press 
scott 
data types lattices 
siam computing 
smith 
top synthesis divide conquer algorithms 
arti cial intelligence 
stickel 
case study theorem proving bendix method discovering implies ring commutativity 
shostak ed proceedings seventh international conference deduction volume lect 
notes comp 
science pages 
springer verlag 
tamaki sato 
unfold fold transformation logic programs 
intern 
conf 
logic programming pages 
zhang kapur 
order theorem proving conditional rewrite rules 
lusk overbeek eds th intern 
conf 
automated deduction pages 
springer verlag 
