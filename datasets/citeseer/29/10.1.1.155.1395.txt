appeared algorithmica 
subexponential bound linear programming ji matou sek department applied mathematics charles university czechoslovakia mail matousek kam mff cz micha sharir school mathematical sciences tel aviv university tel aviv israel mail sharir math tau ac il courant institute mathematical sciences new york university new york ny usa emo welzl institut informatik freie universit berlin berlin germany mail emo inf fu berlin de simple randomized algorithm solves linear programs constraints variables expected min ln ln time unit cost model count number arithmetic operations numbers input precise algorithm computes lexicographically smallest nonnegative point satisfying linear inequalities variables 
expectation internal performed algorithm holds input 
conjunction clarkson linear programming algorithm gives expected bound ln algorithm framework facilitates application related problems computing smallest enclosing ball smallest volume enclosing ellipsoid points space computing distance vertex facet polytopes space 
subexponential running time established problems relies results due rtner 
keywords computational geometry combinatorial optimization linear programming smallest enclosing ball smallest enclosing ellipsoid randomized incremental algorithms 
author supported humboldt research fellowship 
second third authors supported german israeli foundation scientific research development 
second author supported office naval research national science foundation ccr ccr israeli binational science foundation fund basic research administered israeli academy sciences 
preliminary version appeared proc 
th annual acm symposium computational geometry pages 
carried author visiting institute computer science berlin free university linear programming basic problems combinatorial optimization received considerable attention decades 
algorithms proposed solution starting simplex algorithm relatives dan proceeding polynomial time solutions khachiyan karmarkar kar continuing techniques reviewed 
proposed algorithms proven extremely efficient practice analysis running time fully satisfactory far 
example simplex algorithm shown exponential worst case klm 
algorithms khachiyan karmarkar polynomial bit complexity number arithmetic operations perform depends size coefficients defining input bounded solely terms number constraints number variables 
assume different model computation real ram widely computational geometry 
input may contain arbitrary real numbers arithmetic operation real numbers charged unit cost 
distinguish complexity bounds model bounds bit complexity model call combinatorial 
best known combinatorial bounds exponential subexponential randomized bound kalai kal 
major open problems area find strongly polynomial algorithm combinatorial polynomial complexity linear programming 
describe simple randomized algorithm solves linear programs inequalities variables expected min ln ln arithmetic operations 
conjunction clarkson linear programming algorithm cla gives expected bound ln expectation running time respect internal performed algorithm holds input 
complexity matches algorithm due kalai kal 
constant exponent significant difference kalai version algorithm runs long linear guarantee bound 
chronologically speaking algorithm published weaker analysis running time kalai analysis subexponential bound came immediately realized algorithm subexponential running time 
algorithm framework facilitates application algorithm large class problems including computation smallest enclosing balls ellipsoids finite point sets space computing largest balls ellipsoids convex polytopes space computing distance polytopes space 
guarantee subexponential running time problems see details 
compare complexity algorithm techniques brief survey relevant literature 
megiddo meg deterministic algorithm running time form cdn linear fixed factor cd algorithm improvement cd dye cla 
number randomized algorithms problem see cla sei better dependence best expected running time clarkson cla log 
dependence exponential 
algorithm seidel sei worse expected complexity extremely simple randomized incremental algorithm 
wel algorithm enhanced move front heuristic practice drastically improved performance algorithm difficult analyze 
algorithm variant techniques sei wel 
interesting examples linear programs constraints adding move front heuristic new algorithm gives significantly worse performance mat 
algorithm behave practice analysis provides considerably improved worst case upper bound expected complexity 
derandomization techniques applied clarkson algorithm obtain deterministic cdn time lp algorithms cd order log chm 
framework considers set constraints function maps subset optimal solution satisfies simple conditions turns needed prove correctness algorithm analyze expected running time terms primitive operations violation tests basis computations 
turns primitive operations easily implemented polynomial time linear programming means clear instances problems framework 
example case computing smallest enclosing ball basis computation amounts computing smallest ball enclosing points space 
rtner able show done expected arithmetic operations 
clarkson algorithm cla shown framework algorithm seidel sei generalization applications wel needs explicit geometry problems 
different framework developed dyer dye yields deterministic algorithms linear larger constants 
organized follows 
section introduce notations review basic observations linear programming required presentation analysis algorithm section 
analysis recurrence relationship solution nontrivial interesting task section devoted solution 
section describe framework mention examples 
notation basics prepare notation required presentation 
model case linear programming objective function defined vertical vector 
problem maximize intersection halfspaces 
lexicographical ordering 
ordering extended rd special symbols convention rd set closed halfspaces space call constraints space 
vh denote lexicographically smallest point feasible region fh vh called value 
standard look backwards lexicographically smallest point case 
reader accustomed may prefer think backwards 
fh empty vh 
fh nonempty contains minimum vh 
intuitively view point lies halfspaces dominates points 
may seen point minus infinity simply symbol undefined 
basis set constraints vb vb vb proper subsets vh minimal subset vb vh 
constraint violated vh vh equivalent vh constraint extreme vh 
note extreme violated 
properties trivial ii standard linear programming theory iii 
cite explicitly constitute needed correctness time analysis algorithms described 
lemma sets constraints space constraint space 
vg vh 
ii vg vh violated violated 
iii vh basis exactly constraints extreme constraints 
algorithm set constraints xi set constraints algorithm compute basis basis exists 
vh 
algorithm works initial basis particular take basis available take set constraints xi symbolic value representing arbitrarily small number 
assume vh constraint sets consider 
known condition obtained cost extra dimension extra constraint 
note general position assumptions require bases unique 
set constraints consider trivial approach 
remove random constraint compute basis recursively 
violated equivalently violated basis done 
violated try removing hopefully different random constraint 
note probability violated extreme constraints basic idea find seidel lp algorithm sei order guarantee efficiency need additional ingredients 
procedure subex lp solving problem parameters set constraints basis general basis call candidate basis 
viewed auxiliary information get computation solution 
note influence output procedure influences efficiency 
problem computing basis solved function procedure subex lp subex lp return set constraints space returns basis 
pseudocode subex lp uses primitive operations test violated constraint basis violation test operation implemented time keep vb basis second subex lp assumes availability operation basis computes basis element basis constraint basis computation 
step corresponds pivot step appropriate representation performed arithmetic operations 
note vb vh constraint sets considered execution 
function procedure subex lp set constraints space basis return returns basis choose random subex lp violated vb return subex lp basis return simple inductive argument shows procedure returns required answer 
happens finite number steps recursive call decreases number constraints second call increases value candidate basis finitely different bases 
analysis expected behavior algorithm take closer look probability algorithm second recursive call candidate basis basis 
noted happens exactly extreme choose elements follows probability extreme extreme constraints bound improves fact bad choices choices bound lowered min want show numerator decreases rapidly go recursion entail subexponential time bound 
key notion analysis hidden dimension 
basis hidden dimension pair measures close solution basis hidden dimension minus number constraints contained basis value greater equal value lemma hidden dimension vc 
proof 
need show constraint satisfies vc iff appears bases vb vc 
vc basis vb vc vb vc contradiction 
conversely vc basis 
vb vc completes proof lemma 
hidden dimension depends value intuitive interpretation local optima defined constraints lying level vc contained flat defined bounding hyperplanes constraints hidden dimension 
hidden dimension zero implies basis enumerate constraints way hd vc hd hn ordering unique parameter emerging ordering unique definition equals hidden dimension 
note vc 
hd choices possibly entail second call hd 
hd hi vh 
suppose constraint hd chosen call candidate basis returns basis vb vh hd 
compute basis hd 
vh hd vb vc hidden dimension pair second call hidden dimension monotone hidden dimension exceed hidden dimension 
holds constraints 
hd vg hi vh hi denote tk bk maximum expected number violation tests basis computations respectively entailed call subex lp constraints hidden dimension discussion yields recurrence relationships tk tk tk min tk bk bk bk min bk 
simple proofs induction show bk tk 
turns larger gross overestimate section show bd ln ln tk bk constraint tested violation basis appearing computation tha factor test elements violation add bk account initial basis 
recall account arithmetic operations violation test arithmetic operations basis computation 
note computation vh add nonnegativity constraints initiate subex lp 
anticipating solution recurrences section conclude theorem set constraints space 
lexicographically smallest nonnegative point vh intersection halfspaces computed randomized algorithm expected number arithmetic operations 
nd bd ln ln clarkson cla shows linear program constraints space solved expected log td log arithmetic operations td stands complexity solving linear program constraints space 
replace td bound observe replacement middle term dominated terms omit log factor term changing asymptotics expression 
obtain corollary lexicographically smallest nonnegative point vh intersection halfspaces space computed randomized algorithm expected number arithmetic operations 
solving recurrence log section prove promised bounds bk 
put bk bk function satisfies recurrence bk equality bk 
solution recurrence min 
prove upper bound lemma holds 
exp ln ln large range values bound essentially tight leading term 
order avoid various technicalities lower bound proof restrict range try get tight bound concerning order magnitude lower order terms 
show lemma tending infinity exp ln emphasize lower bound bk 
lower bound bk conceivable bk smaller 
see mat related lower bounds 
upper bound 
proof lemma apply technique generating functions easy inductive proof bound mentioned previous section omitted 
define gn multiply recurrence sum obtain gn gn words recurrence follows min gn gn gn gn gn gn gn nj zj zi regarding complex variable want find value coefficient zk taylor expansion gn 
known equal gn dz zk integral closed curve contains origin contain pole gn 
choose circle 
easily checked denominators product defining gn vanish follows inequality implies yields bound tk fj fj tj integer parameter determined set estimate terms product 
distinguish cases 
estimate fj stirling formula fj 

calculate fj 
absolute values terms alternating sum parentheses form decreasing sequence 
summation term error sign omitted term 
fj fj 

estimate get qe exp values set yields bound exp extreme cases 
ln ln ln ln 
definition gives happens exponentially large compared easy bound ln comes close smaller set obtain bound 
playing estimates somewhat get better bounds case observe product goes gets better choice possible large 
establishes lemma 
lower bound 
lemma proof lower bound explicit form mq iq 
iq sum tuples 
mq mj mq second sum tuples 
iq iq ij mj 

contributes term equal sum 
formally interpret term corresponding unique tuple term empty product equal 
proof 
initial conditions term sum yielding value 
similarly get nonzero term gives 
consider difference defined 
terms appear precisely iq sum terms mq mj iq iq ij mj 
iq min mq mq mq iq 
iq mj ij mj min function defined satisfies initial conditions recurrence relation 
proof lemma define auxiliary parameters 
function tending slowly instance log log set ln 
assume large may neglect effect truncating integers similarly integer parameters sequel 
assumption logn guarantees 
consider inner sum tuple 
mq mj 
mq sum 
iq iq 
iq 
iq 
easily verifies induction say ln 
furthermore stirling formula get estimate 
estimate expression ln 
known easy prove number tuples 
mj denote number tuples additional condition mj claim 
see suffices encode tuple 
contributing tuple contributing 
encoding performed follows mj leave element replace mj elements equal element equal mj mj instance tuple transformed note mj replaced block elements sum mj 
number elements resulting vector mj may pad vector ones get exactly elements 
easy see encoding reversible 
just observed sum elements resulting vector exceed sum initial tuple proves 
value may choose show number tuples 
mq mj mq 
ke combining observing ln ln ln obtain proves lemma 
ln framework consider optimization problems specified pairs finite set function values linearly ordered set assume minimum value 
elements called constraints called value goal compute minimal subset bh value general value easy determine assuming availability basic operations specified 
turns algorithm section perform computational task long axioms satisfied axiom 
axiom 
monotonicity 
locality implies 
axioms hold call lp type problem 
obviously linear programming lp type problem set vg constraint set axioms coincide lemma ii 
notions needed section carry obvious way basis set constraints proper subsets basis minimal subset 
constraint violated 
constraint extreme 
efficiency algorithm parameter crucial maximum cardinality basis called combinatorial dimension denoted dim 
assume primitive operations available 
violation test violated constraint basis tests violated 
basis computation basis constraint basis computes basis 
note checking violates equivalent checking basis 
shows primitive operations closely related 
ingredients necessary apply algorithm lp type problem provided initial basis call subex lp 
show simpler inductive argument mentioned section expected number primitive operations performed algorithm dim combinatorial dimension 
order ensure subexponential time bound need extra condition axiom 
basis regularity basis dim constraint basis exactly dim elements 
axioms satisfied call regular lp type problem 
seen linear programming space basis regular lp type problem combinatorial dimension provided program feasible lemma iii provides stronger property basis cardinality 
treatment section careful properties linear programming formulated lemma 
glad properties obtain faster algorithm know 
course extra computational assumption order start algorithm 
initial basis initial basis exactly dim elements available 
case linear programming nonnegativity constraints play role initial basis 
may conclude theorem basis regular lp type problem combinatorial dimension initial basis dim algorithm subex lp computes basis expected number violation tests basis computations 
ln ln turns clarkson algorithm formulated analysed framework basic cases involving constraints solved algorithm expected number required violation tests log expected number required basis computations log log problems shown satisfy axioms see list problems linear programming basis regularity naturally satisfied 
artificially enforce axiom trick due bernd rtner lp type problem combinatorial dimension value set define pair min new value set 
lexicographical ordering 
straightforward proof lemma omitted 
lemma lp type problem pair defined lp type problem combinatorial dimension dim 
basis complemented arbitrary dim elements serve initial basis 
transform lp type problem basis regular careful new interpretation violation tests basis computations 
obtain algorithm expected subexponential number violation tests basis computations primitive operations quite expensive 
exhibit examples lp type problems successfully apply algorithm including efficient implementation primitive operations 
smallest enclosing ball 
problem computing disk smallest radius containing set points plane goes back sylvester 
linear time solution problem provided megiddo meg see short guide previous log solutions 
general problem computing smallest ball enclosing set points space solved linear time long dimension considered fixed see meg meg deterministic algorithm wel simple randomized algorithm algorithms exponential set points space define smallest radius closed ball containing known smallest radius exists ball realizing radius unique 
subset containing points see jun 
basic facts hand easy show lp type problem combinatorial dimension clearly adding points constraints set decrease radius smallest enclosing ball monotonicity holds violated lies outside unique smallest ball containing easily implies locality 
problem basis regular apply transformation validate analysis 
violation test easy point ball test basis computation amounts non trivial task basically compute smallest ball enclosing points space 
rtner able show problem solved expected arithmetic operations 
obtain corollary smallest enclosing ball points space computed expected number arithmetic operations 
min ln ln combining clarkson algorithm complexity reduces bound linear programming 
distance polytopes 
compute distance closed polytopes want dist min dist dist denoting euclidean distance points polytopes intersect distance 
intersect distance equals maximum distance parallel hyperplanes separating polytopes pair hyperplanes unique orthogonal segment connecting points dist dist 
easy exercise prove sets vertices respectively dist dist conv conv conv denotes convex hull point set distance positive bound holds 
formulate problem lp type problem follows vi vertex set pi assume subset unique representation ui vi 
convention define dist conv conv empty define 
pair constitutes lp type problem inequalities go way round implies plays role 
order see locality observe violated lies unique pair parallel hyperplanes separate distance shows perform violation test 
mentioned combinatorial dimension problem polytopes intersect 
basis computation compute distance polytopes space altogether vertices 
invoke ensure performed expected arithmetic operations 
corollary distance convex polytopes space altogether vertices computed expected number arithmetic operations 
min ln ln best previously published result expected randomized algorithm considered fixed cla 
result corollary established polytopes intersections halfspaces combining result clarkson yields bound 
examples 
quite number examples fit framework solved time linear number constraints dimension considered fixed 
mentioned subexponential bound delicate issue depends efficiently solve small problems 
just provide list examples giving details 
smallest enclosing ellipsoid points space compute ellipsoid smallest volume containing points combinatorial dimension see dll wel 
problem treated number papers pos wel dye chm 
constraints points value set points volume smallest enclosing ellipsoid affine hull 
ellipsoid called john ellipsoid known unique dll locality easily follows monotonicity obviously satisfied 
primitive operations treated applying general methods solving systems polynomial inequalities claim subexponential time bounds course bound linear number points holds 
largest ellipsoid polytope polytope space intersection halfspaces compute ellipsoid largest volume contained polytope combinatorial dimension 
smallest intersecting ball closed convex objects space compute ball smallest radius intersects combinatorial dimension 
order see combinatorial dimension observation 
consider minkowski sum convex object closed ball radius centered origin 
ball radius intersecting objects intersection minkowski sums nonempty 
helly theorem intersection nonempty intersection nonempty 
smallest radius intersection nonempty interiors minkowski sums common point set common point 
corresponding set objects contains basis cardinality claimed combinatorial dimension follows easily 
angle optimal placement point polygon star shaped polygon vertices plane polygon star shaped point inside polygon sees edges vertices locus points called kernel 
want compute point kernel connecting vertices straight edges minimal angle adjacent edges maximized combinatorial dimension 
previous examples obvious constraints problem 
assume polygon allows placement angles occurring 
restricts locus intersection convex regions vertex polygon incident edges inner respect angle wedge angle apex forced lie 
ii edge incident vertices circular arc contains points see vertices angle lie inner side point forced lie region bounded circular arc suggests take vertices incident edges edges incident vertices constraints purpose algorithm ignoring stem polygon 
number constraints combinatorial dimension reasoning helly theorem 
integer linear programming halfspaces vector space compute point integer coordinates intersection halfspaces maximizes combinatorial dimension see oi bel sca 
integer linear programming fits framework bad example sense basis computation bound unit cost model 
problems mention far may occur reader natural examples largest ball polytope polytope space intersection halfspaces compute ball largest radius contained polytope 
smallest volume annulus points space find concentric balls symmetric difference contains points minimal volume 
problems lp type problems directly formulated linear programs respectively variables transformation smallest volume annulus problem 
subexponential time bounds hold 
chazelle matou sek chm gave deterministic algorithm solving problems time provided additional axiom holds additional computational assumption 
extra requirements satisfied natural lp type problems 
matou sek mat investigates problem finding best solution satisfying constraints lp type problems defined 
nina amenta ame considers extension framework suppose family lp type problems parameterized real parameter underlying ordered value set maximum element representing infeasibility 
goal find smallest feasible 
ame provides conditions problem transformed single lp type problem gives bounds resulting combinatorial dimension 
related ame 
discussion randomized subexponential algorithm solves linear programs related problems 
clearly challenging open problem improve bounds provided kal find polynomial combinatorial algorithm linear programming 
section shown bound give tight recursion derived analysis 
stronger mat gives examples lp type problems combinatorial dimension constraints algorithm requires primitive operations 
order show better bound algorithm linear programming properties axioms 
rote rot megiddo meg suggest dual permutation variants algorithm 
interesting examples linear programs variant algorithm suggested mat behave worse certain linear programs original algorithm fact substantiated experimental results mat seen contrast situation seidel linear programming algorithm wel 
acknowledgments 
authors gil kalai providing draft copy nina amenta boris aronov bernard chazelle ken clarkson bernd rtner nimrod megiddo nter rote comments useful discussions 
ame ame amenta helly type theorems generalized linear programming discrete comput 
geom 

amenta bounded boxes hausdorff distance new proof interesting theorem proc 
th annual acm symposium computational geometry 
bel bell theorem concerning integer lattice stud 
appl 
math 

chm cla cla cla dll dan dye dye chazelle matou sek linear time deterministic algorithms optimization problems fixed dimensions technical report dept mathematics freie universit berlin proc 
th siam acm symposium discrete algorithms 
clarkson linear programming time information processing letters 
clarkson new applications random sampling computational geometry discrete comput 
geom 

clarkson las vegas algorithms linear integer programming dimension small manuscript 
preliminary version proc 
th ieee symposium foundations computer science appear assoc 
comput 
mach 
lenz ber das ellipsoid und sein unter den einem eik arch 
math 

dantzig linear programming extensions princeton university press princeton 

approximation durch algorithmen zur der mit ger diplomarbeit ulm 
dyer multidimensional search technique application euclidean center problem siam comput 

dyer class convex programs applications computational geometry proc 
th annual acm symposium computational geometry 
dyer frieze randomized algorithm fixed dimensional linear programming mathematical programming 
rtner personal communication 
rtner subexponential algorithm optimization problems proc 
rd ieee symposium foundations computer science appear siam comput 
ellipsoid 
algebra geom 

jun jung ber die die eine reine angew 
math 

kal kar kalai subexponential randomized simplex algorithm proc 
th acm symposium theory computing 
karmarkar new polynomial time algorithm linear programming combinatorica 
khachiyan polynomial algorithm linear programming comput 
math 
math 
phys 

klm klee simplex algorithm inequalities iii pp 
ed 
academic press new york 
mat mat matou sek lower bounds subexponential optimization algorithm random structures algorithms 
matou sek geometric optimization violated constraints proc 
th annual acm symposium computational geometry 
meg megiddo linear time algorithms linear time programming related problems siam comput 

meg megiddo linear programming linear time dimension fixed assoc 
comput 
mach 

meg megiddo note subexponential simplex algorithms manuscript 
oi 
convexity lattices geom 

pos post minimum spanning ellipsoids proc 
th annual acm symposium theory computing 
rot rote personal communication 
sca sei scarf observation production sets proc 
national academy sciences united states america 
seidel low dimensional linear programming convex hulls easy discrete comput 
geom 

sharir welzl combinatorial bound linear programming related problems proc 
th symposium theoretical aspects computer science lecture notes computer science 
sylvester question geometry situation quart 
math 

wel welzl smallest enclosing disks balls ellipsoids new results new trends computer science maurer ed lecture notes computer science 

