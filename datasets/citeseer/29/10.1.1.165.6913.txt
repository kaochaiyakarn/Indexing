memory management counted regions alex aiken report 
ucb csd march computer science division eecs university california berkeley california memory management counted regions alex aiken eecs department university california berkeley berkeley ca cs berkeley edu march introduce new region memory management technique allows flexible memory usage patterns provably safe 
technique explicit manual malloc free allows programmers exert similar degree control program behavior 
method quite simple spite expressiveness safety 
apply technique small functional language formally describe core concepts prove safety argue usability efficiency analytically 
particular show system efficiently encode rigid traditional regions lifetime bounded stack frame 
show technique works nicely multi threaded imperative programs 
software practice widely heap memory management approaches explicit management malloc free implicit management garbage collection 
approaches known disadvantages 
problem malloc free verifying memory safety difficult 
garbage collection overcomes problem cost making difficult control objects deallocated garbage collection unattractive situations require tight space timing guarantees 
addition experienced programmers produce efficient code ability manual memory management 
memory management system allows programmers exert manual control provably safe practical interest 
number proposals concept regions allow safe explicitly controlled memory management :10.1.1.10.8871:10.1.1.1.3704
systems exception portions hicks developed independently time guarantee safety compile time 
presents new static memory safe region system 
totally static sense systems listed deletion region fail result run time error programmer required add run time checks see regions alive strategic points program 
system static guarantees compile time run time checks necessary program memory safe 
dangling pointer dereferences run time errors behaved program recover example catching thrown exception ml java 
compared totally static approach system slightly weaker memory safety guarantee 
believe benefits static approach justify trade 
research supported part subcontract 
py stanford dept air force prime contract 

principle behaved run time error part program semantics argue system just static 
xsr vars sr finite xsr regions types reg expressions pack open newregion freeregion useregion small region language source syntax drawback totally static approach trades simplicity ease expressiveness simple static system limits kind programs proven safe 
contrast system allows high degree expressiveness complicating static system 
particular region lifetime tied stack frame regions may created deleted program point 
argue section run time error indicate bug programmer thinking limitation system 
technique best understood conceptually dividing static part dynamic part 
static part simple type system resembling tofte 
dynamic part simple basic implementation shall stick section 
run time behavior transparent programmer 
programmer easily tell source code dynamic check occurs important control 
describe core concepts technique call counting 
shall slightly modify concepts section enable flexibility 
run time system maintains data values region validity bit indicating region deleted 
counter non negative integer starts incremented decremented explicitly program 
combination static dynamic checks enforce accessing memory location counter region containing memory location greater 
deleting region region counter 
incrementing counter region region validity bit 
hard see conditions sufficient memory safety dangling accessed 
check condition statically check dynamically 
deletions explicit dynamic checks transparent 
incrementing counter explicit dynamic checks transparent 
trick static check simple 
design language programs adhere certain syntactic pattern incrementing decrementing counters 
consider pseudo code 
suppose denotes region 
increment uc 

decrement uc operations increment uc decrement uc respectively increment decrement counter proposal force programs adhere block pattern manipulating counter 
increment uc decrement uc introduce single language construct increment decrement useregion values pack reg abort expressions pack open newregion freeregion useregion reg contexts pack open newregion freeregion useregion reg small region language type erased intermediate expressions evaluation contexts reg open pack newregion reg pack reg freeregion reg reg freeregion reg abort useregion reg reg useregion reg abort reg small region language selected reduction rules evaluates counter increments executes decrements counter finishes 
programmer point view useregion enables access region lexical scope 
resulting system simple easy stack regions systems enjoys expressiveness comparable complex approaches :10.1.1.10.8871
contributions overview main technical contributions formal presentation basic counting system proof safety section 
improvement base system increases usability section 
feature introduced immediately natural understand modification base system 
analytical evaluation system including efficient encoding stack regions style memory management multi threaded programming sections 
addition provide small illustrative examples 
section discusses experience toy implementation 
section discusses related section concludes 
regions small language apply counting call value monomorphic lambda calculus tuples shown 
small region language designed illustrate new technique self contained manner omits features parametric polymorphism types effect sets recursive types non heap allocated unboxed tuples mutable values 
features incorporated little additional effort leveraging previous research region memory management see grossman extensive study incorporating features stack regions style framework :10.1.1.10.8871
appendix shows system extended features 
infinite set region variables 
region variable refers region 
example function closure allocated region referred type form argument type return type 
note function may polymorphic region variables assumed distinct 
notation mean tuple 
addition function type carries set region variables effect set similarly tuple values types allocated type type reg type region handle region referred region handle program value allocated region just program values 
region handles necessary validity bit counter region stored region handle pointer triple containing pointer head region validity bit counter 
type existential type handy typing data structures containing region handles 
theory encode higher order polymorphic functions existential packages natural 
assume expressions types equivalent consistent renaming bound variables bound region variables 
program expression free variable sr set free variables expression defined usual way 
variable sr denotes region handle special region rsr 
doesn matter region pick special just need pick regions infinite set regions program starts 
region rsr special region exists prior execution program regions created program 
see need starting region recall region handle allocated 
core concepts described section implies order region deleted region handle allocated region 
chain reasoning pre existing region program created region handle allocated 
show way remove constraint section 
dynamic semantics dynamic semantics series small step reductions states states 
state pair program region map maps region domain pair validity bit counter starting state program rsr 
note starting region accessible start 
fact starting region deleted remain accessible program needs manipulate counter 
single step reductions written usually omit parentheses 
type region variable information irrelevant reductions erase expressions replacing occurrence type region variable 
result erasure expression language 
shows selected reduction rules 
reductions may give rise expressions intermediate language evaluation contexts defined 
discuss reduction rules 
reduce function allocation reduced region handle reg reduces expression function closure expression reg region handle region allocated region region handle represented form 
program starts reducing replace occurrence sr reg rsr rsr 
fact allocated program alternatively implement region handle double word value consisting pointer head region pointer pair containing validity bit counter save dynamic checks allocation sites 
value form meaning value denoted allocated region function closure value allocated condition says region function allocated alive 
symbol wild card 
addition condition required region handle stores pointer head region needs looked 
rule function application 
shows function application usual capture avoiding substitution assuming region function allocated alive 
region variable application essentially op type erasure semantics 
rule opening existential packages straightforward 
newregion reduced region handle reg reduces newregion reg creating new region reducing region handle allocated binary operation union dom dom undefined 
reasons explained new region handle existentially packed 
conditions required allocating region handle allocating program value region region handle allocated alive region region handle resides 
rules handle freeregion reduce region handle 
assuming counter region deleted sets validity bit region indicating region deleted 
counter region greater reduces program special value abort signals failure dynamic check 
alternatively language designed dynamic check failure reduces special error value raises run time exception 
exactly dynamic check fails language designer 
note require assumption region handle allocated looked see applies 
form useregion increments decrements counter 
reduced region handle region validity bit counter incremented expression reduced reg shown 
region validity bit aborts program 
require assumption counter validity bit accessed 
rule reduces reg reduced value counter decremented returned assuming region counter allocated alive 
note run time system physically check conditions form appearing hypotheses 
violation conditions correspond dangling pointer dereferences show section typed program violates 
cautious reader may wonder safety claims assuming validity bits exist hypothesis 
validity bit deallocated prior reduction 
see situation occurs observe dynamic semantics deallocates value just sets validity bits 
order deallocate argue previous paragraph conditions form required program known get stuck turn lets physically delete regions argued section 
static checking stated section role static checking check accessing memory location counter region memory location allocated greater 
counter incremented reducing useregion decremented reduces value 
notation may look strange readers 
commonly expression allocates program value expression reduces pointer pointing memory location program value stored 
program value language region handles immutable save characters showing extra level indirection 
readers uncomfortable notation may state imagine store partitioned regions replace pointer memory location containing partition store 
note region handles mutable validity bit counter may change 
reason region maps handle extra level indirection 
reg reg pack open reg newregion reg reg freeregion reg reg useregion small region language type checking rules plan disallow accesses region context useregion region handle type effect system type judgement reads type environment effect set judgement type environment mapping variables types 
shows type checking rules 
briefly discuss type checking rules 
note including appear expression substituted value reduced call value semantics 
rule local variable definition self explanatory 
rule types function allocation 
notation denotes set free region variables 
define ran 
function allocated region specified region handle referred region variable pointer region stored region referred required 
assumption types body function 
note appears function type set latent effect function takes place function applied 
rule types function application 
latent effect carried type function required reducing function application leads reducing body function 
furthermore required function closure value accessed 
rule types region variable application 
rule types tuple allocation 
judgement short hand 
en required 
rule types tuple projection 
condition required tuple accessed 
rules existential packaging opening straightforward 
rule types region creation 
type expression existentially quantified region handle type matching reduction rule 
existential types statically distinguish different regions different regions assigned different region variables appear free piece code 
reason similar condition required 
rule types region deletion 
condition required validity bit stored region referred set counter needs checked 
rule types manipulation counters 
counter region referred incremented entry allow access type checked effect 
counter may decremented pose problem case decrementing happens reducing useregion reachable reducing 
counter incremented entry 
follows counter reducing large immediately reducing single threaded case equal 
shall formalize argument works multi threaded programs 
program say typed iff xsr sr reg xsr xsr xsr 
rules syntax directed type checking clearly decidable 
readers familiar stack style systems able easily recognize rules 
example expression shows function allocated starting region function takes region handle region referred function body argument creates new region say region handle gets allocated creates new region say region handle gets allocated returns new region handles tuple allocated reg open newregion reg useregion pack newregion reg reg sr expression typed type reg xsr reg reg function 
call function region handle delete region returned requires accessing region handle allocated region allocated function 
code fragment assume bound region handle type reg xsr bound function 
proof safety useregion open xsr reg reg open reg useregion freeregion program stuck reach state value reduced 
show program typed get stuck implies eliminate conditions form hypotheses reduction rules serve programs get stuck 
reduction turns validity bit easy see region physically deleted validity bit goes may free region implies typed program memory safe 
proof style wright 
proof need type intermediate expressions 
extend type environment map regions region variables variables types 
omit detailed presentation type checking rules intermediate expressions 
note abort type environment rule type check need definition proof 
reg definition state typed environment iff dom dom xsr 
injective 
subexpression form contain subexpression form 
dom rsr number occurrences subexpressions form reg equal 

write mean typed 
definition prove theorem 
theorem subject reduction exists 
proof conditions proven independent choice 
condition follows inspection reduction rules 
straightforward inspection 
condition straightforward inspection 
remains find satisfy 
straightforward case analysis redex substitution lemma replacement lemma 
prove theorem 
theorem progress value reduction 
proof main part proof showing conditions form hypotheses reduction rule satisfied 
need lemma 
lemma xsr sub derivation xsr occurrence reg lemma proven inspection type checking rules 
lemma show definition 
satisfied 
easy see typed program xsr rsr xsr rsr rsr starting region 
theorems follows typed program get stuck memory safe 
detailed proof extended version system appears appendix 
self allocated region handles problem system described far region handle counter validity bit needs allocated separate region region sr 
problem leads inconvenience 
example just create region temporarily delete get back memory state system leaves region handle garbage 
order collect garbage needs delete region contains region handle leads back problem 
may small problem practice region handle takes small amount space may serious problem severely resource limited applications 
annoying reg reg newregion reg reg freeregion reg reg useregion modifications technical point view manual region systems region handle essentially just pointer head region requires separate heap space region information stored region 
section solve problem cost small run time overhead 
idea modify basic system slightly counter allocated region validity bit dispensed 
region handle longer requires separate space deleting region leave garbage region handle 
small changes language reflect fact region handles self allocated 
replace newregion newregion reg reg change intermediate representation region handle reg reg straightforward changes type checking rules reflect changes 
shows new rules 
new rules slightly simpler 
longer need starting region get rid sr xsr 
program typed iff 
introduce new intermediate value dr type reg xdr xdr special region variable 
note constant dr available source programs 
basic idea modification replace handle deleted region dr region run time system maintains data structures doubly linked list called singly linked list called 
run time system stores pointers occurrences reg 
addition region stores pointer occurrence reg allocated concretely allocation reg direct occurrence reg runtime system stores address occurrence 
example evaluating reg reg reg reg allocates element containing heap location second element outermost tuple second reg 
note region handles allocated needs done 
general tuple 
vn reg vi form reg needs considered assuming treat pack similar treatment done allocating function closures address free variable bound region handle reg gets stored closure allocated region region handles allocated non heap locations stack variables handled similarly 
region handle implemented double word value 
implementation choice warrants discussion section section 
region handle reg pair pointers pointing head region pointing element corresponding 
program tries delete region freeregion reg run time system goes element overwriting region handle dr goes element finds region handle dr follows pointer element deletes element doubly linked list 
region deleted 
similarly non heap location containing region handle deallocated run time system follows pointer corresponding element deletes element 
counter stored region 
longer need validity bit runtime system just needs check dr useregion run time system pays price modification allocating value containing region handle deleting region containing 
shall see section suitable restriction static system guarantees run time cost needs paid 
example run time system extra allocating value contains immediate region handle 
deleting region costs time proportional number region handles allocated region region handle independent number type values small factor reasonable program 
note tracing counting garbage collector operation requires reachability computation 
mutable values suppose extended language mutable values 
order maintain invariants just discussed location containing region handle modified refer region handle run time system follows pointer element deletes element list allocates element containing pointer location 
polymorphism order allow smooth integration system polymorphic language prefer implementation region handle opposed double word implementation described 
accomplished storing pointer head region element implementing region handle pointer corresponding element 
change incurs extra level pointer lookup allocation sites 
strong reason allow instantiating type variable region handle type 
problem allocation sites run time system needs check value type type variable compile time region handle corresponding linked lists need extended 
example allocating value type reg type variable run time system needs test element tuple region handle 
similar run time overhead incurred updating mutable value type variable type 
contrast forbid abstraction region handle type region handles known compile time 
note programs allowed instantiate boxed type contains region handle type heap allocated tuple containing region handle reg reg 
design lets keep double word region handle implementation 
unboxed multi word values appear important efficient manual memory management full scale programming language having region handle type just non generalizable type cause damage uniformity language :10.1.1.10.8871
worth noting case wants abstraction region handle types despite shortcomings possible alleviate run time overhead static analysis 
example flow analysis conservatively estimate value may evaluate region handle 
leave choice open language designer 
analysis discussion section evaluate counting technique analytically discuss pragmatic issues 
show efficient encoding stack regions style memory management system show counting powerful known region technique 
encoding stack regions stack regions refers region memory management technique region lifetime bounded lifetime stack frame 
technique basis region proposals manual automatic 
concerned manual interpretation 
basic manual stack regions obtained removing newregion freeregion useregion small region language adding letregion reg reducing expression creates new region referred substitutes region handle new region reduces value deletes region returns type checking rule reg letregion reg show letregion efficiently encoded newregion freeregion useregion 
abbreviation fvars 
consider open newregion reg useregion freeregion easy see encoding behavior letregion 
entering new region created bound reduces value region deleted 
easy see encoding preserves typedness 
resulting program efficient 
constant time overhead occurrence letregion 
evaluating body new region counter allocated counter incremented checking region deleted 
body evaluates counter decremented region deleted checking counter 
easy see stack regions program translated counting version aborts 
dynamic check failures full potential counting realized program regions stack wise order 
example stack regions insufficient express example section function forced delete regions creates returns 
general case programs enjoy abort free property 
argue rare written program encounter dynamic check failure 
recall kinds dynamic checks dr check validity bit check useregion counter check freeregion 
consider situation check fails useregion reg encountered region deleted 
suppose programmer adheres discipline useregion reg means definitely going dynamic check failure indicates real programming bug spurious dynamic check failure deleted executing code supposed hand second dynamic check fails freeregion reg encountered context reg single thread case 
type failure harder characterize 
worth noting detecting failures compile time possible degree known static analysis techniques 
example variation algorithm foster produce compile time warnings potentially dangerous freeregion occurrences 
type failure easier recover worst programmer ignore leak memory 
annotation cost system programmer needs annotate code useregion constructs addition writing type effect annotations 
somewhat surprisingly useregion type effect annotations mutually compensating 
intuitively useregion annotations programmer writes fewer type effect annotations required 
illustrate point consider large block code uses regions say 
assume delete regions 
idea wrap corresponding useregion amortize cost dynamic checks large 
useregion useregion useregion 

region handles respectively 
consider function contains subexpression say sake brevity 
type function just assuming uses regions 
general occurrence useregion eliminates corresponding region variable effect sets parent expressions turn relieves programmer having annotate latent effect sets 
see glimpse property action examples section function trivial latent effect set annotation 
property compounding benefit context calling function requires useregion effect annotations regions accessed callee 
contrast conventional region approaches function types required carry identifications non local regions accessed function abstraction sets region identifiers 
hand run time efficiency desirable leave body short running function free useregion small function regions effort required annotate latent effect set correspondingly small 
system explicitly typed 
outside scope easy see inferring type effect annotations possible suitable restrictions 
amount inference spirit local type inference important incorporating counting full scale programming language 
regions threads problem common manual memory management systems difficulty supporting multi threading retaining safety controllability 
consider stack regions approach 
handle thread shared memory run time system aware threads may potentially access region region may deleted potentially accessing threads terminate 
thread allocated region allowed continue stack pops regardless behavior threads memory behavior difficult control lifetime region longer tied lifetime stack longest living thread having access region 
hand thread allocated region forced stall safe delete run time behavior allocating thread predictable 
thread concurrency common modern programs 
features counting approach thread concurrency supported free 
extend small region language form fork extend dynamic semantics concurrently executing threads 
state form ei thread 
reductions states states reduction rule applied thread reduction rule fork fork unit constant unit place holder value type unit 
type checking rule fork just fork unit changes needed 
argument proof safety single thread case works 
key observation proof safety number syntactic occurrences 
prove safety multi thread case simply add number threads compare sum counter region map 
contain newly forked thread satisfies invariants definition induction argument goes 
appendix discusses reasoning detail 
single thread case deleting region trying region deleted results dynamic check failure 
difference situations may involve concurrently running threads example thread attempts delete region thread 
avoid dynamic check failures programs synchronize threads region uses deletions correctly scheduled 
synchronization done explicitly programmer implicitly concurrency abstractions programming language issue 
proposal provides simple sound basis incorporating safe memory management synchronization mechanism 
experience regions informally discuss experience toy implementation 
creating entirely new language scratch extend existing language counted regions 
choose purpose mainly prior experience manual unsafe region programming language 
ideal goal replace malloc free newregion freeregion 
realistically implementation provides counted regions safe alternative keeping rest available unsafe 
leave features casting language 
implementation covers monomorphic fragment system 
monomorphic sense section permit quantification region variables 
support non heap allocated unboxed records form structs turns useful writing short interesting examples 
reason section provide ample examples easy read syntax 
examples designed illustrate expressiveness system safe explicit memory management approaches difficulty expressing 
syntax basic syntax identical small region language 
built function region newregion void creates new region returns region handle built function void freeregion region deletes region passed 
useregion written useregion 
number differences lambda calculus put mildly dictate somewhat different design 
major changes notation indicate value stored part pointer type 
example int pointer integer region referred allow null pointer type 
syntax resembling templates write data structure types parametrized region variables 
struct def region variables binding occurrences may appear free def type region variables instantiated 
unique structs instantiated value said closed roughly corresponds existential type bound region variables example newly created region handle type region closed 
example type consisting region handle reg region pointer data pointing integer allocated written struct region reg int data instantiated type closed time intuitively corresponds automatic pack 
angle bracket notations denote bound region variables function declarations 
omitted examples section assume function polymorphic region variables appear type 
built polymorphic function region allocates values type region passed returns pointer allocated memory block 
allocated memory blocks initialized zero 
set denotes latent effect function 
latent effect annotations omitted functions latent effect 
conventions compound statement scope 
example open closed type instantiating region variables write open new region variables available current scope 
variable forced const 
example linked list element wise linked lists implemented system full imperative destructive goodness expected region list element definition elt shows list element consists region handle pointer content data 
content data just integer example probably economical regions just demonstration 
shows functions insertion deletion list printing respectively 
note deleting list element deallocates space element keeping rest list intact 
functions written imperative fashion common programs need rebuild list element inserted deleted 
example economically realistic integer list element suppose large data structure potentially consisting connecting pointers allocated region element allocated element creation 
need region variable referring region element allocated 
add new binding region variable definition elt binding equate region instance elt allocated region data structure going allocated 
updated definition list element appears 
note struct type data type definition shown instantiated allow values data structure allocated region 
struct elt struct wrapper region reg struct elt wrap struct data type data struct elt struct wrapper region reg struct elt wrap int data void insert struct elt cur int data open region newregion struct elt useregion struct elt data data wrap cur wrap cur wrap reg void delete struct elt cur open struct wrapper cw cur wrap useregion cw reg cur wrap cw wrap freeregion cw reg void print list struct wrapper list open struct wrapper cw list cw null return useregion cw reg printf cw data list cw wrap element wise linked list example game life example simulating game life iterations henglein illustrate varying expressiveness different region systems 
show counting implementation closely matches original code 
function creates returns new generation 
resulting function life satisfies criteria suggested tail recursive region endomorphism problem region allocate generations leads memory leak 
existing region programs looked existing programs regions safely part memory management counting capable expressing region usage patterns strictly speaking statement insert valid syntax initializations 
overcome extending syntax adding extra scope initializing new variable type elt gets immediately assigned cur wrap 
henglein allocates integer argument heap 
just stack allocate brevity 
struct gen region reg struct game struct gen struct gen struct gen life int struct gen return struct gen open struct gen freeregion reg return life game life simulation programs 
common pattern fixed number regions exists time regions stored global variables accessed calling global functions 
example lcc compiler uses regions placed global array size called arena functions statements permanent region 
region deletion function deallocate int called delete current arena function statement compiled 
arena course permanent assigned newly created region allocation arena 
easy express pattern system 
store region handle data globally accessible closed struct open data requested 
reset region deleting region creating new closing struct assigning closed value global variable 
programs written regions safety pressured tight space timing requirements contain exciting region usage patterns 
gives practical evidence technique usability 
related introduced stack regions concept tofte extended higher order functions polymorphic regions 
systems formulated automatic memory management manual variants idea proposed :10.1.1.10.8871
comparisons counted regions versus stack regions earlier parts 
note issues formally discussed main body parametric polymorphism types effect sets recursive types non heap allocated values mutable values extensively studied aforementioned papers 
straightforward incorporate features formally system way minor exception issue discussed section 
appendix shows small region language extended ml style mutable refs parametric polymorphism types effect sets 
hicks developed similar technique called dynamic regions independently time 
technical report briefly outline technique memory management ideas independent interest 
dynamic regions roughly interpreted small region language assuming region handles existentially packed 
opening package system corresponds open immediately followed useregion 
incorporated dynamic regions cyclone report positive results :10.1.1.10.8871
main contributions report formal presentation technique proof soundness analysis discussion including exposition multi threading support technical differences regarding region handles 
mentioned hicks formulation ties dynamic operations region handles existential types arguably natural formulation treats existential types purely static construct standard type theory 
addition somewhat cleaner theory formulation practical advantages 
example system allows different existential abstractions region handle turn example enables sharing region different data structures having syntactically equate region variables 
second difference extension shown section allows region handle allocated region 
walker combine regions linear types create static system allows interesting region usage patterns 
system region handle linear region deleted non linear allowed aliased region needs accessed 
wadler construct turns linear region handle non linear designated scope back linear exiting scope 
walker system uses linear non linear phases statically prevent region deleted program non linear scopes 
underlying idea somewhat similar useregion counting method may viewed way remove limitations imposed linear types inserting dynamic checks 
shows integrate counting interpretation linear types regions 
crary region system uses notion linearity statically track aliasing region handles 
system expressive require non trivial program annotations example deallocating individual elements recursive data structures ala example section 
intention expose region system source level certify memory safety intermediate level code 
henglein take different approach region memory management employing floyd hoare style proof system 
primary goal create automatic system conventional non region language 
system meant exposed programmers quite manual systems discussed 
particular language construct explicitly delete region 
system maintains counts region handles region automatically deleted count zero 
counting scheme similar spirit chirimar 
left open system extended handle function closures polymorphism 
contrast gay uses counting main device memory safety counting content regions addition region handles 
system allows explicit deletion regions statically guarantee success similar freeregion 
system demands little static side relying largely dynamic counting safety 
recover efficiency compile time optimization reduce number counting operations provide optional type qualifier annotations help optimizing compiler 
counting approach related counting way 
approaches count users memory location memory location may deallocated number users zero 
approaches group memory locations regions amortize number runtime counter operations 
difference approaches meaning user counting approach user pointer pointing region approach user piece code region accessing memory locations region 
group memory locations counting approach prefers connecting pointers group approach encourages grouping memory locations accessed piece code 
observation led coin term counting describe technique 
counting approach advantages counting approach 
counting require dead region deleted 
advantage deciding locations grouped region counting capitalize directly program memory access pattern dependent points relationship 
region variables 
new static safe region memory management technique 
method scales naturally variety modern language features including multi threading offers flexible manual control relatively simple 
hope provided new insight designing highlevel languages resource conscious applications 
aiken hndrich levien 
better static memory management improving region analysis higher order languages 
proceedings acm sigplan conference programming language design implementation pages la jolla california june 
boyapati jr rinard 
ownership types safe region memory management real time java 
proceedings acm sigplan conference programming language design implementation san diego california june 
chirimar gunter riecke 
counting computational interpretation linear logic 
journal functional programming 
crary walker morrisett 
typed memory management calculus capabilities 
proceedings th annual acm sigplan sigact symposium principles programming languages pages san antonio texas jan 
foster aiken 
checking programmer specified non aliasing 
technical report ucb csd university california berkeley oct 
gay aiken 
language support regions 
proceedings acm sigplan conference programming language design implementation pages snowbird utah june 
gifford jouvelot lucassen sheldon 
fx manual 
technical report mit lcs tr mit laboratory computer science sept 
grossman morrisett jim hicks wang cheney :10.1.1.10.8871
region memory management cyclone 
technical report department computer science cornell university 
grossman morrisett jim hicks wang cheney :10.1.1.10.8871
region memory management cyclone 
proceedings acm sigplan conference programming language design implementation berlin germany june 
henglein niss 
direct approach control flow sensitive region memory management 
proceedings rd international conference principles practice declarative programming pages montr canada 
acm 
hicks morrisett grossman jim 
safe flexible memory management cyclone 
technical report cs tr department computer science university maryland july 
lucassen gifford 
polymorphic effect systems 
proceedings th annual acm sigplan sigact symposium principles programming languages pages san diego california jan 
pierce turner 
local type inference 
proceedings th annual acm sigplan sigact symposium principles programming languages pages san diego california jan 
xsr vars sr regions locations static vars instantiations effect sets types reg unit ref expressions pack open newregion freeregion useregion fork ref extended small region language source syntax values pack reg abort unit loc expressions pack open newregion freeregion useregion reg fork ref contexts pack open newregion freeregion useregion reg ref ref loc extended small region language type erased intermediate expressions evaluation contexts murtagh 
lifetime analysis dynamically allocated objects 
proceedings th annual acm sigplan sigact symposium principles programming languages pages san diego california jan 
tofte 
talpin 
implementation typed call value calculus stack regions 
proceedings st annual acm sigplan sigact symposium principles programming languages pages portland oregon jan 
wadler 
linear types change world 
broy jones editors ifip tc working conference programming concepts methods sea israel pages 
north holland 
walker morrisett 
alias types recursive data structures 
international workshop types compilation montreal canada sept 
walker watkins 
regions linear types 
proceedings sixth acm sigplan international conference functional programming pages florence italy sept 
wright felleisen 
syntactic approach type soundness 
information computation 
imperative concurrent polymorphic small region language shows small region language extended quantification type effect variables ml style mutable refs 
recursive functions easily expressed refs 
formally add multi thread extension discussed section 
bound static appearing function type assumed distinct 
shows corresponding type erased intermediate expressions reg open pack newregion reg pack reg freeregion reg reg freeregion reg abort useregion reg reg useregion reg abort reg reg vi ref reg loc loc loc fork unit extended small region language reduction rules evaluation contexts 
purpose exposition stick notation section extension described section 
dynamic semantics series small step reductions states states state triple store mapping location domain value 
brevity define multi thread evaluation context shows corresponding reductions rules 
shows type checking rules source language 
set fvars denotes set free static variables region variables type variables effect variables 
define fvars ran fvars 
bound static variables appear function type assumed distinct 
assume substitutions sort consistent type variable substituted type region variable substituted region variable effect set variable substituted effect set 
relation defined follows addition usual axioms set theoretic interpretation 
assume commutative associative 
reg fvars reg pack fvars fvars fvars open reg newregion reg reg freeregion reg reg useregion reg ref ref ref ref xsr fork unit extended small region language type checking rules source program typed iff xsr sr reg xsr xsr xsr 
shows additional rules typing intermediate expressions 
type environment extended map locations types 
proof safety reformulate proof extended system 
fill details omitted proof section 
expressions mentioned rest section assumed intermediate language specified 
definition state typed environment iff dom dom dom ei xsr ei 
restricted dom injective 
subexpression form contain subexpression form 
dom rsr number occurrences subexpressions form reg equal 

reg fvars pack fvars fvars fvars open reg abort unit unit unit fvars fv tv reg reg rv loc ref mv extended small region language additional type rules intermediate expressions dom 
write mean typed 
lemma substitution proof induction type checking derivation 
lemma substitution 
proof induction type checking derivation 
lemma replacement suppose 
subderivation 

proof trivial 
lemma 
proof induction type checking derivation 
theorem subject reduction exists 
proof conditions proved independent choice 
condition follows inspection reduction rules 
straightforward inspection 
condition straightforward inspection 
remains find satisfy 
case analysis reduction rules 

reg active thread 
inspection type checking rules subderivation reg reg reg fvars inspection rv case fv lemma follows holds 
trivial 

xsr active thread 
inspection type checking rules subderivation inspection fv case lemma follows lemma lemma follows holds 
trivial 
xsr 
active thread 
inspection type checking rules subderivation inspection fv case fvars 
lemma follows bound static variables assumed distinct 
fv lemma follows holds 
trivial 

xsr open pack active thread 
inspection type checking rules subderivation pack fvars fvars fvars open pack inspection case lemma follows lemma follows holds 
trivial 
xsr fvars 

easy see dom dom dom 
holds 
thread xsr lemma 
newregion reg active thread 
inspection type checking rules subderivation reg reg newregion reg reg inspection rv case rv reg reg pack reg reg lemma follows holds 
trivial 

pack reg xsr freeregion reg active thread 
inspection type checking rules subderivation reg reg freeregion reg reg reg reg lemma follows holds 
trivial 
reg xsr 
holds 
trivial 
abort xsr 
useregion reg active thread 
inspection type checking rules subderivation reg reg useregion reg inspection rv case reg lemma follows reg xsr holds 
trivial 
similar case 

reg active thread 
inspection type checking rules subderivation reg value inspection type checking rules lemma follows holds 
trivial 
xsr similar case 
similar case 
similar case 
ref reg active thread 
inspection type checking rules subderivation reg reg ref reg ref 
clearly dom dom dom 
thread xsr lemma 
inspection rv case mv loc ref lemma follows loc xsr holds 
holds 
trivial 

loc active thread 
inspection type checking rules subderivation loc ref loc inspection mv case 
left state lemma follows xsr holds 
trivial 

loc active thread 
inspection type checking rules subderivation lemma follows loc ref loc xsr holds 
inspection mv case 
holds 
trivial 

subderivation thread fork xsr fork unit unit unit lemma follows unit xsr xsr 
holds 
trivial 
lemma xsr sub derivation xsr occurrence reg proof inspection definition evaluation contexts corresponding type checking rules 
theorem progress value reduction 
proof main part proof showing conditions form hypotheses reduction rule satisfied 
hypotheses appears multiple reduction rules essentially argument 
shall show case contains inspection type checking rules case reg subderivation reg reg reg fvars rv lemma definition occurrence reg occurrence reg 
definition implies 
applied reduce state 
cases proved analogously 
theorem typed program source language 
corresponding type erased program intermediate language 
xsr rsr xsr rsr rsr starting region 
proof trivial 
corollary type soundness source program typed get stuck memory safe 
proof theorem theorem theorem 
