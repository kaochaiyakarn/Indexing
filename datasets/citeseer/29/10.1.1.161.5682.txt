dynamic feature tracing finding features unfamiliar code andrew david eisenberg rice university thesis submitted partial fulfillment requirements degree master science faculty graduate studies department computer science accept thesis conforming required standard university british columbia august andrew david eisenberg dissertation shows existing functional tests software features developer unfamiliar software system identify source code relevant features understand source code relevant 
prior techniques locate features source code roughly broken techniques static analysis dynamic analysis 
features behaviors system dynamic nature 
dissertation focuses dynamic techniques static techniques 
dynamic techniques require significant knowledge system technique useful 
furthermore suffer respects binary judgments source code artifacts relate feature determining extent relate meaning feature precisely characterized technique return inaccurate results provide idea piece code relevant feature 
technique creating dynamic feature traces improves previous advantage existing test suite reducing amount system knowledge necessary technique ranking source code artifacts strongly related feature retaining part execution trace test suite developers understand piece code part feature 
show technique provides benefit techniques applying existing software systems comparing results existing technique 
ii contents contents list tables list figures dedication ii iii vi vii viii feature understanding 
hope 
previous attempts 
enter dynamic feature traces 
structure remainder dissertation 
background feature location techniques 
static feature discovery 
dynamic feature discovery 
test suite design test driven development 

dft created 
partitioning test suite 
gathering execution trace 
ranks calls 
generating calls 
iii generating ranks 
dft tool produce 
viewing dynamic feature traces 
jquery 
extensions jquery 
summary 
evaluation evaluation ranking heuristics 
data collection 
analysis 
comparison software reconnaissance 
case studies 
task cookie enhancement 
task table creation 
task column metadata 
re weighting ranking heuristics 
show 
contributions 
directions 
concluding remarks 
bibliography iv list tables breakdown feature location techniques 
note previous techniques described binary judgments code elements relevant judges extent code elements relevant 
features analyzed 
rfe means request enhancement 
results quantitative evaluation table shows clustering interesting methods top rankings 
comparison dft results software reconnaissance approach 
optimal weightings heuristics feature second third fourth columns provide optimal weightings heuristics implemented set interesting methods provided features 
final column provides ratio actual number methods expected number methods 
list figures dft created structuring footprint test set terms footprint calls ranking methods 
process creating dynamic feature trace 
results jquery query asks readers writers field 
jquery package browser creators sub query showing creators canvas class 
context menu list additional queries shown sub trees original query 
part features query showing animate feature 
dynamic stack forward dyna stack back sub queries show dynamic call graph starting selected node 
static call graph emanating 
dynamic call graph emanating 
understanding shaded methods called helped understand javascript properties general 
vi people helped guided supported way finish 
am grateful 
kris de supervisor listening ideas matter silly may 
gregor kiczales second reader incredible advice formulate claims tighten argument 
gail murphy promptly answering questions 
jonathan needs providing initial spark topic 
jan rob walker kevin need input earlier drafts thesis 
addition remaining lab mates help 
chris brian de taken time research help latex unix related questions 
doug reid holmes 
need sticking master program mik kersten assuring aspectj fault misunderstanding language 
family new york really understanding realizing important leave city country come canada continue studies 
lastly cat couldn locate feature landed paw kind things weren going 
andrew david eisenberg university british columbia august vii wife done 
viii chapter dissertation shows existing functional tests software features developer unfamiliar software system identify source code relevant features understand source code relevant 
prior techniques locate features source code roughly broken techniques static analysis dynamic analysis 
features behaviors system dynamic nature 
dissertation focuses dynamic techniques static techniques 
dynamic techniques require significant knowledge system technique useful 
furthermore suffer respects binary judgments source code artifacts relate feature determining extent relate meaning feature precisely characterized technique questionable usefulness problem discussed section provide idea piece code relevant feature 
technique creating dynamic feature traces improves previous advantage existing test suite reducing amount system knowledge necessary technique ranking source code artifacts strongly related feature retaining part execution trace test suite developers understand piece code part feature 
show technique provides benefit techniques features applying existing software systems comparing results existing technique 
feature understanding de lucia software comprehension constitutes software maintenance time 
comprehension process includes identification relationship source code software features 
poor missing dated documentation render designed source code nearly incomprehensible 
maintaining documentation typically low priority software developers reliable source information regarding structure system 
particular problem developers unfamiliar system 
may know feature exists interactions system extra help extremely difficult locate source code relevant feature 
hope growing popularity incorporating testing frameworks junit development life cycle encouraging form self documentation impossible test suites 
existence structure test suite implicitly relates structure system testing 
particular systems created test driven development strategy tend clear mapping test cases features feature exhibited test cases 
basic tenets test driven development test cases written test piece functionality functionality implemented ensuring functionality test attached 
tests called acceptance tests written explicitly test correctness particular feature 
call set test cases focus feature feature test set 
define footprint test set methods executed test set run 
assuming correlation tests features test set footprints potential help map features source code help software engineering tasks evolution 
feature defined behavior system observable external world 
discuss locating feature mean determining mapping feature behavior source code implements static structure program 
note attach footprint directly feature requirement 
source code executed test set relevant related feature want distinction explicit 
previous attempts test sets find implementations features new idea see section 
briefly introduce software reconnaissance motivate discussion strengths weaknesses previous attempts feature location dynamic analysis :10.1.1.17.6012
software reconnaissance technique help software maintainers locate key source code particular functionality :10.1.1.17.6012
technique depends availability test sets exhibits feature 
executing test sets technique subtracts footprint test set exhibiting footprint determine relevant blocks code 
software reconnaissance shown useful large case studies claim locate features falls short results list blocks code block deemed equally relevant feature having disadvantages presenting full footprint test set typically contain elements comprehensible developer flat list software reconnaissance retains elements deemed relevant discarding potentially useful information 
order exacerbate problem software reconnaissance depends having high quality test sets precisely characterize feature 
provide quality results exhibiting non exhibiting test sets precisely correlated 
obtaining suitable non exhibiting test set particularly difficult clear definition non exhibiting means 
test sets unrelated results set large vague 
test sets similar results set small worse empty 
flat list help developer determine elements relevant feature 
context elements included list results way understand block code called context feature 
described section dynamic feature location techniques suffer short 
static techniques useful identifying concerns interest source code useful identifying features 
define features behaviors system apparent dynamically 
code test test suite test set footprint method ranking dft calls test test test partition test set test set execute structure dft created structuring footprint test set terms footprint calls ranking methods 
enter dynamic feature traces introduce dynamic feature traces dfts help locate features source code 
dft feature combination sets artifacts created execution test suite partitioned test sets 
set rankings contains methods test set footprint ranked confidence method importance feature 
set calls contains set unique calls occurring methods footprint 
describes dft created code base test suite 
developer partitions test suite test sets 
partitioning test cases may left partitioning 
developer executes test suite conjunction dft tool calculates footprint defined test sets splits ranks calls sets 
process described detail section 
dfts avoid problems outlined section ways dft ranks methods measure relevance established heuristics making binary decision methods re tain 
heuristics estimate extent method relevant feature 
dft retains methods footprint highlights relevant ones 
non exhibiting tests gradual adjustments ranking methods removing outright approach require availability precisely correlated non exhibiting test sets 
dft retains information dynamically observed call graph available developer 
helpful determine methods included footprint 
created prototype dynamic feature tracing tool creates dfts junit test suite java system mapping test cases test sets 
dft tool locate code relevant features existing unfamiliar software systems perform feature enhancement systems 
compared dft results applying software reconnaissance features unfamiliar systems 
structure remainder dissertation chapter chapter outline feature location describing strengths weaknesses existing techniques 
chapter details dynamic feature trace created 
describe evaluation results analysis dfts prototype creation tool chapter 
chapter lessons learned research concluding remarks 
java trademark sun microsystems chapter background dissertation claims existing test suite aid feature location provide benefits previous feature location techniques 
survey chapter overviews previous feature location techniques breaking broad categories statically determined links locate features dynamic analysis 
provide overview test driven development relates test suite construction self documentation software system 
feature location techniques important distinctions approaches feature location software systems 
broadest distinction employ static analysis dynamic analysis 
split section accordingly section introducing static analysis techniques section introducing dynamic analysis techniques 
techniques located feature subset base code system 
static techniques rely user interactions determine subset dynamic techniques rely execution test cases scenarios choose subset 
minimum dynamic feature location techniques rely set tests scenarios test sets exhibit feature located 
static dynamic distinction distinguish techniques enable developer help determine code element related feature versus 
mean techniques allow developer scenarios executions system test cases meant illustrate particular interaction system check correctness 
purposes terms interchangeable 
understand code elements feature related typically sort dependency call graph 
static techniques largely integrated ide static relationships code elements feature retrieved show code related context feature static techniques find static relationships exercised dynamically system exhibits feature 
dynamic techniques simply return list elements exercised feature exhibited explain executed 
dynamic techniques allow developer explore relationships code elements helping provide intuition elements related feature 
distinction dynamic techniques return entire test set footprint versus return subset footprint 
dynamic techniques rely tracing execution test set 
dynamic feature location techniques return part footprint deemed related feature question 
entire footprint large developer fully comprehend 
returning important part footprint techniques focus developer attention code elements relevant footprint test sets precisely correct 
test set chosen precisely vital parts footprint inadvertently removed 
dynamic techniques avoid problem returning entire footprint 
danger tactic entire footprint large comprehensible developer 
remainder section introduces feature location techniques terms distinctions described 
static feature discovery sub section explores examples techniques static analysis locate features source code 
relationships inherent source code execute system 
define features behaviors system unnatural search features statically experiencing features executing program 
problem manifests executing target system difficult determine exactly code behave code gets executed feature exhibited 
instance problem difficulty determining runtime type object static analysis 
theoretically possible perform static analysis determine exactly system behave input set technically difficult described attempts 
techniques sort static analysis locate features source code 
feature extraction analysis tool feature extraction analysis tool feat tool created enables developer locate modular concerns encapsulate concern graph formal way represent source code concerns system :10.1.1.18.6851
process primarily manual developer tool facilitates code exploration provides mechanisms maintaining consistency code concern graphs code base evolves 
elements concern added explicitly feat tool 
tool primarily useful specifying concerns representation source code source code 
concern graph stores subset dependency graph code allows developer understand relationships code elements graph 
developer feat explore learn system tool little prior knowledge system necessary get tool 
feat constructed developer exploration static code base relationships available runtime difficult discover 
example exact execution path taken feature exhibited difficult impossible determine statically 
dependency graphs chen rajlich introduce semi automated technique dependency graphs locate features software systems 
developer browses statically derived system dependency graph asdg determine code belonging feature 
asdg similar combination static call graph data flow graph 
structure asdg dependent type static analysis 
particular construction asdg algorithm handle languages dynamic dispatch instance problem finding dynamic relationships statically 
static analyzers create asdg difficult creating succinct correct 
chen rajlich approach similar advantages disadvantages feat 
developer need intimately familiar target system approach developer learn system exploring concern informally defined interest 

developer quickly understand static relationships code elements selected asdg 
dynamic relationships system behaves executed difficult determine 
concern manipulation environment concern manipulation environment cme framework assist incremental adoption aspect oriented software development 
capabilities help software developers identification software concerns features extracted code base 
capability currently supported cme plug eclipse 
plug allows developer query code base code relevant concern 
allows code explicitly added concern 
similar techniques described static relationships elements related feature retained 
cme support dynamic analysis determine code artifacts part concern difficulties feat determining runtime behavior statically 
automatic inference concerns murphy algorithm automatic inference concern graphs 
static structure program determine code related feature previous techniques technique automatically infers concerns investigation activities developers 
technique records path code taken developer exploration system 
uses set heuristics translate exploration data concerns viewed edited feat 
technique gathers data different sources techniques explained previously relationships explored returned statically determined 
technique automated previous ones problem easily determine dynamic relationships model elements 
dynamic feature discovery addition software reconnaissance introduced section discussed section techniques dynamic analysis extract features source code :10.1.1.17.6012
greater lesser extent rely system expert create precise test cases feature location data retrieved dynamically 
techniques structure pieces located feature meaningful way show relationships code elements 
results context difficult understand 
retaining artifacts executed test set techniques retain artifacts executed test set 
remove relevant artifacts comparison non exhibiting test set 
exhibiting test set set test cases execution collectively exhibits feature non exhibiting test set set test cases execution precisely exhibit feature 
software reconnaissance mentioned section software reconnaissance locates source code related feature subtracting results non exhibiting test set exhibiting test set 
remaining source code artifacts uniquely implement feature 
locate feature exhibiting test sets constructed way feature possible feature exhibited 
test sets constructed precisely exhibit feature 
exactly clearly stated 
non exhibiting test set improperly determined risk significant portions code inadvertently removed results 
test sets need constructed precisely precluding technique unfamiliar target system 
results technique flat list code blocks uniquely part feature assuming precise test sets 
way determine code blocks important feature techniques retain calling context feature exhibited 
means way see relationships code blocks pertain execution feature 
execution slices wong describe process similar software reconnaissance rely exhibiting non exhibiting test cases find blocks code related features :10.1.1.22.2891
expand wilde technique realizing heuristics find code related features vary depending goal exploration instance technique slightly different searching code unique single feature searching code common multiple features 
provide hints find exhibiting non exhibiting tests excluding tests similar possible terms execution slice invoking tests common code filtered possible finding non exhibiting tests unfamiliar system difficult penalty poorly chosen non exhibiting tests 
software reconnaissance technique return code blocks footprint remove potentially important information test sets chosen precisely retain information different blocks code results pertain notion blocks important feature 
retaining artifacts executed test set techniques retain artifacts test set execution 
avoid problem removing potentially important elements execution trace apparent previous techniques 
returned footprint large developer technique overloaded information impacting usefulness results 
techniques lacking ability emphasize code elements relevant feature 
technique removing elements lesser importance able focus developer attention small subset code relevant feature removing code potentially relevant 
technique vue retain part calling context elements deemed related feature results unstructured list code locations called important 
techniques eisenbarth allow developers view relationships code elements 
helps organization elements deemed relevant feature may sufficient 
code feature tends tangled code due existence crosscutting concerns code executed test set equally relevant feature analyzed 
techniques help elucidate code element part feature help understand extent 
vue agrawal introduce vue locates features source code recording blocks code executed set scenarios test cases 
terms invoking test excluding test mean exhibiting test non exhibiting test respectively 
originally developed problem vue commercially viable tool 
gui fully functional completely integrated tool suite vue part 
allows developer see footprint test set different levels granularity 
example developer view blocks executed test set feature block level method level file level directory level 
tool help developer understand executed blocks code distributed system help understand related structure results code important feature emphasized 
locating features source code eisenbarth koschke simon combine static dynamic techniques determine source code relevant features :10.1.1.13.4624
technique applies concept analysis set code elements exercised scenario test case determine relationships code features 
concept analysis formal means analyze binary relations determine mapping executed code elements scenarios 
results concept analysis compared static structure code feature extracted 
results displayed sub graph full dependency graph viewed rigi tool 
eisenbarth approach semi automated requires human input including domain expert construct precise scenarios exhibit features analyzed 
technique retain concept code element part feature sub graph related feature displayed rigi tool 
static relationships displayed 
rigi tool show relationships code elements exercised dynamically relationships statically inactive feature exhibited 
automated requirements traceability proposes scenarios similar test cases perform requirements traceability 
technique uses scenarios trace functional requirements similar features source code elements types artifacts uml sequence diagrams 
existing profiling tools scenarios traced related back requirement represent 
executed code deemed relevant requirement 
approach iterative progressively refines user generated hypotheses regarding source code elements relevant functional requirements 
iteration methods executed retained calls 
approach iterative user technique need intimately familiar system 
familiarity increase iteration 
system expert supply initial scenarios 
technique retains part dynamic call structure pertaining feature analyzed 
retains information relationships visible execution system allows developer browse 
offers evidence technique scale largescale system 
examples provided java systems containing classes 
believe scalability problem arises element scenario footprint deemed equally relevant feature organizing code elements relevant elements emphasized 
test suite design test driven development test driven development development strategy tests written new code code written 
beck written comprehensive book subject 
provide overview tdd order show test suite constructed strategy contains implicit mapping features test cases 
chapter show leverage implicit feature mapping help developers locate features familiar target system 
tdd progress larger goal ensues small incremental steps 
tests written applying increment code written 
new tests fail initially increment implemented 
proceed increment tests pass 
test suite grows system grows test suite comprehensively tests increments system 
failure system failing test written expose 
test help find fix fault 
fault fixed passing test remains test suite documenting fix 
developing software manner ensures aspects system feature development increment design decision bug fix embodied test suite 
unfortunately tests created difficult understand relate system testing tests succeeding 
overcome difficulties tools evolved help organize explore test suite system 
allow tests organized hierarchical manner mirroring object hierarchy code 
provide visual representation success failure tests 
general family testing frameworks called junit java net python virtually programming language 
provide developer framework general test suite written piece software written target language tool 
tools allow tests written hierarchical manner test suites structured mirror structure system testing 
hierarchy may sufficient group test cases arbitrary relationship due existence crosscutting concerns better organization 
test driven development defines types tests unit tests acceptance tests 
unit tests written developers write code test individual software components 
acceptance tests written designed customer system passes acceptance tests customer satisfied accept system acceptance test corresponds functional requirement feature non functional requirement security performance 
acceptance tests defined unit test hierarchy separate hierarchy depending relationship tested code 
systems developed tdd tend clear mapping functional behavior test cases tool support mapping understood developers unfamiliar system 
shown section previous dynamic feature location techniques rely extensive knowledge target system readily applied 
static feature location technique easily identify dynamic relationships source code elements realized feature executed 
technique see section maintains part dynamic links source code elements context feature execution 
technique potential scalability issues emphasize source code relevant feature 
table shows summary related described chapter 
show chapter test suite system developed test driven development strategy help feature location 
net registered trademark microsoft 
technique static dynamic retain retain binary decision notion issues feat section browse static relation user locate feature ships exploration dependency graphs section browse static relationships user explores dependency graph locate feature cme section browse static relation query automatic section browse static relation infer concern feature ships ex concerns software re section difficulty choosing test set execution slices section difficulty choosing test set vue section relate results back code structure locating section browse static relation relate results back concept static structure sis auto re section browse relationships potential scalability issues determined dynamically traceability table breakdown feature location techniques 
note previous techniques described binary judgments code elements relevant judges extent code elements relevant 
existing test suite helps alleviate reliance knowledge target system feature location techniques 
chapter dft created 
chapter identified methods data collection feature location techniques static analysis methods feature location tool supported user driven approaches partition source code features 
approaches require significant time effort part developer require significant knowledge target system prior analysis 
developer learns system explored 
dynamic analysis methods feature location test case scenario driven 
approaches data collected execution trace test suite set scenarios 
approaches tend automated static analysis approaches tend rely precise input defined intimate knowledge target system order find code related particular feature 
defeats purpose feature location techniques place 
identified design decisions dynamic analysis approaches feature location amount test set footprint retained approaches retain relevant parts test set footprint retain 
benefit retaining result set smaller potentially easier understand danger important code removed final results 
approaches retain footprint potentially return data overwhelming developer 
structured unstructured results approaches simply return portion test set footprint provide structure 
approaches provide ability understand relationships elements test set footprint 
believe strong feature location technique combine strengths methods design decisions 
automated approach require significant prior knowledge target system combine strengths dynamic static data collection methods 
possible benefit sides trade retaining test set footprint 
entire footprint retained important elements emphasized developer overwhelmed data potentially useful information dropped 
developer basis judge extent element important feature 
ability popular ides provide different visual representations relationships code elements call graphs package browsers benefit developers 
believe critical results feature location technique integrated ide viewed way package browser call graph 
help developer understand element important feature 
remainder chapter discusses dynamic feature traces dfts create principles outlined 
elaborate part thesis statement asserts dfts created minimal prior knowledge system provide benefit developer way helping map features source code 
chapter provides description dfts artifacts description created 
creation dfts intertwined artifact combine description artifact description creation 
dynamic feature trace comprised parts test set footprint related feature ranks ordered set methods called execution test set footprint calls set observed method calls methods test set footprint 
dfts created dft tool steps shown partitioning developer determines features analyze partitions test suite accordingly process described section 
partitioning represented user generated file sent dft parser 
execution tracing dft analysis engine applied target system 
partitioning created analysis engine generates execution trace test suite process described section 
ranks calls section describes dft analysis engine uses execution trace generate ranks calls 
details heuristics rank methods 
section discusses feature finding heuristics useful inclusion tool implemented 
viewing results lastly section describes rankings calls sets integrated existing ides development processes 
particular section describes dfts viewed jquery generic code browser implemented plug eclipse ide help visualize code related features analyzed 
dft tool consists parts parser parse feature mapping files section analysis engine generate execution trace section generate ranks calls sets section augmented version jquery import apply dft data section 
partitioning test suite goals dft tool generation test sets simple possible developer unfamiliar target system technique 
force developer create custom tests purpose dft tool tool expects system large comprehensive test suite relatively clear mapping features test cases 
unreasonable systems developed test driven development strategy properties mentioned section 
systems incomplete test suites analyzed dft tool results accurate 
developer provide dft tool feature mapping exact structure mapping described groups test cases related feature test sets 
features explicitly analyzed tool 
remaining tests explicitly mentioned mapping implicitly grouped test sets similarities test suite structure 
dft tool implemented extension junit testing framework similar test cases tend grouped test classes dft tool uses test class implicit test set grouping 
implicit test set grouping may perfect situations test suites incomplete poorly modularized focus modules features developer explicitly exclude test cases test classes analysis 
implicit mapping test cases test sets means need specify non exhibiting test sets automatically generated 
artifact created stage feature mapping file defines mapping features test cases test case part feature 
created developer user tool 
file mapping feature test classes denoted mapping feature test methods denoted 
classes methods explicitly excluded analysis adding special exclude test set 
method class mentioned separate features method overrides class 
example feature tracing file simple drawing application 

ca ubc cs draw 
ca ubc cs draw 

animate 
ca ubc cs draw 

exclude 
ca ubc cs draw 
ca ubc cs draw 
feature tracing file identifies line animate line features trace specifying methods contributing exhibiting test set lines entire class contributing feature exhibiting test set line 
specifies test methods test class line explicitly mentioned excluded final analysis 
test classes implicitly compared explicitly mentioned features heuristics described section 
mapping parsed dft parser provided dft analysis engine input 
gathering execution trace dft analysis engine part dft tool collects execution trace system generates ranks calls sets execution trace 
section describe execution trace system gathered 
dft analysis engine profiling analysis tool written aspectj extension java programming language provides aspect oriented programming facilities :10.1.1.21.5662
mentioned dft tool extension junit unit testing framework 
unit test execution dft analysis engine collects data method execution 
unit test excluded trace method calls call depth stored analysis engine separate partitions defined section 
dft analysis engine applied system instantiating main junit test suite system class dft library inherited advice activates profiling process 
test suites lines code need change dft tool applied 
code snippet creates test suite simple drawing application adds test cases suite 
snippet set dft analysis engine create dft test suite execution 
line added line altered occur 

package ca ubc cs draw 
import junit framework test 
import junit framework 
import ca ubc cs 
public class extends testcase 
public static test suite 
line 
change weaving process occur 
suite new 
suite class 
suite class 
suite class 
add remaining test classes 
return suite 

typically junit test suite created instantiating object type 
order dft analysis engine instantiated test suite type 
class contains code instantiates parts analysis engine 
analysis engine contains aspects define pointcuts advise code 
line added order import 
altering test suite hook dft analysis engine software system test suite weaved compiled aspectj compiler ajc 
artifact created stage process data structure contains information needed calculate ranks calls sets 
includes record method calls test case part call depth calls 
information analysis engine described section 
ranks calls data gathered execution trace generate ranks calls sets 
generating calls calls set simpler sets generate 
test set defined mapping calls set created 
execution trace gathered analysis engine call information added calls set 
methods added caller callee pair particular test set call occurs multiple times 
generating ranks data required generate ranks set gathered execution trace 
rank methods executed test set separately 
method score test set part 
score average equally weighted heuristics 
final rank method determined sorting exercised method sum individual scores 
top scoring method rank forth 
ties broken arbitrarily 
heuristics follows originally implemented heuristics equal weighting data suggested weighting straightforward implementation 
section describes experiment performed determined optimal weighting heuristics 
multiplicity method exercised test set multiple times different situations important exhibited feature method 
chose implement multiplicity percentage exhibiting tests exercise method compared percentage methods non exhibiting set tests contribute score 
curr tests exercises method current test set min tests exercising method test set exercises method fewest number times max tests exercising method test set exercises method greatest number times multiplicity curr min max min specialization method exercised different test sets exhibiting features utility method part feature method exercised fewer test sets measures specialization 
specialization exercising test sets number test sets note added ensure methods exercised single test set score 
call depth expect reasonably designed partitioned test suite test set exhibit behavior feature focuses direct manner possible 
test sets tend exhibit feature directly 
correlate directness call depth 
implemented heuristic comparing minimum call depths exercised method exercising test sets 
rationale directly method exercised shallower call depth 
find call depth score cd method called stack depth depth test set 
determine lowest highest low hi call depths fewest greatest number stack frames top test sets exercise 

determine linear scale depth low hi depth low hi low test set low call depth test set hi call depth 
low hi test sets call depth avoiding division 

re scale account test sets exercise specialization score 
cd specialization specialization assume non exercising test sets method effect call depth score 
accordingly fewer test sets exercise method higher call depth score method test sets exercise method 
reason call depth score depends specialization score 
call depth score ranges specialization score 
feature call depth specialization exercises lowest call depth 
feature call depth exercises highest call depth 
features call depth score linearly scaled 
assume single combination heuristics find relevant methods situation 
believe heuristic find relevant methods 
initially chose weight heuristics equally explore weightings section 
heuristics identified potential heuristics implement studies 
include illustrate heuristics implement arbitrarily chosen motivate 
naming conventions methods related feature names similar feature 
example method named draw part implementation draw feature 
naming conventions informal choice feature name independent naming convention feature name chosen developer unfamiliar system unaware naming convention difficult generalize rule applicable features 
chose implement heuristic 
static slicing definition program slicing proposed weiser starting test case part feature test set remove code irrelevant feature 
useful mechanism removing code static slicing conservative removes 
remove code executed starting point 
dynamic slicing conservative technique dynamic slicing return smaller subset code applied execution trace test case exhibits particular feature 
dynamic slice proposed agrawal returns statements executed particular input 
explicitly performed dft tool dfts contain methods executed set inputs 
reason generation dfts improved heuristic dynamic slicing 
inheritance hierarchies types deeper inheritance hierarchy chain definition specific important feature type deep 
implemented heuristic calculates depth method inheritance hierarchy determines score 
heuristic useful comparison methods hierarchy difficult meaningless compare methods separate hierarchies 
chose implement heuristic 
multipliers intuition interesting methods tend follow interesting methods led think multipliers 
method called calling interesting method relevant feature interesting 
implement heuristic believe useful 
exact value multiplier need experimentally determined 
test data explore 
static analysis incoming outgoing calls statically determine incoming calls method compare incoming calls exercised test set information determine ranking 
method exercised large percentage total number call sites important feature method 
similar argument outgoing calls 
heuristic implemented promising 
profiling comparing relative lengths time spent method test set footprint help infer useful ranking 
method takes long time execute important feature quickly executing method 
heuristic measurements compare execution times methods features 
furthermore heuristic need account threads sleep methods due example concurrency issues 
heuristics implemented topics research 
dft tool produce 
artifacts stage dft creation process sets 
element ranks set triple containing feature name method name rank feature 
element calls set triple containing feature name caller method name callee method name 
files implemented fact files 
logic programming language similar prolog serves underlying query language jquery described 
jquery provides mechanism view interpret sets created dft analysis engine 
viewing dynamic feature traces sets comprise dft viewable jquery generic extensible code browser built plug eclipse ide 
fact files representing calls ranks sets imported jquery add additional relationships existing source code artifacts 
detail contents fact files intermediate representation understanding help understand dfts 
jquery 
core jquery logic database contains set source code artifacts fields methods classes statically determined relationships calls reads writes inherits 
developer query database 
query asks set java source code artifacts fulfill boolean expression relationships 
sample query translated plain english methods write read field classes contain methods 
result set tuples tuple containing method writes reads field class contains 
result displayed tree browser node represents source code artifact edge represents relationship 
shows results query asks readers writers field coordinate shape 
developer write general queries contains structure package browser inheritance hierarchy browser 
queries specific return example callers method 
furthermore developer incrementally expand view performing sub query node 
sub queries perform query result previous query input 
default queries sub queries included jquery accessed context menu 
include package browser call graph explorer inheritance hierarchy browser queries calls calls overrides overridden sub queries 
shows query sub query context menu listing default queries available jquery 
double clicking source code node opens editor focused piece code 
full description tool 
extensions jquery fact files contain new relationships added database 
relationships calls ranks methods dft 
creation described previously chapter 
relationships determined dynamic analysis easily determined static analysis 
new relationships queried exactly way static relationships returning browser containing code artifacts defined relationships inherent dft 
single query combine static relationships dft relationships 
adding dft data jquery database increases semantic power jquery information 
extended jquery dft calls ranks sets properly inserted database queries dft relationships code artifacts queries employ dfts ranks sorted rank 
created customized queries developer directly ask questions dft 
features query returns list features methods exercised features 
resulting methods ranked order 

dynamic stack forward sub query uses called methods facts recreate forward stack trace frames maximum depth prevent infinite loops dynamic information retrieved dft 

dynamic stack back similar dynamic stack forward stack traced backwards maximum frames 
shows example queries performed jquery respect dfts 
top level query features query returns footprint test sets features analyzed dft tool 
case feature visible animate 
animate method top ranking method feature 
method dyna stack forward sub query shown displays part execution trace starting animate animate feature 
dft tool tight integration jquery eclipse ide believe tool accessible easier stand version 
summary chapter described process creating dft dft composed dfts integrated existing ide 
shown process creating dfts attempts overcome problems identified previous feature location techniques 
chapter show extent dfts achieve goals performing experiments technique evaluate technique 
test suite system partition test suite user input needed feature mapping collect execution trace dft analysis engine execution trace create sets dft analysis engine calls rankings import jquery initiated user explore 
process creating dynamic feature trace results jquery query asks readers writers field jquery package browser creators sub query showing creators canvas class 
context menu list additional queries shown sub trees original query 
part features query showing animate feature 
dynamic stack forward dyna stack back sub queries show dynamic call graph starting selected node 
chapter evaluation chapter introduced dfts explained comprised calls ranks sets created dft tool 
explained step process creating dfts partitioning section execution tracing section creating ranks calls section viewing jquery section 
chapter focuses determining extent dfts convey relevant information feature improve existing mechanisms feature location 
course claim dfts unequivocally useful developers 
order substantiate claim need perform user studies large software systems extending development 
unfortunately resources time execute claims 
heuristics rank methods dft tend cluster methods important feature upper ranks 

developer unfamiliar target system create dft completely captures implementation feature source code developer unfamiliar target system previously available test suite feature location techniques software reconnaissance 
fact software reconnaissance breaks situation precise exhibiting non exhibiting test sets relatively complete test suite available 
applicable dfts created situation 
informally mean relevant methods grouped top ranks 
define cluster formally section 

dfts capture knowledge implementation features applied expanding feature information easily accessible standard search techniques existing eclipse ide 

justification method part feature retrieved dft 
claim substantiated experiment performed analyze efficacy ranking heuristics described section 
dfts created author dissertation medium sized open source systems developed test driven development strategy see section 
dfts created developer unfamiliar target systems 
measured dfts predict methods necessary feature enhancement comparing rankings dft actual methods changed data cvs repository project 
experiment examined dfts effectively show extent method involved implementation feature 
compared software reconnaissance technique appears dft creation set feature enhancements described section claim 
described section 
experiment examines effectively software reconnaissance technique applied unfamiliar system comparison dfts created unfamiliar system 
claims discussed section author dissertation took role developer created dfts open source systems experiments 
case studies show dfts created applied particular feature enhancement tasks 
focus dfts supply information readily available standard search techniques claim examination dynamic call graphs features claim 
section examine alternate weightings heuristics multiplicity specialization call depth 
previous experiments weighted heuristics equally believed produce strongest rankings evidence weighting effective 
section experiment re weighted heuristics determine heuristics contribute positively ranking 
evaluation ranking heuristics section describe experiment performed test effectiveness dft tool ranking heuristics 
expect user dfts tend closely analyze top results skim list ignoring lowest results 
expect upper results interesting expect greater concentration clustering hits elements 
analogous user browse results web search 
measure effectiveness heuristics analyzing methods deemed relevant feature tool places top elements various call measurement clustering 
relevance defined relationship particular feature enhancement task extracted cvs history described 
methods relevant feature enhancement task ways 
core set relevant methods directly modified deleted process implementing enhancement 
second methods directly linked core set call called override class core set 
relevant suggested tool aid discovery core set 
call union core set directly linked methods expanded set 
data collection chose open source java systems analyze unit testing framework focusing testing dynamically generated web pages methods constructors 
unit testing framework models protocol methods constructors 
file database implemented java methods constructors 
systems chosen source repositories freely available developed test driven development strategy making test suites large fairly comprehensive active feature request list relate feature enhancements cvs check ins 
systems searched completed feature requests corresponding changes source code 
table provides description features system feature description rfe rfe rfe added support operations dom nodes 
added support document open document close javascript 
added ability retrieve page links regular expression 
issue fixed problem boolean typed columns comparable 
issue fixed problem having multiple columns type table 
table features analyzed 
rfe means request enhancement 
analyzed 
feature names names feature tracker hosted development sites 
feature names appear feature tracker emphasize actual features systems 
prior knowledge code base study performed minimal knowledge code base 
furthermore little formal documentation provided developers 
existed cvs logs newsgroup discussions bugzilla feature bug trackers test suite 
process analyzing features identical cases performed author dissertation 
read feature request page feature analyzed includes information posted user desired addition enhancement system 

performed checkout code cvs repository corresponding time immediately feature request closed 

relevant information possible spending time understand code details partitioned test suite appropriate test set feature 

compiled code dft library executed test suite collected data results execution 

dft analysis engine applied ranking heuristics data collected execution performed automatically completion test suite execution 

cvs tools generated core expanded sets methods corresponding feature change 

compared dft core expanded sets 
performed experiments pentium mb ram ghz processor running windows xp 
aspectj compiler experiment version 
minutes spent partitioning test suite feature enhancement 
actual execution time test suites increased twofold dft analysis engine woven code 
test suites executed minutes dft analysis engine involvement just minutes involvement 
test suite ran just half hour analysis engine hours analysis engine 
extremely long time heavy reading writing disk 
extra time needed run test suites due tracing mechanisms added methods system 
analysis table shows results study 
feature analyzed sets numbers num number relevant methods top elements respectively 
non integers exist proportionally compute ranks equally scoring methods cross boundaries 
clustering raw count num column divided expected number relevant methods distribution 
formula calculating expected number methods top ranked methods total methods interesting methods ound clustering raw count hard translate sense ranking considered effective 
immediately convey sense relative degree clustering respect size footprint actual number interesting methods 
normalized number significantly greater indicates heuristics effective resulting high degree clustering number close signifies heuristics non effective 
probability probability random distribution produce strictly better clustering heuristics produce 
values computed variant hypergeometric cumulative distribution function 
number provides means gauge effectiveness quantifying difficult better 
shown table feature enhancements study heuristics appear effective core set rfe rfe issue 
large portion relevant core methods clustered high ranking 
results convincing expanded set rfe 
rfe heuristics performed poorly core set moderately successful picking relevant methods expanded set 
core set failed identify single relevant method covered test cases 
anomalous case issue heuristics appear counter productive 
trying explain anomaly discovered missed test case test set feature enhancement 
initially obvious test case apparent relationship datatype related feature 
adding missing test case test set re running new ranking issue expanded improved unable rank core methods highly 
chose update results table accordingly initial results realistically reflect tool performs user little prior knowledge target system 
recall goal experiment establish measure effectiveness ranking heuristics create dft assess completeness coverage relevant methods dft 
coverage possibly affected changing heuristics dft retains methods test set footprint heuristics alter emphasis 
number relevant methods discovered related quality test suite effectiveness partitioning 
deficiency feature methods exercised total relevant methods relevant methods rfe num core clustering probability rfe num expanded clustering probability rfe num core clustering probability rfe num expanded clustering probability rfe num core clustering probability rfe num expanded clustering probability issue num core clustering probability issue num expanded clustering probability issue num core clustering probability issue num expanded clustering probability table results quantitative evaluation table shows clustering interesting methods top rankings 
negatively impact clustering useful methods results 
relatively na partitioning heuristics appear effective 
focus experiment observations worth mentioning discrepancies number relevant methods feature third column versus number relevant methods fourth column rfe methods items factory methods constructors 
methods code perform get set create initialize 
remaining methods significant code located physically close methods 
rfe methods executed test entire test suite implying test suite incomplete 
rfe methods exercised junit test file 
test class included study missing methods 
heuristics run accurate feature mapping clustering relevant methods core set expanded set 
relevant methods exercised test set significant improvement 
despite heuristics ranking highly relevant methods features analyzed able create dfts clustered methods top ranks despite unfamiliar target systems 
variation results majority feature enhancements analyzed suggest ranking heuristics dfts tend cluster methods relevant feature upper ranks 
studies performed little prior knowledge target system tests chosen ones strongly exercised feature 
show familiarity system produce precise partitioning stronger clustering familiarity reasonable partitioning created 
comparison software reconnaissance compared dfts software reconnaissance described order substantiate claim :10.1.1.17.6012
relevant methods software reconnaissance discover feature unfamiliar systems described previous section 
described section software reconnaissance technique locate features software system 
technique exhibiting test set non exhibiting test set feature executed 
typically test sets chosen system expert intimate knowledge system 
set blocks executed non exhibiting test set subtracted set blocks executed exhibiting test set 
remaining blocks code uniquely part feature 
study apply software reconnaissance method level 
chose wanted consistent dft tool works method granularity discuss potential ramifications choice section 
features examined section author dissertation created exhibiting test set feature test set create dft labelled non exhibiting small number excluded test cases quickly deemed exhibiting non exhibiting 
little prior knowledge target systems impractical create precise partitioning exhibiting test sets significant overhead understanding systems defeating purpose feature location techniques place 
standard way choosing exhibiting non exhibiting tests software reconnaissance wanted show software reconnaissance breaks situation described claim creating precise test suites possibility due lack experience target system previously available test suite place 
table compares results techniques features analyzed 
table shows software reconnaissance technique interesting methods trials 
trials expanded sets 
trials interesting methods significant number false positives 
software reconnaissance results trial rfe expanded return elements relevant success rate fewer number relevant elements contained dft 
number relevant elements discovered dft top elements total number relevant elements versus total elements software reconnaissance 
top dfts aid developer sifting ranked elements allowing developer view context ranked method executed feature test set calls 
described section information help developer quickly sift ranked methods determine relevant ones 
software reconnaissance information available 
software reconnaissance typically block granularity method granularity 
soft recon dft top total feature relevant false pos rfe core rfe expanded rfe core rfe expanded rfe core rfe expanded issue core issue expanded issue core issue expanded table comparison dft results software reconnaissance approach 
relevant perform software reconnaissance block level shown technique performed method level granularity discovers fewer relevant code elements dfts 
case studies section discuss claims applying dfts perform feature enhancements open source systems 
show information stored dft readily available standard sources eclipse search functionality 
task cookie enhancement task mimic feature enhancement codebase corresponding cvs check december 
enhancement consists adding ability get set cookies javascript document cookie statement 
task carried author dissertation little knowledge code base prior starting task 
task entail significant amount code written changed involve learning javascript handled 
performing task reading relevant newsgroup thread regarding enhancement realized enhancement consisted parts corresponding features manipulating cookies calling statements javascript document object 
looked cookies manipulated spent minutes choose test cases appropriate testing general cookie functionality mapping feature called cookies 
running test suite collecting data heuristics weighted evenly importing data jquery explored feature trace starting highest rank 
soon discovered methods manipulating cookies including 
basic understanding cookies manipulated shifted focus learning get set javascript object properties 
started writing partially implemented test cases tested reading document cookie writing document cookie added tests new feature called 
added third test feature called document links property retrieves links web page 
third test case similar structure test cases provided template perform task 
ran test suite expected new tests failed 
contributed code execution trace feature 
data imported jquery queried feature trace 
methods top returned results caught attention 
performed backwards trace eventually method high ranking execution trace 
performed forward trace 
examining methods returned forward trace noticed dft tool results included call methods document class including link 
visual inspection code showed calls 
thought error tool closer inspection realized fact call methods albeit indirectly call back mechanism library code 
regardless link interesting test cases included feature javascript statement document link 
dynamic call graph dft helped view code relationships exist statically 
idea change added methods stubs document class cookie cookie 
re running tests determined new methods called expected place execution 
step determine give new methods access document cookies 
earlier task determined class maintained cookies object document class direct access cookies 
performing forward stack trace query constructor determined constructor transitively calls document initialize 
refactored necessary methods passed argument initialize method refactoring intermediary methods 
access cookies document class filled code cookie cookie get set cookies manner prescribed newsgroup 
ran test suite time producing errors failures completing change 
changed added total methods hours 
analysis ranking choose places start looking dynamic call graph useful tool helping understand ways interesting methods test set 
exploring rankings top effective find initial seeds start exploring detail 
ranks decisive top ranked methods immediately relevant conversely relevant methods top ranked 
despite able complete task relevant methods identified ranked highly 
illustrate instances task information contained dfts readily available standard eclipse search tools 
looking cookies commenced task seeking understand cookies implemented 
created dft help eclipse search wade irrelevant code 
case insensitive search declarations type cookie returns matches codebase declared libraries 
case insensitive search methods cookie yields results declared code 
possible search time consuming 
compare rankings dfts ranked methods top 
immediately able narrow search methods explore call hierarchies 
getting setting properties document object dft able discover properties functions javascript get set executed calling entity name 
example page links get set calling methods link link document class 
document class quite simply eclipse search mechanism calling javascript properties easily understood standard eclipse functionality 
exploring static call graph effective xxx xxx methods called directly callback mechanism library code 
eclipse call graph view shown 
method explored dft learn javascript properties manipulated 
view calls emanating show code base 
library code calls back code shown static call graph 
recall unfamiliar system knowledge callback mechanism 
exploring dynamic call graph stored dft method easier see dynamic structure understand method accesses javascript elements 
notice dft show library code just shows methods executed context feature 
regardless way view reflective calls involved feature static techniques 
dft dynamic call graph justified methods links forms included feature 
able knowledge implement cookies manner 
task table creation task author dissertation took stance developer new system wants understand tables created database show dfts helpful developers trying understand existing feature 
task extend feature shows dfts capture feature implementation 
comparisons eclipse search functionality show information readily available note choose task relied reflection fact know reflection existed feature started exploring 
possible include library code dft order library woven dft analysis engine 
static call graph emanating 
standard tools 
quick search development site mailing list archive issue tracker shows posts dealing directly table creation 
direct access developers 
place find piece information code 
imported project eclipse ide performed dynamic call graph emanating 
understanding shaded methods called helped understand javascript properties general 
searches code standard eclipse search functionality 
search declarations type called table yielded results 
table creation 
table creation classes discovered searching single classes difficult understand table creation performed browsing static relationships code artifacts tedious time consuming explore 
decided dfts help task 
database project test methods test classes 
search test table yielded results test classes quickly filtered interest 
reading comments top test classes decided directly tests table creation tests general table functionality 
eas ier understand purpose test class determine purpose standard class 
partitioning test suite test set corresponding feature called table creation tests default partitioning created dft dft tool imported results jquery 
saw important table creation feature execute 
explored individual method call stack executed test methods table creation feature 
dft able understand steps database takes creates tables 
access dft dynamic call graph task completed data wade 
example static call graph eclipse call graph view execute method class called unique methods entire system creating tables different specific purposes 
dynamic call graph incoming calls directly test cases test set illustrate direct manner standard way execute called creating tables 
time spent task minutes partitioning minutes exploration 
task column metadata task explores dfts help simple extension existing feature 
issue bug tracker asks comprehensive column metadata 
issue completed column metadata accessible result set column name column type 
issue asks addition precision scale metadata numeric typed columns 
issue asks expand existing feature reasonable step understand feature originally implemented 
partitioning test suite column metadata feature creating dft partitioning highlight exactly column metadata retrieved result set 
metadata extracted similar way 
author dissertation largely unfamiliar read details issue discovered column metadata feature implemented metadata accessible programmatically metadata exist accessible 
search test case test metadata finds test methods test metadata directly test column metadata 
partitioned column metadata tests column metadata partition put remaining tests exclude partition affect dft creation 
executing test suite viewed dft data jquery 
saw top ranked methods column metadata feature retrieve piece metadata column 
exploring methods call stack led execution methods able determine existing means extracting column metadata 
understanding implemented accessor methods metadata specified issue closely mimicking existing metadata accessor functions 
partitioning performing change took minutes combined 
re weighting ranking heuristics section discusses study performed see way combine heuristics increase number interesting methods clustered top ranks 
originally heuristics weighted equally believe optimal 
experiment exploratory substantiate claim 
varying weightings heuristics maximized number interesting elements ranked top linearly scaling elements element ranked count times element ranked 
intuition methods higher ranked weighted heavily easily recognizable 
table shows weightings produced strongest cluster top ranking 
results show significant variations optimized weightings features 
find single optimal weighting features studied 
average weighting specialization greater averages heuristics specialization strongest 
call depth features heuristic currently implemented strong indicator method relationship feature 
suggests studies weight specialization greater heuristics 
interesting observation feature rfe core method combination weightings push top optimal weightings normalized interesting methods top specialization multiplicity call depth feature rfe core rfe expanded rfe core weighting effective 
rfe expanded rfe core rfe expanded issue core issue expanded issue core issue expanded average table optimal weightings heuristics feature second third fourth columns provide optimal weightings heuristics implemented set interesting methods provided features 
final column provides ratio actual number methods expected number methods 
ranks unable compute optimal weighting case 
show 
chapter explored claims dfts 
section describes experiment tested effectively heuristics cluster methods relevant feature upper ranks 
showed heuristics perform clustering effective situations 
showed dfts created little prior knowledge target system 
show test suites partitioned extreme care rankings effective 
section describes comparison software reconnaissance dfts showing developer unfamiliar system create dfts closely capture implementation feature achieved applying software reconnaissance system 
section showed dfts capture knowledge features readily accessible standard tools particular eclipse search 
showed dfts capture method part feature 
lastly section described exploratory study looked efficacy heuristics relative 
chapter thesis statement claimed possible developer unfamiliar software system existing functional tests identify source code relevant features understand source code relevant 
introduced concept dynamic feature traces dfts validate claim 
described heuristics rank methods meaningfully task hand 
heuristics determination extent method relevant feature 
needs done fine tuning heuristics 
shown dfts retain part method calling context feature developer easily deduce method important feature 
comparison software reconnaissance technique shown dfts provide relevant information feature location techniques target system unfamiliar 
contributions dfts feature location improves existing techniques doing require significant knowledge target system order useful created existing test suites maintain concept extent code part feature ranking methods executed feature test set order relevant retaining code discarding potentially useful information retaining code unstructured format retain calling context method call occurring test set execution helping developer understand methods part feature 
dfts perfectly characterize feature information relevant feature accessible developer dfts developer standard search techniques 
directions relationships different types artifacts different stages lifecycle models system interest 
believe needs done exploring find relationships heterogeneous artifacts represented 
want explore relationships explored benefit development team 
largest area directly related dfts ranking heuristics 
identified implemented heuristics may useful finding relationships features code 
fine tuning existing heuristics 
sample size quantitative evaluation small 
order obtain statistically relevant results dfts need applied features wide variety systems 
see quality rankings change systems change potentially able categorize different types systems 
able see technique actual development environment ongoing project 
user study users access dft expand feature help evaluate dft usefulness 
concluding remarks software systems especially built test driven development strategy test suite form documentation stale system evolves 
types systems reliable source information test suite original developer understanding system necessarily trusted deteriorates time 
dissertation shown novel technique leverage system test suites order assist developers reliable source information 
bibliography agrawal horgan 
dynamic program slicing 
proceedings acm sigplan conference programming language design implementation volume pages white plains ny june 

test driven development practical guide 
prentice hall ptr edition aug 
beck 
test driven development 
addison wesley pub edition nov 


sourceforge net projects 

object oriented software engineering 
prentice hall edition nov 

cvs manual version management cvs 
network theory edition dec 
chen rajlich 
case study feature location dependence graph 
proceedings th international workshop program comprehension pages 
ieee computer society 
dixon 
com faq 
www com modules 

scenario driven approach traceability 
proceedings rd international conference software engineering pages 
ieee computer society 
gr 
automating requirements traceability record replay paradigm 
proc 
th int conf 
automated software eng 
ase pages sept 
eisenbarth koschke simon :10.1.1.13.4624
locating features source code 
ieee trans 
softw 
eng 
social responsibility 
working group 
www org program index htm 
friedman hill 
software verification functional testing xml documentation 
proceedings th hawaii international conference system sciences 
ieee computer society jan 
gold 

sourceforge net projects 
harrison ossher tarr 
concern manipulation environment 
www research ibm com cme 
harrison ossher tarr sutton chung clement kruskal 
cme plugin eclipse 
www eclipse org cme 
horwitz reps program dependence graphs software engineering 
proceedings th international conference software engineering pages 
acm press 
ibm 
eclipse 
www eclipse org 
de 
navigating querying code getting lost 
proceedings nd international conference aspect oriented software development pages 
acm press 
eisenberg 
jquery query code browser 
www cs ubc ca labs spl projects jquery 
kiczales hilsdale hugunin kersten palm griswold :10.1.1.21.5662
overview aspectj 
proceedings th european conference object oriented programming pages 
springer verlag 
kiczales lamping maeda lopes 
loingtier irwin 
aspect oriented programming 
ak sit matsuoka editors proceedings european conference object oriented programming volume pages 
springer verlag berlin heidelberg new york 
korel laski 
dynamic slicing computer programs 
journal systems software 
lucia munro 
understanding function behaviors program slicing 
proceedings fourth workshop program comprehension pages mar 
magnusson jr 
tigris org index html 

junit action 
manning publications edition nov 
mathworks statistics toolbox hypergeometric cumulative distribution function 
ller 
rigi system programming large 
proceedings th international conference software engineering pages 
ieee computer society may 

feat 
www cs ubc ca labs spl projects feat 
murphy :10.1.1.18.6851
concern graphs finding describing concerns structural program dependencies 
proceedings th international conference software engineering pages 
acm press 

automatically inferring concern code program investigation activities 
proceedings th international conference automated software engineering pages 
ieee computer society oct 

logic meta programming java 
sourceforge net 
weiser 
program slicing 
ieee transactions software engineering pages 
wilde :10.1.1.17.6012
faster reuse maintenance software reconnaissance 
wilde casey 
early field experience software reconnaissance technique program comprehension 
proceedings international conference software maintenance pages 
ieee computer society 
wong horgan gokhale trivedi :10.1.1.22.2891
locating program features execution slices 
ieee symposium application specific systems software engineering pages mar 
wong li 
coverage testing software architectural design sdl 
comput 
networks 

