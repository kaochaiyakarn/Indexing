cognitive support software engineering tools distributed cognition framework thesis submitted partial fulfillment requirements degree doctor philosophy school computing science andrew simon fraser university may rights reserved 
may reproduced part photocopy means permission author 
approval name degree andrew doctor philosophy title thesis cognitive support software engineering tools distributed cognition framework examining committee dr bhattacharya chair date approved ii software development remains mentally challenging despite continual advancement training techniques tools 
completely automating software development currently impossible sense seriously consider tools improve mental activities developers apart automating away 
mental assistance called cognitive support 
understanding developing cognitive support software engineering tools important research issue unfortunately moment theoretical foundations inadequately developed 
furthermore relevant research occurred outside software engineering community easily available researchers typically develop software engineering tools 
tool evaluation comparison development consequently impaired 
introduces theoretical framework intended seed systematic study cognitive support field software engineering tools 
theoretical framework called rods imports ideas methods field cognitive science called distributed cognition 
crucial concept rods cognitive support understood explained terms computational advantages conferred cognition redistributed software developer tools environment 
name rods fact comes cognitive support principles framework describes 
rods hand possible interpret design terms cognition beneficially rearranged 
analyses fruitful cognitive modeling framework called hasti proposed 
main purpose hasti provide analysis ways modifying developer cognition rods 
rods hasti convert previously tacit design knowledge explicit reusable knowledge 
rods hasti evaluated analytically reconstruct rationales exemplar reverse engineering tools 
preliminary field study conducted determine potential inexpensively applied realistic tool development settings 
studies draw implications research software engineering broadly design computer tools cognitive domains 
iii acknowledgments funding research provided nserc scholarship bc advanced systems institute scholarship nserc consortium software engineering research 
wish funding bodies support 
manuscript prepared latex document preparation system associated tex utilities 
figures created xfig system figures created help 
bibliographic metadata provided hci bibliography project www org 
instructions field study adaptation instructions written caroline green ken 
nameless people participated field study 
wish ller janice singer making research visit ottawa possible entertaining educational 
rob cameron careful patient mentoring financial emotional support provided wish members examining committee diligent reading dissertation 
am grateful supervisory committee time effort reading various documents advice 
am indebted freedom pursue somewhat unconventional lengthy dissertation topic 
students lucky 
friends colleagues helped life phd studies enjoyable discussing computing humans philosophy life just great companions 
michael adam carpendale philip fong maria gabor melli francisco robert macdonald friends 

am deeply grateful wonderful family supported thoroughly unconditionally studies 
position start project little manage battle 
supportive wife 
iv contents approval acknowledgments list tables list figures ii iii iv xii overview dissertation contents 
overview background sources 
overview contributions 
need cognitive support theories case cognitive support research 
cognitive support percent 
folk tacit science knowledge 
problems theory thin discipline 
evaluation problems simple comparison 
evaluation problems undirected observation 
evaluation problems cognitive modeling 
analysis problems 
design problems 
summary problems 
possibilities theory research 
leveraging mechanical support theory 
theory methods look 
se research researchers 
practical art designing theories 
summary 
cognitive support phenomena supportive relationships 
embodiment strategic artifact 
external memory internal memory 
external resources structure 
reflective visual intentional thinking 
evolving structures emergent thought 
representation effect 
automation 
descriptive theories 
mediation reflective media 
scaffolding 
augmentation extension symbiosis 
fitness 
schools cognitive support 
research tradition 
problem domain 
summary 
strengthening foundations cognitive support rods dc principles tenets 
human mind cognitive unit 
cognition computation 
cognitive interpretation 
distributed functional unit cognitive unit 
cognition distributed computation 
external cognitive interpretation 
summary dc tenets 
rods computational principles cognitive support 
task reduction 
algorithmic optimization 
distribution 
specialization 
summary principles 
analyzing cognitive support 
design space induced rods 
distributed cognitive architectures 
virtual architectures 
summary analysis proposals 
requirements check 
vi dc design stances 
reifying design space 
summary design ideas 
summary implications 
application craft science meet rmtool example 
tool usage description 
interpreting rmtool hasti 
tool analysis scenario 
design envisionment scenario 
summary implications rmtool analyses 
rigi example 
bottom comprehension bu hasti 
costh analysis bu hasti 
matching features rigi 
summary rigi analysis 
summary 
field study cognitive support field study description 
motivation background 
study design 
observation methods 
test run pilot 
stage summary study 
context research scenarios 
description participant context 
distributed planning visual caf 
exploration data analysis techniques 
analysis methods 
coding scheme 
results 
discussions 
theory application scenarios 
claims check 
measurement scenario 
summary discussion 
validity evaluation 

viii summary contributions 

coda 
invitation participate research description questionnaire instruction card instructions producing verbal reports coding participant ix list tables summary problems se research practice due lack cognitive support theories 
comparison methods evaluate tool ideas 
evaluation testing problems compared promises theory research 
theory requirements lessons learned addressed 
comparing problems current idea evaluation practices theory research 
matching problems current design analysis practices theory research solutions arguments realistic pursuit cognitive support theories 
descriptive theories various cognitive support relationships 
key tenets dc 
decompositions phenomena matching structures 
cognitive resources agent model 
overview rasmussen srk categories human adaptation 
summary task taxonomy 
hasti structures align rods substitution types 
summary redistribution examples 
summary specialization substitution types 
examples compositions multiple support factors 
types reasoning roles theory supporting 
summary 
potential problems caused dependency cognitive support adaptations 
codes event types shadowing observation technique 
summary data collected study 
list cognitive support claims visual caf 
coding scheme visual caf example 
trace table distributed planning activity episodes 
description goal plan labels 
frequencies coded actions type 
diagram contributions spread chapters 
protocol codes visual caf episode episode 
protocol codes second visual caf episode episode 
protocol codes third visual caf episode episode 
full visual caf protocol episodes 
xi list figures knowledge explicitness relation discipline maturation 
models pharmaceuticals possible cognitive support knowledge ecosystems summary rods computational advantage principles 
adt view interfaces mappings implementations 
virtual shared memory abstraction complicated interaction 
summary principles strategies modeling hasti 
simplified joint system model 
hardware level description user 
problem solving metaphor experts working blackboard 
schematic agent model showing generic agents panels panel data types 
mapping agent models hardware 
ordering behaviour categories adaptation preference fallback order 
imposes stratification agent model 
task taxonomy partitions agents task goals 
hierarchy support theories built rods hasti 
relationships artifacts examples theories tool ideas 
tentative leaves processing distribution 
fitness landscape visualization 
problems search 
roles theory synthesis versus evaluation 
magician design method 
resource flow model theory application design 
hypothetical example tabular form worksheet 
simplified flow rmtool sessions 
illustrations rmtool hlm reflexion model outputs 
refining agent model brooks comprehension model 
virtual blackboard illustration rmtool processing 
xii timeline main ideas tools 
typical observation configuration 
snippet coded field nodes verbatim 
participant error list 
participant second error list 
participant third error list 
xiii chapter current ability construct effective bridges chasm separates scientific understanding real world user behavior artifact design clearly falls short requirements 
required carry volume traffic equivalent lane cognitive highway 
offer akin unidirectional constructed strands rope 
phil barnard bridging basic theories artifacts human computer interaction pg 

ow tools useful 
tool usefulness explained 
tools useful 
hardly important questions tool researchers 
known related research question tools fail usable 
difficult learn instance confusing inefficient apply 
researchers frequently concerned usefulness usability 
usefulness helps answer question regardless usability bother tool 
go trouble learning 
build 
rule tool design useful making usable necessarily second close second 
issue usefulness certainly relevant researchers studying software development tools 
software development notoriously difficult costly consequently wide variety tools sought order 
tools vary character relatively automatic ones compilers analyzers highly interactive ones editors code browser 
real software development environments mix aspects automation human interaction 
adequately explaining usefulness tools challenging due intrinsic nature 
important software development tasks completely automated issue usefulness relatively unproblematic 
wholesale automation non trivial software development task practice currently exception rule 
tools generally need combination human users 
unfortunately issue tool usefulness problematic particularly tools meant humans 
reason purpose defined part terms user 
context se frequently related mental 
developing software difficult great extent mentally challenging 
tools interactively applied context usefulness ultimately dependent utility relating cognition thinking reasoning creating 
assistance cognitive called cognitive support 
explaining usefulness software development tools consequently involves able explain cognitive support 
main point tools thinking parts software development better easier faster 
software comprehension tools code browsers examples sorts tools cognitive support important 
primary reason tools exist easier developers understand software software development easier 
stands reason important evaluations tools relate affect cognition 
mental effort reduced 
developer knowledge improved 
cognitively difficult problems easier 
suitable account usefulness tools fail explain particular features tools give assistance essentially cognitive activities 
key challenge building credible explanations cognitive support 
developers currently think technological innovations tool presents irrelevant issues merely background considerations 
able explain cognitive support far reaching implications field 
ability adequately address important research questions hinges having suitable accounts 
research questions go simply scientific curiosity 
right sort theories allow engineer usefulness qualities computer tools principled manner 
allow evaluate compare tools terms cognitive issues better 
able open new avenues rigorously testing validating tools tool ideas 
course may able theories guide invention 
fair say entire research area se depends understanding cognitive support 
lies peculiar conundrum 
se research community presently ill equipped tackle research 
current research development methods involve uncomfortable amount guesswork poorly grounded science 
goal dissertation improve research design cognitive support se tools manufacturing appropriate theory resources 
resources include theories models techniques analyzing tools methods evaluating tools concepts frameworks notations designing new tools 
theory infrastructure essence 
conviction theories methods presently built transform se tools research current craft state regarding cognitive support principled engineering oriented grounded science 
unfortunately thesis reasonably proven test time 
specific restricted thesis proposed theories principles distributed cognition dc form broadly applicable starting point immediately applied possible process theoretical foundations se tools research 
thesis supported building theories trying see able address significant range important cognitive support questions 
tactic taken dissertation 
constructed integrative theories called rods hasti costh attempt package critical knowledge application oriented forms 
survey classify cognitive support common se tool features analyze existing se tools empirically observe cognitive support action 
clear adequate explanation cognitive support carry significant psychological content need explain reasons thinking problem solving development better tool 
appropriate science knowledge accumulating cognitive science psychology human computer interaction hci research 
theories need imported 
argued human cognition understood 
needless say subject human psychology far perfectly understood 
real world human cognition complicated domain software development extremely complex phenomenon 
need understand contributions complex tools development context challenge insurmountable 
humans complex development tools complex domain complex 
completely understanding cognitive support software development tools considered realistically speaking long term goal best 
time expect relatively moderate incremental progress science base 
blame current general difficulty topic 
roots immediate problems stem height hill climb steps taken 
lack suitable explanations cognitive support software development primarily due lack applicable theories 
due primarily general lack appropriate research effort directed specifically topic poor theoretical foundation building explanations cognitive support wide gulf separating research software development tools research psychology cognitive science disciplines contribute useful knowledge 
words cognitive support poorly studied se research little way suitable research framework accumulation actual support oriented theory difficult researchers cs se headway area 
reasons contributing state affairs 
discussed chapters 
reasons clearly fundamental cognitive support really hard understand study merely historical attention usability best described political researchers reluctant pursue perceived softer aspects tool research 
reasons absence suitable theoretical grounding significant impact se research 
suitable theoretical empirical treatments cognitive support may vital long term health tools research 
significant claims usefulness software development tools involve human related considerations psychological organizational sociological 
pressure mounting researchers approach tools claims capabilities qualities scientifically empirically 
doubt critical component systematic scientific study software development tools include psychologically explanations tools useful developers 
consequently topic cognitive support surely near top list issues deserving scientific underpinning 
considering theories needed current state knowledge field matter small gap understanding ugly chasm 
directed attempt helping fill chasm 
doing expected multiple benefits field useful saying goes theory 
comprehensive widely applicable theories models techniques developed employed better analyze test evaluate existing tools develop improved cognitive support tools 
efforts develop comprehensive cognitive support theories premature contrary overdue 
overdue current theoretical capabilities greatly underutilized 
borrow phrase norman pg 
isn realistic hope developing theory cognitive support long time certainly able develop approximate theories 
psychology solved hardly wait human behaviour completely starting project 
approximated theories grounded science better guesswork folk psychology better reason various assumptions hypotheses claims explicit comparable testable 
furthermore raw materials building suitable approximate theories decades fields psychology hci studied people tools se field wealth practical experience tools 
bits pieces needed making full fledged coordinated attack theoretical void 
barnard noted theorists currently offered little strands rope 
time right putting know better 
hardly right time pick extraordinarily focused aspect psychology tool order add tiny incremental piece knowledge 
moment field pressing need long parade tightly focused experiments papers ph dissertations 
chasm remain unfilled long way 
time dumping theoretical material hopes developing workable bridge spanning chasm 
need look big picture 
build fixed refined science advances 
say new basic advances important 
suitable theories developed may helpful determine certain important facts say programmers frequently switch attention different sorts information understanding software vans ph 
findings able inform theories cognitive support 
point material available building initial comprehensive widely applicable theories 
able construction approximate applied theories basic science research continues slow piecemeal process new knowledge software development tool basic psychology 
reason basic applied research operate parallel 
fact research programmes complement 
right applied stream concerning cognitive support se needs 
needs broad integrative treatment 
dc approach building cognitive support theories 
presents initial attempt building needed applied theories cognitive support determining apply se research 
approach taken typical applied sciences 
problem identified turn initiates search sister disciplines existing applicable theories models methods shed light problem 
second resources adapted order usable discipline 
initial theory constructed typically translation adaptation integration prior theories 
attempts apply existing problems 
new theory seed research 
theories iteratively evaluated augmented tuned 
initial theory development essentially exploratory character 
exploration theories cognitive support resources gathered adapted prior relevant 
raw materials part new particular collection presentation novel 
raw materials come prior research cognitive science hci psychology computing science 
main focal point theory building construction general framework making explanations cognitive support 
sort umbrella framework chosen approach termed distributed cognition dc picked 
details framework tricky core ideas simple state relatively short statements 
cognition usefully modeled computation 

computer tools computational systems 
developers tools modeled joint multi processing computational systems 
form distributed computational systems form distributed cognitive systems 

cognitive support provided tool computational advantages tool provides 
cognitive support understood entirely computational terms support provision computational advantage 

real world cognitive systems distributed 
new tools reorganize computations involved 
reorganization involves re engineering computations occurring tools humans 
design cognitive support computational systems re engineering 
collectively statements said form high level dc viewpoint understanding building cognitive support 
statement theory cognition distributed cognition 
key statements numbers 
statement theory cognitive support albeit 
statement theory cognitive support design 
crux elaboration statement chapter takes initial stab expanding statement 
course statements explain relatively little 
specifically sorts computations involved cognition 
cognitive processes important software development 
ways specifically processes distributed tools 
cognition beneficially reengineered 
details absolutely critical filled 
models cognitive processes involved software development need added 
models cognitive processes distributed tools 
details required turn general dc viewpoint framework explanatory power 
core part dissertation elaboration points way applied software development tools 
software development broad topic sub task development software comprehension singled focal task 
focus unduly resulting theories making task specific 
definitely skew presentation list software comprehension specific way 
dc viewpoint outlined consequently fleshed considerably examining models cognition applied software comprehension ways cognition may reengineered distributed order support comprehender 
continuing simple familiar example may help give reader basic flavour sort analysis involved 
example due norman pg 

simple shopping list scenario argue cognitive view tools artifacts 
argued artifacts normally considered simple quite inert quite naturally understood perform cognitive functions 
consider scenario going shopping food 
employ shopping list store names items need get 
write items list find household running 
list go store order sure getting items need 
check items placed cart 
point view need remember items shopping list 
fact checked items put cart needed mentally keep track items collected 
get merely scan list unchecked items 
shopping list serves external aid cognitive support 
shopping list need remember items require able recall store 
basic psychology common sense says relatively hard 
people prefer shopping lists relying memory shopping easier list better shoppers see example block 
simple shopping scenario illustrates important issues dc view cognitive support 
note list serves computational role memory device external memory 
shopping list means remember items items remembered holding list serves memory 
external memory sorts occur software development environments 
consider examples book design patterns acts long term shared memory history mechanism web browser acts personal short term memory 
second notice shopper shopping list form joint system 
just doing shopping combination external memory 
lost list lose memory need buy 
third observe behaviour performance capability joint properties system 
list perform shop differently just 
external memory extends capability possible things remember things easier better 

overview dissertation contents sum shopping list example serves illustrate sample concepts dc view cognitive support support understood computational terms behaviour joint human artifact systems especially human computer systems sort thing needs studied ways tools affect joint cognitive performance key issue 
notice importance cognitive level explanation usefulness value shopping list fully captured considering features qualities artifact degree automation efficiency number user functions considering human limited memory 
example simple involving non computerized tools character analyses software development tools directly analogous 
primary differences complexity joint system models especially concerning particulars cognitive processes involved 
simply put software development significantly diverse cognitively challenging shopping computerized tools offer richer distributions cognition 
overview dissertation contents structure dissertation minus introductions follows 
chapter motivation vision chapter describes current state affairs regarding computing science se currently approaches issues cognitive support 
chapter motivates orients remaining chapters 
argues search applied theories cognitive support idle quest satisfy curiosity important absent part rigorous se research programme 
provides guiding vision theory research list desired qualities needed cognitive support theories 
chapter represents engineering design acts build requirements analysis rough project plan set criteria testing 
chapter cognitive support phenomena chapter surveys phenomena studied defines cognitive support characterizes forms 
chapter words describes sorts benefits tools provide users 
things theories cognitive support seek explain 
simply describing various types cognitive support valuable step 
various conceptions cognitive support widely scattered literature sort review performed bring accessible 
review secondary contribution theory building 
reviews types cognitive support important se 
way establishes lower bounds required breadth coverage 
review necessary avoid problems associated building applied theories irrelevance 
broad review helps theory designer avoid 

overview dissertation contents chapter rods mere description cognitive support phenomena sufficient need explanations 
chapter presents framework building various explanations cognitive support comprehensive framework researching studying cognitive support 
se currently framework speak 
framework built pre existing ideas taken dc hci 
key part framework proposal understand cognitive support purely computational terms 
particular cognitive support identified computational advantages artifacts engender cognition improved 
catalogue types cognitive advantage developed task reduction algorithmic optimization distribution specialization 
hasti gets name principles 
cognitive support principles central feature framework studying cognitive support 
framework provides general way analyzing comparing tools cognitive support describes principles abstracting generalizing support arguments 
centrality support principles overarching framework named rods 
result chapter widely applicable framework understanding cognitive support computational terms expressing arguing claims tools support cognition 
contributions absolutely essential applied research programme cognitive support 
chapter hasti rods effectively produces explanation cognitive support phenomena providing computational account underlying mechanics cognitive support 
explanation level useful se 
order systematically apply computational account tools research detailed models expected frequently necessary 
particular computational models human computer systems built order support principles applied 
modeling framework developed chapter called hasti 
rods lists ways beneficially reorganizing cognition need know cognition arranged 
expected critical requirements models capture important knowledge user psychology especially respect tools 
hasti tailored specifically needs application oriented researchers 
need abstractions simplifications important issues cognitive support efficiently raised addressed 
need pre built models rapidly widely applied yield insight 
result intended suitable high level design reasoning quick dirty analysis 
name hasti acronym modeling structures decompose model hardware model agent model specialization hierarchy task taxonomy interaction abstraction model 
decompositional structure important analyzing cognitive support 
hasti modeling framework simply single model understand particular human computer interactions modeling framework exposes computational principles rods concepts applied generate support explanations 
importance able apply rods concepts models outlined chapter 

overview dissertation contents chapter costh number type cognitive support arguments analyst capable making depends power theoretical build explanations 
chapter demonstrates rods hasti combination generate diverse cognitive support arguments 
capability shown applying various support principles rods modeling features hasti 
analysis generates hierarchy cognitive support arguments called costh 
metaphorically speaking nodes costh cognitive analogues systematic variations simple machines lever inclined plane 
simple machines types cognitive support combined complicated ones 
support argument shown able theoretically reconstruct common tool ideas literature 
support arguments act generalized argumentation schemas specialized specific instances tools order create tool specific arguments cognitive support provide 
initial attack generating systematic reusable design knowledge 
chapter design chapters focused primarily theory building secondarily tool analysis understanding evaluation 
chapter focused squarely design 
possibilities cognitive support theories potential guide tool design 
chapter begins analysis ways theory guide design 
analysis argued cognitive support framework built uniquely positioned offer particular form design knowledge point rare 
specifically costh offers possibility guiding fp reasoning 
fp reasoning essentially reasoning features add tools useful 
type theory contrasted prior theoretical works informed design primarily suggesting design goals constraints 
analysis different ways rods hasti costh proposed making theories easily applied practitioners early design envisionment 
sorts design theories relatively rare hci chapter concludes overview dissertation provides evidence costh useful source practical designer resources 
chapter analytic evaluation chapter begins evaluation theories modeling techniques proposed previous chapters 
meant application oriented primary issues evaluation useful broad scope 
questions answered primarily demonstrations theoretical toolkit action 
specifically rods hasti costh applied high profile reverse engineering tools order analyze cognitive support 
guinea pig tools strategically chosen order topical se research try exercise theoretical framework 
evaluations serve demonstrate applicability theories questions relevant current research interests se 
demonstrate ability preliminary skeletal toolkit interesting statements tool features levels 

overview background sources process theory toolkit shown able reconstruct existing claims experiences guinea pigs 
correspondence theory derived arguments craft oriented knowledge builds confidence validity theory craft knowledge 
chapter field study chapter explores possibilities applying rods hasti costh realistic research development 
chapters primary concern analytic power ability theories models explain predict cognitive support ability generate useful design ideas 
chapter issue rods hasti costh employed empirical studies lightweight manner 
able expected key enabler practical theory tools development 
theories limited 
rods hasti costh provide basic theoretical infrastructure making interesting cognitive support arguments answer questions 
user studies needed 
theoretical framework kick start user study allowing researcher focus answers specific questions pertaining cognitive support 
chapter explores possibility field study software development testbed evaluating various observational techniques 
aim provide insight cognitive support theory applied realistic tool development contexts 
provides initial demonstration claims cognitive support support observed measured claims empirically validated 
overview background sources dissertation focused big picture concerning cognitive support theories applications real analysis design 
necessitates drawing wide range prior 
simpler target particular restricted cognitive support issue 
smaller selection prior works building materials 
simpler better integration hard necessary especially results fields usable palatable se 
result rests shoulders academy researchers cognitive science psychology hci 
main sources prior works distinguished 
basic cognitive science psychology particularly dc psychology software developers 
substantially inform modeling chapters 
basis explorations empirical methods chapter 
second main source applications psychology hci systems design 
relied extracting basic foundations understanding support chapter 
third main source prior research applied theory building 
ideas past theory building activities basis chapter 
final main source prior se tool research literature 
literature contains wealth tool ideas pervasively ground discussion particular domain application 
collected wisdom 
overview contributions field relied order calibrate theory building effort generates research problems solve establishes requirements theory building theory application initial check sure applications helpful sense 
cognitive support theories applications methods exist prior cognitive science hci related disciplines 
likewise suitable application theories se problems past se 
overview contributions contributions dissertation categorized chapter contents 
addition contributions additionally classified core contributions side effect contributions 
core contributions reflect dissertation main research questions 
side effects contributions ones needed order answer main research questions 
preferable need side effect contributions contributions fit tightly 
contributions broken theory building theory application survey contributions 
contribution labelled status core side effect contribution 
theory building vision tools research 
vision tool research provided chapter 
vision suggests tools research guided cognitive support theories 
theory guided research may able resolve significant inadequacies current research methods including difficulties comparing designs constructing evaluating claims tools establishing proper burdens proof tools researchers se cs 
integrated simplified cognitive support framework 
chapter chapter computational foundation explaining cognitive support 
foundation terms dc theories 
critical parts framework 
principled decomposition meaningful ways performing comparative analysis cognitive systems way evaluating differences different support principles 
second method analysis generating arguments artifacts provide cognitive support 
ways comparing joint cognitive systems principled way generating arguments adequately articulated prior 
cohesive integration simplification non specialists particular problem past 
cognitive support arguments 
chapter presents organized collection theories cognitive support 
theories reusable generalizable arguments artifact features lead cognitive efficiencies 
arguments form literature provided framework treating uniform integrated manner 
rods hasti prior arguments directly generated 

overview contributions shows support treated minimum underlying theoretical apparatus 
consequently statement cognitive support shows complexities support reflect complexities cognitive systems involved cognitive support complicated way simple supports composed arranged 
similar theoretical frameworks support analyses exist know showing wide variety cognitive supports explained appealing small set fundamental principles 
secondarily demonstrates variety cognitive support types generated simple support principles combination models cognition 
broad range specific cognitive support explanations generated principles psychological computational 
unified dc framework cognitive support 
dc promising theoretical framework relatively weak tradition modeling cognition distributed human artifact 
polished form wide se 
chapter extracts focused portion ideas dc related literature 
chapter chapter add existing dc modeling repertoire 
chapter takes mechanisms traditional cognitive science build generalizable models expands generalizable models joint human artifact cognition constructed 
unification comparison cognitive models 
cognitive models abound principled ways exist unifying 
chapter provides way unifying previously disparate model types 
key innovation way separating distinct modeling aspects mapping 
hasti decomposition mapping approach question allows different modeling traditions discussed unison 
theory application cognitive support analysis software comprehension tools 
software comprehension tools proposed evaluated adequate justification claims support 
omission impossible engage principled analysis features offer support 
lack theory analysis hinders tool comparison empirical validation claims application ideas embodied tools 
chapter provides theory analysis cognitive support theories chapters 
fills missing support argumentation 
design implications theory 
generating design implications directly psychological theory uncommon 
design implications derived indirectly theories indicate common cognitive overload design experience suggest possible resolutions 
chapter attacks problem generating design implications showing cognitive support framework provides scaffolding resource structuring early design way reasoning forward existing possible existing systems new ones 

overview contributions survey review cognitive support research 
research cognitive support widely scattered little cross discipline cross ideology unification comparison 
chapter adds broad review core ideas artifacts support cognition review research paradigms applied understand cognitive support overview research disciplines independently researching cognitive support 
contribution demonstrates collection common phenomena subject domain independent research discipline seeks attempts explain 
may surprise readers part chapter chapters considered peripheral main dissertation questions 
note side effect contributions directly address dissertation main questions contributions unnecessary minor 
designating contributions side effects merely reflects theoretical gap dissertation pragmatic goals current state science cognitive support 
build desired application oriented theoretical necessary shore required theoretical background 
chapter need cognitive support theories successful system demonstrates success possibly implicit psychological theory underlying design articulated 
alex requirements psychological models support design pg 

field software engineering se need research stream studying cognitive support software development tools 
se part just realize 
primarily lack awareness chapter necessary 
subsequent chapters propose theory resources studying cognitive support software development tools 
resources intended initial seed thorough ongoing studies theories models cognitive support 
initial seed key contribution issue technical albeit difficult problem producing decent initial theory theory immediately little discussion necessary 
reality situation field little attention paid question properly research develop cognitive support tools times cognitive issues ignored avoided 
importance cognitive support research stream fully realized matter theories proposed actions taken rectify situation 
addition describing initial seed theoretical framework elaboration needed research context needed seed grow evolve 
reasons cognitive support poorly respected 
main contributing reasons appears social cultural 
specifically result ways tools perceived researchers developers way cognition related research understood conducted 
side spectrum opinions technology oriented researchers little background patience psychology cognitive science 
view social science related soft irrelevant 
researchers may easily 
case cognitive support research persuaded knowledge cognitive science psychology integrated practice se cs research 
assumed tools adequately developed evaluated absence psychological knowledge 
attitudes known dawn modern hci decades ago prevalent day 
nearer spectrum convinced nearly attempt understanding cognitive activities developers ultimately useful welcomed 
side effort argue positions peers blind psychological research turn useless useful 
reality positions hold grains truth topic deserves debate elaboration 
exploring debate capability clarify goals expand differences various approaches understanding cognitive support provide vision research field 
healthy field study cognitive support able produce arguments temper unrealistic optimism possibilities understanding cognitive support convincing case pursuit 
problems theories cognitive support address 
sorts things need said 
sorts issues outside area concern 
builds theories uses 
remaining part chapter consists debate possibilities roles theories cognitive support se cs research 
debate structured set topic defining questions cognitive support interesting problem se 
need theories cognitive support 
build 
theory related research 
questions asked subsequently debated separate sections 
section focus evaluating current research practice 
problematic issues traced lack cognitive support research 
section question remedy problems addressed 
debates picture emerges discipline definitely concerned cognitive support reasons able properly research cognitive support due lack suitable theory guided research stream 
section argues theories cognitive support best developed providing philosophical vantage point remainder dissertation 
section summarizes debate 
case cognitive support research computer scientists broad claims simplicity naturalness ease new computer languages techniques take advantage opportunity experimental confirmation 
ben shneiderman software psychology xiii cognitive support important research focus se cs 
researchers concerned understanding cognitive support 
subsections argue answer accounts 
section argues subject cognitive support critical appreciated 
case cognitive support research part se cs research 
section argues call explicit theoretical research cognitive support reasonable simply call render current practices principled scientific 
cognitive support percent curious observe authors field programming logic formal aspects require painstaking demonstration proof informal aspects satisfied subjective claims slightest support argument verifiable evidence 
surely common sense indicate manner scientifically unacceptable 
situation programming logic outlined part widespread pattern attitudes manners prevailing academic computing mathematics tend accept sales talk place scientifically sound reasoning 
peter naur place strictly defined notation human insight pg 
old tester adage goes follows software development consists understanding program writing program documenting 
involves testing years software design construction received great deal attention expense critical aspects software development maintenance testing 
gist adage easily apparent difficulties particularly advertised part problem may obscure difficulty parts problem 
testers difficulties designing coding software emphasis 
argue developers need change attitude testing 
saying issues warning woe fool thinking job done development ceases remaining task testing may back breaker 
adage strictly true testing similar sentiment certainly applies regarding cognitive support treated se 
world software development tools lion share attention focused providing automation clear formal precision 
computing science developed numerous formalisms logical frameworks languages computational techniques brought bear formalizing development problems specifications documentation design automating parts development 
instance parsing semantic analysis translation techniques possible modern compilers translate code written high level languages humans write byte sequences computers understand 
compilation fact greatest achievements automating software development 
large degree eliminated tedious error prone process programming assembly language led tremendous productivity gains 
automation essentially achievable parts software development reach current capabilities formalization 
unfortunately reach extend far 
true automatable tasks software design tedious mundane 
case cognitive support research repetitive parts 
simply regular structured tasks easily automatable 
fact quite fortuitous sorts activities tend exactly tasks developers wish avoid 
course easily formalized tasks artificial intelligence ai techniques employed 
widely acknowledged tools significant intervention required part developer reverse engineering 
despite strong focus formalization automation researchers software development activities immediate danger fully automated 
automation formalization clearly important foci tools research entirely possible concentrate goal 
fact successful automation invariably exposes weaknesses 
brooks argued design removes inessential complexity 
similar argument automation removes unproblematic 
development better better forms automation slowly picks away easily automatable parts problems hardly expect 
capacity formalize automate limited routine predictable 
limitations tend ensure landauer put easily reached fruits picked pg 

left developers 
mentally challenging creative error prone parts 
referring back old tester adage parts expect automate constitute tool support issues 
developers stuck 
corresponds difficult ill defined non routine parts 
thinking parts software development essentially cognitive 
consider example automatic program translation compilation 
compilers completely eliminated translating code human level programming languages machine level tasks left developer perform 
designing programming debugging testing 
successful automation away routine structured problems leaving ill defined poorly understood ones 
support residue cognitive support 
automation hogs spotlight cognitive support problem may easily equal 
woe ignore 
automation oriented research cognitive support research needed 
need met 
considering significance cognitive support tools research little explicit attention 
fair say barely scratched surface 
adequate understanding cognitive support software development requires minimum attention aspects cognition software development 
cognitive processes cognitive processes resources important software development understood 
adequate treat unknowns mysterious quantities 
thinking done developers practice totally eliminated complain dichotomy cognitive processes cognitive support false cognition supported external artifacts people point irrelevant categories describe research emphasis developer psychology vs support principles research topic cognition 
attention focused tool user relationships related primarily individual cognitive psychology obviously aspects cognition organizational social dimensions clearly relevant see carroll 

case cognitive support research changed form 
matter tool human invariably operates cognitive processes doing appreciated 

cognitive support principles means cognitive processes supported aided tools understood 
study cognitive processes step understanding tools beneficially alter replace 
learning existing development processes sheds little light change tools 
speaking informally say study cognitive processes concerned elaborating requirements tools support cognition study cognitive support concerned forms solutions ways increasing level cognitive support 
addressing cognitive processing support challenging case software development tools exceedingly rare 
cognitive support particular fair share attention 
contention may argued considering infrequently tools thought terms assisting harder parts development human problem solving cognitive processes explicitly considered studied cognitive support explicitly considered studied 
counts attention lacking 
consider characterizations software development tools main software engineering environment see requirements software application developer viewpoint see seen providing help routine mundane tasks associated software development example producing documentation 
see remove hinder creativity innovative aspects software development crucial enjoyment job satisfaction software application developers 
pg 
software development tools designed assist software developers producing quality products minimum time 
tools provide assistance enabling users perform creative intellectual activity optimal conditions preventing detecting human errors occur relieving users routine mental physical activity associated productive process 
pg 
reveal certain common attitudes tools 
tools understood actively helping developers creative intellectual activity merely enable activities 
phrasing sentences gets feeling constitutes creative intellectual activity quite outside area concern tool developers left 
sake contrast consider alternative characterization software development tools software development tools aid developers participating thinking 
assistance include helping complicated decisions context uncertainty restricted knowledge helping track thought processes assisting evaluating program quality 
point views wrong definitions illustrate common means universal set attitudes concerning importance placed understanding 
case cognitive support research developers think roles tools supporting thought processes 
particular issue cognitive processes marginalized concept support tools limited automation especially mundane parts development 
represented certainly exist excellent considers cognitive processes software development 
deal trying determine process software comprehension example see von mayrhauser vans compared 
cognitive oriented entirely possible methodically study cognition software development fail adequately advance understanding support processes 
research instance focused improving cognitive theories models software developers regard tools involved 
sorts works central issue typically inner environment comprehender mind outer tool context inner environment relates outer 
software comprehension maintenance research inner cognitive models modestly popular 
studies cognition failed shed light principles cognitive support 
difficult see inner model theory shed light principles cognitive support 
known impact tools cognition tools assumed impact 
problem simply cognition cognition oriented field builds knowledge developer behaviour developer psychology knowledge tools mediate modify support behaviour 
models developer behaviour considered typically believed apply development environments significant modification 
consequence power statements cognitive support provided tools 
say interesting cognitive support models need indicate change tools development environment changes cognition 
model able logically necessary take account significant aspects developer environment 

complaint strongly voiced bellamy gilmore discussing studies planning programming strategies understand psychology complex tasks programming need consider planning strategies particular task contexts 
theories planning problem solving spent long heads sand ignoring role external world plays determining behaviour 
psychology going significant contributions theoretical applied areas research need investigations features external world determine behavioural strategies 
able produce artifacts support effective task strategies 
pg 
said issue chapters 
goal establish topic cognitive support failed receive due attention consider example implications 
raison etre cognitive model formalize knowledge cognition 
cognitive models enable think reason cognition 
raison etre cognitive support theories formalize knowledge support cognition 
cognitive models directly allow reasoning support 
failure systematically model explain cognitive support imply 
case cognitive support research researchers fall back background knowledge informal reasoning understand tools support cognition 
case point consider body von mayrhauser vans information needs software 
von mayrhauser vans developed model software comprehension applied analyze comprehension variety tasks environments 
wished knowledge gained sorts studies developing better tools 
case interest research poor cited quite widely positively example research cognition really study cognitive support 
kind knowledge discover 
main contribution analysis information needs software comprehension description sorts knowledge software seek 
call comprehension process knowledge comprehension support knowledge 
statement cognitive activities say artifacts activities better way 
limitation stems fact model inner model works packet front computer full sophisticated software 
go state information needs met variety tools specific tool suggestions 
moment question learned support comprehension 
information needs analysis say support 
role model studies 
resources employ reach suggestions tools 
information needs analysis said little possible means supporting comprehension 
earlier sorts tool suggestions primarily lines analysis search filtering display mechanisms various types program information hypertext browser 
understandable focus information seeking 
consider infer effect software seeking particular pieces knowledge main role tools satisfy knowledge provide information 
comprehension easier tools seek eliminate needs particular forms knowledge way avoid comprehension problems 
providing knowledge tools 
point models studies prompted prevented making sorts suggestions 
model studies neutral respect forms cognitive support 
reasonable way explaining list tool suggestions background knowledge see section common forms tool support address point section models provide analysis support provided various suggestions greatly help generate list 
complaint way suggests sort valuable 
just points cognition oriented research field part failed methodically investigate cognitive support 
outstanding methodical cognition fail adequately study cognitive support 
pattern illustrated von mayrhauser vans information needs common studies concerning development tools 
general form recognize model cognitive processes common action sequences knowledge look support ideas intent automating portion 
weiser instance 
case cognitive support research discovered characteristic form causal reasoning debugging backwards dataflow resulted research automated 
singer learned modeled activity patterns software maintenance got main design ideas brainstorming sessions directly models activity patterns see section 
pattern studying cognition software development stopping short studying cognitive support having fall back reasoning informally background knowledge suggesting designing new tools 
returning question section asks seen cognitive support research topic appreciated insufficiently studied 
cognitive issues bypassed entirely developer cognition studied subject cognitive support typically ignored frequently amounts falling back background knowledge relatively simplistic design reasoning 
folk tacit science knowledge intuitions experienced designers typically play crucial role artifact development 
drawing experience designers astute interpreting user difficulties relating problems design artefact interface 
tacit acquisition application knowledge may serve purpose design contexts requires skill judgment easy develop share 
motivates search supporting techniques frameworks analysis cognitive issues artefact interface design systematic results analysis accessible recording exploring communicating 
benyon interactive situation models cognitive aspects user artefact interaction pg 

research field consideration explicit theories cognitive support 
despite managed produce tools appear dramatically improved cognitive developers 
historically speaking advancement entirely unsurprising 
frequently noted applied domains technology advances apparently needing secure explicitly theoretic scientific foundation 
example bridge building successfully practiced basic mathematical techniques structural mechanics mature similar story holds steam engine 
sutcliffe note typical pattern hci new ideas codified exemplary artifacts abstracted explanations principles pg 

historically unsurprising surely curious amazing successful 
little having painted mona lisa having sight 

things realized tools research se great deal knowledge cognitive support tacit folk knowledge 
knowledge developed long term intimate exposure problems software 
case cognitive support research knowledge explicit tacit craft engineering time knowledge explicitness relation discipline maturation development remains great extent developed 
researchers field extensive training software development accomplished developers years hands experience designing tools 
knowledge developed sort extensive practice called craft knowledge 
enterprises tend experience tend hand knowledge long processes called craft disciplines 
craft disciplines mature frequently able tacit craft knowledge explicit directly form theories models rules 
time wisdom tends predominantly folk craft 
basic progression craft engineering formalization knowledge illustrated 
knowledge quantity represented height bar makeup explicit vs tacit knowledge indicated depicting split tacit explicit knowledge 
diagram tacit knowledge reduced forgetting things converting explicit knowledge 
engineering disciplines recognized having significant explicit content practical experience knowledge important ch 

maturation process tacit knowledge converted explicit articulated knowledge 
knowledge applied increasingly controllable predictable methods 
long say craft disciplines give way engineering disciplines personal experiential knowledge replaced design principles invent test practices say trial error replaced specify implement practices 
pg 
progression tools research se 
significant extent currently craft discipline regarding knowledge cognitive support 
effectively engaging applied amateur psychology social science consciously think 
tools build carry significant psychological sociological impact altering instance problem solving program development done 
craft discipline evolved 
past new tool ideas reported simple sorts argumentation empirical evaluation normally considered sufficient 
partly 
case cognitive support research primary focus technological innovations tool design partly little emphasis placed greater formality rigour argumentation evidence 
authors greatly helped simple fact tools fundamentally similar existing tools dissimilar 
tools complicated entities features similar hundreds ways dozens tools 
reviewers papers introduce new tools similar tools intuitively grasp advantages advantages fully articulated 
situations greatly lessen need authors fully articulate test reasons tools beneficial rely reader familiarity tools cognition related benefits 
consequently past main emphasis naturally directed technical innovations features community achieved consensus beneficial 
little impetus develop clearly defined terms concepts concerning cognitive support little emphasis placed formal rigorous testing basic support ideas 
addition substantial cultural bias social sciences related issues academic computing regarding tool design see curtis curtis green 
consider simple illustrative historical examples principle 
early programming environments batch oriented interactive programmers normally wrote programs submitted operator collected output printout 
computing online advent cheaper time sharing systems subsequently personal workstations new forms interaction possible direct manipulation environments mice 
interactivity innovations related making better human computer interaction merely computing effectively 
innovations introduced basic forms potential benefits known authors promoting considerable efforts describe basic features relate relatively soft issues improving human computer interaction 
instance baecker needed argue close interactivity time sharing systems permitted qualitatively different better debugging interactively examine data program ran 
similarly teitelman writing era modern windowing environments commonplace spent considerable amount time describing mouse multiple windows screen useful developer 
nowadays ears explanations may excessively detailed virtually waste time explaining features detail debating possible advantages batch oriented text interaction 
original papers arguing basic concepts surely considered important bases software development tool research rarely cited 
questions remain superiority new tool features wysiwyg editors really better 
understood community domain tool appears simple grep surely tool embedded larger collection tools see lethbridge 
example teitelman says mouse small object buttons top 
user views environment display consisting rectangular display windows 
windows frequently overlapped screen pg 


case cognitive support research generally beneficial interests lie 
remembered lessons part craft knowledge moved 
similar things happened support ideas 
remember lessons learning achieved 
way craft knowledge preserved generally speaking development propagation explicit explanations tool features useful 
methods involve explicit theories cognitive support 
tacit understanding researchers won experience 
exceedingly example tools researcher se significant experience multi tasking windowed environments 
experienced great discomfort forced forced switch single tasking environments pc dos impossible rapidly switch applications 
value effective multi tasking environments hardly worth explaining 
ideas similarly accepted exposure 
second main store cognitive support knowledge tools 
carroll noted artifacts embody type wisdom psychology users activities engage 
properties multi tasking windowing environment says problem solving methods users 
instance utility having separate windows easy switch focus implies need user context switch attention rapidly 
automated type checking compilers implications types errors committed programmers 
ubiquitous undo feature speaks volumes slips errors exploratory tool 
hard importance tools support knowledge 
designing new tools designers frequently familiar exemplary artifact form starting point modify suit situation 
carroll called sort designer reasoning hillclimbing predecessor artifacts 
example envisioning tool features thinking hypertext developing code browser proceed experiences hypertext systems 
copying existing successful tools doing reusing knowledge successful cognitive support tacitly encoded tools 
knowledge embodied tools create place 
possibility great extent accidental tools built knowing priori thesis expanded chapter 
psychological supportive knowledge embodied tool may known designer advance 
iterative testing weeds features incorrectly understand psychology user separates nuggets gold dirt 
means pure guesswork somewhat lucky occasionally rewarded 
furthermore lucky need lucky tool design normally highly iterative big guesses broken sequence tiny guesses checked proceeding 
ignorance principles cognitive support presents absolute barrier development better forms tools long designs preserved accumulated communal known tools see chapter 
consequently better tacit knowledge principles cognitive support accumulate explicitly theoretical secondary artifacts descriptions tools patents 

case cognitive support research understanding 
main method accumulating principles currently tools 
tools copied ideas propagated 
se researchers may wish rely lucky guesswork 
researchers educated guesses sources knowledge available 
guessing results faster convergence designs 
better guesses se researchers watch people try understand thinking processes try introspect thinking processes reason plausible tools support 
perform case studies visit collaborate working programmers field order observe developers authentic 
fact tools researchers currently 
folk psychologists weekend armchair sociologists 
case studies expert opinion deep field experience heavily valued community 
form experimentation widely 
researchers changes prototype tool observe developers react soliciting feedback reports users 
short se researchers tools sociologists psychologists informal rigorous controlled manner 
distinction acknowledged science discipline sorts craft disciplines respects surprisingly small 
claim cognitive support studied quite incorrect characteristics study craft discipline science discipline 
summary tools research se historically managed creep craft discipline 
knowledge support ideas created intuition guesswork knowledge encoded passed form tools knowledge reused adapting existing tools design 
knowledge cognitive processes software development support lies latent tools 
appreciation principles gained hand experience tools person observation 
craft discipline resembles certain ways applied science design science representations knowledge explicit methods lack proper rigour 
call explicit investigations cognitive support call render current activities scientific principled 
interesting take difference science non science see sagan particularly chapter 

problems theory thin discipline problems theory thin discipline workshop software engineer insisted criterion assessing psychologists offer save money development 
ears doubt perfectly reasonable 
ears case double standards 
software engineering community sinks vast sums systems case tools collective delusions nature design process 
community ought interested refining beliefs bringing nearer reality 
ask expert thought processes give financial estimate value gained refining software systems obviously piece 
green software engineers don listen psychologists don tell anyway pg 

cognitive support studied tools research se really need new theories cognitive support 
managed proceed quite successfully primarily craft discipline 
se fundamentally interested cognitive support important ask theories models cognitive support really needed 
status quo fine 
simple counter argument goes follows try 
little lose potentially gain 
tempting leave argument point instructive evaluate existing research practices consider ways problematic strictly inadequate 
constructive criticism provides informative motivation improving quality character discipline 
identify problems trace lack appropriate theories may find dark horse theoretical approach cognitive support promising option 
points need clarified order avoid confusions focus section 
topic section practice se research 
point clarification concerns relationship hci 
field se tools research overlaps partly hci fields math logic psychology 
readers strong hci backgrounds points brought section may familiar points known se research circles bear repetition 
furthermore section simply review hci literature attempted directly relate literature se research 
subject overlap hci specific viewpoint se researcher issues 
second point desirable distinguish topic content se hci research practices se hci mean research publication activities participants field 
subjects hci se may overlap research practices 
final point desirable distinguish se researchers se practitioners 
normally interested making specific tools possible known principles usually build tools order discover new principles 
reiterate 
problems theory thin discipline primarily concerned research practice se research community 
may gained expanding critique practitioners se hci left 
key evaluating research cognitive support realize research programme se routinely trades ideas claims explanations cognitive support 
group interested question constructively aid hardest cognitively challenging parts software development 
routinely strive software development easier simultaneously recognizing main bottlenecks conceptual cognitive nature 
concern cognitive aspects clearly revealed research topics 
notations evaluated clear easy understand tools claimed natural intuitive easy learn 
languages easy program comprehend 
surprisingly activities consequently involve talking reasoning psychological issues cognitive support trying develop new technology aid software development comparing different tools evaluating testing ideas educating new researchers 
part practice effectively dialogue concerning cognitive support 
push explicit theories desire increase precision formality activities engage 
insisting theories grounded scientific research methods essentially demand rigour 
explicit science grounded theories lacking expect see problems research programme symptomatic discipline missing organizing influence comes strong science practice modeling methodically investigating issues discipline core 
sections argue exactly find patterns research se cs concerning cognitive support tools 
scope thoroughly discuss problems important points touched 
argument research centred theories cognitive support consonant goals science research computing expanded 
key difficulties tool argumentation evaluation design surveyed difficulties related lack suitable theories guide research 
survey problems research practices summarized table 
portrait emerges survey field faces troubles stemming lack theory guided research stream 
activities evaluation testing analysis design research problems difficulties support claims poorly articulated tested tool testing needed burdensome problematic tools researchers forced cognitive science informal analysis suffers concept lexicon poverty deep knowledge psychology cognitive science needed design affected theory late table summary problems se research practice due lack cognitive support theories 
problems theory thin discipline evaluation problems simple comparison imagine study determine apples better oranges dream conducting am fairly certain depend john karat fine art comparing apples oranges pg 

ideas tools generated need evaluated tested 
supposed instance multi focus fisheye interface beneficial understanding software shrimp 
evaluate ideas 
problems face evaluation 
prominent empirical evaluation methods explored sequence scenarios interleaved discussions problems illustrate 
summary comparison practices table problems encountered table 
scenario ad hoc evaluation elsie idea new program analyzer browsing interface navigating information analyzer extracts tool similar sniff rigi 
designed tool built prototype belief tool easier programmers understand code 
know idea 
arguing software comprehension hard expensive tool support needed tool incorporates functions scrolling search clearly useful navigation interface natural intuitive easy learn 
features program comprehension easier suggest interface exploits powerful mental capabilities user tool supports user activities functions needed user 
informally tests tool sample problems order iteratively improve prototype writes experience report 
fairly level justification elsie particularly argued previous section researchers primarily interested technological advances great degree consensus value main parts tool environment 
increasing pressure provide stronger theoretical empirical evidence quality ideas 
elsie colleagues wanting better evidence proof 
approach elsie try tool comparison style validation experimentation 
sort experimentation picks performance measure interest total maintenance time instance compares developer performance differing tools 
aim establish relation input variables tools output variables measured performance 
type models mathematical formulas predict relation called theories 
elsie case try establish tool results faster maintenance specific set tools selection common ones 
style experimentation appealing elsie potential establish superiority tool measure maintenance speed requires understanding fine structure processes 
problems theory thin discipline software maintenance principles tool caused desirable output 
technique possible establish tool helps maintaining maximal ignorance reasons succeeds 
similar sorts experiments verify adding yeast bread triples height know whatsoever biochemical action yeast heard carbon dioxide 
elsie treat user tool unit black box maintenance problems go objective quantitative data comes 
need pondering psychological effects need arguing theories support 
question formidable selling points se cs researchers basic orientation empirical goals informal black box unguided cog 
model theory testing comparison observation observation early feedback informal feedback serendipitous discovery adoption justification evaluate tool promise tool validation find performance improvement discovery learning discover key factors understand context behaviour discovery improve cognitive model generation investigation support hypotheses verify support hypothesis measure support observation focus tool output variable scenario task user problems human actor tool effect effect mechanism study scope tool key features program program environment frequently ignored 
fea specific tures claim characteristics informal simplistic questions discovered informal support mechanisms perceived threats method folk beliefs statistical validity replicability discover new ecological statistical validity incompleteness irrelevance claim articulation level benefit explanation type explanation knowledge source informal ad hoc descriptive folk informal ad hoc human oriented model avoided observer dependent tacit expertise observer background informal tacit psychological training human tool model theory theory table comparison methods evaluate tool ideas 
problems theory thin discipline serious problems method 
scenario black box methods part elsie decides try comparison quickly runs troubles 
tool prototype containing thought minor usability flaws 
finds flaws appear significant practical impact subjects really affected 
feels able fix problems rounds usability testing tool improvement 
take months years gets right wonders really worth effort chance idea fundamentally flawed 
despite possibility prototype real gem rough discovers missing inappropriate extra features entirely confound effects gem experimental output 
furthermore research tool novelties usage hard find experts 
elsie watches pilot subjects ignore novel features struggle experimental design forces try 
begins suspect tool potential subjects need months long term exposure proficient point pro pulling iron bag just right circumstances special capabilities tool integrated unconsciously strategies problem solving 
watches control subjects habitual tools highly ways wonders comparison experiment entirely fair 
scenario black box methods part despite initial difficulties elsie fixes tool adding functionality cleaning interface manages recruit handful expert subjects runs selected tools head head 
unfortunately results somewhat disappointing sees modest improvement data exhibits uncomfortable levels variability performance 
factors controlled randomized 
fixes tool runs test gets marginally better performance 
sort performance improvements hand probably publish results really questions began 
adapts tool new programming language forced repeat process 
say destroy benefits tool modifications 
submitting results publication tries tool different maintenance problems discovers results vary considerably 
practice validation style experimentation evaluating tools quite widespread spectrum se research 
evaluating software visualization reverse engineering tools 
shares long history evaluations different software development techniques languages programming notations object oriented language features program indentation formatting techniques :10.1.1.39.1475
aims methods noble increase scientific foundation software engineering 
context idea evaluation ways methods undermine effort 

problems theory thin discipline practices problem sources problems encountered informal evaluation informality methods arguments data explanations simplistic questions weak results fails cumulate knowledge simple comparative tool evaluation prototypes validation idea validation late black box methods iterative prototype stopping criteria unknown improvements explanation avoidance minimal theory applied improvements weaken core arguments support concepts poorly articulated support concepts indirectly tested heavy dependence observer excellence analysis difficult undirected mismatched goals learning cognition support observation inappropriate methods burdens theory argumentation uncertainty fishing expedition tool shortcomings highlighted successes cognitive model model weaknesses issue support addressed observation mismatched goals learning support mechanisms burdens theory argumentation table evaluation testing problems compared promises theory research discussion am primarily concerned issues methodological rigour experimentation 
concerns brought times past studying right populations programmers toy problems properly controlling variables properly emphasizing effect size reliability statistical significance developing improper statistical tests replicating results :10.1.1.17.1239
ecological validity critical issue hci se problem potentially addressed sort experimentation 
instance techniques applied experimental cognitive science ecological psychology developed handle style experimentation ecologically valid circumstances 
course methodological issues important 
concern proper execution asking wrong questions applying reasonable techniques inappropriately 
sources problems simplistic questions asked tools tested evaluating tool ideas explanations benefits tools developed tested 
problems outlined 

problems theory thin discipline simplistic questions strictly extreme empirical study performed theoretical underpinning utility study limited 
contrast theory provides guidance targeting behavior study assessing study results 
karen whitley visual programming languages empirical evidence pg 

human activity software development complicated surprise comparative evaluation tools techniques software development quite difficult involved 
pointed long time ago said evaluations sight straightforward matter comparing performance groups similar programmers different programming techniques 
unfortunately complexity programming behavior execution interpretation comparisons straightforward 
pg 
particular problem sort questions posed validation style experiments 
frequently overly simplistic especially regard sorts cause effect relationships sought 
carroll said hci field suffers methodological bias posing elegant research questions away variables task context pg 

decade ago green reviewed field noted early studies asked simplistic questions logical conditionals better arithmetic ones flowcharts better code nested conditionals better gotos easy see today general answer going better things worse 
pg 
simple fact argues simplistic forms comparison style experiments understand evaluate tools 
just interrelated factors approach yield informative results 
storey demonstrates fact certainly borne comparing software visualization tools 
provided demonstration simple questions value visualization tools certainly posed complexities realistic software development simple questions investigative instruments 
thing really want ask complicated questions 
need complicated answers 
hypertext wright noted binary judgment works doesn may underestimate importance interplay design decisions simple question imprecise useful 
pg 
simplistic question gives simple answers leaves little substance address design issues consider important 
significant problems arise 
problem alluded 
problems theory thin discipline elsie scenario somewhat notorious fact comparative experimentations results weak 
second problem difficult cumulate knowledge gained asking simplistic questions 
problems discussed turn 
weak results weakness comparative experimental results noted different circumstances 
software development prominent examples studies program indentation formatting visual versus text programming languages 
weak results simple comparative experiments pervasive 
occur software visualization environments layout differences graphs software remodularization tools despite statistical tests program inspection tools 
weak results invade related comparative tests visual versus textual information analogical versus propositional representations hypertext versus traditional book forms 
possible causes weak results possibilities related simplistic questions effect size small relative scale question asked human processes observed just unpredictable answer gross experimental hypotheses 
weak results expected performance gains attributable tool input variable marginal due fact fraction problem addresses small 
expect improvement productivity causal factors addressed tool design 
software development tasks simple tasks touching button light turns 
real software development tasks probably expect performance impact modest 
software development wicked problem tools qualify silver bullet transform wicked problems tame ones 
experimental conditions may need sensitive order reliably expose relatively speaking minor effect 
host factors combination normally dominate performance software developers 
sensitivity control needed show minor effect experimenters driven highly contrived experimental setups order effect interest dominate performance davies highly editors 
contrived experiments obviously useful clearly exposing phenomena interest sensitivity needed experiments bears witness relatively small effect performance 
effects easily lost error bars gross development tasks 
fatal difficulty comparative experiments clearly disadvantages problems 
micro tasks making menu selection checking sources repository reasonable relatively large easily measurable performance increases may achieved 
making dent domain task costs consideration expectations large measurable differences probably modest tools compared enormously 
reasons offer 
making significant mentally challenging problems software development hard realistically speaking just 
problems theory thin discipline started directly tackling issue cognitive support 
landauer spent considerable time arguing essentially point broadest task contexts measured marginal increases productivity precisely automation easily automatable things automated 
easily automatable small fraction left 
second broadest task contexts open flexibility human behaviour competition 
effect size related issue effect reliability individuals important applied disciplines practice effects searched may easily fairly matched comparisons 
case point typical unix development tools 
practice expertise flaws design 
seemingly unremarkable unix tools formidable opponents comparison evaluations 
simple comparisons run host obstacles making contribution minor hard fairly measure detect 
source weak results usefulness tool may highly dependent various uncontrolled unanticipated experimental variables 
possibility hinted wright quotation 
simplistic questions desire simple answers forthcoming 
hypertexts better traditional books 
visual languages better textual languages 
apples better oranges 
questions presuppose simple answer 
answer typically depends 
dependencies frequently uncontrolled experiments 
cited problem studies examining usefulness comments programs evidence utility comments unclear pattern results expected 
clearly level comments useful 
believe believe comprehensibility program independent information reader 
equally clear comment useful tells reader know infer immediately code 
exactly propositions program included commentary matter matching comments needs expected readers 
widely applicable results desirable amount type commenting highly behavioral experimentation questionable value 
pg 
comments useful 
course 
understood accounted experimental setup expect results best 
surely true simple hypothesis testing concerning software development tools 
terms method appropriateness important cause weak results relatively small effect size contextual dependencies variable nature processes observed 
widely noted performance highly variable individuals different performances individual 
variability messy statistical analysis 
individual performance differences appear partly matter individual psychology partly matter proper training 
considerable subtlety issue variability individuals variable performing tasks 
problems theory thin discipline significant problem solving 
illustrated careful word processing experiments performed card 
ran different word processors head head order measure performance differences 
able show significant performance increases certain document editing problems 
notable increase performance wish results due mainly large effect size effect large hard experimental techniques 
second explanation offered card achieved results process studying reasonably predictable experimental conditions controlled 
observed process conditioned 
users changes document order get conform printed version document marked changes 
experienced word processor users subjects task presents cognitive challenges 
practiced physical cognitive skills applied 
fact precisely reason card chose tasks concerned modeling predicting skilled performance 
lies problem applying comparative methods domain software development tasks interest ones performed skills methods 
called device level tasks skilled predictable 
sorts problems tackled software development despite long years training routine skills 
means interested tool support software development necessarily interested called higher level cognitive functions learning problem solving 
put context card experiments fared word processors task chosen write article book dissertation 
cognitively challenging tasks frequently heavy word processor text processors prefer 
tasks processes poorly conditioned 
individual knowledge problem solving strategies dominate 
things subjects bring experiment 
true word processing smaller part task writing book making simple edits document fact sensitive experimentation reveal relatively small effect highlight variability performances individuals 
true restricts study lowest task levels scrolling deleting words reasonable level predictability expected see draper 
example programming environments reasonable try compare relative costs skilled execution common low level edits 
done syntax directed editors programmers 
works ignore task context experimentation works practiced parts development process hard problem solving parts 
point note difficulty experimentation significant portions processes writing poorly understood poorly conditioned 
predicting processes may somewhat akin weather forecasting possible understand mechanisms underlying weather possible predict weather time frames important software development design likened writing 

problems theory thin discipline 
software development processes interest weather simple editing 
tool comparative experimentation highly cognitive domains fundamentally problematic unfortunately clean experimental results conditioned processes card red repeated comparative evaluations circumstances interesting investigators cognitive support 
cumulation impossible second problem raised method asking simplistic questions experiments form results difficult build theories tools adequately reflect complexity software development 
simplistic questions avoids understanding factors affecting performance interact 
hard know combine answers gets asking questions idea factors 
say manage learn shrimp better rigi certain tasks better vi grep tasks 

just knowledge impossible know result speaks 
manage correctly guess major factors involved include features tool task user experimental results better suited tool adopters designers 
designers want know change tools see chapter available results say existing tools 
returning scenario elsie change program re run experiment far clear know results matter turn 
experimental setup allow find difference resort guesswork 
problems symptomatic experiments seek verify simple cause effect relationships seek expose mechanisms creating causal chain 
experiments asks slightly different simply question 
recipe accumulating knowledge 
newell remarked play questions nature win 
view problem knowledge just cumulate experimentation simple dichotomous questions 
argued building integrated models fundamentally sound method research knowledge 
particular contention mechanistic models causation best accumulators science knowledge cognition 
newell talking specifically cognitive models individual psychology argument equally applicable applicable cognitive support 
cognitive support wants understand generalizable design principles hard see constructed simple tool comparisons 
succinctly remarked especially hci vast amount research effort expended trying answer questions comparing various interface technologies example design options scrolling windows hypermedia 
research dubious value depends answers produced efforts lead series technology specific design principles contention somewhat contrary works cognition human performance presume 
readers interested debating point refer clark newell ch lesser extent landauer carroll rosson 

problems theory thin discipline stable generative theoretical account human environment interaction guide design novel situations 
pg 
implied sort knowledge needed designers difficult collect assemble usable form individual results simplistic comparative experimentation 
experimental result dependent myriad contingencies accounted cohesive theory 
theory able away contingencies relate experimental results unclear integrate point form findings 
fact field se tools research little tried combine results style experimentation currently difficult imagine successfully done 
serious suggestions different possible methods scientific knowledge investigated presumed impossible 
need integrate experimental results course seriously studied theories modeling mathematical statistical relationships experimental variables 
examples form theorizing include various forms meta analysis past experiments hypertext visual encoding data see review miller sequential experimentation method method advocated basili modeling performance relations see basili von mayrhauser :10.1.1.17.1239
effort best example consider techniques mentioned tend compare merits competing theories build theories fail integrate results 
basili suggested knowledge accumulated form cause effect map factors affecting various qualities performance :10.1.1.17.1239
view process experimentation provides evidence support hypothesized relationship serves tease typology causal factors development process type design representation type programmer experience effect variations independent variables understood 
goal experimentation develop list input output variables importance empirical evidence create map relate 
map collection hypotheses cause effect relationships forms theory 
basili proposed method accumulating knowledge primarily way beliefs effectiveness various se techniques 
instance technique compare different techniques inspecting code 
comparisons tools code clearly possible validation style experiments similar way tools 
way know sort knowledge building advocated basili succeed creating suitable knowledge understanding engineering cognitive support supposing models mechanisms underlying performance 
evidence raise doubts possibility 
thing proposal relies distinguishing describing significant variants independent variables including tool features 
instance elsie novel modification tool need way consult theory determine tool improve maintainer performance 
possibility 
cumulation said occurring facts principled way connected 
accumulation suffers fate noted series technology specific principles 

problems theory thin discipline appropriate model theory plausible input tool features parameter model generate new prediction 
direct threat basili idea cumulation knowledge newell observation simplistic questions rarely convincingly decided way 
proposal basili depend heavily able determine answers just questions 
basili process accumulating knowledge strictly impossible risky alternatives 
past similar methods tried building grand unified theories psychology see hansen 
entirely merit feeling building actual computational models thinking fruitful tack 
seemingly plausible position basili held green 
basili green envisions way decomposing independent variables interest basili envisions collection relatively independent micro theories kept see landauer broadly similar proposal rasmussen different method decomposition 
purposes green proposal different newell adopts premise causal mechanisms underlying performance understood tested 
proposes micro theories green focus proposing models evaluating avoids asking simple dichotomous questions reasonable possibility accumulating knowledge 
related note recognized immediate problems generalizing simple comparative evaluations 
tools compare 
compare champion compare champion tools 
performing pairwise comparisons conceivable tools obviously impossible 
medical experimentation valid baselines 
white rat called standard unix tool set developed experts decades 
sophisticated time 
developers build impressive systems demonstrably useful 
plus deeply embedded programming cultures gives advantage familiarity 
unix toolset consists simple tools elegance power simple tools frequently overlooked 
pen sophisticated technologies psychological consequences 
point tool evaluation comparative simple fact raises question knowing compared 
hard conceive way answering question suitable theory explaining tools advantageous 

problems theory thin discipline tools tool ideas experimental miller provide excellent study contrasts called black box white box experimentation tools 
miller developed tool assisting software inspections 
black box test measure difference performance tool assisted inspection compared pen 
despite sophisticated statistical analysis techniques experiment generated weak results surprise 
deliberation recommendation iteratively design test tools 
recommendation echoed decades hci research practically guaranteed degree success matter poorly design issues understood see section 
simply testing guesses best experimentation miller know redesign tool 
read lines background knowledge combination informal evaluations tools responses survey questions 
debatable black box test results appreciable impact design process 
point example importance able state test ideas underlying tools 
miller find hints second tool better ways 
despite apparent soundness experiments say little features inside black box lead differences 
design principles extracted 
griswold contrast appreciated need open black box understand tools 
particular knew needed observe program restructuring tools order determine user unsure technology tool serve basis similar tools designed restructure large systems 
effectively ideas prototype help develop restructuring tools need understand programmers tool organization features tool influence programmers perform maintenance 
pg 
appreciated need understand principles support provided tools interfering details particular prototype purpose observing programmers variety tools see tool set better 
restructuring tools prove better certain ways simply specifically designed ease task restructuring unix tools 
restructuring tools certainly inferior ways prototypes 
looked variety tools help generalize observations permit comprehensive improvements tools narrow fixes peculiarities observed study 
pg 
realized limitations black box comparisons determining value tool ideas 
realized opening black box way circumvent confounding effects usability 
usability especially problematic comparison style research usability critically affects performance quality inherently non linear respect tool functionality 
meant non linear small changes tool features dramatic impacts 
problems theory thin discipline usability 
performance drastically affected turn 
tool regularly crashes user machine instance unusable 
crashing version may virtually indistinguishable functionally non crashing version 
true crashing program just extreme example 
myriad omissions significant impacts usability omission undo file saving search help facilities colour assignments command name choices 
simply ways making unusable tools usable ones see section expanded argument 
confounding omissions minor design details fundamentally affect basic idea tool reasons tool supportive 
example storey lack simple textual search function significant source frustration users software visualization tool 
search functionality essentially parenthetical tool essential design ideas concerned utility fisheye views software structure graphs 
raises question evaluate tool ideas needing perfect dimensions design 
impact usability cause problems comparison experiments usability problems controlled accounted 
usually possible experimenters forced highly polished tools expect obtain positive performance results 
note carefully usability problems threats experimental validity performance results 
clear example illustrated superbook project 
landauer notes superbook hypertext systems compared favourably conventional book technology 
technology said validated sense implied zelkowitz wallace 
initial version superbook fare took third major version performance improvements large call project success 
version fail evaluation criteria versions pass 
terms developing productivity enhancing tools initial superbook complete failure pg 
contained gems ideas contained flaws ensure reduce productivity 
terms developing tool ideas design initial superbook entirely spectacularly successful 
initial superbook describes application fisheye views full text indexing information retrieval problems knowledge seeking activity 
final version superbook substantially superbook 
furthermore design superbook copied key ideas define version superbook copied 
really products superbook research tool tool idea 
comparison style experimentation validates tools unable validate tool ideas special case implemented sufficiently polished improved tool 
fact comparison style experiments tend evaluate tools tool ideas causes difficulties se researchers 
firstly clear circumstances prototypes 
certainly research projects iterative development products suitably polished state costly exclusion prototypes drastically limit number ideas validated 
secondly validation comes late 
main reasons performing evaluation establish evidence tool idea spend time 
problems theory thin discipline effort develop polished versions 
thirdly stopping criteria trying improve tool ill defined basic idea figured way fixing flaws 
iterative changes tool means attribution productivity improvement guesswork specific hypothesis testing 
features credited enhancing productivity 
superbook example instance say enhancements iterative improvement merely fundamental design flaws original version fisheye views bad 

explicitly testing hypotheses attribution benefit failure merely guesswork 
fact iterative improvements serve weaken argument performance improvement due core design ideas 
productivity gain due subsequent improvements core idea 
needs go rounds tool improvement weakens argument usefulness core idea 
case try test core design ideas place 
requires testable hypotheses value tool 
theories cognitive support cases hard imagine generate hypotheses invoking guesswork 
explanation avoidance empirical demonstration analysis claims usability effectiveness vital interactive technology built principled grounds mutually constructed folklore 
buckingham shum hammond argumentation design rationale cost pg 

need ask simplistic questions experimental methods reflects inability propose test explicit models theories cognitive support 
way basic experimental methods show yeast raises bread establish specific theory yeast raises bread create carbon dioxide 
type experimentation establishes unknown causal mechanism exists describes mechanism produces proper explanation 
simplistic questions avoid proper explanations lewis called inner theories 
difficulties arising fact key ideas underlying tool design articulated tested adequately 
third problem arising fact testing theory little basis generalizing results experiment past exact conditions experiment 
point argued places experimental contexts greenberg olson foltz 
concentrate failure articulate test claims 
superbook example observational data may revealed fisheye views advantage liability point observational data needed establish extrapolated performance data simple comparative experimentation 
state original idea fantastic tool need fixed 

problems theory thin discipline clear articulation cognitive support provided tool normally implies method formally expressing mechanisms methods cognitive support operate 
adopter technology hardly difference support mechanisms exposed interested merely technology validated 
certification determine wise purchase adopt 
se researchers expressing succinct explicit claims support embodied tool important 
trade support ideas want know instance tools support development essentially novel ways ideas tried slightly different guise 
clear articulation ideas tend remain folk level description analysis 
result evaluation comparison tend ineffective understanding researchers ideas evaluations tend focus low level features tool measurable effect cause 
comparisons low level features effects widely 
price developed twelve factor taxonomy features comparing software visualization systems 
exception effectiveness factor taxonomy considered features capabilities systems graphical vocabulary ability produce multiple views system 
factor decomposition effectiveness tool feature types 
suppose factors contribute effectiveness dimension impossible determine causal influences 
similar way proposed compare visual languages dimensions visual nature functionality meaning sort computations specifiable language ease comprehension paradigm support scalability 
ease comprehension affected dimensions known 
likewise may compare reverse engineering tools surface functional features dimensional views generated outputs accuracy software representations generated 
gall chen performed 
exist ways evaluating sorts tools cognition related proto theories emphasis field tool features measurable effect :10.1.1.22.1477:10.1.1.22.1477
problem style evaluation tends lead call questions 
visualization provides multiple views visualization 

multiple views vital sign ineffectiveness individual views simply distraction 
views better 

visual language demonstrated easier comprehend language 
feature difference 
doubt feature comparisons potentially useful 
type theory features doing developer comparisons merely serve chart presently known design space 
reason important articulate tool ideas succinctly test directly 
course ideas multiple views better understanding software 
trade theories 
doomed remain folk spat directly tested 
blackwell termed way think cognition meta cognitive theories 
surveyed computing science literature visual languages order determine sort theoretical resources field generally uses argue advantages visual programming languages 
observed 
problems theory thin discipline widespread preference simplistic argumentation superiority visual representations detailed understanding factors underlying possible advantages 
included simple claims visual languages improved expressivity intuitiveness naturalness abstractness 
claims grounded psychology science disciplines blackwell review strongly indicated rarely take time back claims grounding existing science claims fact easily justifiable existing research 
blackwell argued effectively group understanding possibilities visual languages primarily folk poorly grounded basic science 
continued attention simplistic explanations change fact visual programming languages maintenance tools reverse engineering tools 
tend avoid important explanations 
investigating simplistic questions means ideas underlying tool directly tested 
really interested expressivity intuitiveness naturalness claims put directly test picking secondary evidence provided productivity measurements 
define think naturalness test supposition 
measure 
supposing elsie ideas tool supported development experiment test 
problem user user tool interaction treated black box 
ideas entirely base tool demonstrably better certain ways certain tasks 
link black box techniques tendency keep research discipline craft discipline 
problems evaluation case researcher understanding cognition cognitive support naive folk 
example blackwell survey noted frequently believed graphical representations natural sentential representations 
suggested instance graphs software structure readily understood extensive training effort 
research graph representations indicated graphbased representations require years experience read properly 
graphical representations may easy read due extended experience familiarity due inherent qualities graphical representation 
imagine tools researcher explaining performance result natural superiority graphical representations 
specific claims directly tested empirical evidence proves performance difference decent chance explanation held fact wrong 
stands reason likelihood making valid claims tool benefits going proportional researcher ability specific claims firmly grounded empirical data basic psychological sciences 
simplistic questions easiest frame risks keeping field dark true causes underlying performance differences noted 
preceding analysis outlines limitations common experimental methods tools research 
method question propose new tool tool prototype perform direct comparison user performance new tool compared old ones typically old 
favourable comparison adds fuel investigation provides virtually measure assurance ideas tool developer justified 
provides statement tool idea generalized outside scope experiment 
simply put 
problems theory thin discipline carefully performed comparative experiments may uninformative experimental hypothesis simplistic 
hypothesis reasons context improvement directly put test 
frequently tool designers hypothesis probably surprised latent folk psychology 
tested adequately simple direct comparisons 
provides argument assuming particular prototype design concept successful useful generalizations emerge creating prototype level psychological assumptions underlying design level particular technologies implement design 
incumbent researcher explicit psychological assumptions contributed success prototype system 
successful system demonstrates success possibly implicit psychological theory underlying design articulated 
hope generalizable demonstrations success surely rides researcher identify psychological hypotheses validated success prototype 
pg 
emphasis original argument essentially impossible avoid issue stating testing specific hypotheses psychological aspects tools simple tool comparisons effectively try 
simplistic validation style experimentation helpful finding adopt technology virtually useless method validating design ideas 
unfortunately simplistic comparison entrenched valued evaluation technique may time limitations realized 
far bringing rigour area tool evaluation frequently opposite effect 
delay required commitment articulate complicated necessary theories hypotheses 
evaluation problems undirected observation clearly insightful individuals profession occupation able observe human behavior objectively specialists domains psychology skill knowledge relate observations observations domains 
brooks comparative task analysis alternative direction human computer interaction science pg 

previous scenario illustrated problems inherent human computer interaction treated black box maximal ignorance happening users sit tool 
scenario illustrates opening black box introduces problems 

problems theory thin discipline scenario undirected observation elsie experiment left questions true causes performance improvements observed 
improve tool 
notes ideas tool benefits went untested right 
convinced order determine right wrong going watch understand maintainers comprehension activities 
knows needs collect analyze observations users doing tool helps 
hypothesizes tool analysis functions extract useful information browser navigation facilities help traverse code 
hopes find data supports hypotheses 
instructs subjects produce verbal report thoughts collects videotapes computer logs sessions tool 
obtaining analyze data 
begins trying watch videotapes pouring dozens hours 
hours uninteresting respect tool 
users proficient tool notices verbalize tool related comments 
ideas pop head watches 
notices users switch attention various aspects program reading code 
notices users run difficulties browser trying return places longer remember intervening excursion 
spending time videotapes begins understand developers doing temporarily order browse try return previous position continue doing 
notices user strategy starting new browser window excursions return old excursion closing new window 
hits idea browser fluid available browser actions hypertext links back button close window correspond actions bring immediately needed information 
able publish 
learned programmers switch focus frequently browsers need support activity 
propose way support activity sure browser provide convenient access needed information 
knew needed information times 
elsie recognizes new problems 
wonders similar things programmers noticed 
notices ignored data concentrated critical incidents 
analysis quite informal wonders generalizability findings 
scenario elsie engaged described unguided undirected observation performed explicit guidance theory hypothesis 
essentially exploratory attempt understanding tool user interactions 
various methods performing unguided observations levels formality collection analysis data 
unguided exploration ranges developers simply watching people tools participant observation field trained researchers iterative coding recoding protocols theory building 
unguided observation response lack understanding situations tool 
scenario contains portrait exploratory verbal protocol observation 

problems theory thin discipline techniques relatively popular verbal protocols shown discovering new unexpected facts especially called higher level cognitive activities 
developers researchers stripes observational techniques verbal protocols see nielsen lang 
grudin noted trend studies planning interaction dialogue rely controlled experiments measuring time errors recording dialogue analyzing transcripts 
includes users sessions asking think aloud logging keystrokes engaging wizard oz studies 
pg 
sort unguided observation effective exposing usability problems 
finding usability problems appears fort verbal protocol studies tend quickly reveal usability catastrophes 
observation methods helpful practical endeavors 
furthermore form exploratory observation indispensable theory building 
despite invaluable technique tool theory building arguably problematic se researchers elsie 
facts cause problems little theory explicitly applied discovery orientation mismatched researcher goals investigative methods inappropriate 
theory missing elsie directly apply explicit theories cognition hci left devices analysis 
successful analysis relies observational vigilance analytic capabilities considerable amount insight 
clearly helped elsie trained psychologist recognize various problem solving behaviours 
rely insight background knowledge 
outcome unguided efforts highly variable dependent observer 
elsie colleagues come 
things elsie missed obvious cognitive scientist 
furthermore analytic power brought bear observation analysis depends powers theories 
theory help providing useful coding scheme 
elsie code protocols motivated coding scheme verbal protocols 
adopting developing coding scheme requires minimum hypothesis certain actions important vague idea start 
iterative coding clustering patternmatching techniques behaviour summaries helpful cases coding schemes developed priori clear starting powerful theoretical resources analytic engine 
unreasonable instance expect se researchers need devise entirely new coding schemes application verbal protocol analysis 
computer responses simulated humans 

problems theory thin discipline goal mismatch exploratory observational methods successful poorly matched researchers goals 
elsie se tools researcher cognitive psychologist hci theoretician 
goal learn tool cognition 
wants theoretical knowledge create 
publishes se journals cognitive science journals 
undirected observational methods antagonistic goals essentially learning discovery oriented 
necessarily bad elsie may learn valuable things subjects tools 
elsie goals goals unguided observation mismatched 
potential problem mismatch reasonable likelihood concentrating important tool related discoveries rediscover known 
elsie learned opportunistic switching behaviour users watching 
knowledge possibly obtained literature software comprehension basic psychology 
complain problem elsie sufficiently versed relevant literature 
complaint merely problem 
expected know potentially relevant literature 
inherently undirected nature observational methods combines non specialist knowledge base se researchers se researchers specifically position wanting apply cognitive theories create 
elsie basic problem activity directed building theory wanted help tool research 
data collected employed support conjecture user behaviour possible tool support techniques 
notice relation browser state needed information go farther analysis postulate models cognitive processes order anticipate sort information needed different points process 
statistical models browser activity generated data tauscher discovery oriented apply existing statistical model 
theory building intellectually challenging task building exactly opposite ambition theories 
tries publish cognitive models cognitive support theories encounters demanding needs basic science researchers cognitive psychologists cognitive scientists hci theoreticians 
face burdens making supporting evidence scientifically acceptable appropriate audience need know existing literature exposed various controversies disputes rage fields cognitive science 
trying build tools burdens entirely 
wrong methods unguided protocol observational methods problematic fail identify advance look verbal protocol methods strongly biased discovering usability problems 
elsie hypotheses tool guide somewhat theories focus observations naturally uncertain parts protocol important 
faced coding examining 
furthermore observational goals clearly understood start hard know 

problems theory thin discipline observed critical sort behaviour needed understand tool 
research process unguided observations closely resembles fishing expedition focused search specific objective 
addition uncertain nature observed undirected observations verbal protocol techniques tend highlight problems errors difficulties successful smooth performance 
consequently casual observation frequently excellent helping find design problems usability 
unfortunate side ability find problems spectacular weakness understanding successes 
instance verbal reports normally skilled smooth action reports tend trying cope usability problems 
means unguided observation chance discovering usability problems highlighted 
causes fluid successful action typically lost view 
vicente notes result verbal reports tend clearly expose called breakdown knowledge reasons success 
understanding fluid action called crucial understanding duplicating designing successful 
simply put verbal reports better suited investigating usability problems tool design usefulness 
curiously difficult problem understand fluid action 
problem successful cognitive support removes conscious cognitive effort 
consequently hope understanding cognitive support offered tool needs able sense absence problem solving part user directly appreciate cognitive advantages tool noticing reduction memory requirements 
suppose new development tool provides novel implementation type cognitive support 
users confronted problem difficult software maintenance expected spare cognitive resources tool frees extend problem solving expect see problem solving behaviour observational data nature problems change cognitive support 
users expected push improved tools point exposing new limitations 
prominently highlighted verbal reports 
combination continued prominence problem solving behaviour tendency verbal protocols emphasize tool limitations easier discover problems limitations fully appreciate successes causes 
insurmountable problem find method poorly suited investigating cognitive support 

problems theory thin discipline evaluation problems cognitive modeling undirected observation suffers due lack guiding theory cognitive model help 
scenario highlights potential problems existing cognitive models 
scenario cognitive model observation elsie unhappy results previous study 
learned comprehension processes real developers felt ran difficulties model comprehension processes 
decides order really get heads needs adopt kind cognitive model software comprehension specific 
reading finds model von mayrhauser vans vmv 
tries recoding collected data 
change dramatic 
model allows interpret complicated sequences activity reading browser manipulations essentially knowledge search acquisition processes 
classic features vmv model exposed including switching different exploration strategies searching knowledge different abstraction levels 
reflects fact results previous study anticipated model model exposes additional details difference top bottom strategies 
elsie notices model appropriate coding categories actions immediately relevant tool 
users tool search data dependency knowledge quickly follow dependencies hypertext links follow flow editor 
addition trick starting new browser window side excursions means browser provides support opportunistic switching search activities 
vmv model possibility coding support related tool 
elsie decides order trace support necessary augment model 
thought comes notion excursion states code user activities tool excursion state representation manipulation 
starting new browser pushes excursion position stack closing browser pops value back 
realizes browser memory extension problem solving 
adds activity model data extension 
users rely trick depend able forget interrupted search rely state stored browsing environment 
elsie feels publish came insight browser state aided exploration 
refined ideas browser support came data support 
little frustrated hypotheses 
elsie activity scenario nearly common informal evaluation simple comparative experimentation unguided observation 
fact scenario may considered little sort theory entirely absent se 
scenario plausible illustrates possibilities limitations observation cognitive models storey vmv model 
suggested procedure 
problems theory thin discipline start cognitive model code mental actions rely analytic resources determine tool implications 
problems sort derive primarily inadequacies available models 
essentially incorporate way explaining external artifacts aid cognition 
result elsie left similar position prior section time needing import model cognition needs import model tool supported cognition 
result type research practice remains oriented discovery theory building theory application 
theory building elsie wants cognitive model order derive understanding measure comprehension process aided tool 
reasonable say model elsie able understand users comprehension activities 
starting strong model internal workings comprehension processes process coding analyzing protocol greatly enhanced 
model ultimately inadequate purposes 
needed way generating coding actions external actions browser manipulation 
way integrating external internal states resources needed browser history incorporated analysis behaviour 
cognitive models fail 
concern internal cognition external states evolve affect cognition 
furthermore way needed express influences tool capabilities comprehension behaviour 
instance tool dependent strategy stack excursions spawning new browser window excursion strategy may emerge long term tools relatively complicated situations 
strategy works appropriate external memory mechanisms available 
exist interaction models account issues 
instance models tool user interaction consider evolving mental tool states 
elsie modify vmv model similar sorts model features eye showing external state tracking interacts high level cognitive activities problem solving 
point discovery theory building activities elsie concern 
perfectly happy modeling framework input tool capabilities able code user behaviour ways expose tools support cognitive processes 
promising cognitive models solution answering important tool evaluation problems 
anecdotal evidence suggests window stacking strategy frequently develops spontaneously time learned 
posting newsgroup comp human factors says excursion links return current location 
example search engine find information find single press release article news site 
mainstream links tend open window links tend open new windows view information close 
gary comp human factors jan 
problems theory thin discipline analysis problems analysis generally activity coming understand situation process modeling 
analysis activities range informal generation highly formal mechanical mathematical models 
section analysis processes interest ones researchers come understand tools support support software development processes 
analysis done conjunction prior design new software development tools 
done writing research proposals research papers comparing designs different tools 
process trying understand observational data case study called analysis verbal protocol analysis 
concern chapter primary focus analyzing cognitive implications tools 
analyze cognitive support software tools 
problems encountered analysis cognitive support 
extent problems caused lack suitable cognitive support theories 
earlier chapter analysis problems pointed 
section noted rare find adequate articulations cognitive support claims 
section argued theory suffers due lack theories account cognitive support forcing analysts rely craft knowledge intuition 
facts imply rarely position analyze cognitive support tools compare adequately 
repeat arguments attention directed common analysis problem word poverty 
green pointed problems plague theories hci 
related difficulty making theories readily applied 
third difficulty hci knowledge word poor 
green meant imply researchers developers discussing common concepts 
succinct word concept fall back drawn argumentation applying analogies similar tools arguing unimportant details 
illustrative scenario concerning word poverty discussing cognitive support 
conversation follows characterizations real designer analyst conversations 
involves design context scenario section considering tool design problems 
scenario communication understanding olga bart discussing design idea object oriented oo software re engineering tool working 
conversation turns possible enhancements bart come specifically bart called method gathering clipboard 
argues useful oo re engineering critical task oo re engineering discerning methods define class hierarchy 
bart olga understand implementation olga sure bart wants add pretty standard clipboard implementation windowing environments 
special clipboard 
say engineer decides lines code really correspond method 
select mouse drag copied 

problems theory thin discipline doesn just new method lines 
oh class may exist enter stuff 
tool dialogue creating new methods 
just extra step especially copy paste 
takes enter method information may sure method just 
just wait sure 
true needs remember lines forget 
true 
decide wrong method undo method addition 
takes find lines belong method 
basically temporary storage 
right 
lets start collecting related lines comparing rest code browses 
sort specific display window 
point modify add lines delete lines move modify making generic placed higher class hierarchy 
may find near clones instance 
collecting pieces small puzzles rearranging sense 
sure thought way temporary puzzle board 
scratchpad ideas case puzzles don pan 

actual activity arguing detail proposed extension tool may important designers 
working argument may bring new ideas problems instance actual conversation may serve repair misunderstandings designers 
absence set concepts supportive vocabulary substantially hinder process 
green puts says application interface described comparative detail useful said type problem rediscovered anew 
absence conceptual vocabulary known effects developing knowledge areas especially applied science prevents discussion design choices repertoire alternatives understood inhibits research limits application fundamentally identical problems recognised different contexts constrains focus attention aspects design fact quality design depends complex tradeoff 
pg 
near clones highly similar snippets code 
passage refers difficulty determining repeated operations known problem reengineering kontogiannis 

problems theory thin discipline cognitive support interface problems recognized different context fundamentally identical support concepts may unrecognized different contexts 
conversation scenario illustrates difficulties 
olga bart grapple cognitive support think provided clipboard 
correctness analysis concern notice main topic conversation concerns cognition related aspects tool reengineering process method recognition uncertainty memory process reaching agreement background knowledge psychology user types support exemplified predecessor artifacts 
counts opportunities improve conversation appropriate concepts vocabulary 
particular able introduce widely usable set concepts terms cognitive aspects problemsolving processes user chapter cognitive support offered tools chapter :10.1.1.22.1477
concepts terms helped olga bart communicate succinctly 
short circuit cascading clarifications arguments unimportant details 
particular vocabulary concepts introduce topic argumentation see chapter simple example help emphasize point hinting possibilities 
bart olga eventually came agree clipboard contained certain functionality supported problem solving re engineers 
support ideas included fact clipboard acted type external memory details need remembered external memory cost effective place temporarily hold uncertain changeable parts problem solution juxtaposition problem parts clipboard may play role recognizing problem solutions 
possibilities suggest supportive roles program features moment agree call external working memory store externalized problem solving heap order take advantage localization effect solution recognition efficient 
conversation gone better bart olga familiar concepts 
appeal analogies tools display window scratchpad 
come agree value memory function clipboard necessity relates tentative backtracking nature method recognition 
quickly acknowledged describing externalized problem solving heap attention turned tradeoffs external internal memory relationship problem solving capabilities working memory sizes 
example characterization started discussion expanded problem solving memory user search methods breadth depth 
designers known bias prematurely focus exploring sections solution space depth depth exploring alternatives breadth 
olga bart effectively argued external memory help reduce bias providing effectively expanded heap memory making breadth heap called breadth searches problem spaces store pool unvisited nodes 
breadth oriented problem solving frequently advantageous depth stuck searching deeply unpromising portions solution space 
excessive heap memory notorious problem breadth searches 

problems theory thin discipline exploration cheaper 
course just illustrative terms purpose scenario imagine possibilities 
point clear vocabulary cognitive support terms concepts help analysis 
vocabulary conversations cognitive support oblique psychological effects prior tools 
design problems software engineering research 
known years programming methods inadequate large projects 
research software engineering programming methodology software design looks better tools methods 
common thrust results fields reduce amount programmer remember checking changing program 
david parnas software aspects strategic defense systems pg 

design synthetic activity 
designers software development tools wish understand problems difficulties software development able come synthesize tools support development 
problems researchers encounter considering design software development tools 
clearly list potential design issues enormously long section concern way tool builders reason assist thinking 
entirely agree summary parnas essential point se tools research means reduce cognitive challenges burdens software developers 
put way assure quality software development tools necessary provide cognitive support 
questions section se cs researchers engineer cognitive support problems encountered regard 
relevant points covered regarding questions 
reiterated cognitive issues frequently treated craft knowledge methods section 
generally means rely designer intuition reuse existing successful designs application folk knowledge psychology sociology relevant domains 
point section argue keeping practice craft desirable 
harm design having explicit cognitive support theory impart 
relevant aspects question 
aspect concerns design practices researchers build cognitive support concerns design theory researchers understand cognitive support 
current problems covered section cognition studied software development researchers forced fall back craft design knowledge 
concentrate problem tools researchers developers se cs think build cognitive support tools 

problems theory thin discipline order lucid argument concepts design theory introduced 
chapter defined detail short suffice 
key problems design knowing needed knowing design satisfy need 
problems setting design goals performing design reasoning synthesis 
instance known software comprehension cognitively challenging adopt design goal reducing memory load reason way doing add external memory browsed locations locations need remembered see von mayrhauser singer 
problem setting design goals exist beginnings promising new theory research 
example hierarchy cognition related design issues developed storey 
design issues immediately suggest design goals limited set examples solutions provided 
se researchers shown generally generalizing examples collecting design goals prior solutions step forward 
second problem mentioned addressed problem generating design ideas design goal 
problem called gulf synthesis see section designer synthesize solutions high level goals 
order bridge gulf synthesis theory able reason forward designs 
reasoning forward means designer able reason design ideas options design goal applicable theory 
ideally theory provide vague recommendations merely validate design goals adopted means 
pointed software comprehension models provide account tools affect comprehension design recommendations model experience common sense 
unfortunately currently large state theory application design 
scattered results design advice quite vague derived common sense experience 
summary problems may argue hci need theory 
disagree 
discipline fails principled explanation justify practice building sand 
alistair sutcliffe effective reuse hci knowledge pg 

understanding software development tools inevitably require understanding tools affect participate human thinking problem solving 
unfortunately insufficient theoretical knowledge tackle issue cognitive support 
basic fact suggested root problems tools research se cs desire address cognitive implications tools unable properly due developed theoretical research thread concerning cognitive support 
support supposition existing research problems reviewed traced lack theory research thread 
problems divided evaluation analysis design problems 

possibilities theory research evaluation techniques reviewed informal evaluation simple comparative evaluation unguided observation cognitive model guided observation 
problems evaluation traced avoidance absence sufficient explanation understanding cognitive support 
trying back supposition empirical data case tools researchers forced essentially generate new theories cognitive support 
fact cause concerns especially regarding efforts match goals tool builders 
hindsight logical evaluating existing cognitive support ideas appropriate discover new cognitive support concepts build new cognitive support models 
explicit models cognitive support key input ingredients evaluations 
analysis design tools cognitive takes place partly plane cognitive support ideas 
current state practice reviewed shown provide ways accessing plane ways reasoning 
hindrance access argued lack useful set concepts appropriate vocabulary 
absence analysis design tends take place concrete plane specific tools gets bogged details designer conversation 
current state theory shown inadequate design 
may able model explain parts software comprehension lacks crucial ability enable forward reasoning support cognition 
possibilities theory research purchased variety artifacts calendars calculators computers created primarily support cognitive activities 
vast majority cognitive artifacts designed application cognitive theory appeal folk psychological intuitions trial error forces marketplace 
researchers begun consider theories findings cognitive science systematically applied design cognitive environment 
alex everyday life environments pg 

suppose agree cognitive support important issue tools researchers appreciated past lack suitable theoretical basis underscores problems se researchers face current practices 
alternatives status quo 
theories cognitive support look 
building 
se research changed available 
section address questions presenting vision possibilities theory approaches cognitive support 
vision theories models cognitive support foundation research designing new better forms cognitive support 
se researchers portrayed consumers theoretical advances disciplines focus se thread research set applications theories derived progress scientifically understanding cognitive support portrayed multi disciplinary collaboration 
possibilities theory research mediated theories exchanged disciplines 
nearly impossible convey sense vision analogous success story intuition pump possible draw understanding reasons success 
analogies mechanical support provide vision theory methods cognitive support research medical research paint picture se research cognitive support relates research disciplines cognitive science 
analogy mechanical support section 
draw attention features modern mechanical support knowledge appear vital successful explanation mechanical support 
analyzing successful case mechanical support may develop set desiderata new support theories strongly set requirements 
chapters requirements analysis guide theory development show resulting theories meet requirements 
mechanical support analogy argue theoretical understanding cognitive support enables theory approach tool design development 
theory approach avoid problems survey se tools research practices 
mechanical support analogy possible contrast theory approach existing practices 
give better indication potential advantages theory methods 
second analogy medical research position se research cognitive support greater research milieu 
se tool researchers compared section pharmaceuticals researchers 
comparison important se researchers limits contributions expected se researchers provides focus cognitive support research se research 
leveraging mechanical support theory author said machines regarded part man physical nature really extra limbs 
observe man digging spade right forearm artificially lengthened hand joint 
handle spade knob shaft additional bone iron plate new form hand enables possessor disturb earth way original hand unequal 
samuel butler pg 

earliest hci bush engelbart believed computers electro mechanical machines bush case augment human thinking capabilities way augment innate digging capabilities 
main difference physical labour computers envisioned assist thinking labour 
physical labour advantages mechanical devices studied long time 
quite understood 
possible carefully examine physical support explained order appreciate possibility explaining cognitive support better 
simplest 
possibilities theory research physical supports examined lever 
lever story chris eric hiking woods 
eric accidentally drops car keys wind hollow beneath large fallen tree 
trying vain reach chris try move tree pushing heavy 
discuss various options retrieving keys decide try lever lift chris reach keys 
eric finds rock moves fallen tree places top medium sized branch chris nearby 
chris presses side branch 
side heavy tree lifted eric retrieve keys 
example simple serves illustrate number important strengths properties modern understanding physical support 
foremost thing note form explanation physical support question 
particular explanation exposes detailed causal chain expresses mechanisms underlying events 
explanation go follows 
physical arrangement branch boulder forms lever 

lever supportive transforms chris downward force larger upward force enabling lift fallen tree 
force amplification effect called leverage 
form mechanical advantage 
allows chris lift tree larger lift unaided 

leverage arises chris downward force transmitted rigid branch move downward force converted torsional force turn transmitted tree lever 
lever longer chris downward force exerted longer distance tree 
physical labour conserved proportional force times distance force tree greater chris 
details explanations important vision section 
important sorts lessons drawn example especially lessons cognitive support theories 
short summary appears left hand column table 
lessons mechanistic explanation explanation physical support mechanistic explanation 
important mysteries left powers chris lever uses 
talks amazing mysterious properties lever natural evoking powerful innate lifting abilities chris 
explanation purely descriptive claimed lever pushed supporting lifting tree mediate physical tautological claimed lever helps lifting supporting pushing task 
possibilities theory research cognitive support deep explanations mechanistic models 
current explanations cognitive support extremely shallow instance tool said support comprehension offers search capabilities browsing program dependency links 
claims proper explanations 
support vs automation lever eliminate changed characteristics 
chris eric hiking powerful robot need lever physical done chris 
robot power supply provided motivating force needed move tree 
chris needs supported 
cognitive support models need explain cognition may assisted completely automated 
date explanations shallow relying arguing automation referring vaguely powers human mind power visual systems 
functional high level ontology right level concept leverage high level functional relationships high level interpretations basic components 
specifically low level details ignored matters little branch boulder 
physics instance just enter discussion ultimately action reducible laws 
boulder thought branch pivot 
abstraction important concepts configurations mechanic floor jack 
concepts high level interpretations comprise ontology list sorts entities pivots relationships defining elements reality 
ontology function related relative absolute 
boulder form lever 
notice words ontology form sort vocabulary necessary reason mechanical support 
words leverage succinct defined terms mechanical models evoke understood implications tradeoff amount mechanical advantage extra distance chris push 
purposes explanation leverage right level 
analyst happily glosses complications fact branch discontinuous tiny particles fact force involved explained fundamental models interaction particles 
time mechanical explanation important times sufficient cut analysis point noting lever force transforming machine 
particular build effective understand features artifacts strength smoothness 
philosophers science probably term ontology liberal term knowledge ai 
follow lead knowledge engineering ontology roughly schema knowledge roughly belief :10.1.1.29.3373
benefit possible employ philosopher notion ontology proposing task relevant properties rock realist facts see dennett done psychology pg 


possibilities theory research cognitive support theories constructed appropriate level functional terminology cognition related interpretations 
critical ontology able away implementation details conception lever 
possibility knowledge level cognition level concepts terminology relate directly cognition issues 
away implementation issues uninteresting lower level details 
cognition related aspects relationships highlighted implementation related ones elided 
transformation comparison physical strong notion conservation labour 
course scenario different solution path instance chris picked small stick keys avoiding lifting tree 
assuming tree needs lifted certain amount unavoidable needed lift tree required distance 
conservation energy laws state unavoidable 
mathematical models possible compare assisted compare chris lifting lever power requirements lever 
comparison lever changes nature chris 
true needs push force lever pushes downwards branch lifting tree 
transformation strictly harder jobs possible cost making lever pushing greater distance 
important remember advantages order accept may unavoidable overheads 
cognitive support models need explain tools transform tasks improve cognitive ergonomics 
method comparing done different tools generated 
ways establishing equivalence important making fair evaluations comparisons tools 
required ways distinguishing main done overheads created 
usability testing mechanical explanation leverage available studied poorest implementations 
lever pipe cleaner wad gum tested variety ways establishing relationship lever length strength possible load limits 
working lever implementation may completely unusable 
possible cognitive support modeling evaluation independent suitability issues possible evaluate supportive nature prototype tools presence usability problems 
tools vs support concepts leverage modeled detected clear leverage needed challenge restricted showing lever effective useful tasks intended applied 
complicated tools merely parts tool value lever established independent functionality 

possibilities theory research cognitive support models need possible separate appropriateness tool design correctness designer reasoning cognitive support 
support independent design 
tool design chris eric adapt materials available new tool 
tool designers require knowledge task perform materials available 
key understand implementation independent concept lever able reason build available materials solve problems 
cognitive support models possible reason forward design analysis cognitive needs done 
cognitive support theories address task user requirements various implementations supportive solutions 
unified explanatory models composition frameworks newtonian mechanics creates framework possible describe explain fundamental principles mechanical advantage 
common simple machines inclined planes described basic elements combined ways generate complicated machines 
cognitive support theories beneficial concepts support decomposed collection elemental support types 
importantly total collection support types framed theory coherently unify 
theory theory building principles leverage known applied relative ease understand basic events situation 
knowledgeable things observed chris eric little trouble recognizing explaining supportive nature lever 
analysis rests established concepts theories reasonable explanations questioned 
correct response refer skeptic science publications experimental data gathered settle case 
quite unrealistic suppose newtonian physics need created defended observer 
highly exceptional design situations new theories required progress explaining phenomena building transistors time 
theoretical resources ensure situations exception rule 
cognitive support theories strive minimize amount specialist knowledge needed required theory application 
particular cognitive support theories strive state tool developers casually recognize discuss supportive mechanisms external memories talk lever 
certainly theory users need cognitive science 
proposing cognitive support explanations may simple mechanical support cognition easily observable importance established theory clearly analogous 

possibilities theory research design intentionality ad hoc tool building tool supportive designed way 
boulder branch designed purpose lifting 
support related uses artifacts put 
cognitive support may created ad hoc manner 
possible generate explanations cognitive support observed prospective user behaviour merely designed mechanisms 
lessons lever scenario greatly influence remaining chapters 
table lists desiderata addressed succeeding chapters 
lesson regarding theory requirements section explanations benefit mechanistic explanations cover partial automation cognitive assistance ontology cognitivist cognition related equivalence tool established definition support independent usability definition support independent functionality forward reasoning support possible simple theories small vocabulary unifying support concepts need deep psychology cognitive science knowledge minimal theory applicable ad hoc designs table theory requirements lessons learned addressed theory methods look 
theory gives answers theorist 
important humans embody knowledge answer questions 
questions answered theory may depend skill theorist answer obtained depends theory theorist 
allen newell unified theories cognition pg 

previous section example lever drive analysis important features theories models mechanical support 
section asks question theoretical models cognitive support elaborated mundane mechanical support se tools research look 
question answered parts 
prospective scenario suggested established cognitive support theories perform theory tools research 
technique previously card landmark book psychology human computer interaction 
tried establish vision 
possibilities theory research applied psychology tool analysis 
second scenario problems current practices revisited order generate suggestions theory methods avoid solve 
comparisons theory methods summarized tables table evaluation activities table design analysis activities 
order example realistic genuine support ideas literature included scenario 
reader encouraged ignore details concentrate general form scenario 
practices problem sources theory approach advantages informal informal methods increased results convincing evaluation explanations formality simplistic explanation building understanding simple questions explanation testing validation stronger comparative tool specific prototypes may validation evaluation feature feedback directed evaluation feedback early black box explanation explanation support idea explicit methods avoidance seeking ideas directly tested minimal theory support relevant better coding schemes applied theories imported reduced proof burden learning tools undirected mismatched goals matched goals psych support observation theory building theory application support theory imported argued proved methods experimentation directed avoids fishing expedition inappropriate support mechanism exposed usability problems ignored model model weaknesses support capable models mechanisms testable observation mismatched goals matched goals see undirected obs 
table comparing problems current idea evaluation practices theory research practices problem sources theory approach advantages analysis word poverty cognitivist vocabulary support related concepts design abstraction details relies craft knowledge theory grounded design reasoning better rationales design backwards forwards reasoning help designers cross reasoning enabled gulf synthesis table matching problems current design analysis practices theory research solutions 
possibilities theory research scenario design lorne developing new software reverse engineering tool intended help reverse engineer design patterns legacy code 
tool contains knowledge base design patterns 
knows design patterns partially matched analysis engine developed colleagues 
partiality matches due fact analysis engine certain inferences correctness matches partly patterns legacy code subject occasional violations design rules 
small part hci consists reverse engineer trying complete partial matches design patterns finding accounting pattern violations 
process making matches hard cognitively challenging reverse engineers 
lorne wants build cognitive support process 
lorne starts thinking opportunistic problem solving methods typical reverse engineers 
white board begins sketching engineer computer resources 
knows computer compute partial match design pattern piece code implements 
match binds pattern features code features bindings may erroneous may fail due pattern violations code base 
lorne realizes engineer task go matches determine correct bindings legacy base find pattern violations determine possibly correct legacy base 
tool essentially kick starts process 
knowledge tool assisted problem solving realizes list bindings tool generates forms shared match completion plan places pattern violated shared repair plan 
tool user act distributed problem solving manner tool initial serving develop partial match generate initial plan user establish binding code 
plans provide series hints regarding locations bad bindings pattern inconsistencies may exist 
knowledge cognitive support lorne realizes suitable support external planning environment ensure plan execution state represented externally 
knows effectively distribute execution states user tool user engage display problem solving internal planning problem solving 
cognitive support theories knows free cognitive resources resulting systematic plan process tolerant interruptions 
armed general idea support needed lorne design task generate interface ideas carry support 
begins sketching interface hold known match completion plan steps accumulate unknown repair plan 
support theories kick advise pay attention types shared problem solving states 
warnings adds ways tracking plan completion state visually indicating action options relating problem goals 
adds features unroll decisions enable backtracking 
adds prioritization algorithm rank bindings list ones confidence listed 
making detailed design decisions involving novel type problem solving characterized external artifacts represent problem solving state cue actions see larkin section 

possibilities theory research proposed interface design initial prototype 
lorne theory guided approach design reasoning 
analyzed reverse engineering task terms problem solving reasoning needed done 
cognitive support concepts reason distribute problem solving process tool user 
particular began reason distribute knowledge system plan state order enable particular form problem solving display 
prior high level ideas cognitive support helped transition analysis synthesis 
transition critical difficult potential theoretical resources assist designers regard powerful motivator pursuit cognitive support theories 
lorne aided appropriate cognition related ontology analyze potential benefits tools 
vocabulary concepts concerning cognitive support readily available lorne 
away low level details windows list boxes think terms planning plan execution states 
ability reason functional high levels absolutely critical 
ability pervasive known differences expert novice performance see chi reviews 
experts tend think function related levels lower implementation related levels 
cognitive support related knowledge act lightning rod attention 
lorne support related concepts display problem solving may helped bring fore relevant issues cost tradeoffs involved externally represented problem solving state 
lorne may able design similar tool theoretical backing see instance koschke ch 
similar ideas able explicitly reason tool supports cognition lorne may think empirically test implications tool 
seen lorne number support claims put empirical test 
instance test display problem solving performed external representation plan execution state really memory requirements 
articulating theoretical claim tempted pursue black box methods 
theories important analysis evaluation redesign cycle 
scenario early evaluation lorne wonders support mechanisms proposed prototype 
current concern maintaining externalized plan completion state costly 
standard textbook cognitive support learns multi way tradeoff externalized state cost manipulating state resistance interference effects things user confidence correctness job ability support cooperative multiple users 
briefly thinks trying goms analysis calculate state manipulation costs decides wait thinking state manipulation costs may minority effect 
thinks important issue prioritization algorithm repair plan display destroys breadth problem space exploration 
thinks users may adopt task analysis applied help determine efficiency low level interface tasks 

possibilities theory research focused depth behaviour chase unpromising leads long realizing errors 
lorne suspects easy way test supposition feels get reasonable initial feedback developers prototype 
lorne visits test sites videotapes developers tool 
back lab edits videotapes get rid observations cases step sorting 
watches users show habit looking highest priority binding 
know strategy cases knows prioritization focus search options algorithm considers important 
sort theory evaluation significantly different character methods surveyed section 
methods highly focused specific supportive ideas designed tools 
detailed supportive nature articulated 
details generate cascade specific evaluation questions 
empirical serves directly validate lorne support build theory support cognitive processes involved 
data collection observation strongly directed 
lorne analyzes videotape knows sort behaviour looking 
model coding technique code problem state transmission internal external representations see chapter help evaluate success display interface 
lorne wanted directly test predicted performance benefits prototype 
example try adding various memory loads articulatory suppression subjects determine ability track progress affected 
allows lorne propose evaluate interesting questions early iterative design phase empiricism best chance making greatest impact 
focusing cognitive support able appropriately ignore usability issues proper help systems printing interface consistency time changes functionality critical 
designing evolving new support analyzing modeling support time 
understanding tool benefits accumulates models uses directly reflect design ideas 
comes time publish claims support crystal clear able appeal standard theories cognitive support grounds widely accepted science base 
scenarios design evaluation lead vision theory guided research researchers directly domain cognitive support 
fully articulate ideas doing engage tight feedback loop proposing support implementation concepts directly testing modifying designs 
cognitive models theories act strong allies helping intended developing computational implementations support exposing full burdens building theories cognition cognitive support 

possibilities theory research se research researchers engineering relies codifying scientific knowledge technological problem domain form directly useful practitioner providing answers questions commonly occur practice 
engineers ordinary talent apply knowledge solve problems far faster 
mary shaw prospects engineering discipline software pg 
research cognitive support software development entail 
role se researchers 
portrayed se researchers users cognitive support theories 
theories going magically appear developed 
develops 
evolved 
unreasonable claim able predict answers questions looking past history domain possible glimpse history 
take cue lewis suggest se research best exhibit parallels modern medical pharmaceuticals research 
modern medicine early medicine frequently highly 
america england th th century prevailed 
view back romantic crawling town town cargo small bottles filled mysterious 
salesmen speak crowds virtues 
snake oil salesmen promised mysterious contained bottles cure multitude 
recipes frequently created mixing various believed healing powers 
little available medical science understand possible mechanisms effective 
consequently little emphasis put explanations body complicated mechanisms poorly understood confidence placed explanations offered 
potential clients just interested worked 
course explanations worked pronounced sciences biochemistry genetics explaining simplistic 
healing ability attributed properties ingredients capability tap powerful unnamed healing capabilities human body 
sales depended endorsements reputation brand names 
time traveling snake oil salesmen medical sciences pharmacology matured point new drugs understand better degree causes diseases progress various drugs organisms chemically physically interact human body 
contrast snake oil see golden age snake oil 
alive 
anti sites web 

possibilities theory research era modern medicine stark 
certain level sophistication concerning pharmaceuticals 
know causes 
knowledge underlying causes capability demanding showing evidence go hand hand 
insist having clinical evidence showing drug safety effectiveness 
want able explain drugs 
appeals properties drugs humans longer acceptable 
explanations important 
unfortunately explanations come high cost theories models create explanations 
chemistry needed decompose pharmaceuticals active ingredients fillers 
biochemistry developed possible explain birth control works 
great deal science knowledge needed support modern pharmaceuticals research 
fortunately pharmaceuticals developer great deal knowledge available 
may just possible glimpse part se tools research history pharmaceuticals medical interventions 
state se tools today arguably better medical interventions golden age 
analogy snake oil times draws uncomfortable parallels 
trade literature today routinely tout ways reminiscent snake oil salesmen 
web page instance claims software project involves millions lines code high application developers sniff tools quickly easily comprehend navigate analyze source code easily comprehend claim vague clearly 
course web sites dubious products removing point current marketing software development tools resembles snake oil era comes cognitive support 
emphasis currently product endorsements prominent clients favourable hands reviews 
subtle implication expectations better forms evidence 
course trade literature thing academic literature se tools 
hardly argued academic research community done distance criticism 
point needs done simply validating tools ways similar way drugs validated clinical trials 
validation deep explanations actual tools required 
case pharmaceuticals research producing better evidence required improvements scientific knowledge causes ways pharmaceuticals 
gaining scientific understanding far trivial 
fact researcher effectively handle 
typical way deal subject complexity decompose problems partitioned subproblems set study 
plato thought said science carve nature joints pg 

joints rightly raises concerns 
set impossible take sister disciplines set knowledge ecosystem 
ecosystem knowledge produced consumed 
modern medicine split quite successfully exactly manner developed roughly defined set roles medical research 
knowledge ecosystem medicine complex narrow specialties 
www com products html embed dev tools html retrieved 

possibilities theory research luckily rough generalization illustrative analogy 
medical practitioners diagnose medical conditions determine interventions solve medical problems discover 
practitioners know drug capabilities side effects prescribe administer drugs matching problem diagnosis appropriate intervention 
need know efficacy risks associated drugs depend fact drugs validated ensure efficacy establish associated side effects risks 
pharmaceuticals research divided research clinical trials establish efficacy risks research develops new drugs drug ideas 
pharmaceuticals researchers frequently understanding biochemistry genetics human physiology develop new drugs 
particular rely understanding drugs produce effects delivery mechanisms interaction immune systems barriers absorption 
general problems solving build underlying science base solutions 
rely basic science researchers protein structure researchers cell chemistry researchers 
especially rely researchers turn basic research applicable techniques 
researchers include gene splicing protein synthesis practical 
pharmaceuticals researchers import knowledge frequently export set unsolved problems solution desirable 
time medical professions tackled early basis building medical interventions human approach involving separation basic sciences research applied science design sciences testing 
clearly order ecosystem successful pharmaceuticals researcher able effectively knowledge gained basic sciences 
scheme applied theories methods carry knowledge 
pharmaceuticals research ecosystem depicted 
ignored details regulatory agencies pharmaceuticals packaging picture crude characterization sufficient drawing parallels cognitive support research 
way mapping drugs tools tool concepts medical practitioners akin software developers tool adopters pharmaceuticals testing similar tool validation pharmaceuticals development tools research development applied scientists bring basic science practice cognitive support theory developers 
scheme basic principles cognition cognitive support akin basic sciences underlying modern medicine 
scheme diagrammed 
dissertation fits squarely cognitive support adapter role diagram 
target audience knowledge developed tool draw basic sciences psychology cognitive science 
goal knowledge basic sciences available tool 

possibilities theory research certification medical practitioner certification tool adopter drug tester drug drug drug technology validator tool tool tool applied scientist science knowledge new problems methods tools science knowledge basic scientist physiology biochemistry cognitive support adapter science knowledge new problems methods tools science knowledge basic scientist cognitive science logic 
models pharmaceuticals possible cognitive support knowledge ecosystems alternative visions scheme ecosystem software development tools research establishes clear distinction users developers cognitive support theories models users developers basic science underlying theories 
applied theories tie basic science application 
scheme potential critics 
different sorts proposals times advocated blur distinctions specialists 
standard names proposals called scientist tool builder tools researcher scientist group knowledge approaches 
approach different suggestions appropriate specialist knowledge applied 
scientist tool builder approach advocates basic science done tool building 
instance anderson landauer norman envision research programmes scientists cognitive psychologists create basic science knowledge building tools 
vision research collapses roles basic applied scientists roles tool developers 
reasons trying approach 
norman argued applications tend drive science way basic science researcher developing tools 
reasons included belief theories relevant application fact novel tools rely new theories 
reasons cite benefits basic scientist tool developer 
may reasons borne certainly true wearing dual hats tool developer basic science researchers provide assurances knowledge underlying sciences applied tool builder research development 
tools researcher scientist approach essentially suggests tools researchers basic science 
commonly argument advanced support approach scientific methods basic scientists adopted tool builders design 
tool designers need establish validity principles inherent designs 
numerous suggestions vein methods specialist disciplines software development 

possibilities theory research include applications methods psychology anthropology 
expectations software developers specialist experts nielsen suggestion computing scientists protocol analysis 
cases clear tools researchers expected acquire maintain highly specialist skills knowledge cognitive science 
instance proposal assume fundamentally theory building experimental methods design 
general thrust approach tools researcher principles theories originally constructed experimentally establishing particular design contexts 
group knowledge approach argues specialist knowledge imported form human experts 
psychologists hci specialists suggested part software design teams research teams 
imports required knowledge form human specialist 
consequently side steps problem making basic science knowledge available non specialists 
raises number problems scientists tend specialize narrow areas open question experts included assure measure availability specialist knowledge 
proposals raise serious concerns practice se research 
group knowledge approach principle quite sound practiced quite successfully past see carroll landauer ch 
green 
approach avoid need cognitive support theories specialists poorly developed anyway really solve problems se researchers left critical issue properly address recruiting knowledgeable colleagues disciplines 
proposals field include funding requests psychologist research associate 
approaches problematic implication se researchers wear hats basic science researcher tools researcher 
arguments certainly support hats approaches 
history shown certainly possible scientist successfully wear hats 
fact frequently pointed seemingly clean split basic applied research quickly dissolves close inspection naur 
split applied basic scientist quite clean anyway 
addition common researchers psychologists sociologists study software development particularly interesting domain study application 
result works studying software development tried advance theoretical understanding simultaneously build better tools adelson 
researchers domains software development tools research 
sharing common problem domain mutually beneficial 
certainly stopping se researchers knowledgeable cognitive science sociology 
excellent example results possible done redmiles weave applied theory tool development argo tools 
close ties really necessary 
question rhetorical 
psychologists hci specialists currently looking need email argue affirmative 

possibilities theory research necessary marriage 
laboratory experimentation test systems interim procedure approximate benefits models wait science mature point models complete 
bonnie john panel statement role laboratory experiments hci pg 

alternative views merit question remains tool need effectively trained scientist contributing research discipline 
reasonable question tight couplings proposed exist current practice really necessary 
troubling issues 
proven advances basic sciences necessary build better tools 
certainly unclear currently employ know full effect 
consequently research cognitive support argued invariably require extensions underlying science base 
doing basic science research certainly absolute universal necessity 
second requirements research basic sciences frequently odds aims tools researchers 
instance green argued sorts research demanded parent disciplines frequently generates results wrong sort emphasizes statistical significance effect size favours simplified models easily verified models integrate numerous phenomena address design tradeoffs 
basic sciences simply haul baggage respective research paradigms 
third accessible cognitive support theories se researchers faced difficult task finding interpreting integrating applying basic science research 
applied redmiles shows experimental problems described section crop burdens building theories 
alternative vision basic ideas models cognitive support quite established main challenge tools researchers theories models establishing new supportive technologies 
scientific basis tools research improved tools researchers applied models ultimately grounded basic research 
vision creates clear distinction tool oriented research uses basic science research generates knowledge cognition cognitive support 
knowing cognition cognitive support may requirement tool oriented researcher value mature theoretical framework imported purpose 
furthermore permanent position created research generates applied models basic sciences 
goms models created card results known prior effort generating applied theories tool researchers 
chapters dissertation attempt 

practical art designing theories practical art designing theories far section argued topic cognitive support important research community need pursue cognitive support theories largely neglected detriment appear resource long term hope build tools having continually build 
continue ongoing debate questions building 
built 
mentioned debate appropriate cognitive support theory built 
debate appears hinge expect cognitive support theories expect 
argue expectations relatively modest thoroughly pragmatic real difficulty developing useful cognitive support theories 
view theories tools artifacts think theory building design activity 
setting proper expectations theory opinions usefulness psychology related sciences differ greatly 
people highly feel psychological sciences obviously relevant potential 
unwise avoid debate 
studying critics identify avoid potential pitfalls 
importantly debating issue requires preparedness 
answer critics psychology requires demonstrate appropriately useful theories put forward reasonably convincing realistic plan building 
presents pragmatic plan building se relevant cognitive support theories 
potential criticisms approach considered countered pragmatic replies 
approach iteratively building theories outlined 
able plan hinges settling appropriate definition term theory 
position taken essentially newell assault unified theories cognition 
newell said state positively general body explicit knowledge answers obtained questions inquiries 
answers predictions explanations prescriptions control 
body knowledge yields answers questions call theory 
little sense worrying body knowledge just collection facts data base people heights ages fundamental axioms subject matter newton laws plus supporting explication 
difference course important 
clear going answer different sorts questions different scope different potential development 
different bodies knowledge 
play role providing needed answers 
pg 
theories considered ways generating answers questions 
naturally traditional conceptions scientific empirical justification apply considered desirable 
definition key aim define theories useful tool analysis design scientific empirical justification 
remaining question 

practical art designing theories answer offered consider seriously idea application oriented theories artifacts need designed just artifact needs characteristics users mind 
stance expanded somewhat chapter comments 
approach treats theories artifacts things design 
purpose theory artifact approach take seriously idea theories need built suit intended application 
approach new 
barnard instance pointed reasons design relevant cognitive theories exist really ensured usability seeking apply cognitive theory hci fact behaved just early system designers 
glass basic psychological technologies developed new purpose early design command languages interfaces application representations engineering models heuristically constructed theorists provide deep analysis requirements extensive study target users designers actual contexts design occurs 
pg 
view account outlook pursued artifacts theories models examples produced supposed early prototypes 
tools analysts designers tools answer questions 
ones alpha versions 
necessarily missing functionality partially usable 
reasonable expect go improvement cycles common artifacts 
researchers may try improve 
new capabilities added 
different theories join 
user manuals tutorials written theories done cognitive dimensions framework 
theory artifact viewpoint provides way answering possible criticisms potential pitfalls 
shows point counter point debate 
debate summarized table 
point counter point approach pylyshyn took approach debating possibility theory applicable design tactic 
tactic raise counter arguments may put forward useful cognition related theories built 
behaviour complex 
point psychology seriously studied century barely dent 
approach expect basic sciences provide answers 
counter approximations useful able generate approximations 
furthermore approximations want 
instance newtonian mechanics approximate frequently just fine ordinary mechanical engineering 
argued relatively little deep scientific knowledge needed useful observations 
instance hutchins dc argued little internal psychology 
practical art designing theories useful theory impossible point counter point approach behaviour complex able approximate iteratively refine deepen theories hope theory shallow models useful approximation better intuition theories really needed build broad brush theories theory available point counter point approach design precedes theory craft folk knowledge try add rigour formality analysis evaluation important improve theory basis evaluation ignored practitioners se community se researchers psychologists se research psychological research problem usability theories models carry psychology import psychology hci export current theory poor familiar computational ideas build knowledge models build theories existing knowledge point counter point approach theories applicable applicable seek related usable research theories irrelevant wrong base tackled wrong issues focus problem available theory theories immature exploratory research broad high level theories theories fragmentary try integrate pioneer integrative frameworks table arguments realistic pursuit cognitive support theories individual needed 
may produce decent approximations relatively psychological phenomena 
approach start relatively gross approximations build broad brush theories initially 
iteratively refine theories 
detail added required application oriented theories follow advances basic sciences occur 
hope theory 
point hope complete accurate theories built able handle analysis design needs 
said certainly probably psychological principles determine design 
deducing design principles ask psychological theory pg 

psychology solved design theory 
counter previous counter point answer impossible perfection happily approximate 
extreme approximation useful right practically scientifically cognitive support theories 
approach se researcher theory 
practical art designing theories provided simply supplement craft skills intuition 
aim resources best abilities 
design precedes theory 
point case build tools theory explain 
theories needed 
counter 
theory construction design designers theory available 
theory 
furthermore design precedes theory need right explanations analysis evaluation see section 
rationally compare tools 
know parts tool copy 
lessons generalize 
approach worthwhile pursuing rigorous foundations tool building 
chapter illustrates understanding existing tools better fact worthwhile goal truly novel design knowledge comes 
ignored practitioners se community 
point tool developers se cs part ignore hci psychology 
cognitive support theories little practical impact psychologists possibly hci specialists 
counter problems making theories usable non specialists severe proven problems insurmountable 
modern undergraduate hci courses teach theory 
simple reasonably expect added curriculum way slowly 
approach dissertation concepts terminology familiar researchers traditional computing science backgrounds 
part familiar intuitions computation transfer topic cognitive support 
help increase acceptability results computing scientists obviously guarantees 
se people psychologists 
point past approaches hci required considerable amount psychological sophistication order effective 
building theories specialists deep knowledge inherently wrong average se researcher wants se research 
right background skill set 
counter straightforward answer models carry psychological knowledge 
necessary psychology built models 
limited number useful models built number surely nonzero 
approach focus important items addressed broad brush theories 
probably bang buck 
basic psychology included models chapter limited memory capacity 
learning models entails learning little relevant psychology 
importantly models psychology learned precisely needed 

practical art designing theories se research psychological research 
point se researchers want build novel technologies computing science theories psychological theories 
build cognitive support theories needs better cognitive science scientific foundations 
counter psychological research import 
right plenty useful research start process adequately explored context software comprehension software development 
approach trying add small bit detail tapestry basic science knowledge validating model comprehension focus collecting integrating existing knowledge 
existing research applicable 
point basic science sources consult fail directly applicable 
may low level explain highly esoteric isolated phenomena fail ecologically valid 
left practically applicable science base 
counter prior inapplicable 
true fraction applicable somewhat underdeveloped claim basic science build initial application oriented theories 
approach plan seek useful research entirely absent 
start required survey appears chapters 
prior irrelevant 
point finds potentially applicable theory existing literature irrelevant important issues software development 
wishes understand role tools programmers studies restrict tools model disembodied thinking going especially useful 
succeed modeling real world thinking may help understand cognitive support 
counter prior concentrated cognitive support part little awareness issue 
addition field adopted methods techniques inadequate addressing cognitive support 
mean existing knowledge entirely useless 
suitably augmented 
approach solution problems drive theory start favorite theory available try squeeze possible 
gaps science base highlighted filled best possible 
feed new problems back basic sciences 
long term problem driven help steer research theories needed ways 
hci research immature 
point right science base understanding hci cognitive support immature 
possibly produce 
counter true ways immature hardly 
try better fill rest tentatively 
approach current state reasonable course action start 
summary broad brush theories 
goal adopted chapters building theoretical frameworks models 
course theories expected iteratively refined deepened time 
cognitive support theory fragmentary 
point artifact supported cognition frequently taken back seat studies unaided mind 
research exists scattered multiple problem domains research disciplines unorganized 
efforts build application oriented theories light premature 
counter start gathering stuff 
need perfection time 
try update 
approach order get broad survey cognitive support phenomena theories needed generated 
survey collectively chapters 
summary human factors faced critical questions human behavior technical systems having gone cache theoretical weapons bare 
flach preface chapter pg 
xii 
decades se cs researchers psychological aspects software development 
fringe area traditional se cs researchers 
probably rightly 
mainstream se cs research regarding tools dealt primarily computational theories technological innovation performing psychology sociology 
topic supporting cognition central issues discipline 
cognitive social issues widely agreed pressing problems software development probably difficult solve 
endeavor building tools software development psychology written 
majority se researchers probably psychological research psychology ignored 
marginalized way past 
particularly vexing problem developer cognition studied distinction studying cognition cognitive support frequently supportive nature tools fully realized 
needs change sooner better 
se research seriously address development tools aid cognition 
needs applied science cognitive support engineering discipline built applied science 
basic psychological research argument establish applied science imports basic research 
really sort currently exists 
applied science cognitive support nearly important se tools research parsing automata theory logical frameworks 
summary models formal semantics 
difference applied cognitive support theories born disciplines cognitive science cognitive anthropology psychology come historically closer siblings mathematics logic theoretical computing science 
way chapter aimed advertise clear need applied science cognitive support serve call arms appreciate need applied cognitive support theories join development 
chapter organized debate role cognitive support se research 
hope debate helps put importance topic cognitive support sharp focus 
past se researchers able justify way maintain ignorance psychological aspects tools 
flip side cognition oriented works field effectively avoid question applicability 
viewpoints real threats positive change 
hope extended debate chapter pick apart rigorous research discipline 
debate consisted progression questions arguments response 
argued cognitive support subject important se research 
pointed studying cognitive support informal 
call research cognitive support theories merely call increased rigour sound scientific principles 
second serious problems existing research practices noted traced lack suitable cognitive support theories 
third desirable form theories explored examining mature example provided knowledge mechanical support 
addition way se research related cognitive support research elaborated order set realistic goals expectations se researchers 
programme building suitable theories outlined 
programme typical applied sciences research 
applied sciences starts problem looks existing research applicable theory candidate theory shape tries see useful 
rasmussen ecological interface design outstanding example sort research involved sort programme 
vicente summed efforts follows conducted literature review identify empirical findings pertinent aspects interface design interested 
second srk taxonomy umbrella framework integrating common language variety research results encountered 
third theoretical constructs srk deduce findings set principles interface design ch 

particular theories findings involved process described quotation closely followed remaining chapters 
theoretical construct covered chapters 
chapter cognitive support phenomena power unaided mind highly 
external aids memory thought reasoning constrained 
human intelligence highly flexible adaptive superb inventing procedures objects overcome limits 
real powers come devising external aids enhance cognitive abilities 
increased memory thought reasoning 
invention external aids things smart 
donald norman things smart ch 
idea cognitive support quite absurd way world outside head kind difference world inside human thinking problem solving 
tools claimed support cognitive activity provide sort explanation proof world support possibly 
really explain cognitive support way external world integrated thinking needs modeled supportive nature integration needs understood 
cognitive support designed way reasoning introduce tune interventions needs elaborated 
attempt deliver design reasoning saved chapter 
chapter concerned issue simply able explain external world impact cognition especially way artifacts software development tools support cognition developers 
search cognitive support theories 
approach taken theory design approach outlined section 
plan theory construction determine explanations needed find resources build suitable explanations create theories models raw materials way valuable eventual users 
scientist point view roughly corresponds elaborating phenomena interest sort statements wishes setting theoretical stance researching prior related generating initial theory accounting phenomena 
theory designer point view process looks performing requirements analysis exploring design space elaborating design approach settled 
viewing situation top level clear general plan chapter survey expose types cognitive support relevant software development chapter existing dc theory applicable resources chapter customize build appropriate models theories chapters 
step skipped 
cognitive support currently 
hard understand cognitive support simply cognition human behaviour hard understand 
complications 
thing essential nature cognitive support unitary homogeneous thing 
simply put different types support 
consider instance tool sets pen typical compiler checks program partial semantics type checking search tool grep 
clearly important types software development 
support thinking developers way 
support different case 

answer question real danger choosing focus narrow consequently adopting conception support far limiting 
challenge sure cast net wide encompass important variations able recognize similarities differences 
complication fact research concerning cognitive support lies scattered small pieces spans boundaries traditional research disciplines 
investigated cognitive scientists 
studied educational contexts industrial ones 
surprisingly basic descriptions phenomena cognitive support diffused variable 
example researcher talk artifacts external media act enhance reflective thought may speak augmenting human intellectual capabilities 
cognitive support guises aliases 
challenge presents problem synthesis various ideas gathered coherently composed 
comparing collecting past knowledge coherent difficult challenge exists independent problem explaining phenomena proposing models theories account 
making obstacle difficult fact explanatory frameworks understand cognitive support fairly incompatible varied 
potentially applicable theoretical schools widely known difficult reconcile 
chapters settle particular school called dc competitors discussed briefly assessed 
challenges met chapter short review selected research pertaining cognitive support 
review necessarily incomplete 
thousands history contemplated relationship human thought artifact 
psychologists considered century 
complete representative review history thoroughly scope 
goals particular chapter correspondingly modest wish help bring general se number common observations nature intelligent human activity enumerate supportive relationships artifacts 
shot unfamiliar field illuminate general lay terrain hope 
supportive relationships brief summaries outline basic types cognitive support issues may particular interest se 
addition hope review resulting collection citations aid researchers wanting continue line se researchers desiring additional reading 
wish take opportunity relate cognitive support se research studies disciplines 
disciplines related topic method papers generate sitting bibliographies 
relating may help build better bridges sibling disciplines conduits knowledge useful se 
organization survey organized main dimensions supportive relationship descriptive theory schools dimensions 
supportive relationship concerns characteristics human thinking artifacts tools relate thinking 
dimension addresses question generally speaking artifacts aid thought descriptive theory concerns ways researchers philosophers tried argue purpose significance artifacts human activity belief certain interactions artifacts crucial developing called higher mental capacities 
dimension generally addresses question artifacts important human thinking schools dimension concerned identifying sort research traditions problem domains seriously studied cognitive support 
dimensions tackled separate subsection 
chapter stage set building models theories seek explain phenomena 
supportive relationships solving problems human beings internal representations stored brains external representations recorded blackboard medium 
larkin simon diagram worth words pg 

aristotle speculated reasons base numbering system prevalent fingers useful counting 
know different number systems developed history counting physical artifacts base 
point hands bodies artifacts support thinking consequently significantly affect 
certainly takes moments reflection realize ways human thinking human artifacts inextricably 
dependent 
cognitive culture depend cognitive artifacts owe existence form cognitive needs 

supportive relationships written language wealth books fill libraries light technology updates flurry emails rely daily 
little doubt artifacts significantly impact mental lives 
thinking software developers exception 
software developers nearly scrap white board seemingly ubiquitous restaurant napkin 
software developer intellectual world differs mundane fact artifacts think special somewhat complicated everyday activities 
software designers build play prototypes critical part design requirements analysis draw diagrams write formal models programmers run programs order understand 
thinking creating problem solving takes place context artifacts impacted 
particular supportive relation mental activity 
important classes supportive relationships surveyed 
categories represent completely orthogonal dimensions support significant overlap 
attempted draw common themes understanding relationships 
theme support concepts described salient research reviewed implications se tools research drawn 
embodiment strategic artifact key understanding psychology complete tasks understand different task environments affect peoples strategies newell simon argued long ago 
stephen payne mental models cognitive artefacts pg 

live complicated world quite smart expect people artifacts environment full advantage 
world includes bodies artifacts surround 
called external world world outside head 
embedded physical world external world extension internal world 
consider external world place internal world 
example fingers counting coins data flow lines visual program :10.1.1.22.1477
way looking external devices resources action 
external resources available internal resources memory need 
bodies artifacts nearly endless variety 
known examples include abacus calculation bookmarking techniques tracking progress 
sorts external markers perform mental arithmetic mentally track progress tasks 
consider authors term internal refer things head mind external things external memory 
assorted philosophers may object definitions eyes internal external 
suffice purposes 

supportive relationships example long division frequently accomplished pencil 
having world hold partial results crucial process 
particularly important facet embodiment developing experience people strategically external resources mentally challenging 
words people ecological experts adept making effective strategic settings 
examples strategic external resources comes norman 
norman tells story colleagues uses office workplace organize activity ch 

files papers level system uses multiple calendars mark different categories appointments post notes office serve reminders reinforcements 
picture painted researcher keeps current state embedded state office 
example different domain short order 
observed strategic environments simplify mental 
may organize placement order may lay dishes plates serve temporary external memory orders prepared pg 
see 
norman example way unusual 
norman colleague published examples creative organize thinking research see instance harnad engelbart 
lesson humans adapt environment activities adopt strategies fact 
lave early everyday math earlier influential sources similar observations situated strategic 
relationship thought artifact hardly new obscure 
focused visual thinking provides overview consider thinks clay chemist thinks manipulating dimensional molecular models designer thinks assembling rearranging cardboard 
thinking seeing touching moving materials externalizing mental processes physical objects 
contemporary science engineering art design respect fertility form visual thought 
confused similarity externalized visual thinking expression visual thought 
chemist advancing thinking playing molecular model involved process chemist molecular model communicate fully formed idea person 
externalized thinking involves actively manipulating actual structure manipulate structure mentally 
pg 
sum points embodiment 
various parts external world including bodies may stand place objects thought 
manipulations objects replace mental 
popular phrase world best representation pg 
fact internal representations external artifacts necessary external ones stand 
corollary saying try world head fact right strategy artifacts serve representational calculational inferential roles required mental capacity 
corollary raises 
supportive relationships second point embodiment relationship capability external artifacts support thought ad hoc habitual strategies employing capacity 
important know artifacts strategically people 
studies artifacts strategically reduce mental effort familiar mundane frequently studies cognitive development piaget celebrated studies children manipulating artifacts difficult problems easier called everyday cognition 
studies everyday cognition performed quite time little overlap studies streams cognitive science cognitive psychology 
examples known cognitive science circles 
norman popular psychology everyday things categorized everyday cognition facilitated cognitive artifacts 
relatively known example strategic artifact de la rocha study turned physical objects solve math problems 
de la rocha observed dieter physically manipulate cottage cheese calculate fractional amounts trying mentally see pg 

important example larkin analysis coffee making 
larkin explained normal course events state world helps making plain current state problem providing clues course action see section 
larkin analysis suggests external resources reduce need memory planning degree problem coffee making facile solve reliably diminished capacities early morning pg 

examples serve illustrate ways people naturally incorporate environment reduce cognitive burdens 
relevance software development examples noted tend simple familiar general rule illustrate carries highly complicated domains software development 
software developers strategically resources available tasks artifacts software development complex 
example comes cardelli 
cardelli noted experienced programmers adopt coding style causes logical errors show typechecking errors 
example changing name field invariants change type remains get error reports old uses pg 

type checker employed essentially simple change impact analysis 
trick getting world help thinking 
automated typechecking explicitly designed impact analysis employed 
significant point typechecking ability compiler tedious method find uses field 
cognition oriented studies similar artifact software development 
interesting study done investigated maintainers reacted different toolsets performing remodularization maintenance task analyzing changes dependent software features see arnold 

supportive relationships programs 
study observed maintainers strategic external resources order easier systematic 
observing teams maintainers revealed variations ecological expertise practiced maintainers bring tasks 
noted keeping track state restructuring task state specific restructuring modifications called bookkeeping crucial activity 
bookkeeping occurs levels process completely performing specific restructuring change evaluating progress set changes sequencing restructuring activities 
team exploited structure implicit tools cursors program representation ordering lines file keep track information regarding current state activity 
methods employed programmers vary widely share underlying similarity trying achieve certain properties completeness consistency change 
method exploiting structure decreases possibility class missing required change address formulating flawed design requiring additional integrity checks 
general tactics amount maintaining lists data design considerations processed 
pg 
emphasis added glimpse ecological expertise maintainers 
observations authors go directly state general rule strategic implications going far study context remodularization faced complex design task programmer tool features way allows tool store information conveniently programmer 
tool conveniently store information programmer order subtasks way information immediately forgotten 
ibid pg 

variety studies complement 
flor hutchins observed paired software maintainers strategically program correctness checking capabilities compiler get feedback gain sense closure incremental modification 
bellamy studied smalltalk browsers experienced smalltalk programmers 
observed trick creating dummy classes perform category searches reusable classes exploiting capabilities browser 
interesting note sorts strategic flexibly ad hoc uses software development tools frequently overlooked evaluating usefulness software development tools see lethbridge studying cognition software development 
raises question regarding proper evaluation software tools 
advantage software tools employ strategically ways overtly designed grep dependency analysis generally utility knife determine tasks evaluate 
addition risk evaluating tools acknowledging burden learning strategies 
studying se tools appropriate research slogan don study software developers think think tools 
supportive relationships external memory internal memory man extra members importance deal hair rate whiskers 
memory goes pocket book 
samuel butler pg 

world remembers things just 
donald norman things smart 
external memory generally refers storage knowledge mental states artifacts externally internal memory 
sch intriguing fact roman educated slaves store appointments remember facts figures remind important points conversations arguments 
pointed fundamentally little difference modern memory devices personal digital assistants pdas online databases ancient uses external memory systems apart course enormous socio political dimensions underlying technology differences 
general external memory devices variety settings variety purposes simple reminders stored post notes list items kept shopping list phone number written temporarily palm hand long term works systematically permanently record knowledge 
external memories access costs costs employed mental memory limitations processing shortcomings 
textbook hci sure point memory short lived poorly accessible effortful update 
external memories help overcome shortcomings 
addition inherent cost external memories effectively requires specialized strategies 
studies despite obvious importance external memory general reluctance study external memory par internal memory 
tides slowly turning favour balanced treatment types memory utilized activity 
mixed bag researchers contributed mosaic individuals external memory aids norman peterson sch hunter card davies 
course conditions met counted external memory artifacts qualify representations said knowledge mental state 
details discussed 

supportive relationships external memory extensively studied context group social cultural memories 
instance organizational memory appears relatively higher research profile 
relevance software development software development memory intensive external memory expect pervasive 
individual personal external memory common 
external memory simple command line histories greenberg browser histories tauscher 
memory acts type external working memory 
study mentioned section strategic artifact provides examples external working memories form bookkeeping 
external memory longer term versions developer diaries naur scavenged code flor 
organizational memory place code libraries repositories collecting development design related knowledge zimmermann 
final example studied external memories interacted software comprehension processes 
study instance act externalizing memory shown influence degree recorded material understood fact noted research external memory 
crucial resource software development models development account external memory may turn important understanding developer behaviour 
instance characteristic expert developers retain high level knowledge piece software low level information novices tend develop 
way explaining preference experts extensive external memory needing remember program details need small efficient high level index knowledge order able retrieve external memory 
observations singer regarding just time comprehension strategy consistent conjecture developer relying externally stored knowledge page knowledge needed basis need index information know look order page 
understanding software comprehension better research external memory potential address problem developing computer support different ways design short term external memory browser histories improving effectiveness long term memory code repositories 

supportive relationships external resources structure user interface stimulate initiate cognitive activity user interface helps organise direct cognition passive receptacle thoughts emanating internal model plays active role problem solving process 
nardi models metaphors 
difficult tasks accurately called ill structured properties solution partly understood start fixed routine methods exist solve criteria success weakly defined 
result ill structured problems inherently involve guesswork backtracking reflection 
consequently role artifacts play help organize direct problem solving ill structured tasks 
help structure ill structured 
structuring problem solving inherently involves sharing control cognitive activity degree 
simple examples structuring artifacts checklists shopping lists written plans action 
resources consult activity 
examples passive structuring artifacts 
active example wizard software agent guides problem solver 
structuring resources pre designed built problem solvers 
solving ill structured problems requires problem solvers perform problem structuring goel de vries problem discovery carroll problem setting 
activities termed problem structuring 
problem structuring yields artifacts plans structure action 
studies literature classic works frequently cited illustrate capacity artifacts structure human behaviour simon ant walking beach 
actual path ant takes great degree dependent shape complicated problem solving mechanism ant 
simon analogy argue human behaviour characterized similar sorts structure 
ant humans think sources structure outer environment inner 
notice shopping list example came example external memory 
single artifact exhibit type support remember sections summary necessarily represent orthogonal notions support 
issue orthogonality cognitive support types visited depth section 
mistaken simon intentions suggesting arguing humans behaviour may structured external environment inner 
stretches point somewhat simon primarily human memory ant beach ignore structuring influences memory environment concentrate modeling presumably simple generalizable cognitive processing drives navigation structures 
simon argues human adaptations environment means mind revealed analyzing behaviour 
seen argument human action conditioned primarily external structures internal ones 
reality argument correctly seen limiting sorts validations possible inner models see rasmussen pg 
barring way tapping inner processes protocol analysis 

supportive relationships generally speaking notion activity structuring tends crop contexts problem solvers appropriate knowledge needed solve problem problem solvers wish retain structuring representations internally problem solvers structure action constructing artifacts manipulating environment 
examples case include design wizards novice application users construction learning environments students see section 
example second case precomputation performed creating checklists 
examples third case include office organizing activities norman colleague cooking organization done short order see section 
relevance software engineering software development activities including reverse engineering ill structured 
surprise find widespread artifacts structure software development processes 
classes structuring contexts described apply discussed turn 

delivering problem solving knowledge 
providing structures novices relevant software development novices learning software development techniques expert developers relative novices particular tool expert developers novice domain software system 
examples cases include structuring lessons students learning data reverse engineering techniques provision wizards execute source code queries engineers unfamiliar tool capabilities structuring lessons new software projects 

pre structuring 
potential advantages case tools regularly cited ability enforce particular development process brown 
type constraint action active forms structuring 
hutchins classic precomputation form structuring checklists case software inspections 
inspections checklists defect types miller ensure systematic evaluation 
course checklists passive tools enforce attendance checklists varying degrees 

self built structuring artifacts 
third type structuring known software development 
development problems difficult planning problem structuring activities common 
argued instance flow charts represent earliest uses external structuring mechanisms programming 
flowcharts developers form program problem structuring program directly transcribed see knuth 
produced flowchart structures dictate coding process 
similar arguments modern descendants technique coding oo systems uml diagrams 
problem structuring limited coding desirable difficult task software development 
excellent example revealed previously cited software 
supportive relationships restructuring 
observed maintainers building manipulating lists structure subsequent activities 
reflective visual intentional thinking create record mental efforts outside vaguely memory represent artifacts talk back form basis critique negotiation 
arias transcending individual human mind pg 

reflective thinking contrasted experience rote thinking described thinking activities knowledge mental processes strategies 
reflective thought important considering situations way ordinary ch 
amenable highly practiced routine thinking 
long observed artifacts play important roles reflective thought 
way better understanding role highlight metaphor implied term reflective artifacts reflect thoughts actions mirror reflects image 
sense artifacts world thinking concrete reify mental constructs ideas process descriptions models 
doing artifacts encourage facilitate reflective thought making potentially easier think thought actions 
phenomenon related reflective thinking called intentional thinking intentional thinking involves consciously learned ways extending memory solving problems thinking creatively thinking critically 
familiar example technique brainstorming train method writing words concepts thought hopes discovering connections structuring 
intentional thinking techniques inherently artifacts drawings charts checklists 
organized trying visual perceptual capabilities 
studies main points literature reflective thinking covered section concentrate intentional thinking 
exists great deal non academic trade press self help pulp psychology sections modern western 
books advertise improve mental fields management marketing mathematics polya claim able improve creativity idea development creative writing design flower see allen ch small review 
works highly regarded lean scientific reify regard material concrete thing merriam webster online encyclopedia 

supportive relationships part academic psychology avoided techniques publications 
considerable interest sorts techniques contemporary education educational psychology literature perkins especially constructivist educational literature see section 
certain idea processors concept mapping programs widely known examples 
relevance software development confronting cognitively challenging problems software developers naturally reflect thinking attempt self consciously apply problem solving strategies 
instance intentional strategies problem decomposition design commonplace software development 
called variety names analysis methods engineering methodologies 
classic examples include proposals solve design problems focusing persistent data functional decomposition 
main implications se tools research derived relationships reflective intentional thought artifacts support 
side coin properties tools needed effectively enable reflection intentional strategies sugiyama fischer 
side creation teaching thinking methods enable effective tools available 
evolving structures emergent thought complicated artifacts created incrementally iteratively thinking things completely 
writing research familiar example 
final form research may resemble superficially writer original vision 
process writing author revise edit structure flow passages individual wording 
sections may rewritten deleted entirely 
writing author may think new things say 
may re read written order re orient inspire new passages 
artifact constructed piece piece grows incrementally non monotonically 
point view writing process unstructured inefficient planned simply typed letter letter having changes 
ideal planner write head hierarchically decomposing topic sections simply transcribe results 
process considered optimal observed practice trivial construction problems 
construction frequently consists incremental interactive process interleaving writing reading evaluating 
process uncertainty discovery backtracking updating previous results occur 
interesting exceptions rule psychologists studied certain mental tricks techniques mnemonic coding techniques memory calculational shortcuts arithmetic problems ericsson chase 
tended artifact free methods understood problems 

supportive relationships sorts problem solving processes characterized variants design 
carroll rosson describe design non hierarchical strictly bottom strictly top 
radically transformational involving development partial interim solutions may ultimately play role final design 
design intrinsically involves discovery new goals 
pg 
design problem solving activity occurs broad spectrum activities including engineering design writing software design programming software construction reverse engineering 
number reasons suggested prevalence limited planning capacity human designers fact goals requirements frequently change design fact ultimately designers learn problem solution poor decisions due presence uncertainty absence foresight 
return point section design processes ones thought artifact intimately tied 
complex artifacts sketches documentation specifications programs normally created iteratively evolved design 
artifacts part designer environment situation 
designers extensive environment evaluating current progress managing focus attention receiving ideas back return see section 
design involves feedback loop design moves impact 
difficult attribute causal roles systems feedback loop circular causality 
brooks described problem circular causality said hard point event place system say external action manifested pg 

result designed artifact seen emerge iterated application local changes feed back decision making design emergent process see poon 
incrementally evolved artifacts play crucial complicated role emergent process 
partly function external memories alleviating need remember partial form solution encourage reflective thought progress serve partially structure 
say designer responsible design contribution artifacts inseparable part design process 
proceeding small point needs covered 
thought certain representations uml diagrams eliminate backtracking involved making development process structured 
clearly techniques merely changes medium form design 
incrementally constructing program directly medium programming language planning stage added incremental iterative process developing representations uml diagrams 
point adding extra step take advantage environment planning especially exploring backtracking unpromising decisions costly 
studies see sections reflective media design studies 

supportive relationships relevance software development iterative evolutionary process artifact design update implications design supporting languages environments engineer training 
design tools needs take characteristics design processes consideration 
true tools designed software design maintenance reverse engineering software comprehension see section 
tools need take account emergence solutions resulting cyclic interaction developer environment 
representation effect long observed differing representations logically equivalent measure remarkably different psychological implications significantly different ease 
problem represented form may certain inferences automatic different representation problem problem incredibly difficult 
norman calls phenomenon representational effect refers phenomenon different isomorphic representations common formal structure cause dramatically different cognitive behaviors pg 

familiar example difference line graph table values 
line graph easy read certain information finding maximum value 
certain visualizations displays features pop 
representation effect solely concerned fast inferencing quick recognition rapid perception 
form representation help mental manipulations problem solving 
norman gave example arabic numerals facilitate multiplication roman numerals 
addition design representation possible nearly simultaneously answer multiple questions giving certain inferences free rides inference result seemingly immediately apparent 
studies representation effect widely studied cognitive support related phenomena 
sample overviews include norman scaife 
relevance software development representation effects primary motivations pursuing software visualization research 
area application design textual visual programming languages environments 
automation lest forget problems amenable completely automated solution processing capabilities computers 
problems involve mathematical manipulation symbolic manipulation inferencing pattern matching search 
complete automation task represents extreme case cognitive support task automated mental effort absent 

descriptive theories descriptive theories denying people important valuable insights human nature design technologies 
confuse wisdom having scientific theory 
pylyshyn remarks theory practice gap pg 

realized artifacts important parts human thought culture attention frequently turns characterizing describing relationship 
various theories proposed rough sketches thoroughly developed 
theories primarily descriptive introduce concepts terms describe phenomena thinking artifacts importance producing causal explanations mechanics thought 
theories developed basic science researchers psychologists find strong voices certain domains practice education 
times theories originate practice domains 
theories conceivably applied various supportive phenomena noted previous section 
instance concept mediation section conceivably invoked help understand external memory 
short review surveys descriptive theories domains frequently 
table summarizes 
table column lists entities section column section section 
characterizations descriptive theories theories concepts associated support relationships common study domains sch reflective practitioner reflective thinking emergent thought strategic artifact activity theory mediation embodiment intentional thought education software design education writing augmentation symbiosis external memory structure automation writing hypertext fitness representation effect visual thought programming decision making table descriptive theories various cognitive support relationships admittedly brief review theories mean imply analytic power research underway fully elaborate models causation 
things true 
point behavioural gestalt psychology emergence cognitive science discussed schools developed strong mechanical explanations section tries distinction mechanistic theories 

descriptive theories mediation reflective media thought products processes represented externally natural say artifacts media thought clay medium sculpture newspaper medium communication 
external artifacts structure control activity say mediate thinking processes artifact users 
themes mediation reflective thinking external artifacts woven diverse schools thought nearly century 
instances noted 
notion reflective media donald sch designer thinking design education 
describes design conversation materials designers parts solution external media models provide practitioner 
explanation relies idea practitioner engages distinct modes thought 
course design designer frequently expertise skill able act minimum amount reflection making decisions gaining insight fluidly little conscious effort 
activities said evoke skilled practiced responses designer may know knows things 
challenging design settings fluid design activity inevitably interrupted poorly understood surprising evidence encountered 
breakdowns skilled execution cause designers reflect actions 
circumstances designers enter different mode thought artifacts help reflect actions design problem 
interaction artifacts portrayed conversation conversation materials 
sch quite influential design studies design science world way understanding practice industrial designers architects software designers developers 
sch especially designer education strong education research including design learning environments educational materials lehrer 
mediation important concept approach called activity theory school psychology traces history soviet psychologists particularly vygotsky 
activity theory reputation difficult understand western taste ideas purposes 
activity theory tools artifacts understood stand metaphorically speaking thinker subject thing thought object 
interposition tools mediates activities mediation radically change nature activities engaged 
especially relevant notion activity theory idea functional organ joint system composed human working close combination artifacts 
example eyes glasses form functional organ produces sharp vision 
activity theory interest posed alternative theoretical framework hci particularly alternative dc 
deserved 
activity theory written capitalized 
acronym chat cultural historical activity theory 

descriptive theories scaffolding scaffolding evocative term understand roles artifacts people agents helping people think learn 
metaphorical temporary construction 
possible build structure fall scaffolding built strong stand 
roots scaffolding frequently see soloway goldman traced back called constructivist socio cultural education theory psychology 
idea scaffolding commonly applied artifacts idea processors learning environments simulations micro worlds writing tools help establish thinking processes enable learning 
meaning term scaffolding expanded include practically external structure strategically perform tasks pg 

concept extremely versatile precisely defined 
jackson defined classes scaffolding supportive scaffolding reflective scaffolding intrinsic scaffolding 
exact definitions especially concern types close analogues concepts review cognitive support 
instance notion reflective scaffolding echoes reflective media previous subsection 
general manner scaffolding similar support adds certain wrinkles 
particular issue learning scaffolding critical idea added scaffolds fade removed learning accomplished 
augmentation extension symbiosis idea computers augmenting humans comes primarily bush brought term computing engelbart carried torch augmentation 
basic ideas far older pioneers understand physical mechanical augmentation centuries see butler page 
concept augmentation enjoyed popularity distant computing past see symposium computer augmentation human reasoning 
main idea underlying augmentation basic human capabilities added augmented computer capabilities 
take bush memex example computers augment human memory knowledge 
way telescopes augment vision possible see farther vision computers augment human memory possible remember better think better 
extension extended memory essentially idea may carry additional connotation extension apply existing human capabilities complementary ones 
worked engelbart sri proposed computers related human activity terms systems 
view humans computers coordinate closely bring different play complicated problem solving 
attempted distance idea symbiosis notion augmentation suggesting relationship see bootstrap institute homepage www bootstrap org rheingold 

descriptive theories computers humans involved simply adding memory human capabilities 
particular claimed thinking problem solving taken computer systems 
instance ai programs perform pattern matching suggest alternatives problem solvers 
distinction may superficial fundamental difference augmentation symbiosis symbiosis human thinking capabilities cognitive processing augmented addition human memory capabilities 
authors noted possibility instance seemingly corresponds perkins distribution executive function 
augmenting thought connotation symbiosis shared augmentation mutually beneficial evolution see butler mackay 
distinction unimportant regard explaining cognitive support works 
notions augmentation extension symbiosis powerful evocative terms describing ways aiding human thinking problem solving 
useful envisioning possibilities setting goals 
modern threads human machine cooperation trace ideas back roots 
highly descriptive just descriptive generative predictive 
engelbart aware limitation carefully cast main writings conceptual framework intended outline research paradigm generate specific tool ideas requirements 
really needed se research explanatory predictive generative theories 
authors promoting sorts perspectives provided models exactly augmentation extension symbiosis built 
consequently smallest illumination cast mechanics artifact supported thinking works 
fitness notion fitting representation task beneficial problem solving new 
idea may intuitively obvious little explanatory predictive power expressed level abstraction defined operational terms 
judith right tool task pg 

artifacts better certain tasks certain circumstances 
relationship named described necessarily explaining 
call fitness 
notion fitness invoked describe suitability artifact respect aspect intended context see section 
tools need fit ecology 
instance may hear tool fit expert programmer performing impact analysis unfit novice performing program restructuring 
naturally definition fitness complicated environments tools 
tool fitness depend users environment activities 
words things affect performance behaviour see storey basili 
schools cognitive support stake tool fitness 
surprise notion fitness applied tools various ways 
examples include notion fitness task fitness psychology user fitness purpose cognitive fitness fitness system 
similar concepts called congruence gilmore match mismatch green gilmore 
identify support fitness cognitive support cognitive fitness 
schools cognitive support everyday lives people seldom undertake complex reasoning decision making tasks turning pencil scientist laboratory subjects permitted 
explains state affairs 
exist argument underlying traditional approaches cognitive skill looking unaided skill see mind action 
people tools pencil view mind confused contingencies circumstances outside scope psychology 
argument surely fallacious 
realize crucial role locomotion vision subjects move realize crucial role artefacts cognition subjects 
stephen payne mental models cognitive artefacts pg 

relationships artifact human thought action research focus certain groups people 
research cliques form particular problem domain education architecture form studying particular phenomena common way specific domain problem orientation short term memory social norms 
say research paradigm school say common problem type 
salient clusters cognitive support research surveyed grouped tradition problem type 
research tradition cognitive support subject potentially apply problem domain involving thinking problem solving 
consequently possible develop research paradigms study cognitive support domain independent way 
result studied various schools sub schools psychology lesser extent schools social psychology sociology cognitive anthropology linguistics 
sort research tradition set beliefs commonly understood ways doing research adopted study cognitive support matter school researchers belong matter particular methods ethnography versus laboratory study 

schools cognitive support reviewing research traditions exceedingly difficult worthwhile identify strict boundaries traditions shall understandably categorizations 
chapters umbrella dc review starts traditions linked closely dc works outwards 
main focus shall matters close hand relates cognitive science context artifact real world situations software development 
reasonably distinct clusters activity closely tied dc traditional cognitive science socially distributed cognition situated embodied action ecological psychology 
traditional cognitive science functional viewpoint stm short term memory defined internal memory combination internal stm part visual display subject foveal view newell simon human problem solving 
research paradigm reasonably called traditional cognitive science tends centre research cognitive models high level symbolic representations centralized processing 
newell simon seminal human problem solving paradigmatic 
contrary claimed external representations crucial explanation problem solving performance 
example school possible find intermediate results viewed stored externally algebra problem solving 
explain cognition contexts memorial capacity external world relied 
traditional cognitive science memory distributed head world 
distribution marginalized 
number relevant works continued traditional vein managed take account impact artifacts cognition 
examples sort include foundational larkin problem solving diagrammatic efficiency card hci modeling brooks program writing comprehension 
sort external world explicitly simply treated external memory currently perceivable contents appear working memory 
treatment mechanisms involved frequently simplistic items stored externally appear automatically internal memory magic relevant portions artifacts field view attended altmann 
type treatment external world adopted explicitly brooks pioneering modeling programmers third major internal knowledge structure information access external memory code programmer written 
quite little actual code remains accessible internal memory written subject study wanted rewrite reuse pieces code longer line written able recall directly memory 
modification correction 
schools cognitive support code written retrieve code external memory internal memory contain information necessary perform retrieval 
pg 
brooks models explicit external artifacts explanation thinking 
basic ideas rediscovered extended decade green 
brooks model suggested emerging solution section structure thought section implying programmer sub goal generation driven partially external representation internal goal stack 
chapters expand ideas point easily classified traditional cognitive science significantly anticipated dc situated action 
noted cognitive science evolved time research traditions 
aspects task artifact central issues descendents traditional cognitive science see review gray 
socially distributed cognition sdc second cluster cognitive science concerns external artifacts dc 
possible appropriate review dc adequately section especially main ideas covered depth 
sort dc covered highlighted 
type called socially distributed cognition sdc emphasize social group aspects cognition salomon collection 
sdc research loosely connected underlying conviction human intelligence human behaviour embedded context collaboration partnership underlying social cultural content 
instance common conviction sdc agreements meanings socially arrived socially constructed interaction communication 
sdc particular interests artifacts viewed knowledge pea mediate social organizational activity hutchins perry 
small glimpse ideas brought world software development researchers 
closely related socially distributed cognition research called shared intelligence collective intelligence group cognition 
long recognized people groups behave perform differently individually norman 
fact newell influential blackboard model individual problem solving inspired groups experts come solve problems way individuals see section 
choice term shared intelligence exposes interest intelligent behaviour purely function individual cognition ways tasks problems shared terms collective intelligence group cognition imply emphasis individual combine group structure dynamics group thought processes 
authors salomon collection come sorts research backgrounds link prior research sdc quite established 
context building supportive artifacts authors boy ideas understand application intelligent assistants 
smith considered support collaborative groupware 

schools cognitive support situated embodied action third cluster revolves called non symbolic anti representational explanations situated action embodied behaviour 
situated refers primarily fact behaviour contingent particulars situation actor finds 
important claims cluster behaviour ad hoc opposed purely rational fundamental ways action appears globally coherent result local interactions result global plan 
technical level important contention actual competencies behaviours humans intimately connected constituted contexts embedded pg 

words particular situated condition interest agent social cultural setting 
situatedness cognition simply phenomenon psychology address different schools try 
fact situated action viewpoints bear remarkable similarities viewpoints dc 
circles situated action schools takes situatedness challenge certain modeling traditions see thagard ch 

details controversy important see clancey special issue cognitive science lively discussion situated action theorists pursued modeling tradition avoids core reliance directly representative symbol systems plans action centralized processing 
frequently models emphasize global properties emerge local interactions highlight intimate interaction external internal world 
prominent figures loosely connected school include suchman clancey clark 
little situated action camp applied software development attempts see law shukla 
ecological psychology fourth cluster related research gathered termed ecological psychology tradition pioneered gibson 
ecological concerns captured gibson attention familiar strains psychological study certain ideas said endemic ecological psychology cluster 
gibson appears require concepts fit order gel properly 
idea direct perception information picked directly involving information processing steps computation 
needed concept great concern notion affordance 
gibson affordance realist property objects relates perceived actual capabilities artifacts actions performed 
instance buttons afford pushing chairs afford sitting 
affordances artifacts task relative single artifact afford different actions different people 
screwdriver affords driving screws poorly affords driving 
human action consequently related artifacts worth noting computational models symbol processing significantly different character see section 

schools cognitive support artifacts affordances relate tasks performed 
way relating artifact task behaviour gibson influential certain circles particularly field cognitive engineering see section 
problem domain research problem domain may directed cognitive support realized artifacts important parts mental lives people domain 
different research traditions mentioned previous section subsequently employed domain 
design educational research institutions maintain separate faculty design includes graphic design architectural design engineering design 
list design professionals extended include software designers 
ideas design theory software design somewhat directly see reviews mcphee indirectly influence christopher alexander design patterns 
design community philosophically connected shared premise underlying common activity different forms design 
research movement began founding design research society www drs org uk watershed conference possibility creating science design 
edition simon influential sciences artificial came soon helped speed progress field 
problem domain main concern people design things routinely creatively 
potential crossover points design studies research cognitive support software development 
topic similarities 
design field shares software development interest processes methods designing things artifacts computational support processes 
instance interested things sketches models different phases design envisionment creative design 
second methodological similarities 
studies design field closely reminiscent studies software design programming maintenance 
instance protocol analysis studies field bear remarkable similarities software comprehension reverse engineering purcell 
addition ways researching tool support similar 
example authors protocol analysis try discover information designers attend design order determine requirements information management tools 
tactic remarkably similar information needs analysis software comprehension von mayrhauser 
third definitely opportunities sharing theoretical content 
ideas design related authors christopher alexander herbert simon donald sch way computing science theorizing see robbins guindon sch 
direct mixing occurs authors publish design literature visser hoc guindon davies publish journals common communities publish software psychology related conferences books 
schools cognitive support empirical studies programmers workshops 
addition design research may utilize science base computing 
example design may dc theories perry 
cognitive engineering cognitive engineering mixture human factors hci industrial engineering 
viewed industrial human factors industrial psychology concerned high level cognitive issues industrial contexts 
contexts typically constitute complicated socio technical control systems aircraft control industrial nuclear plant control 
researchers area concerned design human machine systems self consciously interested notion joint system performance 
example typical assumptions domain total distributed humans machines important design goal allocate functions machinery ways reduce cognitive overheads operators 
great deal relatively mature research field concerning analyze design cognitively intensive socio technical systems 
example see volumes vicente flach hancock rasmussen 
ideas floating community applicable designing software development tools modifications applied field 
instance ecological interface design articulated theory provide support cognitive provision called abstraction hierarchy 
testable hypothesis usefulness certain representational forms forms applicable software visualization 
theoretical resources field integrated hasti framework chapter srk taxonomy see section 
management decision making management decision making concerned products processes involved making informed decisions purchases manufacturing decisions 
artifacts tables decision charts important resources decision making 
area contributed long stream research textual graphical representation effects 
research influenced rasmussen srk taxonomy cognitive engineering may potential points contact software development 
education education research interested improving teaching learning 
way viewing design science concerned improving facilitating cognitive performance problem solving 
shares common ground applied sciences cognitive support engineering disciplines built 
cognitive engineering long history theories applying practice instructional design research see 
instance theoretical schools surveyed applied technologies 
schools cognitive support education see special issues instructional science multimedia metacognition various conference 
noted cognitive psychology educational psychology distinct disciplines journals conferences 
design oriented focus educational psychologists nascent analogue software engineering psychology 
potential crossover points include studies representations media problem solving learning studies tutoring systems interactive learning environments studies training methods metacognition reflective thinking order skills problem solving possibilities theory transfer cross 
point education researchers longest histories research benefits diagrammatic representations visualizations see paige 
educational researchers past recognized importance external media education research external media currently vigorous mathewson 
research time mature may hope transfer relevant research cognitive models studies reading software comprehension software visualization 
examples include studies diagram reading strategies studies memory spatial location passages 
second point argues psychologically motivated design ideas computational support investigated educational researchers anderson salomon ideas learner support scaffolding conceivably transformed analogous concepts se support 
third point indicates research education quite directly relevant cognitive support se workers se frequently need formal training need learn job order enable effective novel technologies see 
fact training technology deployment frequently go hand hand see rasmussen cogent argument 
fourth point suggests may great deal theoretical groundwork common 
certainly authors working computer learning field related theoretical roots salomon dillenbourg 
reading writing reading writing research exists semi independently related areas education computer documentation hypertext 
reading researchers frequently concerned people read understand texts 
writing researchers concerned problem writing sorts stories reports easier better 
known importance intermediate representations outlines sketches notes annotations writing aspect performance neglected writing research 
design science reading writing research involves observational studies verbal protocol similar performed software development tool research 
volumes writing environments highlight building maturation field 
possible points relation reading writing research cognitive support research software development 
obvious fact text comprehension research influential software comprehension research pennington soloway 
schools cognitive support 
similar cross fertilization concerning cognitive models planning feasible 
instance models writing planning hayes strongly resemble programming planning models turn consistent modeling framework chapter 
points contact specifically related cognitive support significant research roles diagrams text comprehension maturing research attempted organize explanations artifacts aid writing processes 
best examples bodies research pemberton colleagues smith 
hypertext information retrieval library sciences books marchionini allen dillon collected works increasing understanding fields main problems face involve cognitive support issues especially relating users perform iterative media manipulating interaction tools 
past fields strong interest underlying technology non linear representation documents document query retrieval collections management 
years awareness fundamental level information retrieval inherently interactive pg 

watershed workshop problems interfaces ir interest began grow regarding importance task concerns navigation problems sensemaking iterative querying regarding roles artifacts manipulation 
increasing awareness need understand user cognition problem solving subsequently relate task environments order develop corresponding requirements tool features 
example stanford digital libraries project gave birth reflective media scatter gather interface iterative problem solving models sensemaking models 
excellent example tweedie interactive visualization artifacts attribute explorer 
certainly direct point contact software development software developers hypertext information retrieval consens clarke tools 
clearly expect models program browsing need highly compatible models hypertext browsing hypertext browsers browse programs 
may relatively easy establish case 
instance ask anomalous states knowledge model information seeking hypertext see marchionini shares intellectual ground letovsky model knowledge seeking programs 
addition storey cognitive design issues developing software comprehension tools derived similar framework hypermedia 
dillon framework task information manipulation standard reading attempt build theoretical resources hypertext design ways similar spirit 
hypertext ir research seen having significant overlap program comprehension research 

summary extraordinary hci people confronted lesser diminished mental capacity 
diminished capacity result disability accident aging temporary conditions fatigue extreme stress 
reason diminished capacity exists motivation furnish mental capabilities augmented memory inferencing vigilance 
design field concerned support called extraordinary hci 
course humans limited mental capacity 
cognitive support mentally challenged fundamentally different cognitive support capable course special conditions genuinely distinct strand hci 
contributions se research extraordinary hci great extent symbolic substantial 
symbolic contributions readily appreciated 
personal experience reason frequently difficult fully appreciate cognitive support provided artifacts especially simple ones 
support overlooked 
tendency assume people amazing things build line programs simply mental capacity discipline 
fact impossible external artifacts frequently glossed 
cognitive support cognitively challenged helps put faith power human perspective 
convincing simple computer tools help people profound memory cognitive disabilities perform tasks write organize daily living 
activities just done prosthesis 
extraordinary hci symbolic helping appreciate importance cognitive support 
substantial contribution extraordinary hci concerns unique disabilities subjects studied 
experiments able subjects frequently difficult determine support offered tools subjects lack support substituting mental effort special mental tricks 
extraordinary hci study people established limitations zero capacity remember newly information minutes elapsed 
known limitations may useful experimenters way studying subjects various head injuries helped research brain function neurophysiology 
summary obvious things repeated realized 
ulam adventures mathematician 
chapter started relatively modest goals provide global overview types phenomena considered cognitive support clusters research contributed understanding help relate concepts se tools research order raise awareness issues community indicate potential applicability 
summary relevance research 
survey covered distinctive clusters support concepts descriptive theoretical schools understanding support concepts explanatory theoretical schools brought bear understanding cognitive support quite independent research communities stake understanding cognitive support histories trying 
survey reveals cognitive support multi faceted research widely scattered 
conclude chapter worthwhile standing back reflecting juxtaposition different strands research reveals 
thing hopefully quite obvious integrative reviews materials difficult se researcher global understanding cognitive support 
examples discussions cognitive support widely scattered unrealistic suggest tool researchers psychologists sociologists matter aware possibilities flavours cognitive support applications practice 
consequences predictable 
destined rediscover facts 
useful techniques ideas remain unused 
find simultaneously amazing incredibly frustrating research disciplines problem domains contain similarities regarding cognitive support 
tried pepper review adequate citations left included 
day am frequently discover papers essentially replicate similar insights publications past 
closing chapter allow point just example 
decades ago engineering design professor wrote non academic book visual thinking 
intended sort cookbook thinking better fact strategy manual problem solving 
noted people tend manipulate world order externalize thinking artifacts medium thought 
noted design implications media externalized thinking best accomplished materials easy form reform 
chemist snap elements designer tape virtue easily manipulated spatially symbols images moved modified internally mental space 
materials communicate visual idea formed need flexible 
pg 

similar sorts observations sure places 
essential implications design noted humans think external media medium external thought designed easily manipulable ideally fluid internal human thought 
relatively simple observations link aspects cognitive processes problem solving desirable properties supportive artifacts 
observations straightforward argue incorporated type standard design theory wisdom 

green cognitive dimension viscosity example nicely captures need easy manipulation context 
green includes excellent analysis psychology underlying cognitive dimension incorporated viscosity broad brush psychological design theory 
sequence papers presentations served expand framework virtues :10.1.1.134.5007:10.1.1.22.1477

summary point view surprising cognitive dimensions viscosity need argued papers 
surprising respected cognitive psychologist introduce little theory software development community viscosity obviously precedents 
noted things 
vexing psychological observations needed ones obvious known centuries 
take instance norman popular book psychology everyday things 
received contains scores psychological facts extremely relevant design standard reading undergraduate hci courses 
pylyshyn argued require knowledge psychological theory training psychological research sorts insightful psychological observations practical contained don norman psychology everyday things 
pg 
chapter find surprising little puzzling basic concepts cognitive support long ago brought loose functional theories designing computer tools 
focused articulation type support favoured reconciliation synthesis forms 
course come see section progress slow 
chapter highlighted number cognitive support concepts think just page enormously beneficial 
certainly thorough review cognitive support concepts help tease apart issues organize concepts publication 
chapter strengthening foundations cognitive support rods framework informal appeal clean living software engineer suppress mess cognitive psychologist 
green cognitive dimensions framework software engineers don listen psychologists don tell anyway pg 

general high level qualitative theories biggest impact field 
happens capture fundamental principles provide deep general insights important fine details 
trend noted newell simon acm turing award lecture 
observed essential characteristics discipline stated short general sentences 
field share theories explaining specific phenomena details overshadowed big picture 
newell simon highlighted particular importance cell doctrine biology theory plate geology germ theory disease 
gross qualitative theories critical understanding domain 
tie relate organize facts 
consider theory plate instance 
theory argues essentially earth crust plates moving growing pressing 
stated simple theory helps explain host facts fossil records earthquakes 
stated simply theory specific predictions explanations details eventually count 
non predictive qualitative nature theories diminish importance 
general qualitative theories enormously valuable understanding broad range phenomena high 
important function high level theories provide firm non specialists 
theory collects neatly packages key insights effectively 
theory detail awaits 
theory initial really stepping stone deeper specific theories 
look experiences typical science students countries evidence support view 
time high school age usually exposed qualitative theories listed newell simon 
qualify bona fide biologists basic conceptual tools needed able understand key aspects geology biology 
need deeper conceptual tools learned stepping stone qualitative theory easing transition 
main point high level qualitative theories widely accepted vital general knowledge 
general general useful 
normally think valuable children learn theories able apply sense world considered part rounded education 
similar reasons clearly articulated general high level qualitative theory cognitive support invaluable developers software cognitive domains 
se instance wide variety tools proposed order reduce mental challenges software development 
expect developers tools greatly helped understood apply basic psychological principles supporting cognition 
specific details cognitive support course important point arguably important knowing core principles 
core principles undoubtedly foundation detailed theories built 
details needed developer means guaranteed specialized theories principles assimilated applied 
case prudent expect general theories included list things educated tool developer know 
unfortunately simple comprehensive qualitative theory cognitive support clearly perceivable literature 
aim chapter take steps rectify 
form resulting theory important 
goal produce theory satisfies desiderata outlined section 
means making sure theory mechanistic explanations explains equivalence see table page 
judging qualitative theories enumerated newell simon able recognize suitable initial theory simplicity sentences ability help sense host related facts theories 
aim providing broad survey chapter fact set aim widely 
know succeed theory simple helps explain supportive phenomena identified chapter 
existing science base extraction theory cognitive support non trivial exercise 
phenomena cognitive support generally inadequately understood date studied limited incompatible theoretical approaches 
facing theoretical sensible course action limit confusion picking approach appears practical promise 
better theoretical frameworks appear update built put frameworks aside build new ones 
approach adopting industry standard developing software 
entirely satisfied standard agree importance adopting 
pragmatic strategy helps side step controversies rage cognitive science psychology 
standard picked key principles extracted highlighted general qualitative theory cognitive support 
act framework prior results theories fit 
distributed cognition dc theoretical approach chosen dissertation 
dc relatively new developing area cognitive science hold high practical promise 
researchers adopted dc umbrella approach hci research design wright dillenbourg rogers holland 
dc appears eminently suitable starting point scope enquiry taken cognitive systems composed humans combination artifacts 
artifacts seen peripheral cognitive machinery part 
contributions artifacts woven directly models theories cognition 
dc starting point leaves issues resolve 
fact dc theory cognition theory cognitive support 
cognitive theory model distributed guarantee means supporting cognition clearly spelled 
theory cognitive support provide explanation benefits artifacts provide 
analysis necessarily comparative benefits tool may understood comparison implied absence substitution modification 
cognitive support theories compare various cognitive systems determine relative benefits 
benefit explanation distinguishes theories cognitive support theories cognition 
theories cognition explain cognitive phenomena mental constraints forms internal representation learning performance 
class cognitive systems theory cognition explain predict sorts aspects class systems 
loosely speaking output cognitive theory prediction explanation cognitive phenomena behaviour output cognitive support theory explanation cognitive benefits provided class artifacts compared class 
existing dc theory embeds kind cognitive support theory description unintentionally concealed flushed 
fortunately easy convert basics dc theory simple high level qualitative theory cognitive support 
key idea doing described page chapter cognitive support provided tool computational advantages tool provides 
cognitive support understood entirely computational terms support provision computational advantage 
notice clearly theory cognition trying explain support 
theory cognition obviously necessary statement logically distinct type theory 
note phrase providing computational advantage statement comparative means computations involved artifact better way 
stated way qualifies high level cognitive support theory high level unfortunately 
imagine dial sets level detail theory theory threatens set dial high useful 
details added statement analysis proceed 
wish lower detail dial 
dial lowered addressing questions quickly arise reflection 
computational advantages mentioned 
existence mentioned natural ask complete list 
second go determining advantages 
tools differ support provide natural ask method analyzing differences 
involves knowing support implemented artifacts cognitive support principles apply hci supportive mechanisms compare 
obvious 
tools frequently compared surface features widgets user interface metaphors functionality store edit graph analyze 
contrast need able compare artifacts cognition users 
simple theory offered front really needed slightly complicated follow useful relatively simple answers questions 
rods theory analysis framework proposed fit needs 
core part rods list fundamental principles computational advantage 
ordinary notions computational efficiency familiar computing scientists 
principles called task reduction algorithmic optimization distribution specialization 
principles collectively referred acronym rods 
principles central entire cognitive support framework defined chapter called rods 
rods intended strengthen foundations understanding cognitive support se 
adopting goal meant form qualities rods engineered specifically criteria 
designed try fulfill desiderata section mentioned 
second specifically constructed needs traditional software designers mind 
needs discussed section 
rods designed try define cognitive support principles orthogonal computational ideas 
point important sections dissertation discussion best delayed section 
time design issues put aside issue constitutes rods considered 
chapter proceeds follows 
main dc tenets collected described section 
review necessary part theory unfamiliar se circles help relate theory domain 
needed exists considerable variability dc treated various stated 
second cognitive support principles rods introduced section 
third ways analyzing tools support described section 
fourth rods evaluated terms matches theory desiderata outlined section 
section summarizes rods construction 
naming scheme similar card called entire analytic framework goms key cognitive elements framework goals operators methods selection rules 
properly speaking goms rods refer focal parts analytic frameworks embedded 

dc principles tenets dc principles tenets impossible say constitutes dc viewpoint variability field 
dc se cognitive science generally 
sorts research differing underlying methods philosophies fly flag dc 
important state basic assumptions 
goal section simplified version basic dc 
aim characterization suitable se research relate important dc principles se issues 
tenets necessary understanding rods framework required appreciate rods applied 
small core set commonly assumed singled 
chosen enable theory design subsequent sections 
discussed separate sections 
tenet attempt supply representative links supporting literature 
links se works possible 
addition implications rods design noted appropriate 
presentation attempts distinguish independent atomic tenets 
divided groups consisting cognitivist modeling principles corollaries dc terms 
labelled easy simple naming scheme 
table tenets appears table 
table uses arrows columns illustrate fact standard cognitivist dc analogues 
note dc tenets needs advance 
tenets fundamental reasonably widely held may times review known concepts ideas 
may times worth repeating 
tenets said universally held currently contested 
result review seemingly dubious dual properties review material certain accounts incorrect 
important explicit fundamental underlying framework 
explicitness bound beneficial researchers new dc 
clarifying basic assumptions helps researchers similar fields understand relationships worlds 
quite worthwhile risk relatively benign hazard tedium listing 
cognitivist distributed human mind cognitive unit distributed functional unit cognition computation cognition distributed computation cognitive interpretation external cognitive interpretation table key tenets dc human mind cognitive unit traditional assumption cognitive science thing studied modeled cognitive functioning human mind 

dc principles tenets cognition computation fundamental principles cognitive science cognition adequately modeled type computation computation consists operations symbols cf pylyshyn newell 
explaining cognition computation advantage mechanical explanation cause behaviour advanced 
difficult importance advantage 
rods takes lesson heart attempts explain cognitive support purely computational terms 
cardinal rule rods support properly explained explained computational models appealing fundamental principles computation 
software comprehension se computational models de facto cognitive modeling technique se domains late early 
cognitive models slowly begun offer explanations causes programmer behaviour 
explanations offered advantages black box techniques unable properly uncover causes 
cognitive interpretation cognition modeled computation simple corollary certain computational mechanisms interpreted cognitive terms 
particular possible talk data corresponds knowledge mental state computational processing correspond perception attention thinking deliberation reasoning 
important note viewing data knowledge processing thinking interpretive act 
computational models assumed data processing systems systems purely syntactic manipulation symbols having inherent meaning 
model posits concepts cat house encoded means syntactic entities interpreted analyst terms semantically meaningful concepts 
level fruitful talk cognition manipulation meaningful symbols 
mean open subject see tiny inscriptions words cat house 
adequate treatment cognitive support require possible principle map cognitive concepts goals plans implementation 
guarantee mapping obvious way 
cognitive level concepts goal plan may implemented centre gravity temperature directly point may perfectly reasonable build models reality 
importance points shall apparent conviction chapter 
terminology accords turing original understanding term symbol cognitive science symbol normally understood syntactic element symbol system semantic content interpreted 
definition reasonably leads notions sub symbolic computation purely syntactic notion symbol nonsensical 
section reason presenting cognitive models interpretation data processing clear 

dc principles tenets distributed functional unit cognitive unit cognitive models built explain predict behaviour 
models able insofar model mechanisms contributing 
bounded systems mechanisms weak connections external entities 
consequently bounded systems form distinguishable units analyzed relatively independently 
units modeled independent computational subsystems understood ways interacting embedding contexts 
say independent bundles causal influences identifiable subsystems modules may say low external coupling 
strict modularity real systems systems loosely connected termed modular studied separate entities 
modular subsystem human mind 
typically assumed generated brain bounded physically skull 
mind forms traditional unit analysis cognitive science conviction 
sufficiency traditional unit analysis challenged dc represents approach expand unit analysis 
example traditional unaided mind unit breaks group interaction 
people working groups form larger combined systems behaviour individuals group dependent relationships interactions individuals norman 
subsystems combine larger systems expanded unit analysis 
duke called coupled units units fact subsystems unit tightly bound term comes greek word meaning bind 
dc examples units studied 
examples include airplanes navigation teams ships pairs maintainers sharing single computer 
humans form units artifacts pdas significantly software development tools environments 
key criterion identifying units closeness interaction subsystems strength coupling entities 
coupling physical temporal proximity causally functionally related 
consequently hutchins uses term functional unit refer units variety terms 
instance activity theory similar concept functional organ see term system applied context socially situated cognition see 
imperative settle single term generally referred joint cognitive systems speaking single user human computer simply cognitive systems clear systems question distributed ones 
cognition distributed computation conviction cognition modeled computationally combined conviction unit analysis joint system implies joint cognitive systems modeled distributed instance may return marked passage book long marked passage qualify external memory 

dc principles tenets computational systems 
hutchins ship navigation best exemplar view 
body extended groups actors artifacts jointly participate perform navigational computations fixing position ship 
cognitive models dc simply distributed computation models existing computation modeling techniques cognitive science potentially imported applied 
different terms applied emphasize cognitive implications 
instance traditional cognitive science standard analogue computation symbol processing emphasize semantic level processing 
dc literature finds manipulation propagation representational state 
external cognitive interpretation conviction computational systems interpreted cognitive terms combined conviction artifacts part joint system implies possible interpret artifacts cognitive terms 
able speak artifacts terms function memories store knowledge 
able think artifacts terms participation reasoning planning problem solving 
possible view artifacts different sets lenses cognitivist lens reveals cognitive functions artifacts computational lens reveals implementation cognitive system computational system physical lens shows computational functions manifested real world objects 
instance printed checklist viewed plan cognitive list computational body text printed page 
notice mapping levels generates abstraction boundary allows substitutions occur affecting higher levels 
instance cognitive function occur printed checklist implemented pda true plan represented say set actions set ordering constraints elements 
point important considering compare cognitive systems section 
non distributed case way cognitive content encoded may arcane 
example pending goals may represented part position hamburger piece string 
just possible peer inside head see inscriptions cat house cognitive roles artifacts may labelled convenience 
hutchins pointed artifacts readily available inspection inner workings brain 
different streams research take care explicitly interpret artifacts cognitive terms 
best known approach ai approach begins argument computers may implement artificial cognitive systems 
data processing ai system referred cognitivist terms mental states knowledge inferencing reasoning 
approach interpretation cognitive level overt explicit openly acknowledged reasonably easy follow 
consider explicitly intelligent artifacts employ cognitive interpretations understand participate human thinking problem solving 
approaches cognitive interpretation implicit tacit 
examples overt tacit approaches 

dc principles tenets overtly intelligent ai dai agents dc ai called old fashioned ai approach cognitive support generally tries build relatively autonomous intelligent programs assist humans 
ai research concerned represent knowledge efficiently implement inferencing realize various problem solving methods 
ai efforts ai developers explicitly cognitive level notations tools formal ontologies knowledge representation languages inferencing algorithms 
manifestly cognitive level formalisms help ensure analyst cognitive level understanding knowledge inferencing translated faithfully computational implementations 
prime example programmer apprentice pa project 
pa project aimed build intelligent assistants smart take relatively coding programmers 
pa project utilized formalism representing knowledge form plans 
mapping analysts understanding plans implementation strings bits explicit straightforward 
artifacts 
different strain research studies artifacts explicitly intentionally intelligent ascribes cognitive level interpretations 
ai oriented clear intent complicated computer programs behave intelligently autonomously 
artifacts pen involved cognitivist interpretation material artifacts tends significantly muted 
may speak roles dumb artifacts joint cognitive terms 
norman fact calls cognitive artifacts 
ordinary artifacts people interact thought part cognitive machinery individual 
view artifacts substantially different qualitatively overtly cognitive approaches exemplified ai research 
magical implementing ai computations digital computer 
exact computations implemented principle hand pen 
take mental part analyst understand shopping list string tied finger terms cognitive state 
world seemingly ordinary frequently finds close cognitive 
example sort interpretation software development comes flor hutchins 
described code scavenging behaviour knowledge reuse 
interpreted external artifacts embodying knowledge manipulation artifacts form knowledge manipulation 
specifically proposed mapping code base episodic knowledge base grabbing old code knowledge retrieval hacking unneeded parts schematic abstraction substituting particulars schema instantiation typically done cognitive science roughly separate cognitive interpretations artifacts mental representations cognitive processes 
mental representation brand research focuses humans extend external representations knowledge 
dc principles tenets mental states 
instance brand research examines ways knowledge exists world 
prime example se research reified externalized goals green 
essentially varieties mental representations traditional cognitive science goals plans concepts may analogues external representations 
cognitive interpretations external processes overtly considered cognitive processes 
ordinary computational processes take place computers sort process 
non electronic processes interpreted computationally cognitively point clear navigational computations hutchins 
issue processes done electronic computers occur part single joint cognitive process 
interesting ways occur artifacts process mental states externalized humans humans manipulate externalized mental states 
manipulation computer 
computer manipulation externalized mental state familiar cases external cognition 
form cognitive processing ranges simple calculation complicated symbolic processing 
example spreadsheet program calculating expected profits financial analyst exploring various forecasts 
example automated theorem prover employed software developer check program matches specification 
bias interpreting symbolic processing cognitively math symbols symbols 
processing occur head analyst may count part distributed cognitive process 
manipulation user 
brand cognitive processing associated cognitive artifacts involves direct manipulation artifacts users 
type external processing artifacts function medium cognitive states 
clay medium manipulating sculpture artifacts serve medium mental states manipulated user 
distributed version internal mental manipulation manipulated medium merely external internal 
classic examples come mathematics abacus slide rule long division 
variant epistemic actions kirsh 
put roughly epistemic action action world functions cognitive process inference 
variants cognitive processing manipulating external media 
scaife called types external processing external cognition supplied overview different instances 
main point dc provides important twist understanding external cognition models external cognition ordinary dc processing 
dc point view external artifacts manipulated external 
viewed merely parts joint cognitive system 
notes interpreting artifacts cognitive terms continuing preliminary remarks regarding forms realities representations external manifestations data 
topics data information knowledge 
dc principles tenets tricky exceptionally thorny 
hope satisfactorily resolving controversies continuing 
controversies resolved impact somewhat clarifying advance assumed see hayes 
goal provide definitions advance controversial topics raised discussion blizzard 
goal issues concerning cognitive interpretations external world need briefly touched 
notes regarding implementation encoding semantic content 
terms data processing mental state knowledge loose manner 
may ultimately great value pinning terms mean commonly assumed definitions precise 
terms information signal sign generally avoided 
reason simple data processing comfortable terms computing scientists suffice current purposes 
decision goes long standing traditions term information processing cognitive science 
worthwhile targeting computing scientists see section 
neutral computing terminology may help avoid thorny issues surround terms information signal sign 
similar reasons term knowledge treated cognitivist analogue data 
decisions may turn inadequate long term experience far distinctions captured rods hindered analysis 
interactions cs people quickly beneficial speak terms lowest common denominator data processing 
second notion equivalence implementations addressed 
essentially adopt assumptions introduced zhang norman 
introduced general scheme understanding distributed manifestations data dc systems 
scheme essentially expansion simon concept information equivalence representations 
view establishes way understanding functionally informationally equivalent manifestations data 
instance view problem constraint may equivalently manifested explicit rule head needs deliberate interpretation logical constraint easily checked visual processes implicit physical constraint observed necessity 
particular trio implementation types reminiscent scheme rasmussen proposed distinguishing signal sign symbol encodings 
delving distinctions productive 
shall remember equivalent implementations data computing process implementation considered privileged 
third representation 
representation slippery concept 
popular way defining representation terms representing relationship representation represents norman 
authors happy call practically stimulus representation special concern represented see zhang definition 
definition closer spirit terms information data 
distinguish representation data preference generic term data justified 
instance consider case program track list 
complications pile endlessly top may wish distinguish real physical constraints simulated ones 

dc principles tenets list date really said represent list items 
answer creates set problems 
serious confusion created logical physical aspects representations intermixed 
term representation refer objects manifesting representing relationship properties objects 
confusion unfortunately possible quite easy confound perceivable depiction representation representation 
discussing design artifacts confusions troubling 
instance consider list program 
output program representation list 
program able display list variety ways formatted coloured filtered elided better call array bytes held computer memory representation transient display 
just screen layout changes magnifying glass 
representation crt image formed viewer retina 
limiting definitions need progress occur 
gloss various nuances consider just issues manifestation data computer artifact presentation way making known user 
henceforth called representation presentation 
way representation identified data data structure presentation equated ways accessing data 
stance parallels tactic taken comparable framework defined wright 
fourth fact data data structures may distributed complicate matters 
possible non atomic data structure 
distributed different processing elements 
obviously relevant case data structure distributed human computer 
instance programmer writing code part written part stuck inside head 
zhang green give excellent examples data structures distributed 
choice examples tend cases data structures completely external 
just simplified cases tend examples 
bear mind practical instances distribution data human artifact may involved 
fifth duplication 
just artifact external memory data mean data may held internally 
copies external memory may cached internally 
conversely just user maintains internal copy mean external memory holding duplicate copy memory 
users forget things 
summary dc tenets dc theory provides viewpoint conceptualizing cognition terms permit artifacts members cognitive systems 
cognition treated type computation computation spread humans artifacts 
world view adds important layer understanding artifacts cognitive interpretation layer 
artifacts viewed terms function memories processors store process knowledge mental state 
conceptualization dc theory provide explanations complicated cognitive systems 
rods computational principles cognitive support airline paired software maintainers 
world view possible discuss contributions artifacts cognitive terms 
left pick principles beneficial artifacts support cognition 
done section 
rods computational principles cognitive support artifacts reduce cognitive challenges problem solving said offer support 
order speak support principled way sort language required arguing support consists 
assumed cognition modeled computation appropriate language cognitive support computing concepts 
simple example helps introduce idea 
hutchins notion precomputation understand benefits drawbacks checklists 
fundamentally computational explanation cognitive benefits checklists 
standard computing science understanding term precomputation connotes needed comprehend nature checklists 
instance computing list items advance effectively spreads computational time potentially lessening peak demands amount stack memory 
rearrangements computation standard tricks enabling real time performance 
addition understood value precomputation increased results reused times bound tradeoff terms memory requirements lookup costs 
precomputation spread computation different computing elements processor precompute values 
basic effects known standard computing 
hutchins noted effects occur cognitive systems improvements computing result improvements cognition 
cognitive analogues computer advantages precomputation formulated instance cognition distributed time individuals 
cognitive advantages artifacts stem directly computational advantage computational system 
simple example clear key benefits attributed checklist analyzed purely comparing implications differing computational methods 
type comparative computational analysis core part entire rods framework 
ultimate success dc explanation framework rests appropriate computational accounts types cognitive support needs understand design 
may initially worrying example precomputation certain sense quite limited 
basic notion precomputation provides computational account just facets cognitive support 
chapter surveyed varieties cognitive support incomplete selective survey 
may necessary able generate challenging number ways explaining cognitive support 
surprising find completely different explanations needed cognitive artifact 
plausible scenario relatively small set principles combination sufficient account varieties cognitive support 
situation cognitive support 
rods computational principles cognitive support similar chemistry 
chemistry small number different atom types combine endless variety generate enormous universe different chemical compounds 
alternatively reasonable compare cognitive support mechanical support 
mechanical support small vocabulary simple machines inclined plane pulley sufficient account wide variety mechanical aids 
zoo cognitive artifacts turn eminently manageable small collection principles computational advantage derived 
computational principle identify equivalence class artifacts provide sort cognitive support 
trick course settling suitable set computational principles 
ideally identify orthogonal computational principles considered independently 
rods proposes selection computational concepts principles appear account combination varieties cognitive support 
currently infeasible know certainty combination principles completely sufficient 
fortunately appears small vocabulary computing science concepts goes long way appear explain great number different types cognitive support identified chapter 
basic underlying principles fall categories task reduction algorithmic optimization distribution specialization 
taxonomy referred acronym rods 
principles rods identifies distinct substitution principle 
substitution says equivalent computation better way 
course notion equivalence defined adequate way notion substitution really particularly important part 
intuitively fact cognitive support principle identifies substitution principle may sense 
cognitive support necessarily comparative comparisons fair 
awkward argue artifact supports cognition entirely unrelated computation performed 
analogous rule mechanical support total conserved lever reduces force needed done 
issue equivalence substitution revisited detail sections chapter 
briefly mentioned order help readers appreciate rods arbitrary collection principles help relate principles 
subsections describe computing principles underlying cognitive support categories identified rods 
summary appears 
table lists concise statements computing principles 
exactly expect suitable high level qualitative theory 
provides short statement substitution principle design parentheses 
statements included primarily design theories discussed chapter 
terminology literature varies intended audience framework computing science oriented presentation computing science terminology possible 
category purely computational description principle offered followed analysis idea applied hci related fields 
principle may wide applicability 
applications listed sections primarily chapters section 
enumerating possibilities applying principles obviously scope chapter 
examples provided principle applied explain type cognitive support 
examples intended 
rods computational principles cognitive support task reduction principle functions easier compute substitution type substitute simpler tasks complicated ones example removing redundant unused computations example hci eliminating unnecessary steps design principle remove unnecessary relax task demands algorithmic optimization principle computational efficiency functionally identical algorithms differ substitution type substitute equivalent methods adts encodings example changing doubly linked list switching faster sorting algorithm example hci switching arabic numerals design principle optimize cognitive processes task infrastructure distribution principle distribution adds memory computing resources substitution type substitute external resources internal ones example caching memory hard drive client server architecture example hci puting shopping list automating constraint checking design principle distribute redistribute offload data processing specialization principle specialized routines processors efficient substitution type substitute specialized processors general ones example fpu accelerated graphics card example hci enable visual search substitute manual search design principle change representation specialized hardware summary rods computational advantage principles anchor discussion computational advantage somewhat concrete specifics 
task reduction possible eliminate unnecessary 
example designed development environment insist having developer re read line code program edit forcing line line scroll program 

circumstances waste time effort usually little new knowledge expected re reading entire code base 
computationally speaking problem unnecessary computations performed hci point view task reduced eliminating unnecessary steps 
removing unproductive influence performance 
form performance enhancement quite obvious discussed 
included taxonomy primarily reasons 

rods computational principles cognitive support main reason including task reduction rods confuse support types simple reduction done 
principle rods insist maintaining strong notion equivalence 
able eliminate differences amount done crucial rationally comparing support provided different tools 
nonsensical instance claim supports task doing math homework rendering unnecessary 
task sense needs done tool modified version 
consideration leads second reason including task reduction rods important identify cases designer simplify task demands requiring results 
cases strictly speaking instances artifacts supporting cognition 
rods proposed tool performing design chapter including task reduction category help designer consider design options 
note real world activities problematic tell parts task tasks 
necessary unnecessary 
problem user efforts side effects 
hypothetical environment forces developers repeatedly re read line code may cause bugs discovered 
developer may gain confidence correctness code confidence affect decisions legally signing security system 
circumstances re reading completely unnecessary 
news types support principles applied improve unnecessary 
algorithmic optimization algorithmic optimization refers modification data structure algorithm procedure method order improve aspects performance changing essential outcome 
hci terms typically manifested changes representations task solution methods 
computing science principles rods term algorithmic optimization denote change computing methods data encodings underlying hardware computational infrastructure remains unchanged 
fair say intent algorithmic optimization generally get computational resources mechanisms available 
interpretation aligns standard computing science 
instance bacon say goals optimizing transformations compilation technology 
maximize usage computational resources processors functional units vector units 
minimize number operations performed 
minimize memory bandwidth register cache network 
minimize size total memory required 
rods computational principles cognitive support 
maximize data access locality 
generally speaking optimization goals simultaneously achieved optimization involves making tradeoffs 
case goals description optimization computing science match goals optimizing dc systems generally 
question fundamental computational principles optimization included category rods 
rods term algorithmic optimization refers specifically principles computational optimization concerning may called algorithmic substitution 
refers fact changing data structure algorithm procedure method result performance changes 
key contribution computing theory regard defines way fairly comparing equivalent algorithms data encodings 
compare algorithms looks differences procedure loop nesting depth data type adt implementation 
adts 
adts usually defined encapsulation collection values set operations values 
instance list adt defined set sequences values delete insert data accessing operations 
adt implementation decides encoding values methods computing operations doubly linked list 
change data structures implementing adt certain operations implementation faster 
example list adt doubly linked list implementation normally insertion faster array implementation 
depending algorithm different adt implementations important performance differences 

algorithms 
algorithms roughly defined terminating side effect free procedures operating adts computing single function 
different algorithms perform identical functions different performance characteristics 
sorting algorithm quicksort example requires fewer comparisons average case algorithm bubblesort 
assuming comparisons fixed cost quicksort run faster average bubblesort 
running speed algorithm performance differences possible maximum amount memory utilized number memory updates 
adt implementation algorithm implicated performance differences 
ways altering computational performance problem change data structures procedures operating 
intimate relationship procedure data structure see rumelhart considered variants algorithmic optimization 
note functional equivalence 
tricky apply ideas algorithmic optimization hci 
computing case notion functional equivalence required comparing computations 
exact functional equivalence stringent requirement frequently inappropriate analyzing real world systems 
notion equivalence expanded point assumes memory access costs independent case computing technology due caches lookahead virtual memory 

rods computational principles cognitive support demanding definition 
strict functional equivalence fairness criterion breaks non algorithmic processes cases exact function defined 
instance may wish compare non halting computations phone switching systems size state space 
may wish compare running times heuristic statistical approximate procedures equivalence criteria relaxed 
furthermore may interested ill defined problems known set criteria solutions 
typical examples problems include designing aesthetically pleasing buildings laying graphs understandable manner 
circumstances function compute known specifiable 
fair comparison programs relies degree analyst evaluation program output 
relaxed equivalence situations normally possible apply basic principles algorithmic optimization different procedures computing comparable results perform differently depending data structures procedures 
applications hci advantages diagrams view computational 
diagrams better representations contain information indexing information support extremely useful efficient computational processes 
jill larkin herbert simon diagram worth words pg 
psychology cognitive science hci application algorithmic optimization known 
example cognitive science widely agreed shifts internal representation procedure lead improved performance see rumelhart 
question applications optimization principles reasonably called cognitive support 
instance possible improve performance tasks teaching users better task strategies 
unreasonable say newly users may perform different algorithms achieve function tools optimized sense discussed 
stretching intent term call type optimization form cognitive support 
note example issue particular tutoring form support tutoring system may quite easily considered cognitive support 
tutoring system application optimization question efficient task strategy user 
case probably best say support offered tutor lead optimizations optimizations constitute example cognitive support 
merely better task strategy cognitive support 
question remains applications optimization principles classified cognitive support 
criteria adopted causes computational rearrangement stem existence properties artifacts benefits due support principles benefits result changes adt implementation procedure operation dc system benefits specifically ease user cognitive challenges difficulties 

rods computational principles cognitive support criterion rules counting changes internal cognition cognitive support 
may take learning effective artifact learning considered just independent task may course supported 
second third criteria merely limit consideration cases benefits come optimization say distribution 
criterion kind catch intended maintain spirit term cognitive support 
cases optimization occurs reduce user may necessarily reduce cognitive challenges 
instance just physical effort involved operating interface reduced 
optimization vein may considered form support prudent reserve term cognitive support instances cognition easier faster better 
guidelines necessary define method mapping principles hci 
aspects mapping interpreting dc systems way able understand optimization principles applied understanding optimizations lead cognitive improvements 
consider second issue optimization lead cognitive improvements 
consider varieties optimization computing science map hci issues 
optimization computing 
different performance measures may optimized program 
software developers think term optimization think terms speeding computations 
addition assumed main contributor speedups reduction number instructions executed 
frequently case speedups optimization result efficient utilization limited resources 
instance speedups closely associated efficient limited register cache memory executing fewer instructions 
alternatively optimization may involve executing operations reducing number expensive operations 
sum computing question optimize common answers reduce number instructions reduce non processing resources memory reduce number costly operations cheaper operations needed 
analogues hci 
terms cognitive support optimization types relevant 
collectively reduce cognitive load placed user 
optimizations may reduce amount short term memory required reducing depth goal stack needs maintained 
optimizations include reducing total number operations reducing number hard mental operations need performed 
mapping hci 
optimization issues essential idea mapping hci interpret human artifact systems computational systems optimizations apply 
primary way see user running methods tasks operate externally stored adts interactive systems 
basic idea advanced different guises 
instance green argued computer systems consist notation ways interacting 
rods computational principles cognitive support user catch loop select unread read mail select done 
exit goto loop adt interface select read item delete item implementation command mouse operation menu operation adt view interfaces mappings implementations notation 
system viewed external information store 
ways accessing altering external information provide operations adt 
particular notations interface manipulations provide implementation adt 
view adt corresponds artifact interface read value write value sort adt implementation corresponds concrete interface select menu option mouse 
simple illustration idea appears 
schematically depicts situation task catching new email particular interface 
example green gave example speech interface standard text pascal editing environment 
interface required sequential dictation pascal 
coding environment understood manner adt consists pascal store statements operation append statement implementation dictation interface seen terms pascal statements encoding speech input method operations 
green noted restricted adt forced unnatural coding order 
lower level implementation viewed terms specific interaction technology communication mode terms speech acts operations verbal utterances encoding see bass moran 
mental vs physical optimization 
note view procedures executed adt internal cognitive functions inferences external manipulations edit tasks mixture 
green interpretation mentioned mix aspects 
related interpretations lean way internal cognition action 
thinking action differences closely correspond classic perception action dichotomy hci 
read mail italics may modeled mental operation select mail may considered physical operation 
interpretation larkin simon example optimizing mental operations 
argued physical action mental component thought planned order performed see goms analysis 
fact needed 
complication muted hinders making helpful distinction mental physical action 

rods computational principles cognitive support looked specifically viewers passively reading diagrams physically manipulating reading diagram active process physically 
instance compare inferences diagrammatic sentential representations physics problem 
particular problem involved configuration diagram showed configuration ropes sentential representation effectively encoded thing describing english weight hangs ropes 
mental operations required inferences needed answer questions differed depending representation 
bass focuses primarily designing artifacts implement efficient action procedures 
instance considered example email system 
particular adt accessing email argued efficient adt operations eventually implemented physical interaction level single manipulations extended manipulation sequences 
issue optimizing physical operations arguably issue supporting cognition case cognitive resources interaction skilled interaction goms modeling shows 
applications hci 
analysis optimization principles involve changing processing involved performing task interface 
involve changes representation encoding interface adt 
processing 
particular set interfaces note pad possible rearrange cognitive processing making new representations available 
instance hutchins notion precomputation discussed effectively computational optimization enabled provision precomputed data 
example user writes checklist piece uses reduce mental load cognitive processing changed distributing time 
precomputations provide cognitive support reducing instantaneous processing demands performance 
argument holds external structures similar manner 
representation 
cognitive science circles differences representation pointed making problems mentally easier solve see larkin norman peterson 
basic understanding representation stored medium gives access methods note external resource needed particular example making example composition different support principles see section 
effect occurs user merely memorized checklist mnemonic sort heard process crossing self wallet watch 
case precomputation rearrangement computation effect 
memory needed case offloading memory external medium counted separately see 
normal term representation refers encoding semantic content structuring encoding mechanisms 
representation consists data encoded data structure carries additional requirement data bear particular relationship data represents see norman 
usually structure encoding format representation discuss efficiency matters little structures represent entity 
including representing relationship discussion adds little analysis algorithmic explanations efficiency differences 
consequently emphasized 

rods computational principles cognitive support reading manipulating 
example representation substitution switch roman arabic number systems see section 
substitution mental operations multiplication easier 
interface 
tools media provide various interfaces external structures processors 
differences interfaces adts affect costs manipulation adt 
example interface viscous depth goal stack may need increased order successfully updates 
distribution distribution refers act spreading computing costs multiple elements 
cognitive terms typically means letting computers artifacts hold process mental states knowledge 
computing science principles ordinary term computational systems called distributed multiple distinguishable processing elements elements loosely connected 
concept distribution hardware level considerations stemming interconnection communication properties 
particularly relevant distributed computation communication costs 
distributed systems usually parallel processing systems property parallelism imply distribution high communication costs elements key criterion 
dual symmetric processing pc accelerated video card scsi hard drive normally considered distributed system cpus video card scsi drive controller circuitry run computations parallel 
hand beowulf cluster pcs connected relatively slow ethernet connections considered distributed 
difference communication costs processing elements 
processing elements single pc access common memory locations directly communication costs considered low 
course possible consider single system distributed levels 
non distributed dual processor pc considered distributed finer granularity associated internal hardware 
level individual cpu pc seen network processing elements communicating slower system bus 
ways realizing performance differences distributed systems 
single computational process may distributed elements 
multiple processing elements splits done element reduced 
speed execution frequently done parallel 
distribution mean computations resource requirements exceeding capabilities limited processor performed excess load taken elements 
addition distribution lead processing advantages scalability fault tolerance 
distribution desirable computer system sorts performance advantages 
distributed system run serially 
see www org 

rods computational principles cognitive support important aspect distributed systems nature distributed elements combine form conceptually single computational system 
logically independent computations performed simultaneously distributed system part called single distributed process 
example intranet connect office computers run quite unrelated processes different window managers 
criteria met distributed considered part single distributed computation 
particular share equivalently distribute conceptually unitary data state processing 
involve activity data replication state change propagation rollback update conflict management synchronization coordination scheduling 
forms coordination instance performed centrally hierarchically involve self organizing coordination local rules 
important note distribution frequently introduces great deal complexity specification description computational systems 
complexity considered form overhead see section 
complexities arise distribution coordination parallel processes 
merely converting serial program parallel considered code obfuscation technique 
distributing simple computations significantly complicate 
distribution especially destroy local coherence computation specification program 
simple locally specifiable control structures may give way distributed coordination mechanisms 
instance program simple tree structured control graph considerably complicated just breaking client server system 
distribution add cycles polling wait states data translation access negotiation transaction rollbacks 
conceptual cost associated distribution way unrelated computation performed 
easily hide underlying simplicity 
loss local coherence problematic extremely difficult understand computation looking part 
understood accounting programs examining action database server 
application hci humans conjunction artifacts humans form dc systems distributed computational systems conviction section 
benefits problems distributed systems consequently analogies dc hci 
example hands light principle analogue computational sharing distributed computing decomposed independently processable chunks resource communication contention reduces speed ups achievable 
part traditional computing science intuitions distribution carry forward sphere human cognition provision course certain ways engineering human cognitive systems possible 
example joint human computer systems solve problems difficult large human coordination synchronization important problems hci coordination overheads greatly complicate simple tasks human computer interactions spoil simplicity simple cognitive task 

rods computational principles cognitive support specialization specialization refers construction specialized computing facilities function manner slower general facilities 
specialized means restricted applicability general capability 
computing terms means compute fewer functions operate restricted input domain 
cognitive terms typically refers efficient specialized mental capabilities 
computing science principles years computing science created number ways abstracting generalizing computing methods procedural abstractions object hierarchies 
general rule generality abstraction usually cost associated specialized specific computing mechanisms tend faster general 
roughly computing science analogue difference swiss army knife generalist knife specialist 
basic phenomenon known relation simulation implementation hierarchies 
computational systems normally hierarchically decomposed operations viewed atomic higher levels simulated compound operations lower levels 
traditional boundaries hierarchy levels hardware microcode microcode machine language machine language high level language modern architectures blur traditional boundaries 
levels related simulation faster operations implemented lower levels possible simulate operations higher levels 
way improve performance directly specialized hardware place simulating operations performs 
familiar examples efficiency specialization principle include floating point processors accelerated video cards vector processors supercomputers 
examples dedicate specialized hardware compute restricted sets functions efficiently 
advantage units fast efficient operations able perform 
specializations optimizations construction applied 
instance may possible take advantage parallelism opportunities special purpose algorithms general algorithms 
specializations certain operations performed 
hardware specialization software specialized typically perform better particular problems data 
example technique called partial evaluation see hatcliff section bacon specialize general purpose methods efficiently partially specified data 
optimizing compilers specialize code locally general due global properties invariant expressions specialized 
example ai literature problem solving methods socalled weak problem solving methods efficiently called strong methods 
difference strong weak methods essentially strong methods take specifics problem account specialists 
principle specialization commonly cognitive science hci 
cognitive science find models specialized perceptual hardware edge detection motion detection course principle counts 

rods computational principles cognitive support distinguished computational components cognitive system 
low level cognitive operations fast automatic unconsciously performed 
specialization mechanism explain skills learned see especially rasmussen 
skills include activities reading english typing riding bike 
learning models performance skill conscious act general purpose reasoning capabilities 
repeated exposure task repetition important computations compiled rudimentary inflexible mechanisms 
training performer longer conscious activity place point able say precisely doing 
distinction hardware software specialization may clear difficult say confidence cognitive phenomena classified hardware level specialization 
highly practiced skills adding single digit numbers quick great degree automatic similar built hardware capabilities underlying mechanisms differ 
sensible group software hardware specialization taxonomy 
applications hci computing science specialized software hardware improve performance substituting general mechanisms 
context hci specialization principle applied recognizing instances specialized processing capabilities available 
differences artifacts lead situations enable special processing capabilities 
substitute cognitively processes 
variety examples general principle 
known called perceptual operator substitution 
perceptual operator substitution occurs efficient low level perceptual mechanisms substitute deliberate inferencing reasoning see section 
effect called bread butter visualization research 
essential understanding certain types stimuli exercise highly specialized perceptual mechanisms 
classic perceptual mechanisms involved visual mechanisms motion detection visual search 
create called pop effects 
point excellent computational accounts substitutions available 
essential quality accounts specialized mechanisms perform computations substitute complicated inferences see larkin casner rasmussen 
perceptual operators just instance specialized cognitive abilities 
blueprint specialized abilities perceptual operators artifact differences enable specialized processing substituted cognitively demanding processing 
aside notion substitution reasonable computational system composed distinct levels processing elements heterogeneous way distributed 
situation analogous example computer accelerated video card 
level considered distributed 
past called substitutions specialized processing internal distribution 
interpretation reasonable unifies categories taxonomy better leave substitution separate category qualitatively different explanatory 

analyzing cognitive support summary principles section taxonomy different support principles task reduction algorithmic optimization distribution specialization 
support principles consist computational principles way explain causes cognitive support 
computational principles state different computations dc configurations generate computational advantages generate cognitive benefits 
taxa chosen intention providing quite orthogonal dimensions analyzing computational advantage 
basic gist support principles relatively easy state 
task reduction essentially elimination unnecessary computation 
algorithmic optimization efficient algorithms adts efficient adt implementations 
distribution additional computing resources 
specialization general mechanisms efficient customized adapted specific task task environment 
rods meets expected criterion suitable high level qualitative theory simplicity 
important reflect significant aspects support principles relate remainder 
aspect significant fundamental principles familiar principles computational advantage 
certain respects considered astonishing understanding basic principles cognitive support requires little psychological knowledge 
fundamental principles explaining cognitive support quite familiar computing scientists 
naturally enormous difference understanding basics applying real situations lesson clear essential character dc vision cognitive support inextricably psychological 
reasonably taken encouraging sign 
suggests reasoning certain aspects cognitive support may tractable ordinarily trained computing scientists 
possibility explored chapter 
second reason optimism fundamental principles appear underly important aspects computing science cognitive support 
consider sort theoretical unification significant see goguen simon 
analyzing cognitive support dc relatively new school cognitive science 
result ways employing analyze compare various artifacts explored 
open questions best analyze model dc systems 
particular important issues long term interest applying rods analyzing cognitive support 
cognitive systems compared understand cognitive support provided artifacts 
able answer question obviously critical tool evaluation comparison 
critical question analysis design cognitive support understood comparative terms 

generalize dc models multiple joint cognitive systems 
question adequately answered may restricted statements 
analyzing cognitive support particular joint cognitive systems classes cognitive systems 
serious blow applications hci impossible reuse previous dc models scratch new system 
cost analysis 
knowledge design accumulated models 

usefully computational structures dc systems 
human interactions artifacts extremely rich level physical interaction 
wish understand higher level avoid death detail 
instance point may care user access fact external memory access involved particular search mechanisms scrolling suitable methods abstracting details away 
necessary fully answer questions position 
helpful initial comments questions answered 
full answers forthcoming important chapter help set tone reveal ground rules theorizing 
consequently proposals questions answered generally addressed remainder 
proposals arguments existing literature need explicit form importance applying cognitive support theories rods 
proposal suggestion joint cognitive systems compared locating logical space functionally equivalent joint cognitive systems 
cognitive systems space related substitution transformations defined rods 
compare cognitive support cognitive systems needs determine substitution transformations relate systems 
systems related variations artifacts logical space fact projection associated design space 
proposal outlined section 
second proposal dc modeling hci se oriented defining refining standard distributed cognitive architectures 
architectures general reusable computational models 
dc studies focused specific cognitive systems 
observations systems generalizable resulting models theories defined dc architectures 
proposal outlined section 
third suggestion frequently useful define virtual architectures modeling dc systems 
purpose virtual architecture context encapsulate meaningful interactions system components especially user computer 
surprising regular systematic interactions occurred users computers 
virtual architecture modeling technique encapsulating systematic interactions 
proposal outlined section 
design space induced rods dc literature contains comparisons cognitive systems 
example hutchins seminal book cognition wild analyzes differences western navigation 
analysis shows vivid detail navigational systems different computational implementations navigation 
related way zhang show games 
analyzing cognitive support analyzes different implementations problem 
accounts reveal instances support 
way systematically analyzing support adequately spelled 
instance space possible ways supporting cognition mapped 
argued space conceived aid comparing tools reasoning tool designs 
suggest artifact supports cognition indirectly imply way cognition un supported way suggested 
instance slide rule thought support cognition doing calculations life slide rule 
general support provided artifact may understood comparison implied absence substitution modification 
way thinking comparison suggest continuum different levels support ranges completely unsupported entirely mental completely automated human thinking involved 
extremes cases cognition spread humans artifacts 
practice extreme ends spectrum unattainable interesting tasks 
instructive imagine principle unachievable extremes spectrum entail 
entirely mental continuum hold close inspection user problem evolving solution mental state information need held internally processing information need done internally 
akin floating sensory deprivation chamber solving problems mentally 
reality course people embedded environment strategic 
programmers instance normally code non trivial interacting external media 
matter imagine case capable programmer keeps copy entire world head 
completely unsupported programmer logical possibility actual possibility 
distribution begins change picture 
distribution cognition increased locus cognition expands away individual mind dispersed 
imaginary unsupported programmer may notepad example offload specific item memory 
considered cognitive systems mythical lone programmer programmer plus notepad system 
logical difference cognitive systems substitution transformation external memory substituted internal 
words artifact computation making distribution substitution 
critical substitution transformation sense cognitive systems belong equivalence class 
difficult argue differences due cognitive support 
various parts computation distributed variations systems posed considering specialization algorithmic optimization substitutions 
data sort distributed processing distributed specialization substitutions enabled algorithmic optimizations performed 
may case transformations occur unison 
instance noted writing things unlocks types support way overcome difficulties performing complex knowledge manipulation head capture ideas external medium computer screen form external representations stand mental structures 
long ideas plans drafts locked 
analyzing cognitive support inside writer head modifying developing overload writer short term memory 
putting suitable medium writer able explore different ways structuring content apply systematic transformations prioritizing items reversing order clustering related items 
observations suggest conceivable method generating space possible cognitive supports task conceptually 
generation effectively recursive application rods transformations start unsupported human pick possible data apply possible substitution transformation generate new compositions 
instance writing example enumerating possibilities partially distributing ideas plans drafts goals 
consider various ways processing externally changing representation enable specialized processing substitute deliberate processing making changes encodings methods 
changes represents possible design option 
logical space cognitive systems identifies design space 
may case full design space generated 
logically defined space provides ways trying rationally compare support artifacts environments 
tools similar successor earlier prototype instance reasonably argued transforms cognition combination rods transformations 
transformations identify cognitive support differences 
type relative comparison support tool compared neighbour absolute 
possible envision absolute analysis 
need start analysis unaided mind perform task describe substitution transformations required achieve system 
reverse transformation considered 
user tool dyad consider transformations needed relevant activity occur entirely inside user head 
distributed cognitive architectures level generality artifact analyses conducted 
believe specific analyses prove necessary understand functionality artifacts relatively general analytic tools developed issues user interface design issues general wide range artifacts 
stephen payne interface problems interface resources pg 

cognitive science uses ages old trick computing science build cognitive models generalize multiple individuals situations 
trick incomplete model 
incomplete just right way 
missing parts correspond variations wishes generalize 
conversely parts specified correspond invariants 
cognitive architectures cognitive science just models 
intended capture invariants 
analyzing cognitive support cognition essentially normal humans 
cognitive architecture software architecture 
specifies model cognitive machinery mind 
cognitive architectures specific tasks social context particulars environment tools artifacts available 
cognitive architectures general 
statements architectures efficiency behaviour communication costs generalize 
generality architecture means done applying specific situations 
applied appropriate details analyzed situation plugged 
instance cognitive architecture soar contains essentially domain task knowledge 
knowledge encoded run simulate users 
user knowledge base programmed 
user knowledge normally required program simulate account aspects tools tasks social settings 
generality cognitive architecture obvious crucial advantages applying analysis 
generality critical architecture useful analyst applied situations interest 
just important reusability 
contents cognitive architecture aspects cognition models aspects invariant 
words architecture captures encodes certain context independent facts knowledge 
content reused analyst applied 
save effort content recreated situation applied 
currently dc cognitive architectures obviously point candidates reuse 
problem may types studies field take point view situation studied modeled individually 
face approach may unreasonable 
trouble modeling joint cognitive systems come different flavours configurations system model frequently shifting ephemeral entity 
contrast pursuing individual cognitive architectures certain degree sense similar brains modify brains barring injury limited ways 
currently pop new ram chips processors brains 
universality stability prima facie reasonable talk model cognitive system unaided individual 
joint cognitive systems exhibit universality stability 
talk human computer systems human computer system 
brain external parts joint cognitive systems easily modified 
dc viewpoint purpose design cognitive system see chapter 
human computer systems naturally fluidly change moment 
developer slide chair room computer working entirely different set tools 
tool manufacturers continually update change products 
fact developers known customize program tweak environments 
intents purposes simple facts rule hope building single model side note dc researchers adopt philosophical backgrounds tend reinforce practice 
certain philosophies anthropology communication value fundamentally bottom procedure understanding cultures systems view suspicion pre existing theories phenomena study 
result may tendency try model system starting scratch 
basic modeling principles reused sort philosophy generally rules assuming particular cognitive architecture 

analyzing cognitive support applied relevant design situations 
generalizable dc models impossible 
context variability universally preclude abstraction generality 
dc models generalized various tools tasks 

best knowledge questions answered dc literature 
far publications dc tended focus arguing viability necessity dc view tried show particular cognitive systems modeled explained 
generalizability analysis currently research emphasis 
result prescriptions studying dc hollan emphasize need capture situation specific details say need understand particulars system relate similar systems 
consequently standard models builds dc models scratch 
related suggestions potentially useful modeling techniques flor media constellations address reuse models 
cognitive model building involves computational model building fair say dc modeling currently founded software reuse 
surely necessarily 
similarities dc systems recognized utilized effectively 
identify useful invariants exist capture standard dc architectures 
trick identify unimportant variations away recognize important variation provide abstractions omit computational details situation specific details plugged encode important invariants distributed cognitive architecture 
computing scientists prescription generality come surprise 
parnas normally credited identifying steps needed order define families similar programmatic structures 
main prescription recognize similarity anticipate variation structure system capture similarities allow easy modification variations 
possible define generalizable computational structures families similar computational systems 
may universally useful dc architecture able define reasonable collection incomplete dc models 
capture important dc invariants may reused wide variety similar situations 
humans expected learn participate restricted set artifacts adequate collection general architectures eminently manageable size 
basic vision driven software architectures research se 
standard dc models scope 
main point bringing dc architectures chapter ensure importance dc architectural level analysis realized 
important sections proposing dc cognitive support theories 
useful address issue generalizability 
parnas terminology theories need statements family artifacts 
furthermore significance dc architectures emphasized wider context dc research 
importance building generalizable science base realized risk dc systems continue unnecessarily difficult analyze compare dc architectures reuse 
threatens viability efficiently dc cognitive support analysis instances realworld design 

analyzing cognitive support virtual architectures people plug ram chips hard drives network interface cards coprocessors device controllers heads relatively little need cognitive artifacts 
bother appointment book slip flash ram card head store appointments 
brain extra ram store important appointments poor fallible memory 
able plug components may ideal way augmenting human intellectual capabilities usually imagines little overhead involved 
cognitive artifacts overhead involved 
overhead interacting cognitive artifacts shows cognitive effort interface activity pointing typing speaking reading overhead mixes real user 
users learn artifacts command manipulate communicate react perceive monitor 
cognitive artifacts real hardware extensions may possible go ways restoring similar level simplicity modeling dc systems 
key try encapsulate overhead dc models 
way employ model virtual hardware virtual architecture 
virtual architecture simplified model cognitive hardware 
idea virtual hardware really exist fact simulated operations performed user computer 
virtual hardware simulated complicated implementing hardware 
instance consider user doing pencil 
level sense consider pencil extension user memory 
real dc hardware level memory operations storing recalling contents addressing simulated user 
perform writing reading steps manually 
involve considerable cognitive machinery perform 
furthermore user charge devising addressing scheme contents 
example data stored dimensional ordinal data tabular graph indexing methods see norman ch 

piece external memory memory may viewable burden paging right portions external memory passed user 
may interested viewing memory extension look closely simple memory interface 
create degree abstraction viewing extended memory virtual memory architecture postulated 
point architecture provide direct simplified read write abstraction distributed memory system 
rough illustration abstraction 
appears complicated really diagram shows cognitive overheads involved accessing external memory addressing paging right parts view 
postulating virtual architecture way clarifies process encapsulating overheads involved interacting particular implementation virtual memory 
note simulation overheads forgotten 
merely collected encapsulated mapping implementing architecture 
memory processing overheads involved 
analyzing cognitive support mapping data mapping processing simulating architecture virtual architecture process processing overhead process write read addressing scheme user memory memory overhead paging scheme virtual extended memory virtual shared memory abstraction complicated interaction implementing reading writing addressing paging merely handled level 
virtual architecture modeling method precisely approach taken distributed shared memory systems see skillicorn 
systems provide interface programmer single physically shared memory available 
reality scenes simulated 
means virtual architectures way making transition level explicit 
bridge lower level detailed hci abstracted view system details 
sense propose non greedy explicit reduction high level description implementation 
see relevance possibility reconsider hci frequently dealt performing cognitive modeling 
instance consider von mayrhauser modeled comprehender behaviour high level model 
protocol analysis build interpretation mental actions take 
analysis effectively ignored human computer interactions involved 
natural interactions done skill leave verbal traces analyze 
times interactions tools actively filtered see gray considered example 
cognitive analysis filters interface activity explicitly 
suitable aim build simplified model human cognition complications interactions tools 
reasonable considers interacting artifacts constitutes separate sub task human thinker simply cope 
dc point view throws away tool interaction chance full contributions tools missed 
tool acting external memory instance system memory left unmodeled 
example model von mayrhauser 
see coded protocols chunk store action concern internal activities 
analyzing cognitive support implement action 
external actions implementing chunk store action external memory 
correctly coded memory action 
interactions tools ignored answer 
interactions simply thrown back analysis threatens bogged thick interaction details 
virtual architectures may significant 
allow systematically control complexity interactions simply throwing away 
ability chapter away details interacting external medium 
second possible significance virtual architectures 
previous section suggested families human computer systems common structures fruitfully described dc architectures 
lead definition study collection common dc architectures 
come pass virtual architectures useful addition generalized task analyses 
virtual architecture maps abstraction layers defining tasks performed simulation virtual machine addressing paging 
important account tasks defined independent particular interface problem domain tasks assigned cognitively meaningful interpretations 
combination may hard achieve means 
exists prior describing generalized task structures ways reminiscent see generalised task models gtm 
virtual architecture additionally casts tasks cognitive terms abstraction mechanism suited dc modeling 
sum external artifacts directly connected user possible step back view dc systems implementing virtual architectures 
essential virtue virtual architecture logical modularization simplification provides 
may encapsulate complicated interaction heterogeneous components modular virtual architectural components 
virtual implementing architectures related simulation 
tasks performed simulate virtual architecture define meaningful set tasks perform 
summary analysis proposals dc theorists argued joint human computer systems modeled distributed computation models 
hoped systematic ways studying cognitive support fitted existing dc research 
fundamental problems appear addressed prior modeling compare systems way carefully describes support possibilities support generalize analyses different types tools task situations collect generalized analyses effectively encapsulate low level complexities involving human computer interaction 
proposals advanced response issues overviewed 
concept space functionally equivalent cognitive systems defined 
motion space corresponds applications primary substitution principles rods 
defining logical space clarifies understanding cognitive support tools may compared support 
second notion dc architecture promoted method providing generalizable dc models 
notion dc architecture relatively minor extension common cognitive architecture 
requirements check modeling techniques 
dc architecture capture computational structures invariant family contexts 
suggestion investigate dc architectures significant implies potentially useful shift studying individual systems studying families systems common computational structures 
third idea virtual hardware architecture proposed technique encapsulate certain human artifact interactions 
abstractions may important analyzing hci 
may easier understand interaction cognitive level may possible define meaningful tasks 
proposals may turn critical parts rods design analysis frameworks 
developed potential significance important describe framework definition chapter 
requirements check certain theories proposed improvement previous theories usually explaining predicting better accurately contexts 
proposed primarily try meet specific desiderata requirements concern expressed improving theory accuracy 
rods example 
requirements generated mature field physical support intuition pump section 
key requirements recalled rods examined clarify anticipated requirements met 
high level qualitative theory cognitive advantage exposition rods chapter hides core statements extended definitions 
relatively simple definition exists 
high level rods stated artifacts reengineer cognition substituting computation 
cognitive support substitutions provide computational advantage generated reengineering 
distinct forms cognitive support generated distinct types computational advantage 
types computational advantage task reduction eliminating unnecessary algorithmic optimization switching algorithms adts implementation distribution specialization 
cognitive artifacts decomposed applications computational principles 
reasonable say statement rods qualifies high level qualitative theory cognitive advantage 
small vocabulary primitive types rods identifies requires primitive types cognitive support 
rely distinct computing principles substitution orthogonal 
compositional language primitive types cognitive support combine substitution principles defined identify independent computational substitutions 

summary mnemonic evocative names rods couched terms familiar computer scientists 
guarantee terms understandable memorable evocative important implications 
improve odds terms familiar meaningful average computer science student 
computing scientists frequently understand principles optimizing computing 
may allow non specialists reason analogy various forms cognitive support 
generalizable description level rods names categories cognitive support defines underlying principles cognitivist terms knowledge inferencing computational terms memory processing 
description levels independent implementations 
particular cognitive support categories defined task particular cognitive model 
instance distribution defined referring specifics distributed 
plans constraints goals processing history distributed see wright 
means rods issues cognition analyst considers important goals social roles 
significance ability chapter 
addition computational principles referenced abstracted away implementation 
instance considering distribution cognition number artifacts may play role external memory white boards computers people 
rods independent task technology depend analyst application context 
analysis framework rods contains framework analyzing cognitive support terms computational 
core framework way comparing cognitive systems 
cognitive system identified part computational architecture created humans particular artifacts 
equivalent cognitive systems seen computational reengineering types advantageous substitution identified rods 
summary chapter framework generating theories cognitive support 
framework consisted main parts dc tenets dc assumes particular way understanding cognition way artifacts contribute 
main tenets dc reviewed importance rods goals dissertation considered 
set analytic framework rods 
simplified general theory cognitive support taxonomy cognitive support principles defined 
principles task reduction algorithmic optimization distribution specialization 
principles intended identify 
summary orthogonal computational explanations cognitive benefits 
collectively form theory cognitive support 
analysis techniques effectively applying rods dc framework real design requires understanding principles identify compare cognitive support tools 
requires consideration generalize reuse dc analyses away unneeded low level interaction details completely discarding 
section discussed beginnings ways dealing issues 
basis described defining logical design space generated substitution cognitive 
importance searching reusable cognitive architectures highlighted 
addition potential virtual architectures encapsulate low level interaction details 
parts rods framework establish coherent foundation studying exploring cognitive support tools 
point se similar framework 
bits pieces prior works ad hoc fashion missing clear articulation high level qualitative theory cognitive support ways applying 
fact part realized principled theoretical foundation possible constructing generalizable explanations cognitive support 
related prior se primarily assumed framework researching theories cognition theories cognitive support 
realizing encompassing frameworks possible strategically important 
cognitive support point dealt theoretically piecemeal fashion 
considering diversity support research described chapter bit astonishing 
coherent capable framework puts diversity new light 
rods may ultimately limited types support talk argues cognitive support understood just handful basic principles principles stated single coherent generalizable theoretical framework 
basic principles explaining cognitive support noted united way 
chapter hasti dc modeling framework theories models potentially relevant systems design applicable narrow psychological phenomena 
positive side feel fortunate potentially relevant knowledge draw 
negative side obvious identify knowledge relevant design problem package knowledge form practical implications systems design obvious 
kim vicente cognitive analysis 
stands reason anybody wanting analyze design cognitive support need reasonable command salient aspects applied cognitive psychology 
informal qualitative descriptions place formalized descriptions computational models cognition 
consequently pragmatic minded cognitive support researchers especially trade undoubtedly appreciate simple standard unified models cognition 
ideally standard models simply theoretical shelf modification 
certainly considered cognitive models great applying support principles rods 
reason simple support principles rods practically psychology free 
explain cognitive support different sorts computational advantages details real world cognition required order understand advantages possibly consist 
models help answer question aspects thinking supported words support principles necessary intellectual tool understanding developing cognitive support needs material tool 
aim chapter try provide needed material 
blush modern psychology especially cognitive science helpful matter generally propose knowledge psychology form computational models 
models computational easily employed analyze various computational rearrangements 
unfortunately case 
cognitive modeling psychology standardized sense common consensual base model pervasively assumed 
modest cognitive model combination empirical evidence thing psychology clearly far thing 
narrow little cognitive models abound 
average non psychologist cognitive psychology independent models irreconcilable theories modeling methods 
seemingly presents small isolated model integration difficult impossible 
integration psychological results probably primary impediment trying analyze develop cognitive support 
integration problem known cognitive scientists 
card described follows isolated human performance models necessarily integrated give larger model 
trying match miscellaneous inputs outputs integrated chief problems trying build practice computational ergonomics isolated models literature 
pg 
exist efforts integration newell high profile unified theories cognition 
domain programming specifically unification past theorizing occasional interest boehm davis hale von mayrhauser pirolli 
efforts integrate aspects human cognition especially useful analyzing cognitive support 
explain cognitive support rods needs adequate characterization ways performing substitution transformations identified rods 
clearly facets psychology environmental interaction need modeled possible 
includes able model high level thinking problem solving modeling impact environment integrating details different cognitive mechanisms capabilities 
existing models fail deliver aspects 
second challenge typical models 
simply address issues phenomena 
practical modeler psychology appears apply occam razor far liberally 
left done usually bare bones architecture enormously limited model 
unified models 
certain sense quite astonishing serious proposals model complicated human behaviour simple computational mechanisms 
instance far mark say known soar architecture essentially explains cognition particular form rule pervasive automatic rule learning mechanism 
characterization surely crude little essence critique accurate 
soar take cognition akin arguing linux kernel structured risc processor fetching operation codes executing cyclically 
description defensible level totally inappropriate maintainer planning tinker software 
properly understand linux purpose usually needs abstractions form higher level computational structures 
exactly analogous argument see simon pg 
statement basic philosophy approach limiting psychological enquiry simple mechanisms 
true cognitive models developing cognitive support amounts dc systems 
course architectures soar create specific models adding knowledge 
instance analysts program models rules tedious amount detail 
way viewing situation order able say useful applied modeler supply additional information 
means models frequently bare 
wrong just employed purpose carrying psychological knowledge 
base models aim encode start information cognition related issues way provide practical analyst suitable launching point 
current situation hci modeling frequently creates third challenge existing modeling techniques costly apply making unsuitable broad brush analyses 
particular amount effort needed get model say useful high giving low benefit cost ratio 
section costs considered relation relative benefits user testing main point note situations require simplified models easy apply 
fourth challenge analysis existing models properly insulate complexities science base 
simplified broad brush models effectively mediate interactions analyst science base draw 
important function applied models index underlying science base 
currently small fraction useful knowledge psychology hci 
partly issue awareness 
important function simplified models provide convenient access point model suitably integrative provide access greater fraction usable knowledge 
second important aspect mediation models sense semi transparent complicated detailed models accessed need 
important model fails address question simplified applied models expected occasionally cause happen analyst needs able look model access related literature 
function model way model documented 
regardless way making model suitably transparent needed 
researchers transparency helpful find need wade deeper related literature 
practitioners transparency needed smooth way accessing complicated models order iteratively deepen analysis 
hurdles model structural simplicity analytic cost weakness currently face researchers se 
obvious solution provide suitable encapsulation bridging representation integrates simplifies existing knowledge reduces cost analysis improves access science base 
context cognitive support particular need suitably capable model reasoning logical space viable forms cognitive assistance 
say potentially applicable models plenty costly tend stand poorly 
really choice try working integration recovers structure useful 
aim try modeling challenges entirely highest order 
goal provide just gap solution 
overview hasti worst poor se researcher trying reason cognitive support 
prior models individually fail hope integration succeed 
success sense means integrated model embody suitable abstractions science base concerning dc systems reason high level reengineer cost effective manner 
chapter proposes modeling framework called hasti 
hasti framework building dc models joint human computer cognition 
intent framework possible perform quick dirty analyses cognitive systems way possibilities reengineering exposed 
building modeling framework decisions form take 
key issues choosing right prior works integrate deciding framework principles integrating 
words main issues content structure models 
obviously important decisions regarding content integration mechanisms principles construction crux entire project 
reason integration structuring mechanisms chosen give hasti name 
hasti framework comprises set modeling principles structuring methods 
acronym hasti formed names decomposition structuring methods identifies hardware models agent models specialization hierarchy task taxonomy interaction abstraction layer 
described separate subsection sections 
described underlying principles framework construction introduced 
decomposition framework way mapping hasti elements attempt vicente says package psychological knowledge form practical implications systems design obvious 
requires appreciation principles building models serve designer needs 
principles introduced section 
hasti structuring methods described summary provided section drawn 
overview hasti experiences led believe central problem needs overcome products cognitive science relevant design identifying productive set dimensions modeling efforts decomposed 
support cognitive engineering decomposition derived framework capable ensuring resulting research products reassembled coherent theory useful design 
alex requirements psychological models support design pg 

perfect way modeling understanding cognitive support respect needs tool developers 
singular perfection hasti pronounced rhyme 

overview hasti left aspire develop collection approximate modeling techniques capable addressing particular set phenomena degree approximation 
pragmatic minded tool researchers hope modeling techniques exact sort abstractions approximations enable analyze evaluate tools design ones 
context important concern modeling just detail dc system enable tools researchers jobs 
models modeling traditions potentially drawn project 

primarily challenge remains gather integrate appropriate models ways useful 
chapter predicated conviction needs se researchers met focusing decomposing cognitive phenomena useful way 
key requirement success determine aspects cognition important consider determine ways decomposing 
cognitive modeling driven desire model specific phenomena establish constraints cognitive theories timing constraints 
building hasti contrast driven varied needs general design tasks 
see quotation hit nail squarely head argued way cognitive science relevant design identifying productive set dimensions modeling efforts decomposed pg 

particular proposal doing differs hasti basic argument decomposition exposes design issues 
regard main modeling consideration question various ways dc systems modified artifacts 
way see importance appeal analogy rubik cube 
rubik cube effectively consists interlocking rings number ways rotating number degrees freedom 
motion degree freedom moves collection coloured squares face 
rubik cube physically implements way generating number permutations original colouring cube 
ignore moment goal rubik cube game uniform colouring sides consider just ability rotate cube different configurations 
rotating rubik cube way similar reengineering cognition cube cognitive system sense number degrees freedom changing cube various rotational degrees freedom correspond substitution types rods various different colours faces correspond different aspects cognition changed applying substitutions 
analogy purpose building hasti determine various colours mean terms cognition match rotational motions valid interesting rearrangements cognition 
analogies carefully lest pursues far worth pursuing steps implications rest dissertation clear 
particular look rubik cube help explain compare roles hasti rods analysis 
consider imaginary rubik cube 
imagine existing cognitive system represented particular cube configuration 
aspects cognition hasti cube puzzle uniquely coloured sides split rotating rings axes total sections face tic tac toe board faces rotated axes object game rotate rings colours sections face matches ones face 

overview hasti statements correspond colours 
encoded coloured squares relative positions 
analyst hasti considers salient aspects existing cognitive system maps aspects particular squares appropriate colour 
instance analyst considering shopping task note knowledge items mentally considered 
mark particular square item knowledge 
aspects similarly marked analysis important aspects current cognitive system represented markings various squares 
analysis cube models cognitive system 
imagine rotating rings 
rotation correspond application rods rotation corresponds substitution transformation modifies structure computations changing essential function 
imagine instance square previously marked item knowledge rotated position 
say change corresponds distribution substitution 
transformation achieved instance providing handheld computer memory item externalized shopping list maintained computer 
analyst number rotations see various ways reorganizing cognitive system 
click 
progress shopping recorded externally having kept head tick marks display 
click 
planning shopping steps done externally having computer order list item 
rotations identify ways rearranging cognitive system order support cognition 
model allows analyst explore different transformations task cognitive level responsible relating transformations ways implementing design artifacts 
imaginary scenario possible emphasize purpose hasti 
dimensions hasti enumerate important cognitive issues consider reorganizing cognitive systems 
akin different colours cube 
furthermore hasti establishes relationships cognitive issues 
akin mappings colours faces 
important hints dependencies cognitive aspects 
note rubik cube game impossible move square affecting 
game winning solution general lesson remember certain configurations considered rotating squares fix face cube face 
similar effect occurs cognitive rearrangements changes cognitive aspect imply changes 
cognitive support analyst reasons design playing model determine winning combinations see chapter 
tool evaluator effectively uses model determine moves particular design 
rods correspond ways rotating cube critical know rotated happens rotations 
role hasti analogous cube provide way deriving cognitive models analyzed ways transforming 
rods identifies hasti degrees freedom 
remainder section describes principles methods making cognitive modeling framework 
basic principles building framework described section 
section describes way hasti structured 
shall argued deciding right structural decomposition hasti key developing models useful analyzing cognitive support 

overview hasti framework principles strategies basic bottom investigations experimental psychology literature filled tens thousands experiments demonstrating thousands regularities human behavior 
conducting experiment adds best small piece information existing pool 
argue basic bottom experimentation efficient hci researcher time 
researchers existing psychology literature foundation building computational models 
bonnie john panel statement role laboratory experiments hci pg 

main principles guided generation hasti 
summarized described 
building applied theory decisions include form result take 
hasti described principles guiding construction having statement help evaluate wisdom decisions underlying hasti design 

model 
favour inclusion integration approximation 
embody psychological knowledge low detail computational structures 
decompose phenomena model application 
structure models phenomena decomposition summary principles strategies modeling hasti principle model view relationship science application science fruit tree 
fruit various branches eventually 
human performance model useful just water tree give patient eventually fruit fall hands 
unfortunately look available models needed engineering suggest view accurate stuart card theory driven design research pg 

primary assumption applied modeling models suited uses put 
may may correspond basic sciences interested 
overview hasti presently modeling 
obvious point worth stating important principle 
main assumed models reason ways dc systems beneficially modified artifacts 
principle favour inclusion integration approximation simple theory cognition theoretical model adheres premises simplicity provides viable alternative acknowledges impossibility contain model richness human decision making performance 
hoc technology fundamental issues pg 

hasti designed broad brush analysis 
result inclusion integration approximation favoured 
efforts cognitive psychology cognitive science take opposing view favouring accuracy minimality 
strategy pursued focus specific phenomenon reasoning learning perception language introduce limited microtheory explain 
approach proven effective explaining phenomena rarely resulting microtheories stitched 
microtheory proposed goal try account phenomena possible 
green says normal approach cognitive psychology propose theory see predicted squeezing juice possible fruit bears pg 

freed express different focus applied modeler models meant evaluated degree performance fits empirical data reluctance incorporate capable speculative model elements easily understood 
goal predicting performance complex domains prescribes opposite bias human operators exhibit capability carrying task model capability 
general implication applied modelers willing put having inaccurate models model usefully addresses relevant facets cognition 
wise follow advice freed initial model powerful weak extend refine model required 
include necessary integrate models approximate required 
course doing introduces important liability approach means may realistic hope validating models standards rigour normally associated microtheories 
liability completely ignored put perspective 
done chapter 
pragmatic issues remain useful 
choice term integrate term unify intentional 
term unified come associated efforts explain aspects cognition detail 
hope unified theories making models account different aspects cognition possible pin theories constraints observed phenomena 
contrast aim determine unified theories integrate theories 

overview hasti applied settings fruitful admit approximation merely models useful 
normally fruitful approximate model features detail known 
aim able discuss different forms cognitive support broad strokes 
broad brush analysis techniques thinking tools frequently needed surprisingly useful short supply 
broad brush techniques permit generation highly cognitive support arguments see chapter 
suitable early stages design benefits codified knowledge effective chapter 
lightweight approximations favoured initially 
efficiently kick start analysis 
specific analysis needed models refined needed 
iterative deepening approach may important efficiently investigating cognitive support times analyst may know sorts details needed 
broad brush models act heuristic tools narrowing focus raising addressing theoretical empirical questions pg 
allowing investigators isolate variables designing empirical studies human subjects pg 

considerations establish heuristic strategy deciding modeling contents decided approximate left highly general broadly applicable 
card provides cogent analyses design driven reduction detail idealizations means simplifying phenomena inference tractable 
simplification achieved dropping details little effect outcome 
details effect may depend interested broad coverage subtle mechanisms 
theory driven design research paradigm heuristic keeping idealizations theory details matter class design 
pg 
concentrates broad coverage subtle mechanisms assumed default interest demonstrably needed 
time broad brush models act help determine needs 
may strike reader goals inclusive deliberately approximate sense contradictory 

inclusiveness context means knowledge diverse range cognitive hci phenomena collected 
sources knowledge may rich details interesting cognitive support developers regular basis 
necessary pick choose detailed turn complicated aspects generalizations 
principle embody knowledge low detail structures knowledge psychology hci formalized number ways loose english descriptions computational architectures programs written lisp 
sort models interest 
general rule pursued hasti encode relevant knowledge features computational structures little detail 
structural architectural diagrams computing systems 
describe computational structures 
overview hasti implementational details 
reason adopting preference encode psychological knowledge match way model especially chapters 
primary models provide possibilities argue artifacts rearrange dc systems 
emphasis rightly placed making plain explicit features dc systems essential arguments 
relevant feature psychology hci visible separable presence model 
models soar propose simplified base architecture embed relevant psychology diffuse intangible rule sets 
aim embody relevant knowledge relatively simple computational structure models 
principle decompose phenomena strategically classificatory exercise integral step development theory 
resultant classificatory system provides consistent conceptual framework elements eventually utilized interpretation prediction behavioral phenomena 
taxonomies human performance description human tasks pg 

purpose hasti provide material reason cognitive support dc systems 
important inventory distinct changeable aspects dc systems relate know system logical elements degrees freedom constraints modification 
fact arguably important simply inventory aspects predictive accuracy 
rasmussen appreciated fact 
argued order build models appropriate design important decompose relevant phenomena appropriately see green 
observation led develop related taxonomies incorporated 
natural phenomena decomposed way order understand point decomposition strategic carve phenomena ways 
way done hasti described section 
principle match model structure phenomenon decomposition rasmussen argued decomposes phenomena independent models model separately 
instance proposed classify human behaviour types skill rule knowledge behaviour srk 
proposed distinct general models account type behaviour 
proposed integration model relates srk categories mistake models 
authors vicente dillenbourg exercise considerable models models 
rasmussen processing model declared model framework clearly similar highlevel layered cognitive architectural models see brooks 
fact resembles multi stage processing model norman holds type approximate models need developed hci 

overview hasti explains general rules coordinate real world cognition 
reality proposed model different modeling levels base models modeled specific categories behaviour independent mechanisms integrating model captured aspects interplay mechanisms 
words base models modeled distinguishable categories phenomena structure integrating model matched structure decomposing taxonomy 
basic recipe success integrating heterogenous aspects cognition computational models 
modeling scheme emphasized rasmussen exposition absolutely critical strategy 
generally speaking principle model structure way mirror decomposition phenomena 
structure overview knew phenomena scattered literature psychology helpful system design 
specialist designer literature appears disorganized contradictory 
psychologists love split hairs find small contradictions published models 
robust approximate generalizations engineering tend get debates 
stuart card thomas moran user technology pointing pondering pg 

integrative effort contents decided 
strategies described subsection involves generating decomposition contents suitable design relevant analysis 
content decomposition scheme assumed decisions reflect modeling framework structure 
subsection provides overview decisions 
result list key structures hasti hardware model agent model specialization hierarchy task taxonomy interaction decomposition hierarchy 
structures discussed detail separate sections overview 
main purpose overview provide guide rationales structures take form 
rationales sections detailed expositions 
countermeasure subsection provides simplified account content integrated decompositions content model mapping techniques 
words explain way principles observed 
addition section describes relevance structure analyzing cognitive support principle observed 
decompositions matching model structures rationales summarized table 
table highlights key issues hasti addresses phenomena issues model way decomposing way modeling relevance analyzing cognitive support 

overview hasti phenomenon issue decomposition model feature support relevance invariant capacities constraints memory processors hardware model distribution performance behaviour agents panel types agent model distribution alg 
opt 
specialization adaptation layering specialization task problem taxonomy partitioning overheads interaction virtual architectures layering generalized task analysis table decompositions phenomena matching structures capabilities constraints hardware model hardware model captures task knowledge invariant capabilities constraints dc systems 
hardware model encode basic physical psychological facts joint system 
common hardware level models 
example cognitive constraints short term memory limits frequently modeled resource bounds cognitive architecture 
functional behavioural aspects system orthogonal hardware aspect usually sort mapping decompositions hardware level 
computing science circles mappings routine 
prime example called viewpoints framework 
hardware model decomposes basic capabilities constraints terms memories processors 
important know reengineering cognition state computational resources available distributing computations 
encoding psychological constraints important reasoning performance issues cognitive system 
behaviour agent model agent model captures abstractions behaviours dc system 
humans switch randomly actions alternate goal focused clusters activities 
cognition may decomposed task goal relevant behaviour 
structure decomposition directly mirror physical logical structure dc system mapping assumed 
agent model way matching system structure behaviour structure 
agent models encapsulate logically cohesive mechanisms generate coherent action 
generic template agent model proposed aim capturing common aspects behaviour 
template includes taxonomy different types data agents process ends operations constraints goals plans current state past state history 
agent model mapped hardware model order reason constraints behavioural regularities 
agent model plays key role discussing cognitive 
specifically primary source hasti identifying generalizable task independent aspects cognition rearranged 

overview hasti specialization strata strata impose partitioning behaviour levels adaptation levels specialization mechanisms responsible behaviour 
closely follow srk taxonomy rasmussen 
rasmussen argued exist genuinely different categories behaviour people exhibit 
called skill rule knowledge name srk 
behavioural categories related system adapted tasks 
notably categories related function agent behavioural decomposition class adaptive response task demands 
generally speaking categories behaviour may involved performing single coherent goal related activity 
category associated different classes cognitive behaviour 
instance skill behaviour associated rapid perception action loops cognitively penetrable performer 
srk categories ordered relative degree adaptation degree specialization means specialized 
fourth added called meta cognitive behaviour taxonomy expanded taxonomy 
behaviour categories integrated hasti imposing modeling layers strata agent model 
agents belong particular stratum 
srk category mapped different hardware mechanisms explain differing performance characteristics 
importance srk stratification provides way labeling degrees computational specialization model 
needed discussing types specialization dc systems 
task type partitioning partitioning impose partitioning behaviour classification task types 
possible model dc activities searches problem spaces 
helpful decompose problem space meaningful problem taxonomy 
doing partitions problem space identifiable components inject useful vocabulary analysis cognitive support 
hasti proposes fold classification system sub problems tasks 
classifications domain device coping cooperation 
taxonomy referred acronym 
taxonomy imposes partitioning agent model 
classify type activity agent responsible 
vocabulary method tagging task types manner important reasoning cognitive support particular needed trace cognitive overheads dc system may reduced 
interaction virtual architecture virtual architectures generate layer abstraction encapsulate regularities interaction 
easy get bogged interaction details reason behaviour low level 
important able interactive behaviours able consider higher levels term behaviour rasmussen little confusing unreasonable 
agent model proposed decompose behaviour common goals srk taxonomy proposes decompose behaviour orthogonal way level adaptation behaviour generating mechanism 

hardware model cognitive capacity decomposition granularity 
discussed section way computational models postulate virtual architecture dc system simulates 
virtual architectures identify classes common interfaces direct manipulation interfaces external memories 
virtual architectures map lower level simulating architectures may principle deep hierarchy 
lowest hardware model 
depending granularity analysis agent model map virtual architecture 
far simple virtual architecture mentioned virtual memory architecture abstracting interactions involved managing external memory 
chapter virtual blackboard architecture 
building catalogue common reusable architectures helpful designers catalogue outside scope hasti 
hasti merely explains architectures fit hasti analyses 
hardware model cognitive capacity decomposition debugging program writing doing financial analysis firm attempting reason machine limitations number mental things kept track lay strong constraint human cognitive capabilities 
card window computer dialogues pg 

hardware model describes aspects dc system structural decomposition stable constraints capabilities 
colloquially speaking hardware model factors basic computational hardware aspects psychology interaction knowledge considered software 
joint dc system description includes computer hardware human cognitive architecture 
background assumption modeled multi node distributed computing system 
hasti treats computer simply external memory processing system interacted 
simple treatment depicted 
example direct manipulation interface program editor abstracted manner 
non computing artifacts may modeled similarly processor 
remainder main focus just computing node human 
aim describe cognitive architecture users dc system 
computer user memory processor simplified joint system model great psychological aspects considered hardware model 
representative sources sort knowledge hci include model human processor mayhew overview barnard interacting cognitive subsystems model epic 
hardware model cognitive capacity decomposition take turns stm pm deliberate reasoning slow effortful serial expert response fast automatic parallel ltm small fades llp skills perception fast automatic parallel asynchronous legend abbreviations processor memory cognitive processor memory processor stm pm short term memory perceptual memory thread processor pool llp low level processor ltm long term memory hardware level description user model 
representative examples cognitive science include cognitive architectures soar newell act anderson 
understanding difficult non specialist 
knowledge yield benefits proportional cost acquisition 
principle inclusive approximation salient generalizations approximations picked useful reasoning cognitive support established 
basic items considered 
primarily establish constraints capabilities needed aspects models reasoning need cognitive support 
hardware model summarized described 
intention model diagram encode salient psychological knowledge 
aspects indicated 
processing 
cognitive processing decomposed interacting threads threads distributed pools processors 
pool consists single processor called 
threads running processor execute serially may switch typical multi threaded systems 
second pool consists single processor single thread running 
contains single thread accesses ltm 
third pool contains processors operating parallel single thread assigned 
act independent peripheral processors 
similar sorts multi processing models assumed cognitive agent models hayes roth epic 
processors named indicate purpose labelled main qualities 
crudely approximate number general features human psychology 
agent model behavioural decomposition models deliberate high level cognitive processing 
thread corresponds coherent cognitive processing activity 
humans frequently interleave coherent activities switch attention editing program writing email 
carries operations slowly compared llp pools 
multiple threads share processor models limited resources humans focus attention 
llp processing associated low level skills capabilities perception control 
known generally automatic asynchronous fast opaque introspection 
processing associated memory processing recognizing meaningful stimuli acting stored rules 

memory 
memory divided short term stm perceptual memory buffers pm longterm ltm 
pm ltm unstable register pools fast limited 
ltm effectively unbounded permanent directly accessed 
named indicate purpose labelled main qualities 
crudely approximates basic features memory notorious limitations short term memory relative independence different memory buffers 
similar models frequently hci models mayhew epic barnard card 
se software comprehension models cognition share commonalities model shneiderman 
model description software running processors data types behaviour perceptual function 
selects models key capabilities limitations human psychology 
intent maximally useful minimal model 
analysis needs iteratively deepened detailed models cited turned 
model predicting human performance may leave desired 
model quick dirty reasoning performance implications design decisions may suffice 
fact analyst familiar simpler model rendered collections mental capabilities llp stm pm ltm 
terms indexes simple psychological knowledge 
agent model behavioural decomposition agent model schematic model intended allow analyst model aspects behaviour dc system 
human cognition flit moment moment characterized episodes coherent purposive goal driven semi organized activity 
addition episodes tend organized schematically hierarchically see taylor nielsen rasmussen moran bass 
coherence complicated interleaving various activities 
agent model behavioural decomposition interruptions breakdowns backtracking davies 
different accounts drawn years various aspects behaviour 
needed simplified account model mechanisms causing behaviour 
aim provide simple broadly applicable schematic model describe generalizable aspects behaviour 
analysts adapt model suit particular analyses 
watch blackboard chat chat problem solving metaphor experts working blackboard need met schematic agent model cognition specifically type blackboard architecture purposes blackboard architectures differ agent architectures unimportant ways 
blackboard architectures studied ai number descendents variations 
luckily hasti needs include gross architectural features 
consequence needed concepts described briefly reader referred existing literature detailed treatment called 
blackboard architectures originated problem solving metaphor advanced newell 
newell original metaphor group experts collaborating shared problem standing blackboard turns 
illustration variant metaphor appears 
agent model proposed implementation metaphor 
key characteristics proposes encapsulate behaviour causing mechanisms agent abstraction proposes classification system ontology cognitive resources serve coordinate organize cognitive processing 
cognitive resources function related collections data cooperatively processed agents 
classification types proposed problem description agenda goals control panel holding control representations progress record 
cognitive resources turn composed collection typed data values 
reiterate resources function related collections short bibliography includes garlan shaw nii craig corkill 
reader directed specifically review blackboard systems carver lesser multi level blackboard architecture hayes roth model expert decision making 
presents breakdown problem solving techniques aligns breakdown second describes system mixes autonomous agent processing shared thread control adapted third gives example application blackboard models modeling human thinking similar 

agent model behavioural decomposition data classification systems ontology resources data types 
ontology briefly summarized table 
resources described detail subsequent subsections 
resource types commonly prior works modeling cognition 
ontology consistent collected accounts cognitive resources wright howes 
agent model proposes general scheme cooperatively processing cognitive resources 
maps cognitive resources data stores 
models aspects agents behave 
agent model described section 
section short summary combination example model interpret prior cognitive modeling software comprehension 
resource data types purpose associated function problem ends operations constraints establishes long term objectives achieve ways achieving agenda goals juggle multiple goals multiple levels control panel plans represents control information structure activities resolve ordering constraints progress curr 
state history defines current problem solving state history table cognitive resources agent model problem ends operations constraints typical say users solve problems 
sense problem defines context possible understand actions motives problem solver see simon ch 
vicente ch 

cognitive science ai defining problems treated challenge defining problem space see classic book newell 
problem space essentially graph legal states 
may possible ways represent define logical object reasonable define things achieve set conceivable possible actions operations set constraints actions 
problem solving portrayed process selecting appropriate operations subject constraints achieved 
terms goal considered synonyms hasti term goal specific sense 
goals sub goals may generated user solving problem term needed distinguish long term objective defining problem shorter term objectives adopted try solve problem 
hasti reserves term analyst modeling problems goal shorter term objectives 
similar distinction activity task idea activity roughly hasti treats problem 
way defining problem known raise number difficulties 
somewhat relaxing definitions point difficulties longer hinder informal reasoning 
hasti proposed useful analysis real user problems necessary 
agent model behavioural decomposition briefly mention analysis difficulties overview resolved 
potential difficulty may hard find user independent context possible understand user problem 
classic problem solving problem space normally defined independent problem solver 
fact lead goel puzzling goal part task environment agent 
event goals assumed explained information processing theory pg 
footnote 
puzzle raise confusions problems defined 
particular difficulty stems fact user understood terms user conception problem 
instance problem writing phd proposal reasonably defined phd candidate interests 
lead curious context understanding user action dependent user knowledge belief system 
possibility pose irreconcilable threat problem space definition recursive difficult reason 
note problem problem correctly understanding domain 
established problem contexts controlling nuclear power plant reasonable establish firm worker independent understanding problem domain 
doing may require distinguished point view see zhang vicente 
second potential difficulty problem may poorly defined 
words user may vaguely understood start 
classic case ill structured problem design 
design inadequate knowledge problem constraints paradigmatic problem solving involves problem discovery problem setting 
elaborated problems goal settings tightly defined carefully controlled laboratory situation user set task goals identifiable 
representative situation users unable state unambiguous conditions satisfaction dependent context operating 
extent identify users goals time organized strict hierarchy radically transformed events unfold 
users constantly distracted goals goals rationale fact state goals general vague terms 
general see users acting thrown situation devising goal posteriori asked 
pg 
similar way lesser extent constraints possible actions dependent user conceptions problems poorly defined start 
recursion applied resolve issue 
wish think problem setting just problem albeit distinguished dependent ones 
view just defines sub space problem space kim 
problem solvers act refine solution problem space concurrently 
third potential difficulty problems user faces may change just working 
specifically recorded history problem solving activities change operations may performed 
case covered section progress 
hasti analysis analyst determines problem solved tries 
agent model behavioural decomposition model terms ends operations constraints 
example informal analysis coding java define generation correct java program operations code writing actions constraints java programming language constraints 
agenda goals users goal directed 
simply react moment moment basis response stimuli reaching senses 
achieve need maintain sort internal state call goals 
adopt various goals achieve try achieve 
interleave pursuit multiple possibly conflicting goals 
green says users willing limit tools goal came mind long approached undue difficulty 
pursue strategy task goal breaking subgoals solving subgoal turn task goal 
strategy implied simple theories performance realistic view appears users keep agenda unsolved subgoals proceed time 
nearest approach behaviour literature computational models planning opportunistic planning model 
pg 
agent model includes just sort agenda unsolved subgoals 
agents respond trying achieve specific sorts subgoals 
manipulate agenda posting new goals refining 
assumed goals associated plans sub plans control panel 
hasti analysis analyst determine potential goals adopted order solve problem 
example coding reasoned programmers adopt goals defining collection functions implementing module sub goals writing function definition 
user juggle various goals 
control panel plans human action mechanically sense plans rigorously followed alteration 
plans posed order achieve goal 
important aspects planning intention act plan fix structuring action preparation account constraints acts son put socks put shoes 
simplistic models planning structuring amounts generating full control plan 
perceived unrealistic model human planning see young suchman 
plans seen resources structure entirely dictate action wright 
plans essentially data encoding control information 
agent model modeled instantiating plans shared panel 
called control panel partial control information stored 
agent including asynchronous ones memory processors skills perceptual processors act generate modify plans fulfill plan subgoal act signal plan update see hayes roth green pg 

dubious value try specify 
agent model behavioural decomposition broad brush model plans represented internally 
important point plans usually presupposed hierarchically structured see goms 
plans particular decompose sub goals turn may achieved sub plans 
hasti analysis analyst determine operations needed perform tasks orderings constraints action 
instance coding tasks analyst note design documentation uml model serves plan code generation 
progress state history problem solving said involve progression sequence states problem space 
part data involved defining progression states sequence progressed history 
state defined partial solution constructed internal problem solving state recorded problem solving history 
instance person problem write sentence feel spam email problem solving state include partial sentence constructed plans structuring phrases memory sub goals fulfilled phrase ordering possibilities discarded 
storing progress possible backtrack history determine moves perform 
maintaining history provides evolving session specific set operations problem space definition 
hasti analysis analyst determine constitutes evolving solution memories past history states sequence operations recover states 
instance coding tasks analyst note evolving program current statement coder working test data part current state 
history include previously attempted solutions 
ideal code unsupported external memories hold data memory 
realistic situations course developer supported external memory evolving program recognized part cognitive system support external memories recognized 
agent model mapping base agent model relatively standard blackboard model multiple panels 
panels way logically partitioning blackboard contents functional roles 
agent encapsulates coherent behaviour activity function 
form abstraction differs cognitive processing decompositions cognitive capability planner inferencer 
agents fruitfully viewed experts performing particular operation long term knowledge familiar 
view accords newell original metaphor reason agents called knowledge sources kss lexicon blackboard systems 
important note agents proposed abstractions software mind 
variety ways mapping abstractions lower level software possible mapping related rule sets rule model 
mapping generates performance implications 

agent model behavioural decomposition blackboard metaphor argues agent activated interesting addition problem solution 
read write various panels needed 
essential insight explain key property opportunism human 
instance agent may know generate partial plan particular goal agenda 
post plan plan panel agents resolve 
alternatively agent may know modify current solution state achieve sub goal 
blackboard architecture treats solution processing progress control processing plans goals uniformly 
addition assumed collection agents cooperatively process perceptual motor activities 
agents read access panels full access relevant perceptual memory 
architecture illustrated 
dashed line intended indicate different agents defined modeling framework 
analyst model encode variety goal directed behaviours 
done high level granularity informal design settings 
instance analyst note developers investigating code bug fix switch activities searching files reading documentation running test cases 
draw different agents labelled search read run tests 
argue developer performs activities plan making change formed 
write bug fix plan control panel 
bug fixing plan example consist sequence steps add new function variant search old uses switch new function appropriate 
general agent model model cognitive activities involved performing task 
expose types data processed categorize function related roles 
panel blackboard problem agenda control progress ends operations constraints goals plans curr 
state history agent agent agent agent agents take turns schematic agent model showing generic agents panels panel data types 
agent model behavioural decomposition mapping hardware agent model mapped hardware model shown 
blackboard mapped memories 
assumed explicitly shown blackboard contents held combination ltm stm 
analyst aware contents subject stm limitations persist 
contents blackboard may forgotten data needed parts persist long terms remembering left returning programming problem lunch 
processing agents mapped llp processor pools hardware model 
allows run asynchronously 
flexibility mapping allowed remaining agents 
agents allowed skill mapped llp pools 
agents mapped distinct threads 
threading threads switched priority 
specifically certain agents suspended time potential contribution problem solving elevated see carver 
suspension result waiting particular event contents blackboard blocked input awaiting signal 
scheme allows cooperative threading turn competitive threading competing goals 
action group turn nature require access blackboard contents 
turn indicates contents coordinating role map agent hardware agent agent agent agent llp blackboard problem agenda control progress stm ltm legend abbreviations agent agent memory processor pool llp cognitive processor memory processor low level processor stm pm ltm short term memory perceptual memory long term memory mapping agent models hardware 
agent model behavioural decomposition affect control thought action 
agents doing different may take turns agent may suddenly jump interrupt observing situation thinks important progress 
agents differing ideas solve problem may compete attention 
simplified model expanded needed consulting published models related domains visser zachary 
model mapping model important aspects human psychology 
fact important parts blackboard panels mapped stm means limitations stm affect capacity hold complicated contents 
human cognition 
limits depth breadth agenda control problem state people remember time 
furthermore things prone forgotten pushed memory resulting slips errors 
instance depth planning limited plan steps forgotten see young 

mapping agents separate threads running serial models opportunistic switching different tasks sub tasks goals recognition opportunity 
summary agent model presents decompositions mechanisms cognitive processing decomposed collection agents opportunistically switch coherent goal related actions data contents stored separate function specific panels shared blackboard 
features cognitive processing explained mapping agent architecture resource limited hardware architecture goal switching opportunism planning limitations slips 
addition cognitive resource types decomposed orthogonal types problem agenda control progress 
resource types consist collections data different data types 
problem consists collection global goals constraints possible operations progress consists current problem solving state history control panels store plans agendas store goals considered 
data typology explain properties human problem solving goal directed 
result model human thinking problem solving summarizes knowledge prior models cognition 
discussion focused prior internal models cognition dc framework chapter implies reality resources may distributed 
commented section 
illustrate applicability model software engineering tasks integrated model software comprehension von mayrhauser vmv model re interpreted blackboard architecture straightforward manner 
vmv model postulates comprehension consists process incrementally constructing hierarchical internal representation knowledge base system 
process described consisting different types processes top bottom situation different processing techniques build complementary types knowledge 
processing model described opportunistically switching processing types 
model quite naturally re interpreted agent model 
processing types interpreted specialized agents 
model contain top agent bottom 
specialization hierarchy strata agent situation agent 
opportunistically activated contribution solution 
internal representation identified progress panel solution state understanding long term processes incrementally built solution need stored ltm 
minor aspects vmv model incorporated translation 
simple description show agent model corresponds closely existing cognitive modeling field 
section example different software comprehension model modeled agent model 
specialization hierarchy strata rasmussen note human behaviour falls different categories 
provided reasonably influential analysis sort categorization implies problem modeling designing systems 
proposal divide human behaviour specialized adapted particular tasks 
specifically proposed cognition falls categories response skill rule knowledge 
categorization called srk taxonomy 
summary table 
briefly skill cognition quick easy overlearning controlling external devices 
rule cognition fast deep experience solving classes problems 
knowledge behaviour slow difficult requires deep thinking reasoning 
crucial realization properties cognition match levels adaptation tasks involved 
matches ordering imposed srk taxonomy terms preferred activity 
ordering results ordering processing falls back different levels level adaptation fails 
ordering depicted 
basic categories cognition important understanding cognitive support 
category adaptation cognitive phenomena suggested mechanisms skill highly adapted activity involving deep knowledge 
quick automatic effortless parallel opaque 
simple functional computational models 
rule expert response familiar situations 
rapid response pattern matching rational deliberation 
rapid memory search expert knowledge abstracted cues 
knowledge variations circumstances mean canned responses fail need adapt 
slow serial deliberate 
reasoning problem solving categorization manipulation internal representations semantically meaningful symbols 
table overview rasmussen srk categories human adaptation 
specialization hierarchy strata adaptation preference skill rule knowledge fallback ordering behaviour categories adaptation preference fallback order addition categories rasmussen established taxonomy interpretation levels data set hypotheses mechanisms generating srk behaviour types model schematically depicting behaviour causing mechanisms interact 
aspect considered 
second reinterpreted framework mapping scheme hardware agent models prior sections 
particular mapping accomplished establishing set layers strata agent model 
stratification works follows 
agents located stratum 
stratum defines typing agents located 
agent typing associated specific way mapping agent hardware model 
properties hardware model explain different phenomena srk behaviour categories 
hardware model replaces mechanisms rasmussen suggested srk category rightmost column table 
addition agent model explains different behaviours flexibly interact 
agent model replaces rasmussen model calls framework different behaviours interact 
mapping follows 
skill level 
skill level behaviour rasmussen describes corresponds llp processing hardware model 
agents skill level stratum mapped components 
operations assumed mediated skill level agents 

rule level 
rule level behaviour corresponds simple memory response mechanisms 
agent model modeled agent agents match current contents blackboard knowledge ltm post resulting solutions plans back blackboard 
type agent mapped processor 

knowledge level 
knowledge level behaviour corresponds serial deliberate processing hardware model 
agents knowledge level stratum mapped threads processor hardware model 
illustration stratification appears 
fourth stratum labelled depicted 
explained 
scheme resembles rasmussen framework 
main difference direct communication agents depicted communications resource restricted data store close correlation strata terminology referring rasmussen framework 
simplicity agents forced reside entirely stratum 
rasmussen insights deep potentially useful may fruitful extend including 

specialization hierarchy strata identify behaviour spanning stratum simply decomposed clusters independent cooperating agents 
mappings strata hardware model depicted 
notes regarding precedents scheme 
agent terminology rasmussen architecture somewhat subsumption architecture vertically layered see jennings 
main differences appear related communication methods agents 
note similar schemes proposed multi layer information flow cognitive agents 
examples include norman multi stage model robot architectures see van de velde examples 
worthwhile mentioning rasmussen careful argue information flows environment different strata pass skill level 
action perception accomplished agents stratum 
constraint adopted depicted locating capabilities stratum 
finishing observe model includes fourth stratum labelled 
intended indicate fourth category cognitive behaviour called metacognitive activity 
category included hasti primarily placeholder 
intention category differentiate special type knowledge processing 
knowledge processing occurs thinks reasons problem solving 
corresponds part termed reflective thinking part breakdowns see section reflective thought considered different mode thought norman lloyd 
reasonable extension srk taxonomy represents case knowledge processing ill adapted smoothly solve task 
cases forced reason adapt existing knowledgebased solutions 
related reflective thought thought helpful indicate directions able discuss cognitive support relation reflective thought 
map agent hardware agent agent agent agent llp blackboard imposes stratification agent model 
task decomposition stratification task decomposition stratification notion problem space powerful 
treat different activities moving mice solving algebra negotiating resolution conflict worker 
problem user faces complicated composition sorts problems 
may beneficial simplification logic reality discussing cognitive support useful vocabulary needed 
problem space sensibly partitioned 
hasti propose fold partitioning problem space 
choices partitioning related sorts issues important analyzing cognitive support 
called domain device coping cooperation problems tasks 
summarized table 
follows domain 
domain problem program solved number different tools techniques 
desirable differentiate domain task specific tasks related solution environment 
instance commonly noted distinction hci difference domain task device task see 
may question possible principle define domain tasks completely device invariant manner 
irrelevant purposes model generalizable domain tasks identified 
sufficient analyst able confidently categorize part problem part domain 
device 
particular tool solve problem usually called device 
device creates set tasks 
instance writing letter word processor particular device task save current file periodically 
tasks may differ different tools saving required typewriter 
domain tasks ultimately mapped user sequences device tasks 
coping 
domain problems difficulties user problems encountered may appear part domain proper 
significant unavoidable difficulty imposed limitations small stm bias simplified reasoning 
people adopt strategies cope problems see freed 
difficulties appear form failures power outages unanticipated interruptions telephone call spouse 
regardless source coping problems problems attributable difficulties associated categories 
coordination 
takes effort cooperate 
cooperating individuals synchronize communicate maintain joint awareness understanding planning baecker 
simplicity call coordination problems 
cooperation human computer different 
tempted call category part device category 
reasons considering separate category coordination overheads 
see notice long cooperation occurring similar collection coordination problems exist devices device tasks change 
example external memory shared 
task decomposition stratification user computer coordinating access shared item coordination overhead regardless particular implementation external memory 
unfair design device lump costs device costs 
cooperation tasks considered independent device way tasks 
types task subproblem collectively called taxonomy 
actual proposal relates previously proposed ways decomposing task problems moran 
reasons wishing decompose problem space manner 
problem type domain represents different type overhead 
important able distinguish overhead fundamental problem domain 
discussing cognitive support benefits placed relation overheads creates 
example designer external memory system need evaluate cognitive support provided tasks relation device cooperation overheads creates 
second reason providing distinctions difficult understand underlying domain related problem solving activities user 
importance emphasized experiences gray 
impossible coherently understand problem solving performed subjects recognized spurious activities caused device tasks 
taxonomy identify different types cognitive processing agent model 
problem types intended pair wise orthogonal furthermore problem type orthogonal categories problems potentially tackled categories behaviour 
depicted partitioning multi layer mapping 
shown 
domain device coping coord 
agent map hardware agent agent agent agent llp blackboard task taxonomy partitions agents task goals 

interaction decomposition virtual architecture type domain device coping coordination description related context specific tasks working tool avoid limitations contingencies overhead tasks cooperating table summary task taxonomy interaction decomposition virtual architecture importance distinguishing different virtual architectural abstractions discussed chapter 
chapter introduced concept mapping virtual architectures implementing simulating architectures 
need reiterate basic arguments 
important discuss virtual architectures fit rest hasti 
main impact making possible slide virtual architecture top hardware architecture 
having agent architecture map directly user internal cognitive architecture map virtual human computer architecture 
agent architecture models single user internal cognition multi agent model 
multi agent model small step extend model multi agent systems human computer dyads 
similar concepts advanced usually context communication humans perry 
interposing virtual architecture agent architecture hardware model extension possible 
agents seen execute human mental computer 
blackboard seen distributed human external memory 
scheme interposed virtual architecture map memory processing implementing hardware architecture 
memory system architecture virtual memory architecture may page 
cases done simulate virtual architecture identifies encapsulates common device communication overheads 
virtual architecture elide overheads task view agent model 
depending analyst focus virtual architectures considered important unimportant 
instance certain circumstances designer may wish ignore particular virtual architecture 
just assume agent model distributed version delay considering issue implemented 
cases analyst concerned costs simulation overheads compare benefits device 

summary summary important criteria impinge proposed framework obvious utility 
accurate 
say offer precise picture cognition hci supported offers correct sense describes real factors aspects influence tasks 
second relatively non complex 
invoking psychological descriptors cognitive structures form suitable non specialists apply difficult necessary part framework 
third suitably generic relevance application 
andrew dillon designing usable electronic text pg 
pg 

chapter addressed problem defining modeling framework analyzing cognitive support 
order analyze different types cognitive support necessary dc models apply different support principles rods 
particular dc models supply psychological hci materials discuss various forms possibilities cognitive support 
primary challenges analysts cognitive support face complexity knowledge base 
furthermore knowledge exists cognitive psychology hci currently tends overly detailed relative needs broad brush analysis 
fragmentary nature existing modeling leads result difficult relate cognitive model features performance support issues 
problems met defining collection principles strategies constructing suitably integrated models integrating number existing models dc systems generic modeling framework 
considered modeling framework defines schematic model expected expanded refined needed 
principles construction emphasized needs integration broad coverage approximation abstraction 
especially important principle construction concerned decompose modeling efforts 
specifically argued important tasks entire enterprise determine set dimension helpful decompose dc phenomena 
decomposition decided important decompose models phenomena analogous way 
principles modeling framework called hasti proposed 
key idea hasti decomposition dimensions relate ways dc systems reengineered 
consideration effectively generated primary feature hasti collection dimensions decomposing aspects dc systems 
dimensions called hardware agent specialization task interaction dimensions identified cognition related phenomena issues modeling structure associated see table 
dimensions name hasti 
dimensions adds concepts vocabulary analyzing cognitive support related issues 
models designed abstracted simplified sampling salient facts 
relationships various dimensions established inter model mappings imposing orthogonal models 
emphasis presentation primarily modeling 
summary users 
virtual architectures possible map models joint cognitive systems 
capability illustrated chapter 
reiterated new facts proposed chapter 
phenomena models discussed reasonably science base 
contribution selecting relevant knowledge integrating coherent set structured models inter model mappings 
integration broad simplified principled unique 
concluding chapter necessary discuss hasti help cognitive support analysis ways underlying support base 
simplification may valuable psychology averse se researcher specialist alike 
non specialist selected gathering ultimately grounded established science base 
advantages obvious researchers especially non specialists 
current analysis practices little existing cognitive theories 
existing modeling techniques initial hurdle large non specialists jump 
hasti step providing lightweight modeling frameworks offer smaller hurdles stepping stones deeper analysis 
specialist integration illustrates broadly construed cognitive models need useful design implications 
rarely aspects considered cognitive science hci studies 
instance comprehension model von mayrhauser maps directly agent model 
suggestion fails address dimensions cognition 
integration help give specialist perspective limitations studies understanding relate broader context 
second providing dimensions important way cognition related issues smoothly brought analysis needed 
main advantages analysis inclusive set concepts vocabulary provided 
analyst refer memory limitations discuss goals plans compare knowledge skill behaviour distinguish device domain tasks identify device tasks simulation overheads 
benefit discussed section 
third way dimensions woven important 
fact modeling integration arguably important modeling individual dimensions 
possible pay attention dimension analysis relating cognitive issues models difficult explicit mapping available 
mappings effectively create structure implications associations followed analysis 
instance simulation operation virtual architecture linked cognitive overheads form device tasks classified skill behaviour leads consideration perceptual skills utilized 
conceivable experienced cognitive rapidly appreciate relationships mappings hasti explicit 
lastly hasti structured way rods applied generate space cognitive 
advantage important separate chapter devoted exploring chapter 
chapter costh hierarchy support theories developers maintainers software faced ongoing task assessing value new comprehension aids 
currently assessment entirely trial error usually informal anecdotal kind 
useful task engineering psychology development set design guides selection devices 
starting point developing design principles analysis way program comprehension aids operate necessary 
brooks theoretical analysis role documentation comprehension computer programs 
cognitive support intellectual foundation understanding tools built cognitively demanding activities useful 
postulate tools able improve thinking problem solving 
ingredients indispensable theory description facets cognition way indicating ways tools serve improve cognition 
precisely things hasti rods intended help provide 
rods enumerates ways dc systems improved form support principles specifically form explanations specific computational rearrangements dc systems advantageous 
rods high level support theory explain particular sorts cognition rearrangements helpful 
hasti proposes way modeling joint human computer systems dc terms 
hasti combined rods build specific cognitive support theories detailed arguments sort cognition rearranged 
chapter aims extract theories illustrate relate cognitive support se tools explain theories may someday codify knowledge tool design 
rods hasti set theoretical backdrop chapter begins process applying theories improve se 
hasti rods formalize tool ideas research 
structure chapter follows 
section overview provided hasti specialize high level support theories rods 
output process hierarchy specialized theories cognitive support 
hierarchy called costh 
topmost level costh consists classes support theories 
class application types support principles rods 
specifically computational substitution principles distribution specialization algorithmic optimization basis generating different classes support theories 
hasti basis refining topmost classes theories 
refinements identify equivalence classes artifacts related implementing particular type cognitive support 
costh formalizes generalizable tool ideas 
topmost support types described separate sections sections 
way branches costh hierarchy compose explored section 
chapter closes comparing prior integrative cognitive support section discussing limitations section providing summary hierarchy implications section 
hasti rods formalize tool ideas whilst numerous empirical studies investigating different aspects graphical representations little attempt integrate findings analytic framework 
needed systematic approach evaluating merits different kinds graphical representations theoretically driven accounts cognitive processing people interact 
approach principled way making sense vast empirical literature benefits graphical representations making predictions value new forms animation virtual reality 
scaife rogers external cognition graphical representations pg 

tools researchers commonly interested tool ideas tools 
fact argued chapter 
informally speaking may say tool idea statement certain class tools beneficial certain way 
distinction implementation tool idea idea important 
perfectly tool idea embodied bad implementation 
pipe cleaner instance lever 
fact leads important implications testing tools 
order test generalize tool idea tested minor variation implementation threatens render test results inapplicable variants 
existence minor variations obviously implies basic tool idea implemented different forms 
important know instance papers proposals building re usable design knowledge 

hasti rods formalize tool ideas important able formalize tool ideas able classify artifacts categories equivalent tool types 
rods works goal 
example tools distribute data kind said fall broad class tools function external memory 
categorization involves simply clustering related tools tool idea normally associated understanding usefulness tool 
example reasonably claim idea fisheye source code browser browser helps avoid lost hyperspace presenting detail context view see storey 
explanation important 
rods formalizes idea providing computational explanation class artifacts supportive 
reader may recall section cognitive support principles rods identify theories cognitive support 
underlying computational principles rods thought orthogonal concepts substitution principles rods induce independent support theories 
result hierarchical refinement structure theories follows refinement computation reengineering distribution specialization algorithmic optimization data distribution processing distribution theories identify high level tool ideas external memory 
sense independent particulars cognition independent dc modeling techniques model cognition 
model independence advantages 
conceivably different cognitive models conjunction rods 
models domain specific uniquely model certain aspects cognition auditory perception 
model independence just separation concerns theory engineering 
insulates definition rods certain degree changes understand model human cognition 
insulates rods vastly complicating details various domains application 
advantages transferred topmost levels hierarchy support theories 
disadvantage independence ideas formalize general 
basic rods principles take step formalizing ideas practically speaking steps 
able formalize specific ideas tools 
way making tool ideas specific needed 
way done define specifically sorts computational reengineering done artifact 
instance noted data distributed question asked data noting specialized processing substitute processing tempted ask substitutions possible hasti comes 
main purpose hasti able discuss sorts computational possible see section 
key contribution hasti regard fold decomposition cognitive issues various taxonomies hierarchies 
hasti derived simplification integration cognitive modeling literature provides theoretically motivated decomposition cognitive aspects may reengineered applying rods 

hasti rods formalize tool ideas rods substitution principle hasti matching structure costh refinements distribution agent data typology distribution subtypes virtual architectures distribution subtypes specialization substitution hierarchy table hasti structures align rods substitution types rods model independent cognitive models 
depending cognitive model involved generating refined support theories easier said done 
instance notion specialization substitution difficult apply models clear distinction general specialized processing elements comprehension model von mayrhauser 
hasti designed provide starting point 
principle design rationale hasti structuring mechanisms computational models lines computational reengineering applied see section 
consequently substitution principles rods matched structuring mechanisms hasti see table 
summary matches table described 
distribution distribution substitutions applied resource data type decomposition agent model virtual hardware follows 
data type 
panel types agent model classify different types mental states 
candidates distribution 
instance plans distributed 
existence distributed data type strongly indicates distribution processing data 
instance shared plan indicate distributed planning 

virtual architecture 
virtual architectures encapsulate interface interactions abstracting interface operations 
provides class specific general details data agents may distributed 
example task searching external memory match clearly generalizable different external memory devices external processing possibilities 
specialization hasti specialization hierarchy distinguishes humans degrees adaptation task environment 
level specialization indicates distinct categories processing interpreted hasti involving different levels cognitive mechanisms 
hierarchy provides specialization substitution hierarchy lower level processing potentially substituted higher level processing 
hasti contributes ways refining costh hierarchy specific details different sub categories cognitive reengineering 
result hierarchically structured family 
hasti rods formalize tool ideas distribution data problem pb progress pg goals plans operations constraints ends history state current processing generic domains problem solving methods cognitive functions virtual hardware gd ps cf vh specialization skill perceptive reactive action sp sa algorithmic optimization rule encoding shift recognition rule action sr su en hierarchy support theories built rods hasti cognitive support theories refined 
illustrates hierarchy results refinements 
called cognitive support theory hierarchy costh 
leaves tree represent support theories specialized cognitive system information hasti combination additional ways categorizing support types 
worthwhile fact theories certain computational dc systems explain cognitive support theories generating artifacts supportive 
hasti refine costh particular theories may quite generic 
simply hasti intentionally broad brush modeling framework 
generic cognitive support theories sense essentially broad brush statements large classes dc systems rearranged support cognitive 
generality limits power certain explanations predictions generic theories important prominently utilized chapter 
choice body theoretical hierarchically refined collection separate theories somewhat arbitrary 
chosen sort single unified theory composed leaf nodes tried highlight presenting theories inhabiting topological space 
think hierarchical refinement presentation reinforces theory design perspective section highlighting multiple decision points possible narrowing strokes broad brush theories 

hasti rods formalize tool ideas documentation conventions bulk remainder chapter consists descriptions generic cognitive support theories costh 
unix style file naming conventions name nodes tree hyphens replacing spaces words 
save space set abbreviation letters refer various nodes tree 
letters indicated capital italicized letters node non leaf nodes right nodes leaf nodes abbreviations 
example strings distribution data goals goals refer top leaf encoding en name bottom 
note abbreviations reused different parts tree leaves distinct 
duplication problem name nodes unix style 
likewise leaves named path unclear leaf node root nodes referred note 
order structure exposition support theories schema imposed describing support type follows recap intro relevant features hasti relevant background materials briefly summarized convenient 
interpretation guidelines understanding apply support type real hci analysis situations challenging 
contribution artifacts system cognition extremely non obvious difficult properly appreciate see section 
guidelines part provides characterization constitute instance support type described 
may help reader think characterizations things experimenter look performing observations user tool interactions 
impossible completely thorough characterizations emphasis placed providing paradigmatic examples 
sample implementations examples literature provided theoretical description concrete instantiations 
examples help demonstrate categories inhabit nonempty 
cases examples archetypical instances sub category similar support types 
addition example general description refinement support type included 
worthwhile role examples exposition illustrative samples support category definitely exhaustive 
illustrates examples relate types cognitive support cognitive support theories 
examples categorized type cognitive support naming scheme uses sequence node names separated character specify path root node 
mathematician chosen sub scripted parameterized notation goals think tree walking unix scheme highlights refinement path 
notice pg past pg current little unusual explained 

distribution phenomena theories support types correspondence support theories concrete universe artifacts examples equivalence class universe explanations examples tool idea relationships artifacts examples theories tool ideas 
exhibit turn corresponds types theories explain 
illustration schematically shows examples may members category support types combine 
costh inhabits upper right quadrant chapter attempts elaborate upper left 
organizational issues way sections dedicated describing support types combine 
distribution way thinking cognitive support continuum different levels support ranges completely unsupported entirely mental completely automated human thinking involved 
practice ends spectrum generally unattainable interesting tasks programming 
reasonable imagine principle unachievable extremes spectrum entail 
order entirely mental continuum hold close inspection problem solution mental state information need held internally processing information need done internally 
distribution changes picture 
increasing distribution problem solving dispersed 
increasing distribution computational done user 
common term offloading scaife terms automation boy allocation wright delegation effectively synonymous 
distribution general computation distributed artifacts agents computer science friendly preferred term 
distribution class type description subtype examples data goals directs maintains focus explicit names task list implicit skeleton declarations coding plans orders structures action explicit checklist todo list reminders schedule implicit code repair list query results plan scripts macros wizard plans 
plan thesis outline problem defines cognition context operations menus buttons options constraints linguistic physical graphical constraints combined requirements documents progress problem solving states past trace visitation history dog ears past path undo revision history current focus cursor position object selection window focus current partial process generic intermediate computations math stats mathematica spss domains patterns search grep abstraction clustering concept analysis graph layout virtual abstracted interface tasks vm data layout item sorting search hardware page management psms domain independent strategies iteration wildcards tag drag cognitive thinking activity attn 
mgmt 
critiquing functions planning error list generation constr 

learning type checking programming demonstration script library population peers abbreviations vm virtual memory psms problem solving methods attn 
mgmt 
attention management constr 

constraint enforcing table summary redistribution examples 
offloading allocation delegation helpful evocative terms terms occasionally find uses 
remainder section elaboration different ways distributing cognition 
different type distribution principles categorizing type explained examples 
summary table table 
table organized hierarchically distribution class data process type referred subtype 
subtypes table primarily organizational explanation purposes may explicitly mentioned 

distribution data distribution characteristic uses data distribution 
unloading data user memory consumption user 
typically called memory offloading 
implies functions external memory 
second distribution sharing data user agent computer 
call memory sharing 
type distribution requires external memory shared nature memory obvious 
case normally trace data loop user external memory back 
case data may produced consumed participant data loop may convoluted indirect 
different types data distribution supplied agent model panel content types cognitive resource types data types 
goals plans problem progress 
problem data decomposed ends constraints possible operations 
likewise progress divided past current problem solving states 
data type hierarchy summarized follows problem progress goals plans ends constraints operations current past goals recap intro agenda resource maintain manage multiple goals 
goals things try achieve 
interpretation guidelines external structure feature employed users direct manage focus considered external implementation agenda 
agenda recognized noting cases goals explicitly written presentations desired problem solving states 
sample implementations skeletal declarations 
classic example goal offloading programming green parsing model code generation 
programmers planning complicated addition may externalize pending subgoals form skeletal program declarations filled 
skeleton declarations serve external agenda 
brooks argued external agenda substitute internally stored subgoal stack 
shared goals 
agenda sharing important mechanism coordinating agents 
learning environment contains example external shared agenda context human tool coordination 
computer agent tutor called periodically posts goals infers student currently 
distribution working 
case externally manifested goals names meaningful desired problem states 
analogous function provided task list component system documentation environment see erdem description 
task list maintains agenda sub tasks perform task user selects 
user subtask selection partly driven external agenda 
similar role external agenda software design environment argo see robbins 
plans recap intro planning partially specifying intentions action orders especially response constraints ordering activities 
planning pre structuring acts precomputations action sequences action ordering constraints 
interpretation guidelines planning ordering action external plans nearly kind structure indicate specify constraints intentions ordering actions system 
followed considered plan context 
instance checklist plan shopping list 
plans organize user action computer action coordinate 
sample implementations reminder 
sticky note pasted edge computer screen event database popup reminder agent 
appointment schedule 
day planner online meetings scheduler 
inspection checklists test plans 
code inspection checklists fagan examples precomputed static plans 
checklists performing orderly systematic software inspections 
common se plan test plan 
error lists 
compilers produce error message list compilation runs 
message list forms partial list fixes programmer normally 
search results 
strategic query engines pose queries define structure traverse task 
instance programmer call grep query text base list relevant program locations modify 
search results structure ensuing action form external plan action 
todo lists 
lists things commonly ways accumulating intentions 
lists organize action imposing ordering schemes 
development environments argo sourceforge include todo list tracking features 
externalized lists frequently coordinating multiple agents 
utilized sourceforge net open source online development resource 

distribution conjunction external agendas see 
argo examples multi agent systems task decompositions external plans 
people organize email mailboxes stack things 
scripts macros procedures 
scripts macros specifications procedures sequences operations computer perform 
scripting languages common nearly complex systems operating systems windows scripting host tcl sh applications word processors reverse engineering systems 
instructions problem solving methods 
instructions performing tasks frequently written terms procedures 
instructions novices internalized learned 
classic example polya popular book mathematics problem solving 
external instruction structures include teacher lesson plans computer analogues structured documentation 
generated instance guide software starting maintenance new system 
tours lesson plans 
tours scripts humans 
structures guide unfamiliar application information space contents organization marshall 
wizard plans 
wizard internally stored goal satisfying procedure example external plan 
wizard plans computer scripts typically incomplete schematic see implement formalized decision procedures script decision points users queried decisions 
problem recap intro problem context person group organization acts gains motivation constraints action possibilities 
user problem changes moment moment understanding context changes 
formalizing problem context difficult 
way formalize problem terms problem space consists goals achieve constraints action operations performed 
interpretation guidelines recognizing constitutes external manifestations problem extraordinarily difficult see section 
identifying exactly constitutes problem tough purposes externally manifested problem information classified ends constraints possibilities action 
constraints easiest recognize take different guises 
externally manifested constraints include physical constraints action logical constraints language 
distribution written specifications logical constraints see zhang norman extensive comparison 
externally manifested ends identified just goals external agenda associated setting context problem solving determining moment focus problem solving 
possibilities action indication ability perform action interface logical moves 
logical moves internal operations inferences partly external moves may mapped sequence device level moves 
sample implementations drawing constraints 
architect square implement drawing constraint producing horizontal parallel lines 
language constraints 
compiler need represent explicitly implicitly constraints language compiles 
action restrictions editors 
syntax semantics aware program editors enforce linguistic constraints constraining editing action 
type declarations assertions 
widely believed able specify solution constraints important part software design development 
constraints thought help avoid shooting foot 
strong typing fine example externally specifiable constraints examples cited including assertions contracts aspects various types system structure specification methods 
menus buttons options 
menus command buttons options dialogue boxes visual representations possible action 
systems context sensitive menus represent actions possible context 
means ends hierarchy 
externally manifested possibilities action called means ends representation rasmussen 
rasmussen proposed means ends hierarchy principle designing interfaces 
examples derived related works rasmussen vicente 
requirements documents 
requirements documents frequently represent problem developers face 
commonly acknowledged necessarily incomplete require iterative negotiation 
programming problem evolves explored understood 
requirements documentation excellent example evolving problem conception externally manifested 
zhang norman give nice decomposition different ways manifesting constraints considered adding level refinement costh diagrammed pb constraints node subdivided types constraint manifestations 
refinement begins mix implementation issues support type issues decided mixing far possible 

distribution progress recap intro progress data includes current past computational states system evolved 
division progress past current states generate taxa describe proper dichotomy 
reasonable synonym past states history abbreviation past state information 
current state simply drop current call simply state abbreviating 
interpretation guidelines external manifestations progress tracking generally associated way storing current past system states 
current state includes obvious objects data edited current document database program clipboard 
includes states problem focus currently active window windowing system 
past progress include snapshots prior states ordered record problem solving path taken different system states unordered trace different states system 
sample implementations evolving solution objects 
computing environments revolve presentation evolving solution document word processing system source code software development 
logical focus 
logical object user current focus problem solving may externally represented 
mapped logical position problem space system presentation space 
common examples include mapping logical focus cursor position object selection highlighted presentations window focus window selections 
special instance externally representing logical focus tracing positions hand fingers :10.1.1.22.1477
note logical object distributed external presentation logical focus may map multiple presentation locations brown shneiderman 
visitation history 
browsers keep history visited links link colours differently depending visitation 
similar examples include edit history document lists 
interaction history 
command interfaces provide history commands responses 
example history scroll cascade old machines 
modern equivalent terminal emulator buffer scrollbar 
history includes shell command histories 
dog tick marks 
special form visitation history people mark trail important places indicate relevance 
regularly record terms snapshot trace path defined meant merely evocative terms part ongoing vocabulary building 

distribution progress checklist tick marks 
environments incidentally record usage informally wear tear 
change history revision management 
software development multiple branches documents frequently kept revision tree revision management system 
effectively store partial solutions different branches search space 
undo mechanisms applications similar character revision histories undo mechanisms may differ state revision encoding methods 
systems seesoft able indicate certain aspects object change history 

refers practice gathering interesting things collected works returned referred en masse 
instance incrementally adding items basket browsing online purchases commerce site simple form 
common non computerized forms behaviour include names short notes pertaining pending tasks scrap see instance scrap reported 
processing distribution processing distribution implies shared cooperative processing data 
distributed processing means multiple agents split re distributing processing involve shifting multiple agents typically refers making computers take cognitive load 
software development examples processing distributed 
probably obvious program compilation compilers automate laborious error prone activity generating machine specific code specification 
examples produced apart just listing unclear start coherently organized 
guarantee organization produce carry domains 
arrive quickly important question section principled domain independent way saying sorts processing distributed 
data distribution agent model panel types yield succinct motivated decomposition data types 
produce corresponding taxonomy data distribution types 
case processing distribution clear 
obvious ways decomposing processing generic way 
hasti includes essentially structuring mechanisms kind statement regarding process decomposition 
task categorization taxonomy section 
provides categories labeling certain tasks corresponding domain device coping strategies cooperating overhead 
categories provide helpful ways classifying activities known statements activities 
second statement hasti regarding process decomposition virtual hardware abstractions form virtual architectures 
virtual architectures proposed way abstracting human artifact interactions common distributed processing necessarily implies data process available externally data distribution focus particular subsection 

distribution different interfaces see section 
certainly resources characterizing types processes may distributed utilized 
virtual architectures say little processes implemented top virtual hardware 
processes run virtual hardware 
processes distributed 
sum hasti provides decomposition methods building processing taxonomy insufficient 
ways building generalizable taxonomies processing considered 
possible classification methods processing considered 
include 
generic domains 
frequently method formalizing computation map operations problem domain operations domain independent computational layers algebras calculi logics 
suggests fruitful approach creating domain independent taxonomy computational methods enumerate operations defining sorts intermediate domains set functions matrix calculations graph traversals 
distributing computation amount knowing map cognitive operations intermediate domains 
value approach essentially way successfully automating previously cognitive nearly century 
landauer noted limitation problem remains map domain processes intermediate domains 
cases relatively easy problem vote tabulation 
cognitive software development design maintenance exceedingly difficult 
analyst create mapping users may possible provide users programmable domain independent processing systems 
users responsible mapping particular cognitive problem form externally processed 
spreadsheets obvious example 
domain independent computational layers ignored limited capacity serve generalizable basis decomposing cognitive processing purposes discussing distribution possibilities 

domain task process models 
task models ways decomposing activities relating goals purpose 
example domain specific task translating program machine code 
program translation clearly task specific particular problem domain programming 
domains may feasible discern taxonomy tasks perform may possible systematically break large grained tasks smaller subtasks 
case collection taxonomy tasks necessarily constructed 
task taxonomy emerges developing normative descriptive models problem solving domain 
purposes matter task decomposition created distinctions cognitive presumably non cognitive task analyses 
dc point view little fundamental difference generally substitute section 
exceptions course equating task analysis cognitive task analysis may 
stance unusual dc view tends blur distinction thinking acting 
view especially sensible highly cognitive domains software development rarely worth giving simplicity treating thinking acting interchangeable 

distribution tasks elicited task analysis result process modeling description basili 
se examples process task models 
obvious characteristics models wide variability granularity form content 
classic process model called waterfall software development process consists sequence highlevel tasks perform 
contrast fine grained models program comprehension descriptive pseudocode model program comprehension normative basili mill process model bottom comprehension code 
task models programming maintenance remodularization reverse engineering testify diversity process task modeling field 
similar types task decompositions exist domains reading writing model formulation flight planning decision making coffee making 
specific task analyses performed routinely standard hci practice increasing emphasis placed cognitive aspects tasks 
regardless form content task process model describes processing sort provide vocabulary discussing process distribution 
instance boehm davis model program comprehension consists part cycle hypothesis generation verification segmentation operations 
purely mental activities consider sub processes may distributed 
instance contemplate distributed hypothesis generation 
problem clear obviously pervasive modeling produce general descriptions process distribution 
problem task analyses better considered competence models performance models 
suggest needed task ways performed 
second problem domain task decompositions definition domain specific notwithstanding fact may coarse grained written task languages 
domain specificity unfortunately main liability models normally difficult break free domain 
constructing domain task models easy ignore crucial similarities patterns activities domains 
seeking general theory processing distribution sense try away domain environment specifics 
brooks difficulty primarily due way tasks usually modeled described especially human factors task models low level primitive tasks lack formalism summarization difficult human factors task analysis basis task description hci 
suppose task analysis carried controlling nuclear power plant piloting aircraft 
analysis thousands instances task analysis primitives 
similarities differences tasks determined 
pg 
regardless exact reasons domain task models hard generalize difficult systematically refining costh 
despite brooks pessimism hope useful domain independent taxonomies developed 
instance possible point 
distribution chandrasekaran development taxonomy generic tasks classification data retrieval state abstraction domain ai knowledge engineering body taxonomic domain psychology 
hope generalizing relatively standard task analyses 
example generalized task models gtm tks task modeling method 
task models primarily competence models performance models 
despite bright spots current state affairs task analyses difficult refining costh 
similar sort task analysis featured prominently chapter 
problem solving methods 
brooks suggested hci follow lead ai knowledge engineering ke pursuing descriptions methods problem solving ps 
called problem solving methods psms ke similar concepts known variously tactics heuristic strategies task strategies 
areas computing similar concepts known algorithmic skeletons 
psm descendant generic psms called weak methods means ends analysis 
weak methods entirely problem independent principle take advantage particular details task environment order efficient 
generally speaking knowledge task task environment better tailor solution strategy take advantage available invariants constraints resources 
psms expand weak methods introducing abstraction mechanisms allow add details problems generic way 
capture strategic knowledge solve particular problem types efficiently ps environment 
fensel succinctly sum significant potential advantages psms ke apply just hci 
psms describe domain independent reasoning components specify patterns behavior reused applications 
instance propose revise provides generic reasoning pattern characterized iterative sequences model extension revision study psms seen way move notion knowledge engineering art formulate task oriented field possible produce rigorous handbooks similar available engineering fields 
push identify catalogue name psms certain ways resembles design patterns codifying successful recurring patterns software solutions aim codify successful recurring patterns reasoning ps 
psm approach promising sort approach developing taxonomies processes basis reasoning distributing 
goals psm research match needs tool analysis psm research tries build taxonomies psms matched task type independent domain 
know explicitly applies ai research psms hci basic utility concept caught places various 
realm hci instance psm descriptions problem solving strategies green analysis cognitive 
distribution dimensions 
cognitive dimensions framework started description task type basically design task description psm matched task basically incremental generate modify 
elaborated proto theory taxonomy different generic activities :10.1.1.22.1477
described incrementation transcription modification exploratory design searching exploratory understanding 
related high level psms classify generalized task related strategies employing artifacts solution problems 
currently problem describing classifying activities hot topic research cognitive dimensions :10.1.1.134.5007
excellent example application psm models resources model wright 
part modeling framework consists short list termed interaction strategies 
interaction strategies play role similar psms 
interaction strategies resources reasoning redistribute different types data resources terminology 
unfortunately wright consider interaction strategies categorize types process distribution 
instance calls generalizable efficient strategies 
lists strategies grouped clusters iteration propagation organization visualization 
strategies relatively low level share key idea capturing strategic knowledge solve problems efficiently structure task environment 
similar types taxonomies ps strategies appear places usually find description ps strategies desired hypertext writing 
concept psms commonly applied software engineering program comprehension research 
sizable fraction program comprehension attempts categorize program comprehension behaviours terms psms 
example common categorization tripartite split comprehension strategies called top bottom opportunistic strategies see robson von mayrhauser 
old categorization generic psms adopted prior ai research 
top ps knowledge theory goal driven ps bottom ps data driven opportunistic ps interleaving take advantage opportunities arise see carver 
psm descriptions behaviours 
instance myers defined various debugging strategies inductive deductive backtracking 
psm line promising 
unfortunately time appear mature systematically chapter 

cognitive function taxonomy 
intelligent agents form perform basic cognitive functions regardless tasks need performed 
closed agreed enumeration functions include planning learning perceiving communicating 
newell pg 
provided tentative list functions distinctions systematic versus needed distinctions yield different problem solving strategies possible systematic needed top bottom comprehension 

distribution numerous similar lists easily constructed just browsing tables contents textbooks encyclopedias cognitive science hci example see human factors handbook 
different sort list cognitive functions put forth 
see 
propose divide cognition stages information processing acquisition analysis decision action selection action implementation 
sort decomposition activity popular similar decompositions different places mayhew book multi stage models rasmussen norman 
decomposition cognitive function chosen basic idea distribution applicable individual intelligent agent apply equally extended joint cognitive systems 
consequently may talk cognitive functions may distributed dc system 
may think redistribute planning perceiving learning 
case taxonomy discuss different levels automation types cognitive function 
list cognitive functions possible way decomposing different types cognitive processing distribution 
definitely promise sort decomposition 
course small matter knows list cognitive functions include initial list drawn ways distributing functions considered 
promising approach point basics covered 
hasti explicitly incorporate cognitive function taxonomy 
sense limited implicit agent model panel types naturally associated certain cognitive functions recall panels group function related types data 
distribution panel data types implies distribution associated cognitive function 
plan distribution implies planning distribution constraint distribution implies distributed constraint proposal evaluation 

virtual architecture 
mentioned virtual architectures include generalizations tasks pertaining interaction external devices 
operations models candidates distribution 
instance virtual shared memory architecture define operations searching memory matching item 
clearly task processing distributed tool 
taxonomy operations virtual architectures device tasks 
clear determining decomposition method describing process distribution types unfinished fundamental challenge 
possible time completely systematic generating generic process distribution theories rods 
result may possible go far say certain instances support type processing distribution able classify 
newell pg 
facing human cognition took saying best enemy 
likewise perfect decomposition processing unattainable time 
possible decomposition methods listed 
distribution merit 
consequently adopts attitude pragmatic theoretical prudent examples picked decomposition methods listed 
follows 
generic domains 
examples chosen mathematical statistical operations searching pattern matching abstraction 
obvious choice particularly relevant software reverse engineering 

domain task process models 
saved chapter 
psms 
generic psm iteration simplest chosen 

cognitive functions 
cognitive functions chosen agent model data types resource type agenda control problem progress associated cognitive functions attention management goal selection planning constraint observation progress evaluation learning means learning apply type knowledge 
cognitive functions easily added start 

virtual hardware 
virtual memory architecture example examined 
focus memory management operations describes 
broken back services layout page management types 
page management turn decomposed window management page replacement view management working set management localization 
described detail 
note basic types process decompositions shown diagram costh 
decompositions thought potential tentative extensions types 
extension leaves look 
space saving reasons obvious abbreviations 
indicated acronyms nodes listed 
generic domains statistical numerical methods recap intro automating mathematical statistical processing archetypical computation 
mundane include example 
interpretation guidelines basically computation specified mathematical language 

distribution generic domains problem solving methods cognitive functions virtual hardware math stat search patterns abstraction iteration attn goal selection planning constr obs learning back layout page pm ms sp ab am gs pl win page view localization tentative leaves processing distribution sample implementations notable examples domain independent environments include mathematica spss visi calc 
generic domains pattern matching search recap intro pattern matching search common functions models long term memory 
interpretation guidelines commonly understood 
sample implementations grep instance 
involved examples include involved pattern matchers ple 
generic domains abstraction recap intro performing bottom analysis data involves aggregating patterns classifying abstractions 
abstraction process hierarchical nature 
type task common reverse engineering ller domains synthesis tasks writing 

distribution interpretation guidelines typically involves reinterpreting data higher semantic level looking commonalities structural modularity 
sample implementations statistical semantics 
algorithms statistical occurrence association measures indicators latent meaning object verb associations 
technique called statistical semantics 
clustering algorithms 
clustering usually means collecting items similarity connectivity measures imply construction new abstractions concepts associate clusters 
concept analysis 
concept analysis way generating categories simultaneously classifying items common features snelting 
graph layout algorithms 
layout algorithms spring layouts compute closeness metrics order lay nodes connectivity ller 
appropriate manner help reverse engineering perceive clusters perceive initial candidate clusters 
virtual architecture virtual memory management recap intro certain overheads associated external memory save implant ram chips memory controllers directly brain 
overheads include carrying interface tasks simulate memory access management 
virtual memory architecture trick raise abstraction level interaction model order encapsulate complexity memory management 
architecture hasti models single virtual memory fact implemented combined user external memories managed part user 
task analysis external memory management reveal classes operations 
important subset operations concerned management memory resources 
includes creation management search indexes managing caches managing memory windows paging 
interpretation guidelines remember user view external memory referenced application programmers 
critical confuse 
instance users phone book application external memory application programmer term may additionally refer database stored disk 
user point view memory management access operations restricted mean methods provided application store search access organize memory 

distribution sample implementations back services 
modern computing platforms remarkable number sophisticated memory systems built structured documents hierarchical file systems relational databases example see jones 
database filing services hidden back program sorts systems perform wide array processing accessing indexing 
instance modern relational database provide index processing case database provide advanced index processing 
frequently greatly reduce accessing indexing costs associated external memories filing cabinets file folders card indexes printed subject indexes 
layout sorting 
main criterion layout algorithms indexing efficient 
instance array layout spreadsheet address calculation simple see larkin 
done layout algorithm rearrange data efficiently accessed display form external memory management processing 
reason sorting frequently counted layout processing 
example sorting file names directory listing layout processing purpose improving access efficiency list items 
page management 
vm architecture hasti computer screen treated memory window larger external memory small directly accessible fragment larger indirectly accessible memory 
managing memory window function partially performed computer 
examples literature may point window placement management 
windowing systems perform automatically place new windows need managed directly 
may include creating new windows effectively subdivide display local page replacement schemes window 
page replacement 
wiecha propose visual cache page replacement strategy tries automatically manage small number fixed position windows 
card related page replacement idea window management 
view management 
multi view systems single memory system accessed different views 
automatically maintaining consistent logical location views example distributing view management 
prime example called synchronized scrolling mechanisms updates portion window corresponding updates related views 
working set management 
set memory locations accessed segment time process working set 
management processing redistributed 
involve loading parts memory accessed done layout different sort described concerning structural abstraction 
issue layout purpose efficient access issue layout purpose structure perception 

distribution involve scaling display automatically entire working set seen 
localization 
accessing slower memory faster memory window memory access locality enormously important performance 
reason accesses areas outside current window require paging operations scrolling loading files 
way helping ensure access locality widely scattered working set providing virtual temporary view presents scattered locations close proximity 
words localize non local working set 
methods doing include various ways performing elision filtering querying 
processing redistributes localization processing 
psm iteration recap intro iteration really psm vein psms ke 
fulfills main qualifications represents generalizable computing pattern structure specialized take advantage specifics task environment order efficient 
iteration applies operations elements structure way traversing 
distribution mean getting agent iteration 
interpretation guidelines usually method specifying structure traversal necessary 
sample implementations wildcards tag drag 
command line systems wildcards specify structure iterate command 
instance unix command line bin rm applies remove command iteratively group files 
visual shells iterated commands invoked performing aggregation operation tagging followed gesture command dragging indicate operation perform item aggregation 
similar distribution methods interfaces computer aided design cad drawing packages 
program driven interaction 
iteration follows control loop 
control loop delegated computer agent exercises control user action 
simple example wizard guides user sequence steps 
familiar example search replace agent asks user sequence responses 
cognitive function attention management goal selection recap intro agenda maintained order enable focused goal directed behaviour chosen imperative form description declarative form mapcar higher order functions primarily state prominent discussing hci 

distribution purely data percept driven especially presence multiple tasks subtasks 
agenda serves key role managing attention selecting action active goals 
priority urgency goals change moment moment new opportunities recognized pending subgoals 
goal selection affected agent perceptions cost versus benefit possible action 
attention management goal selection may partially redistributed 
cases external agents take load recognizing opportunities prioritizing subgoals commanding attention 
interpretation guidelines attention management goal selection usually associated shared agenda 
sample implementations alerts 
systems interrupt user manage distributed agenda 
obvious example operating system presents called moded dialogs displaying urgent alerts dialogues responded done 
critiquing 
intelligent critiquing agents manage distributed agenda interrupting believe alternate goals selected 
example critiquing agent argo looks potentially problematic design decisions interrupts user appropriate times 
cognitive function planning recap intro planning means establishing intentions actions establishing course action creating plans 
interpretation guidelines processing done generate structures followed user considered planning 
sample implementations error list generation 
compilers generate error list generating partial repair plan program 
list ordering frequently acts step ordering programmers perform repair activities sequentially scanning list repairs 
query result ranking 
ranking query result sets common technique information retrieval 
result ranking external planning ranking indicates exploration order 
cognitive function constraint observation recap intro problem constraints obeyed vigilance user enforced environment 

distribution interpretation guidelines generally type processing checks enforces constraints reports constraint violation form constraint enforcing 
sample implementations externalized constraints potential candidates checked automatically 
instance type checking compilers instance 
cognitive function learning recap intro learning thought process organizing knowledge process improving ability knowledge available 
dc system embodies knowledge internal external forms 
knowledge encompasses declarative facts concepts maps procedural knowledge rules scripts strategies programs 
dc learning means augmenting refining internal external knowledge adding new capabilities recalling knowledge 
distributing learning processes means moving processing required agents 
interpretation guidelines distributing learning involve instances done synthesize new knowledge structures construct new rules programs 
involve cases knowledge ready hand indexing adding search construction programs 
type learning distribution considered chapter designers embody knowledge tools environments 
instance populating plan matching program database knowledge engineering wills chin certainly redistributes learning cases tool developer special relationship user 
relationship awkward say view developer user activity collaborative learning effort see section discussion topic 
contrast frequently case groups peer software developers cooperatively collect code repository add scripts macros shared development environment 
easily considered learning distribution 
sample implementations programming example demonstration 
possible computer agent procedural knowledge examples demonstrations perform tasks 
instance system procedures program transformations examples 
example heuristic rules knowledge base tweaked automatically response sequences decisions reverse engineering understanding legacy system 

specialization script macro library construction 
people frequently share customizations programmable environments rigi 
extensions sort frequently form plugins macros scripts 
specialization presentation interesting efficient perceptual procedures users perform presentation quickly arrive desired result 
stephen casner task analytic approach automated design graphic presentations pg 

hierarchy provides categories cognitive functioning ordered terms preference ease 
category substitute 
instance learning new skill performance frequently knowledge activity repetition practice increasingly dominated perceptual skill rule behaviour 
practiced activities easy relatively effortless frequently described qualitative terms natural fluid 
cognitive support context means provision artifacts allow perceptual skilled rule behaviour place cognitively demanding cognition 
frequently means modes interaction changed means way data encoded altered 
worth costh enumerates advantageous changes cognitive systems ways achieving 
chapter enumerate possible ways making specializations happen organizes cognitive effects terms specializations enabled 
part subsection adaptation srk rasmussen 
differences worth making note 
main difference decreased emphasis monitor respond type tasks srk taxonomy originally derived increased emphasis highly goal directed knowledge behaviour 
monitor respond paradigm tendency focus tight causal loops catching ball steering bicycle 
sbb skill behaviour rbb rule behaviour particular focused closely coupled perceptual action loops cue response mechanisms 
effort separate perception action components loops 
clear substitution occur complicated goal directed behaviour 
close coupling action perception loops dispute intention try distinguish specializations occurring primarily perception action 
result closely coupled loops highlighted sbb rbb somewhat muted presentation 
addition difference emphasis srk model interpretation recast specifically terms hasti rasmussen framework relating different classes processing 
recasting light hasti possible refine costh types specialization kenny wong personal communication november 

specialization hasti describes 
recasting srk effect changing language specialization rasmussen specializing substitutions terms behaviour substitution substitution behaviour phenomena substitution terms computing mechanisms 
basic idea specialization substitution conceptually simple understanding specialization realistic situations fraught complications 
vicente careful note realworld cognition normally rich mixture activity srk levels 
apparent distinctness srk levels simplicity srk framework mask difficulty converting idea specialization credible explanations support 
complicated nature interactions srk levels focusing examples simple specializations 
purposes simple specialization shall consist single wholesale replacement computational method 
brief summary table specializations table 
table arrows indicate action perception differences perception action 
complicated rearrangements discussed section 
type description substitutes examples skill low level hardware vigilance sound significant events replaces recognition logical operation visual search graphs generalized constraint observation animation visualizations cognitive machinery computer animation envisionment imagery skilled action mental rotation tetris piece rotation rule rapid recognition structure extraction clich plan recognition recall information situation assessment display recognition stored precomputed interface metaphors reuse skill solutions reused perception assessment action table summary specialization substitution types skill level perceptual substitution recap intro perceptual processes rapid automatic effortless occur parallel processes 
hasti describe perceptual processes involve possible enlist worth commenting briefly point rasmussen contended sufficient consider categories phenomena memory issues cognitive processing types models mechanisms underlying phenomena 
practical different describing specializing substitutions terms phenomenon mechanism mechanism phenomenon supposed correspond 
furthermore phenomena need described formalized models parsimonious ways known 
hasti compatible rasmussen explanation behaviour shifting language direction mechanism orientation means model oriented presentation mapped back rasmussen behaviour vocabulary 
see section information mapping 

specialization help resources order fill details 
casner instance lists catalogue perceptual operators potentially substituted inferences 
certainly ample opportunity expand list little guidance 
example kosslyn lists abilities imagery 
related casner list perceptual operators 
resolving level modeling scope shall just listing representative instances specializations 
regardless models perceptual capabilities number logical operations substituted perceptual operators limited ability encode problems representation enables specialization 
interpretation guidelines perceptual processing generally difficult casually observe usually rapid un 
clearly clues specialization possible form artifact differences visual form presentation changes impact perceptual processing 
sample implementations observational vigilance 
perceptual cues replace need maintain observational vigilance essentially situation condition polling 
obvious example probably sound signal occurrence significant event completion lengthy operation 
simple search 
classic example perceptual operator replacement substitution tabular data presentations graphical ones 
instance consider task searching minimum maximum value list values 
tabular form straightforward involves number interpretation memory 
change presentation line graph search simple visual search highest point line graph 
constraint violation detection 
kraemer stasko give example violation program constraint detected perceptual judgment watching animation execution 
imagery proxy physical manipulation 
mental visualization skills operate rapidly mental models way exactly perception physical manipulation 
evidence accumulating suggests mental imagery perception activate common low level brain functions 
provides partial explanation efficiency mental imagery terms specialization imagery skills substitute knowledge cognition 
sense title perceptual substitution head section misnomer actual perception need involved activate imagery processing capabilities 
certainly ample evidence suggest mental imagery important part software developer mental life 
question training artifacts said support cognition imagery 
directly imagery seen internally generated form 
specialization perception action imagery may substitute cognitive actions visualization visual view 
instance consider immediately prior example visual constraint violation detection program animation 
detecting constraint violation imagery may come play 
developer able visualize imagery visualization program animation play certain changes program 
skill action substitution recap intro skilled manipulation external artifacts similar perceptual processing certain operations easy rapid largely automatic parallelizable 
interpretation guidelines external artifacts obviously need manipulable order action substitution occur 
manipulation needs perform reasoning mental action 
sample implementations tetris moves 
studied example action substitution instances epistemic action noted kirsh see section 
instance kirsh maglio observations tetris game playing showed players rapidly rotate pieces move pieces closer final orientation things effectively structure problem eliminating orientation variation input 
media manipulation 
problem solvers skilled manipulation external media substitute problem solving require mental 
writers manipulate notes diagrams designers manipulate models materials 
rule recognition substitution recap intro purposefully simplistic hasti model recognition function active memory system constantly searches long term memory relevant chunks facts contents working memory perceptual buffers 
retrieval cues generated perception higher level cognitive processes 
retrieval automatic fast effortless note skilled action frequently exhibited combination perceptive reactive capabilities rasmussen terms skill behaviour 
instance tracing drawing involves close coordination hand movement perceptual feedback 
spite fact reasonable differentiate perceptual substitution action substitution perceptual substitution stand 
example simple visual graph search physical skills may needed ability move eyes 
distinction blurred active vision see ware franck perception action tightly linked blurring negate utility making distinction 
video game players maneuver moving game pieces winning positions time constraints 

specialization dependent having right cues available cues required nearly exactly cues encode index memories 
fact means recall expert performance situation specific 
types memories recalled including past episodes facts images 
memory basic function obviates need reconstruct recalled information 
clearly useful needed information transient information scrolled screen 
useful recognizing information latent implicit display 
instance usually far better rapidly recognize threat falling boulder deduce calculating probability landing force 
display problem solving see section particular relies rapid perception problem solving state 
interpretation guidelines recognition action identified fluid expert responses leave traces 
subjects automatically rapidly perceive recognize familiar patterns cues 
generally speaking recognition replacement requires expertise recognizing patterns cues environment problem situation 
sample implementations clich recognition 
experienced programmers rapidly recognize clich patterns see 
research relation ability concerned recognition called programming plans programming idioms 
findings probably generalize relevant recurrent structures text structures control flow structures design patterns architectural patterns 
expect structures need relevant programming language programmer require training experience able recognize 
ways enabling recognition include methods presenting patterns way easily recognized names cue appropriate clich situation recognition 
mentioned section data distribution expert display users rely externally represented action cues order determine 
example coffee making coffee maker able quickly perceive state coffee making 
recognition cue response 
perceive respond action coffee maker consciously reason state coffee making 
presentation external state situation way enables recognition way enabling situation recognition substitution 
rule stored rule substitution recap intro knowing act situation difficult involve lot reasoning 
experts exposed different situations learned rules apply similar situations recognized 
rules essentially precomputed solutions experts 
algorithmic optimization vast memory quick cue access means strategy storing precomputed compiled results faster recomputing 
recalling past solutions problems method substituting memory computing effortful reasoning 
expert programmers instance vast stored collection rules write small snippets code 
situation need produce similar snippet perform laborious reasoning promptly produce variation canned result 
said know program generate familiar fragment synthesize understanding 
know answer 
recognize problem key directly knowledge pull working procedure pg 
emphasis original 
interpretation guidelines rule action generally recognizable rapid nature 
instance experienced designer may adopt certain problem constraints comment seemingly thought eastman 
sample implementations interface metaphors 
experts develop skill performing routine low level tasks interface interaction 
part smooth skilled performance rules saying achieve task goals interface correspond methods selection rules goms 
suggested metaphors interaction desktop interface taps knowledge base 
user may relative expert metaphorical world novice particular task domain hand 
metaphor effectively opt rule problem solving knowledge user solve problems analogous world ones novices 
algorithmic optimization term algorithmic optimization intended refer cases computations restructured substituting algorithms adts encodings 
simple demonstration cognitive restructuring norman example changing number systems roman arabic 
multiplying numbers roman format harder humans arabic 
change best categorized change number encoding formats corresponding changes algorithm 
noteworthy improvement performance little principles cognitive support involves reduction task distribution data process new specializations cognitive machinery essentially rule problem skilled art 
restructuring computations supportive effect 
best knowledge principled ways categorizing cognitive 
means impossible systematically refine costh 
main reasons admittedly simplistic account suggests learning rules requires high level understanding solution order precomputation 
case see vicente ch distinction important purposes 

composite rearrangement impasse 
rods stands contain taxonomy optimization types 
ideally taxonomy generic principled way enumerates types computational rearrangements performance advantages 
taxonomy decent initial candidates problem classifying representation shifts roman arabic 
existing knowledge norman principles representation fails provide taxonomy ways changing representations statements cognitive support types especially perceptual substitution 
know principled taxonomies representation shifts potential resources consider see review blackwell 
second cause impasse hasti propose features say sorts optimizations possible 
humans reprogrammable computers human psychology say optimizations reasonable impossible 
problems resources refining theories cognitive 
consequently costh limited merely noting example encoding shifts 
encoding shift recap intro making changes data encodings adt usually alter way adt operations algorithms procedures performed 
relevant application cognitive support number difficult mental operations reduced strain cognitive resources lessened 
interpretation guidelines hci main application shift encoding encoding externally manifested data changes respect user perception interpretation 
type encoding change typically involve referred shift symbol systems see rasmussen 
note type change encoding referred merely cosmetic change presentation 
instance changing colours new set letters considered instance encoding shift roman numerals 
sample implementations canonical example encoding shift change roman arabic numerals arithmetic operations easier perform 
instance piece doing long division far easier arabic numerals 
composite rearrangement types cognitive support distribution substitution cognitive restructuring examined far 
category support divided small number important variations 
variations derived principled consideration ways applying support opposed say changing computer internal encoding pictures tiff jpeg 

composite rearrangement principles dc models 
result collection dozen distinct support theories arranged families 
fruitful view support principles orthogonal bases decomposing complex forms support independent principles 
capability decompose support basic components enormously useful 
chapter showed bewildering number different forms variations cognitive support 
decomposition framework bring degree order wild 
show variations support different manifestations combinations just primary support types 
analogy utilized earlier support principles decomposition plays role similar played periodic table elements chemistry periodic table brought order endless variety chemical compounds incidentally organized families 
support principles decomposition framework chapter may fully developed completely satisfactory clear sort decomposition framework necessary possible 
point quite reasonable restrict focus distinct types cognitive support 
able pick apart distinct types support simplify explanations 
reality categories cognitive support easily 
attentive reader may noticed fact examining examples cognitive support far hint appear depend support principles addition highlighted particular example 
illustrate interdependencies support types number additional examples brought forth 
consider example described support provided writing environments way overcome difficulties performing complex knowledge manipulation head capture ideas external medium computer screen form external representations stand mental structures 
long ideas plans drafts locked inside writer head modifying developing overload writer short term memory 
putting suitable medium writer able explore different ways structuring content apply systematic transformations prioritizing items reversing order clustering related items 
writing creates external representations external representations condition writing process 
clearly account simple pen need multifaceted 
brief synopsis oblique forms support 
referred ideas plans drafts perceptual action 
example demonstrates simple collection artifacts different types cognitive support may potentially involved 
consequently sense realistic instances cognitive support way needed understanding support principles compose 
continue analogy chemistry akin theory chemical composition required 
atoms compose 
families compounds possible 
questions answered composition theory 
similar sort theory needed costh 

composite rearrangement encompassing theory support composition scope 
possible gain sense may involved give representative examples cases support principles composition 
section examples preceding sections 
previously held exemplars various types support 
examples show support types usually conjunction 
aim exhaustive illustrative 
section considers commonly cited examples complicated cognition 
decomposing high profile compositions support types costh hints breadth costh 
may help develop intuition support principles compose 
revisiting previous examples subsection revisits previously described examples give different support principles combine 
selection examples summarized table 
multiple support types mentioned listed table 
entries italics subsection ignored time 
table meant searched patterns intended summarize selected combinations analyzed 
table help clear costh conceivable rationally compare vastly different tools environments serve improve cognition 
requirements docs writing media skeletal declarations wizards emacs compile emacs search replace context sens menu type checker browser links reminder agent precomputation data distribution processing distribution specialization pb pg gd vh ps cf skill rule ms ps ab pm am pl sp sa sr su en abbreviations figures display problem solving table examples compositions multiple support factors 
composite rearrangement goals skeletal declarations 
programming skeletal declarations externalize pending subgoals 
trick seen respect ensure skeleton generates compile time run time exceptions 
trapping skeletons manner ensures pending goals attended point case forgotten 
way externalizing constraints pb constraints externalizing constraint checking cf constr obs compiler runtime system performs checks 
shared goals 
agent environment seen collaborative agent involved plan setting cf planning attention management cf attn mgmt 
example task list serves external plan plan 
plan scheduler 
schedulers frequently reminder functions cf attn mgmt 
scripts macros wizards 
external plans normally executed partially computer 
stepping wizard requires progress information kept computer pg curr 
wizards normally display choice point number options available user pb operations 
may display name task performed keep user reminded goals 
error lists generating error list form external processing specifically planning cf planning 
presentation error list may user apply visual operators determine order errors attended perceptual 
compilation environments functions specifically designed allow programmer step plan 
requires functionality common wizards presentation stepping options pb operations tracking progress pg curr 
example popular editor emacs 
emacs compile mode allows user step error list compiler hitting key sequence move list item 
compilation invoked emacs automatically partitions screen error list editor page shown vh pm win mgmt pages files scrolls error location needed key pressed vh pm page 
note functionality available users frequently simulate multiple windows strategically places compilation results separate window uses cursor position finger trace progress 
query results 
query results frequently error lists traverse sequence related locations 
emacs mode called works analogously compile mode see instance wiki web entry com cgi wiki 
composite rearrangement stepping error resolution plan allows step list search results created tool grep program creates suitable list matter 
similar types stepping tools environments 
variation stepping mechanism called search replace mechanisms emacs query replace function 
wizards search replace mechanisms step update plan calling user decision making concerning replacement normally replace skip 
interfaces display choice options pb operations 
search replace involves having user give main loop control computer performs simple iteration linear structure defined query results ps iteration 
problem menus buttons options 
context sensitive menus implement moded dialogues need shared problem state pg state 
process shared state order determine possible options context cf planning 
language constraints 
external constraints frequently created order mechanically checked cf constr obs 
progress visitation history 
browsers frequently indicate link visitation state colour 
users apply visual search routines perceptual locate unvisited nodes 
change history 
visitation history mechanisms browsers seesoft colour codes program fragments 
uses colours show number change episodes recorded program fragment 
users apply visual routines substitute high level search operations perceptual colouring may serve draw attention high priority items cf attn mgmt 
gd graph layout algorithms 
humans perceptual capabilities determine clustering graph layouts perceptual 
reconstructing naming happy composites section analysis values writing pen hand 
example cognitive support principles fall place simple combination parts 
externalizing mental structures memory 
externalized manipulated processed externally searched visually pattern constraint violations 
able manipulate perceive externalization reason externalize place 
fact clearer computer help process 
analyzes benefits pieces 
composite rearrangement fit lean mutually reinforcing way mutually reinforcing structure stone arch 
support principles appear combine gracefully 
design patterns community say artifact resolves multiple forces 
necessarily wish discourage possibly comparison design patterns 
sake differentiation call patterns just 
agree call happy composites 
theory cognitive support composition say happy composites arise 

bottom approach analyzing compositions may yield fruitful intuitions 
costh toolbelt position pick happy composites decompose see tick 
section happy composites selected literature examined determine cognitive support principles combined 
approach yield theory may deliver insight 
bottom approach important simultaneous benefits 
reinforcing costh 
happy composites chosen wisely may possible lend credence de compositional account cognitive support offered costh 
specifically shown existing published accounts happy composites reconstructed costh argues usefulness applicability costh 

pattern catalog 
happy composites describe pattern fruitful solution problem 
particular describe solutions appear resolve multiple forces 
generative theory building happy composites name construct catalogue 
catalogue certainly useful designers see theory design scenario section 
composites described terms component support principles may prove useful indexing design knowledge 
topic revisited chapter 
ends happy composites selected literature order consider composition 
called display problem solving precomputation 
reasonably widely known firmly established terminology 
happy composites listed entries table easily compared composites mentioned 
probably unwise push analogy chemical composition far interesting similarity 
chemical compounds somewhat uniquely named listing molecular contents 
instance water avoid repetition table salt named 
leaves costh distinct abbreviations similar naming scheme cognitive support compositions entertained 
lower case letters support types need separated choose comma 
naming scheme chemical name equivalent common name sp sr su order reading table left right 

composite rearrangement display problem solving larkin invented term display problem solving describe form problem solving extensive external displays 
clear larkin essential qualities display problem solving relevant problem solving state read display nature external displays perceptual inferences places logical inferences need little planning deliberation required steps solver employs local control 
requirements appear relaxed uses term display problem solving davies important decide considered solving 
larkin notion 
conception differs purely mental equivalent follows pg current state problem readily available 
perceptual 
solver able perceptual skills inferences concerning problem implications goal selection problem constraints 
recognition 
practice user able rapidly recognize salient aspects problem state 
rule action 
recognized states system cue recall rules saying current state 
seen list essentially skilled way solving problems requiring little need store state related planning backtracking 
light newer analyses larkin may prudent augment list cognitive support types 
specifically new analysis physical implementations towers hanoi problems example larkin produced zhang 
analysis physical implementation provides external constraints perceived determined internally pb constraint 
precomputation hutchins introduced notion precomputations refer artifacts constructed advance help structure ensuing activity 
computationally interesting aspects precomputations 
obvious precomputation redistributes processing time 
reduce computational load subsequent performance tasks 
interesting aspects precomputation captured fully costh 
number hutchins accounts pg 
support types may seen apply precomputations common type precomputation checklist 
note precomputations nouns 
involve performing precomputations transitive verb hutchins uses term precomputations predominantly noun 
terminology similar representation 

composite rearrangement pg 
precomputations maps charts frequently drawn 
record history location computations thereof 
precomputations allows agents perform part 
involve performing storing simple calculations example generating table precomputed numbers lookup gd ms pre sorting stack charts preparation ordered sequence actions gd ps 
examples suggest class precomputation involves making subsequent tasks cognitively demanding formatting laying artifact enable manipulation perceptual inferences 
perceptual 
certain precomputations rendered form perceptual inferences substitute complicated logical operations distance rate time calculations ship navigation 
en 
hutchins clear constructing precomputation frequently change takes place data encoding tables bar charts 
difference mental operations subsequently performed 
encoding change may allow substitutions perceptual operations 
gives clear example context airline cockpit 
cockpit studied digital representations desired aircraft speeds transformed analog speed bug representations small indicators circular dial 
allow quick perceptual judgments relative speed see vicente 
may overlap hutchins analysis precomputations costh 
surprising hutchins analysis precomputations really mixture analysis power artifacts beneficially alter cognition importance pre construction cognitive artifacts 
mixture somewhat challenging explicitly map account costh 
sch design thinking noted designers manipulate external materials order elicit termed 
part conversation materials sketches models simulations 
interpreted world software development conversation prototypes possibly various sketches diagrams 
sch analogy conversation apt real conversation smooth transmission ideas party 
active process involving breakdowns communications actions repair breakdowns 
breakdowns instances conversation sense parties feedback elicited 
ability parties provide feedback enormously important frees speakers making clear start extensively planning speech 
conversation materials means designers set forth experiment hutchins gives example encompassing cognitive restructuring differences western methods navigation 
relation restructuring precomputation complex having learning cultural level 

comparison related materials provide feedback help correct invalid reasoning provide pause reflect assumptions chosen course action 
rough account analyzed costh follows 
order place aspects solution externalized pg current 
happen ways 
particular way evolving external solution cues designer rapid recognitions unexpected problems opportunities constraint violations perceptual recognition pb constraint pb operations 
possible way designer play externalized solution consciously perform deductive reasoning 
play may involve skilled manipulations sa lower cost external manipulation 
comparison related main contents chapter enumeration family support theories analysis ways combine 
theories organized refinement hierarchy rods provides core set support explanation principles hasti supplies ways applying core principles elaboration hasti needed 
presentation drawn extensively different sources theories works hutchins larkin zhang 
chapter tries synthesize especially illuminating compare contrast integrative account sources draws 
interesting comparison integrative explanations cognitive support 
works reviewed various forms cognitive support 
cumbersome uninformative attempt exhaustively compare 
select propose comparable theoretically motivated explanations provide sort integration different cognitive support concepts 
focused subset exceptions listed briefly authors internal external representation dichotomy similar mine 
utilize domain task analysis hypertext environments 
touch explanations cognitive support common including perceptual substitution redistribution process agenda 
pursue different tactic enumerating advantages external representations 
cognitive model try determine external features affect model 
model tightly focused specific aspects cognition contains fundamental cognitive processes encoding match execution control cognition implicitly considers control data redistributed 
approach distinct explanations support compatible costh 
tweedie tweedie account role artifacts problem solving provides interesting contrast 
comparison related development 
certainly approach common consistent account support 
example account implies srk decomposition cognition types skill knowledge modes similarities decomposing types external representation inclusion pb operations 
interesting contrast concerns tweedie fold decomposition problem solving orthogonal dimensions situatedness planned vs opportunistic cognition driver conceptually motivated vs perceptually motivated action mechanism automatic vs intentional 
decomposition provides alternate way understanding context cognitive support supportive nature artifacts placed relation mode problem solving engaged 
decomposition conceivably provide sixth type processing redistribution decomposition section 
scaife rogers authors try provide integrated account external representations helpful 
utilize 
core part analysis decomposition cognitive benefits called computational offloading re representation graphical constraining 
close analogues form redistribution cognitive restructuring problem constraint redistribution respectively 
narayanan analyzes cognitive utility visual languages touch situated reasoning visual inferencing give brief account conditions required inferences representing words substitute reasoning represented world 
petre blackwell green contains eclectic lange questions regarding effectiveness visualization programming 
presentation support hardly integrated winding course briefly touches aspects cognitive support 
aspects addressed chapter 
touch external perceptual effects perceptual display planning plans re representation cr encoding 
discuss complicated concepts support hard categorize framework advantages providing secondary notation important relationships kept implicit 
papers easily added ware cheng perry robbins ones listed best qualify focused integrations 
certainly overlap accounts theories chapter 
works integrate number diverse forms support provide type theoretically inspired decomposition 
bodies bear special relationship support theories chapter 
resources model group wright fields harrison :10.1.1.26.7777
cognitive design rasmussen colleagues 
essentially merged rods hasti frameworks forms core part analysis 
bears 
comparison related complicated relationship 
support framework genesis aware resources model wright 
fact bears remarkable similarity developed quite independently important mention 
ways similarities surprising clearly number significant overlaps literature drawn 
result highly compatible observations wright analogues costh 
probably significant difference rods provides thorough computational account support hasti provides rationally motivated decomposition wright term resources 
main divergence clarifies theoretical foundations analyzing distributed resources cognition 
unique theoretical framework integrating cognitive support notable differences rasmussen wright way design treated 
support theories completely separated issues bad design 
support cast accounting computational benefits artifact features 
support involved system may may beneficial impact performance 
instance advantages offloading working memory may completely offset costs offloading 
comparable difference support design muted 
instance cognitive engineering rasmussen notion support clearly enunciated substitution modes behaviour various means substituting behaviour tied just design concepts called abstraction hierarchy 
potentially interesting comparison costh theory organized collections design ideas software development tools 
unfortunately compare 
part surveys organized tools features products see section 
main points comparison surveys storey von mayrhauser 
surveys motivated theory backed analyses cognitive issues software comprehension reverse engineering 
survey storey hierarchically clusters tools hierarchy cognitive issues relating design 
chapter survey employs exemplar tools illustrate leaves hierarchy 
hierarchy probably best described complementary costh 
main distinction type nodes hierarchies especially leaves 
storey essentially provides decomposition design goals see section 
design goal potentially satisfied variety different classes cognitive support 
leaves costh cluster examples similar cognitive principles hierarchy storey clusters examples tools satisfying broad design issues 
logically hierarchies belong different categories design goals relate provision cognitive support relationship complicated 
surveys von mayrhauser quite distinct costh 
started analysis tasks involved program comprehension gain high level view determine program segment examine 
generated starting model program comprehension reverse engineer set common tasks observations 
limitations activities actual maintainers 
tasks determined information needed solve 
needs suggestions sorts tools tool features provide information 
result reasonably fine grained analysis different uses tools total different classes tools total 
classes tools usually abstractly specify tool functionalities smart differencing system list specific tool features display formats interaction methods 
functionalities implemented variety cognitive supports 
survey different category costh 
interesting fact emerges interprets survey costh hand 
costh indicate von mayrhauser tacitly craft knowledge cognitive support order generate particular list tools 
fact mentioned briefly section 
way deduced tool categories task demands explicitly acknowledged 
fairly easy interpret examples history browsed locations function counts various virtual memory operations keyword search 
categorization identifying different examples cognitive support implementations associating certain tool types uses 
limitations costh limited theoretical framework sense preliminary approximated 
limited models cognition form hasti employed limited ways analyzing tasks 
offer basic explanations wide range cognitive support types explanations derived quantitative precise 
addition things successfully integrated goes phenomena described chapter find instances support spirit completely captured costh 
instance point hutchins idea precomputation note specifically mentioned regarding role preparation 
costh fine grained detailed comprehensive 
agree put aside questions sorts limitations time 
hardly fault theory failing simultaneously fine grained detailed comprehensive 
entire point broad brush applied theory approximate usefully provide coverage salient aspects fill fine details entirely comprehensive 
important step back bit try place costh greater context 
specifically costh address main problems wish address problems understanding tool usefulness building useful tools 
important criterion applied theory usefully applied limitations theory impact application need discussed 
issue phrased bottom line question need really regard important limitations affect bottom line negative consequences tools ignored full implications cognitive support traced support eventual performance human learning training ignored issue tool adoption little help available understanding partial coordinated human tool collaboration 

limitations negative consequences support theories full design rationales contain tradeoff information 
design involves tradeoffs 
instance aid offered automation may trouble worth external memory may costly worth storing knowledge 
costh employed arguing bad design saying supported grasp whatsoever tradeoffs 
hand able separate mechanisms support issue negative consequences 
affords insulation complications associated implementing useful tools 
pointed chapter separation critical evaluate test design ideas may may implemented polished tool 
hand bad news designers 
linking tools negative positive consequences important 
need tradeoff analysis 
attempted add tradeoff information costh augmented provide tradeoff information certainly possible direction 
full implications traced difference plan offloaded 
possibilities vast 
memory freed offloading better planning resulting fewer cases backtracking required 
turn reduce need easily undo operations 
user mental workload simply reduced affecting user productivity 
bigger problems tackled 
implications spiral unbounded cutting psychological technological organizational aspects 
holds nodes costh 
tracing implications require rods hasti costh frameworks 
daunting task appear need cognitive models detail 
hint requirements detected examining freed 
details papers concern authors needed derive design implications supportive technologies 
needed analysis ways cognitive biases limitations showed task performances 
identified problem product designers target user population usually bias habitual paths learned past experiences 
bias leads solutions appropriate 
variation old saw baby hammer looks nail 
understand counteract undesirable biases list need generated effects various forms support need established 
unfortunately biases personal motivation training organizational setting 
difficult model 
model biases software development difficult trace reengineering provided cognitive support impact 
fortunately may promise simply building list cognitive biases software development see start 
building list able employ empirical determine cognitive support affects 
costh empirical endeavor possible providing list experimental 
limitations variables support types consider 
freed suggested performance problems need understood context coping strategies people dealing cognitive limitations see sections 
freed say human resource limits easier identify represent model subtle varied strategies people cope limits 
people cope memory limitations maintenance rehearsal writing notes setting alarms methods 
cognitive support counteracts cognitive limitations 
result implications cognitive support understood ways coping strategies relieved appreciated 
unfortunately knowledge coping strategies software development 
bright spots davies coders strategic external memory coding developers bookkeeping strategies coping high demands working memory maintenance 
learning training adoption learning training play significant role determining strategies people employ skills develop 
costh specify 
presumes learning training produced appropriate capability support effective 
appropriate anyway definition support probably independent training designers want know artifact supportive particular class users able effectively 
important design analysis understand importance learning 
example consider exploratory learning known learning doing 
known facet exploratory learning users asymptote competent interface need learn better methods proportion maximally skilled 
words learning tools instance classic negative feedback learning competence 
means provides supportive mechanisms users may learn effectively 
tool designers want know support 
upshot cognitive support tells part story tool designer wishes hear 
costh limited explaining support specify conditions support rendered 
related note issue tool uptake adoption 
cost learning new tool 
potential eventual improvement performance developers adopt 
apparent developers favorite editors near religious 
implication knowledge cognitive support effective design may need account learning costs tool adoption 
understanding collaborative human tool interaction core part costh distribution framework dc system distribution key element 
useless consider support principles 
review conscious decision 
summary commentary implications try provide examples highlight individual form cognitive support 
emphasis resulted review highlight possibilities partial distribution data processing 
costh describes different types data process distribution elaborate develop partially redistributed data processing 
example reverse engineering part acknowledged fully automated clustering real legacy software produce satisfactory results immediate 
certainly appropriate simply wait perfect automated clustering mechanisms appear 
necessarily left consider partially automate clustering ways humans tools 
currently ideas pursued simplistic need 
typical suggestions involve simple human tool coordination schemes propose validate style dialog humans pick choose automatically generated candidates 
method places human judgment periphery clustering process 
words processing currently tight collaboration human software agents 
type cooperative processing shared partially distributed data core dc viewpoint 
sadly costh gives little insight developing 
main culprit weakness characterizing types processing distribution 
needed complex decomposition enumerates classes partial distributions 
consider analogue automatic parallelizing distributing compiler 
compiler takes description process serial program analyzes ways distribute processing different elements 
times compilers look clich patterns know distribute 
similar way generative cognitive support theory distribution able take description problem say split joint human computer processing 
issue revisited section 
summary commentary implications theories cumulate 
refined reformulated corrected expanded 
working theories shooting theories bang shot falsification bullet theory 
theories graduate students admitted try hard avoid better world long term contributors society 
theories things changed built 
happy change useful 
allen newell unified theories cognition pg 

chapter defined space generic cognitive support theories provided examples support inhabit space 
space generated part applying support principles rods model features hasti 
rods hasti matched partners producing support theories rods provided computational explanations different types cognitive advantage artifacts provide hasti provided breakdown cognitive features apply computational 
summary commentary implications explanations 
rods grounded theoretical computing science hasti prior cognitive science result principled integrative theoretically motivated decomposition support types 
details suppressed strategic abstractions resulting theories broadly applicable reusable 
theories quite lot backing basic sciences quite preliminary 
lack solid evidence knock framework maturity basic sciences draws full holes 
aim effort bring existing theory tacit folk knowledge replaced science knowledge currently available 
costh certainly broadly integrative regard 
chapter asked reader consider pen typechecking compiler search tool grep 
cognitive supports exemplified may quite distinct chapter demonstrated may rationally compared theoretical framework 
preliminary thing clear rods framework combination structuring mechanisms hasti convincing case starting theoretical framework cognitive support software development 
particular exposition cognitive support theories advantages relative completeness generality theoretical pedigree 
decomposition support types orthogonal groups appears immensely helpful 
considerable parsimony providing principled decomposition complicated combinations support 
decomposition simultaneously demonstrates principles common computing carry great extent explaining cognitive support 
applications computing concepts cognitive support attenuated issues human psychology course principles apply cognitive support computational advantage 
furthermore note utility gathering different support examples implementations coherent organizing context costh provides 
particular examples populate design space mapped costh 
suggests thorough survey costh types applied software development yield useful cookbook design ideas 
chapter presents rudimentary cookbook 
breadth variety cookbook early testament framework hints potentially broad applicability resulting support theories 
concluding chapter may appropriate comment implications costh regarding research questions covered chapter 
consider fact chapter close mixture theory examples applies 
examples portrayed expository devices see 
choosing examples attempt ones familiar se researchers scholarly purposes selections chosen citing example publications theories argument evidence 
certainly hope examples strike reader familiar little mundane known necessary knowledge skilled art creating se tools 
excellent news 
strongly indicate support theories capture important tacit tool building knowledge field 
able transform enormous quantity craft knowledge explicit knowledge singled critical long term goal evolution 
summary commentary implications field see 
synthesizing broad widely applicable theoretical framework cognitive support accomplishment building brings principled explanations heretofore tacit understanding excellent feather cap 
costh provides vigorous demonstration search theoretical foundations vacuous 
examples familiar reason appreciate exposition 
point brings final issue comment 
chapter argued forms empiricism engage limited lack theoretical basis 
particular tend engage called simplistic comparison experimentation 
pit tool tool little theoretical basis rational comparison 
sincere wish community put rest unreasonable hope continue pursue course 
abandon experiments extraordinarily useful hope clear chapter considerable theoretical apparatus brought bear problem understanding merits software development tools 
thing costh indicates principled tool analysis viable precursor experimentation principled basis comparing merits different types tools way categorizing features tools reasonably fine grained basis differentiating tool variants 
thing example chapter plausible theoretically motivated hypothesis supportive nature artifacts 
empiricist looking problem examine need scan tables find dozens support issues nearly completely unexplored realm se 
potential phd topics category 
costh door leading codified tacit knowledge window potentially central aspect se research 
chapter building theories fit design historically traditionally task science disciplines teach natural things 
task engineering schools teach artificial things artifacts desired properties design 
herbert simon sciences artificial pg 

constructing things properties designer desires 
level designers take input existing world decide dislike determine create artifacts fix 
design engineering constructive synthetic activities 
basic goals differ sharply goals sciences 
herbert simon seminal sciences artificial describes distinction speak engineering concerned synthesis science concerned analysis synthetic artificial objects specifically prospective artificial objects having desired properties central objective engineering activity skill 
engineer generally designer concerned things ought ought order attain goals function 
pg 
emphasis original analysis important part design activities probably better contrast synthesis explanation evaluation analysis see long similar dichotomy 
differences explanation synthesis activities revealed examining consider fixed versus dependent variables 
understood essential differences standard modeling approach cognitive psychology hold task environment relatively fixed create description cognitive activities underlying person behavior environment 
designer hand faced reverse challenge creating environment elicit desired behavior 
problem solving terms solution space scientist set plausible cognitive theories solution space designer set technologically feasible environments 
pg 
simple corollary argument designers explanation oriented theories design evaluations synthetic steps 
designers want artifacts explanations 
designers know design 
resources synthesis step 
simple answer designers utilize craft knowledge experience 
conceivable answer talk regarding development theories design 
interesting answer question synthesis designers able design theories theories provide theory description design solution explanation phenomenon 
note explanation synthesis distinction identified commonly cited basic applied dichotomy 
conceivable basic applied design theories 
difference product theories produces explanations produces suggestions artifacts 
chapter concerned applied design theories cognitive support 
topic design theories cognitive support particularly relevant se 
argued chapter field great keep knowledge cognitive support tacit 
means suffer discipline craft important dimensions 
mind status se theory certainly unique se hci design predominantly craft 
certainly exist theories hci particularly suited design 
oriented evaluation 
long invented terms fit design purpose indicate knowledge theories suited synthesis fit understanding purpose knowledge theories suitable primarily understanding explanation 
agree drop purpose just call categories fit design fit understanding 
fairly easy argue cognitive science hci primarily fit understanding fit design 
state affairs considered surprising 
hci heavily cognitive science psychology sociology theories vast majority theories fields distinctly explanation oriented design oriented 
chapter wish strong case theories models previous chapters little fit design 
chapter initial argument fit understanding chapters reinforce argument 
rods hasti costh developed needs design mind done especially fit design 
converting explanation theories theories fit design trivial automatic facts seriously appreciated 
design theories tools tools need carefully crafted characteristics needs users mind 
different design contexts inevitably need reshape basic theoretical resources different forms 
barnard terminology different design specific forms called application representations forms basic theory takes applied synthesis 
rods hasti costh starting points starting points 
chapter structured follows 
section describes reasons theories hci related disciplines notoriously unfit design 
argument put forward little attention paid type knowledge design oriented theories represent 

trouble theory taxonomy design knowledge proposed 
taxonomy organized type reasoning enables 
taxonomy argue current hci theorizing failed compile knowledge enables may termed forward reasoning positive consequences artifacts 
section considers different ways converting support theories previous chapters forms fit design 
chapter concludes brief summary 
trouble theory basic assumption researchers study programmers understanding programmers task better position prescriptions aid programmers tasks 
soloway iyengar preface proceedings empirical studies programmers 
belief quite widely held science invariably leads usable design knowledge 
argument commonly conviction knowing design context pick user user psychology domain practices naturally enable better design 
belief certainly held researchers se hci 
instance motivating development model software comprehension vans argued better grasp programmers understand code efficient effective lead variety improvements better tools better maintenance guidelines processes documentation supports cognitive process pg 

popular expectation theories inevitably find application 
really myth indistinguishable myth 
readily noticeable lack useful theory applicable real hci situations general fewer theories exist called fit design 
scarcity persists despite decades quality research working erase 
noticeable lack usable theory created running debate hci community 
house workshop called rally hci theoreticians reflect notorious shortcomings theory hci 
barnard summed problems nicely difficulties generating science base hci support effective design real 
strategic problems theoretical approaches overcome thoroughly 
life cycle theoretical enquiry synthesis typically life cycle products seeks deal theories low level restricted scope abstractions behavior fail deal real context fail accommodate fine details implementations interactions may crucially influence system 
similarly theory may predict significant effects receive empirical support effects may marginal practical consequence context broader interaction important effects specifically addressed 
pg 

trouble theory decade elapsed workshop little changed barnard remarks 
high level design oriented relevant applicable theory hci impossible 
landauer carroll argued application explicit theory design hci marginal limited indirect 
giving theory number authors concluded attention paid designers really need theories 
articulated stance field cognitive engineering may fashionable cognitive engineering community little guidance modern psychology provides designer psychological nature design product inescapable 
correct response current unfortunate lack applicable psychological research attempt psychology free design impossible design reflect designer folk psychological theory ask kinds psychological models needed support cognitive engineering long range empirical theoretical necessary realize 
pg 
number including green rasmussen members project barnard buckingham shum blandford reached similar 
concluded useful usable theory possible missing appropriate attention designer needs 
plus little attention takes transfer theory practice 
trouble computers landauer argued length book title adequately usable useful 
analogous way trouble theory authors produce usable theoretical products 
prescription better understand needs designers understand design context understand forms theory take readily taken designers 
theory fit design 
am highly sympathetic theory designed artifact point view 
wish add small important point articulated 
point takes design oriented theory useful 
obviously critical usability problems learnability addressed little written designers find useful theory 
contend designers serious need design theories allow forward reasoning positive consequences artifacts 
type reasoning abbreviated fp reasoning 
forward reasoning mean theory reason designer goal conceivable artifact existing envisioned artifact back explanations predictions 
positive consequences mean facets artifacts desirable opposed facets negatively impact usability 
distinguish design theory theories fit design requiring design theories enable fp reasoning fp theories 
argue fp theory type project large year european project investigate methods modeling designing hci see bellotti 

trouble theory knowledge useful direct attack researching designing tools 
important distinction forward reasoning backward reasoning reasoning positive negative consequences poorly understood 
theoreticians try design usable hci theory frequently unaware important distinction 
may reasons sorts theories poorly developed researchers appear aware possibility developing 
important describe needs designers explain possible roles theory design 
subsection consequently unfolds follows 
problems faced designers examined order understand requirements need met 
key needs identified analysis need survey knowledge design possibilities need resources allows fp reasoning 
argued section casting problem design terms evolutionary algorithms specifically search called fitness landscape 
posing design way casts currently hci light 
clear survey knowledge fitness landscape immediately needed designers 
introducing fitness landscape relatively simple properly highlight importance synthetic reasoning design 
particular difficulty synthesis portrayed gulf synthesis section 
analyzing designer cross gulf leads pressing needs knowledge enabling fp reasoning 
way shown common types theoretical hci simply address needs 
implications building theories fit design summarized section 
navigating fitness landscape followed long digression different races families existing machines 
writer attempted support theory pointing similarities existing machines widely different character served show descent common ancestor 
divided machines genera species varieties forth proved existence connecting links machines little common showed links existed 
pointed tendencies reversion presence rudimentary organs existed machines developed perfectly useless serving mark descent ancestor function useful 
samuel butler pg 

application sufficient persistence takes little intelligence knowledge successful building new useful tools 
fact tools constructed entirely accident explicit intent 
lesson taught century ago darwin context creating biological organisms 
lesson need apply biological entities apply artifacts mechanical computer tools 
quotation head section indicates 
trouble theory samuel butler contemporary critic darwin authors apply concepts darwinian evolution artifactual evolution 
certainly 
formula generating tools simple general 
things needed way preserving existing tools forgetting bad way generating new tools pre existing ones random changes way evaluating tool determine works bad ones detected eliminated 
lexicon evolutionary algorithms algorithm cast terms reproduction mutation recombination selection 
tools just iteratively run generate test process accumulate tools throw away rest 
basic darwinian method building tools knowing 
quite easy see formula building tools approximation currently build successful tools 
connection briefly section mapping straightforward 
knowledge tool design tacitly silently encoded existing tools 
successful tools emulated 
designing new tools rarely starts scratch builds prior designs 
design hillclimbing predecessor artifacts 
know little tools great changes existing tools tend approach random modifications frequently 
deal fact versions natural selection 
single successful idea hci user testing combination iterative design 
user testing weeds poor designs 
cull unfit 
natural selection fitness adaptation concepts explain success organisms species 
precise definition fitness entirely dependent ecosystem organism lives 
concept fitness applies tools tools need ecologically fit 
traditionally main fitness criteria tools performance tool possible user productivity product quality 
clearly performance measure interest conceivably indicator fitness see section 
example degree cognitive support indicator fitness 
obviously globally fit tool fitness depends local ecology 
factors affect fitness expected variations factors affect fitness artifact 
example widely known fitness representation task dependent see casner green peterson user dependent see 
called task artifact cycle ecology tend change response new tools 
tool ecology change process somewhat akin predator prey evolution 
notion fitness need globally fixed definition ecology 
general analyst investigates tool fitness regard combination performance measures characterizations user population situations 
issue fitness simply relation chosen ecology 
see evolution technology overview various attempts apply evolutionary theory mechanical technology 
am presenting simplest form reasons complicating basic formula purposes complications distracting 
parameter optimization style modeling design search uses different analogous vocabulary 
instance tool fitness defined analyst terms utility function manipulable features called command variables see simon pg 


trouble theory fitness dimension dimension fitness landscape visualization variation individual tool induces changes tool adaptation ecology slight change tool affects fitness 
changes run gamut 
include changes screen presentation screen size colour selections layout options input mechanisms command language commands provided virtually endlessly 
try understand dimensions tool vary variations dimension modulates fitness variations dimensions 
dependencies fitness difficult understand 
order illustrate difficulty evolutionary biologists developed useful visualization trick called fitness landscape called adaptive landscape adaptive topology see dennett fogel ch 

idea fitness landscape features may placed different axes resulting fitness plotted function variables 
fitness landscapes generally extraordinarily high dimensionality dimensional slice illustrative 
example visualization 
dimensions design variation resulting fitness results form surface height point indicates degree fitness 
sort visualization quite helpful thinking properties design methods possible roles knowledge design 
viewpoint design seen search appropriate high points fitness landscape 
iterative design preexisting tool seen starting particular location tracing trail slopes 
far knowledge affects design assessed alters properties search landscape 
adequate knowledge search risks dumb 
problems dumb moves important benefit darwinian construction methods little knowledge needed order stumble tools 
scheme practically sort 
trouble theory want got local maximum predictability monsters efficiency problems search random mutations preexisting artifacts sufficient 
long mutations modest iterative build test process follow slopes top hills landscape 
dumb moves 
seemingly fantastic news tool designers 
profoundly ignorant manage produce tools 
unfortunately darwinian closer current state art 
unfortunate ignorance embarrassing problems slope 
problems nature maximally dumb design method 
illustrated follows inefficiency 
obvious problem search inefficiency 
normal design spaces vast filled primarily bad designs 
dawkins said vast majority theoretical trajectories animal space give rise impossible monsters pg 

tool design space inhabited inappropriate unworkable tools 
consequently search happen ones rarely 
unpredictability 
second obvious problem search unpredictability uncertainty 
interesting parts design space may 
particularly aspect unpredictability possible get stuck local maximum find globally optimal designs 
local maximum slopes lead slope small incremental changes doing iterative design user testing converge better solution 
problem especially acute global maxima result multiple dependent design factors 
rasmussen fully aware problem fitness landscape illustrative device 
put missing design consideration dimension may cause optimal design fail pg 

point view searching landscape problems unpredictability random walks random places random walks finding fit designs difficult far locales 

trouble theory 
third obvious problem darwinian design 
mindful selection direction fit designs essentially outcomes series accidents 
outcomes fit result may obvious relation designer original goals 
problems stem search specifically new designs selected constructed 
clear way build new se tools really rely truly random search design space 
helpful look implications random search problems noted random search exist degree current design practice inefficiency 
inefficient search known problem hci 
user testing expensive process sense leap tops hills fast avoid accidentally tumbling downhill 
fact process hills limiting method iterative hillclimbing search efficient searching methods able leap needing sample valleys 
corresponds radical redesign existing tools small incremental change 
unpredictability 
unpredictability uncertainty random search implies useful tool ideas waiting uncovered knew start looking 
problem getting trapped local maxima 
suggests iterative improvement may allow race top hills subsequently traps taller hill close 
times problem result inter dependencies features artifacts tool ideas successful appropriate supporting tool features 
designer realize dependencies idea bad user testing show poor performance 
saw section superbook fisheye view idea careful testing showed performed poorly features added interface 

dumb search may obviously problem tool designers 
taken naively problem normally start trying build compiler accidentally building video game 
design normal sense word intention term design synonym intention purpose designers generally pursue leads far away intentions 
designers try knowledge beliefs available find way landscape 
knowledge may may adequate nature separate notions radical re design 
am talking making multiple significant changes users task environment occurs instance computer system brought existed introducing large number design changes existing products 
notion radical redesign paradigmatic shift tool form described newman 
type radical redesign implies situation truly globally novel ideas investigated 
merely implies ideas novel workplace tool deployed rule possibility having established engineering knowledge say 

trouble theory random search limiting case random search uses knowledge high points knowledge direction better 
clear implication worse designer knowledge landscape wayfinding resembles dumb darwinian search 
way counter problems course obvious build knowledge intelligence generate part generate test cycle 
building knowledge design practical goal frameworks models hci guide derivation suitable initial designs virtue accuracy utility terms equivalent reduce number iterations required ultimately acceptable design achieved 
evaluations subsequently act confirmation rejection design parts thereof andrew dillon designing usable electronic text pg 

wishes improve search fitness landscape knowledge derived theories sense resist applying pet theory long determine adding knowledge holds promise 
place added generate part test cycle trying improve synthesis new candidate tools 
important candidate synthesis 
consider inefficiency 
candidate synthesis speed hillclimbing making possible larger jumps hill avoiding wasted iteration cycles going wrong direction 
possible jump hill hill convoluted path conservative iterative improvement 
unpredictability 
candidate synthesis avoid getting caught local maxima reducing chance starting wrong slope jumping long distances paths low fitness designs order break local maxima 

candidate synthesis help designers start right location set course direction matching design goals 
knowledge doing called survey knowledge 
knowledge candidate synthesis critical resource design 
case fact important role theory design provision knowledge synthesize initial succeeding design candidates 
presentation somewhat unnecessarily order relatively simple point 
sincere hope presentation obvious reader important roles theory design building candidate synthesis knowledge 

trouble theory hope fact obvious significance role universally acknowledged 
fact role appear particularly known investigated 
great majority theory hci concerned evaluation synthesis fine detail survey knowledge 
shall briefly consider turn evaluation fine detail considered secondary targets theory development 
synthesis evaluation hand theory possible zip products faster cut try engineering skip lot cuts tries 
far luxury theory quicker quick dirty engineering methods 
stuart card theory driven design research pg 

popular applications theory hci substitute prediction empirical testing 
clearest example principle authors goms 
goms put simply theory produces predictions performance description artifact user task 
synthesis works way takes desired performance generates new design intended achieve performance 
say goms works backwards relation direction synthesis 
difference synthesis evaluation illustrated 
synthesis needs resources reason forwards design context features new artifacts design goals satisfied 
evaluative theories goms definition serve reason backwards 
needs artifact prototype design hand 
question applying theory problem evaluation valuable 
preceding discussion navigating fitness landscape places contributions evaluation proper place 
theory role evaluation secondary tool helps important decisions 
evaluation role search limited establishing current position compared established positions 
problems inefficiency unpredictability roundabout ways 
limited role theory design appears suit landauer just fine feels empirical cut try foundation design pg 

argued basis design inspired guesswork followed iterative slope theory playing small limited role guesswork portion 
true surely theoretical knowledge perfect design moves 
may simply cheaper guesswork test guesses theory exist 
resist led thinking promising application theory evaluation 
brightest promise better design improving synthesis 
human efficient designers nature evaluation skills construction knowledge 
calling synthesis forwards understanding backwards corresponds industry wide terminology 
forward engineering reverse engineering 

trouble theory synthesis forwards natural selection fitness mutation natural selection new organism organism iterative testing context goals performance guesses testing new artifact artifact theory applications context goals performance informed guesses evaluation new artifact artifact evaluation backwards roles theory synthesis versus evaluation slippery slope evaluation design elaboration point warranted 
card outlined vision applied psychology design held guiding example scenario 
specifically imagined hypothetical designer goms analysis order compare performances users competing designs text editor interaction mechanisms incidentally keyboard vs light solutions 
goms analysis showed design easier learn slower harder learn quicker 
results order rationalize design decisions 
goms synthesis 
answering question satisfactorily requires subtlety answer definitely 
key point notice space design options keyboard vs light pen set 
world text editors option space input devices known needs theory order lay possibilities 
space options enormous issue understanding design options quickly dominant hurdle 
currently rely craft knowledge design space built exposure large portions form different existing artifacts 
fine say designers able learn build internal model structure design space 
things parsimonious theory generates fundamental principles 
seen section restricted decomposition design space important multidimensional space options 
second important thing understand just designer forced goms 
goms role scenario analyze design implications elements design space 
output 
trouble theory design space analysis goms decision table situation specific design theory 
designer preferred mix learnability performance table theory specifying predicting prefer artifacts deliver goals best 
space design options combination decision table form knowledge hypothetical designer forward reasoning 
goms produce knowledge knowledge 
far far better designer description design space decision table hand 
fact critical point question analysis vs synthesis 
consider cost designer producing situation specific decision table goms needed essentially slight artifact variation equivalent generalized decision table generalized design theory 
heuristic approximated 
designer left sample design space evaluate point 
reconstructs fitness landscape 
put way fact evaluative theory goms required definitive proof appropriate design theory exists mitigate need 
designer sweep goms entire design space order point high ground fitness landscape 
point conveniently brings issue survey knowledge 
survey knowledge details ways evaluating adequacy theory prevalent hci cognitive science predictive accuracy 
theories hci cognitive science evaluation synthesis means attention paid accuracy theory predicts phenomenon user behaviour performance artifact 
reason attention straightforward understandable accuracy prediction best ways establishing basic ideas underlying theory sound 
unfortunately predictive accuracy measuring stick bias theories try explain things strong preference limited theories pick small phenomenon predict reasonably 
price usually pays predictive accuracy limited scope see section 
predictive accuracy valid measuring stick design theories discussions difficulty navigating fitness landscape argue applying aggressively lest limited theories unduly favoured 
reasons considering accurate limited theories desirable general theories accurate predictive 
key realizing preference lies cost difference tool analysis empirical testing 
evaluation form user testing relatively easy cheaply pick small flaws design especially problems usability 
minor aspects design easier test guesses generate design decisions place 
course generalization needs qualification qualified agree 
example landauer ch advances argument developing new ideas easy evaluation hard 
suggested new tool ideas spreadsheets direct manipulation quite easy create properly evaluating merits difficult 
ways true important circumstances generally false 
ultimate proof matter 
trouble theory sorts simple usability evaluations proven effective detecting obviously bad parts designs nielsen 
fact average untrained user apparently quite detecting bad designs 
just ask novice computer user think operating easy ask pretty expert computer user think system perfect 
generally able give list problems put effort listing problems designer conceiving novel design 
ultimate proof users detect bad design push ensuring usability seriously muted 
may limitations user testing testing design guesses cheaper building initial designs especially minor usability quirks 
metaphor fitness landscape user testing cheap way inch hill located locating hill hard 
test tweak method may hard beat long minor tweaking required 
relative cost local hill climbing problem limited design theories apparent 
limited theories matter accuracy construction reflect knowledge local topology 
metaphorically speaking equivalent knowing small neighbourhood large city 
improving predictive accuracy limited theory may little eliminate steps slope curve get right street just go door door 
important role theory design may hill finding hill climbing 
hill finding absolutely requires non limited theory theory broad scope general integrates high level design concerns guides roughly right neighbourhoods lets quickly realize wrong neighbourhood 
critical role theory design provide broad survey knowledge knowledge limited local topologies 
addition cost structure theory application disadvantages accurate limited theories 
simply put generally cost predictive accuracy power terms analytic effort 
cost creates shum call cost gulf analytic technique 
clear goes human interact computers incredibly complicated general able predict sorts artifacts maximally fit requires accurate detailed understanding users tasks environments 
expect better initial designs come result better analysis powerful theory 
analysis part difficult techniques harder learn hci specialist non specialist alike 
barnard may describe problem follows techniques require detailed specifications generated application modeled 
application require specification rules construction requires modeling expert 
redone problem considered 
application techniques requires large commitment resources 
design contexts difficult justify 
pg 

accurate theory application may costly user testing cheap 
puts squeeze applied theories circumstances cost effective role theory design may hill finding 
put may little practical highly accurate limited design theories 

trouble theory upshot looking build design theories am chapter obvious choice quick easy survey knowledge gets designer right general area design space 
minimum requirements theories broad scope require cheap broad brush analysis apply need yield general high level suggestions gross forms tools 
suggests applied researchers tend eschew limited theories favour aggressively broad inclusive ones 
am hardly point facts see young barnard green dillon voices difficult hear din papers emphasizing predictive accuracy limited theories 
consequence authors apparently feel need offer apologies broad brush theories wright probably attempt hard line theoreticians 
apology needed 
issues bear strongly design evaluate design theories argumentation necessity survey knowledge worthwhile 
summary navigating landscape theory builders aware importance possibilities theory design 
initial design theories probably favour breadth generality fine detail predictive accuracy 
cost structure theory application user testing supports point 
realized critical roles theory design allow designer reason synthesize designs better analyze existing tools 
facts realized necessary understand required enable synthetic reasoning 
field stands attention paid takes improve synthetic reasoning 
subsection shall take issue outlining distinction design context knowledge synthesis knowledge identifying types theoretical resources enable designers cross termed gulf synthesis 
crossing gulf synthesis assumption understanding programmer mental model efficient route designing effective tools 
obvious design tool specification programmer mental model 
instance knowing programmers top strategy understand code inform tool design 
doesn tell kind tool build integrate tool workplace programmer 
singer examination software engineering practices pg 

thing understand world quite different thing know change 
cognition oriented research software engineering fields great deal attention paid understanding contexts tools designed 
quite understandable 

trouble theory knowing ecosystem tool intended critical knowing fit ecosystem 
fact original cries hci know user 
cry lead wide spread acceptance ideal user design human computer interactions 
basic call understanding design context refined years 
aspects design context studied addition individual psychology concerned things collaboration group interaction social organizational backdrop essential structure domains 
told study authentic users wild know really 
contemporary hci emphasis placed understanding ecological context design 
cognition oriented theories clearly opportunity play important role understanding relevant aspects ecological context 
researchers turned variety theoretical disciplines order shed light users activities issues design context 
typical presumption theories vaguely understood way applied better inform design 
hard imagine bad thing know design context 
important distinction informed design context knowing exactly design 
paraphrase quotation simon started chapter designers want know ought profound theory applied inform designer ought achieve 
am reminded old joke patient goes doctor says doc hurts doctor says don joke applicable patient says doc think broken arm doctor runs exhaustive battery sophisticated tests says broken arm right sends home broken arm untreated 
designers want equivalent doctor knowledge broken arm satisfying just know current state affairs 
restricting theory role simply informing design articulating aspects design context seriously limiting conception theory role 
want theory cross called gulf synthesis 
gulf synthesis long pointed possible learn design context necessarily knowing build order change better 
say learn short term memory limited 
theory short term memory works tell features add source browser 
certainly tells include features require lots short term memory remedies lack 
problem general knowledge design context easily convertible ideas design inert 
knowledge serve inform designers problems users face 
serve constrain design design space vast constraints generative 
imagine going treasure hunt produced excellent review push understanding design context precursor design come 

trouble theory information treasure mobile alabama 
try add constraints theory constrain design exploring design constraints helpful sufficient 
knowing user problems constraints imposed design tell build 
studying design context designer lead analysis synthesis 
norman term gulf describe similar sorts 
instance coined term gulf execution name impasse occurs user plans action performance 
analogous way problem developing design ideas understanding design context called gulf synthesis 
design context knowledge primarily leads better appreciate gulf 
gulf synthesis suppose 
knowledge design context inert act set designer 
pylyshyn provided clear example case designing designers 
design studies shown professional expert designers follow strictly phased development methods known waterfall method despite suggestions phased development right way doing software development see carroll parnas 
pylyshyn correctly asked knowledge actual existing practices developers informs design tools designers findings 
suggest design automated study designers 
fact certain ill structured problems design approached certain way experts may tell approached certain computational aids 
pg 
emphasis original may certainly case design really automated claiming automated observations designers currently simply begs question 
studies authentic situations wary confusing exists possible ought 
designer vantage point possibilities changing status quo understood privileged position 
traditionally issue comparing ought posed distinction descriptive theory describes normative theory describes 
instance normative theory design prescribe design performed group activity appropriate shareholders cooperate 
appropriate unpack various meanings chapter 
point variety models theories understand target ecology user tasks preferences needs social setting understood step knowing ways disturbing existing world meet perceived needs 
important question ask build theories crossing gulf 
carroll described related different problem called analytic synthetic gap 
analytic synthetic gap refers putative limitation deduction theory purpose generating new designs 

trouble theory suppose application oriented theoreticians spend lot time pondering just question 
hope come number satisfying detailed arguments theory bridge gulf synthesis 
reality 
claim theory framework provides design insight design implications embarrassingly 
say existing theoretical works useful 
cases claims improving design true 
instance am inclined believe holland claim dc perspective really provide new insights design conceptually meaningful tools environments pg 

useful design theories hard come skeptic deserves convincing argument 
alas exception sparse set outliers shum rasmussen arguments force believe claims improving design practice hopeful wishes 
reason state affairs theory developers fallacy magician design method 
magician design method magician method designing tools study design context magical insight occurs 
method diagrammed 
magic occurs boundary understanding action theoreticians appear content keep synthesis step 
doubt researchers study problem domain long ideas pop heads 
especially exceptionally clever researchers publish papers design 
am certain expert designers cases able call vast knowledge past designs order come workable ideas 
contrast methods am searching takes input partial understanding design context explicit theory generates useful design ideas concepts 
focus group marketers environment study evaluate tasks user psychology social psychology current tools understanding gulf synthesis magic occurs new design magician design method 
trouble theory unreasonable request 
precisely required theory directly applied cross gulf synthesis 
theory mechanically generate new designs instance ideal automated designer 
automated designer take descriptions design context design goal 
theory generate design moves implicit accordingly construct appropriate artifact 
generating restricted variety information displays theory driven approach tried casner zhang 
automating construction certain suitably restricted aspects se tools certainly conceivable 
example possible automatically generate task relevant program visualization displays description maintenance task partly automatically 
automating se tool design significant degree 
full automation design synthesis need goal 
theory dictate system design characteristics 
theory simply guide design reasoning 
view role design theory provide recommendations suggestions produce guidelines 
designers design theory poor design choices rely intuition craft knowledge iteratively test new ideas 
entirely worthwhile take seriously problem constructing design theories 
accept mysteries magician design method possibility reducing reliance intuition iterative testing 
required way making processes idea creation design decision making 
shedding light necessary order generate decent argument detailing theories may critical step synthesis 
argument needs kind model knowledge resources design reasoning 
subsection propose simple model 
purpose model argue importance theories allowing designers reason call positive consequences tools facilitate fp reasoning 
theory fp reasoning theoretical integrations environment dimension hardly attempted critically needed support cross environmental reasoning inherent design 
come surprise cognitive psychologists overly concerned type theoretical unification acceptable scientific product model behavior specified environment rarely reasoning backward cognitive theory environment required 
alex requirements psychological models support design pg 
order magical synthesis step necessary model design process 
fortunately little detail go long way 
consider 
trouble theory resources designers rely synthesize new designs 
hasti framework employed model sorts knowledge employed designers 
synthesis designer explores hasti defines problem designer goals constraints placed design options design moves possible 
define designer problem space design activity interpreted exploration space 
design exploration possible design moves design goals respecting design constraints 
definition problem space changes design development progresses say resources comprise synthesis state 
point understand synthesis state constructed consider impact synthesis needing problem solving details 
words analysis proceed newell called knowledge level 
question subsection theory applied define problem space constructed explored designer 
answering question helpful elaborate things considered design goals constraints action possibilities 
short survey easily rendered 
goals 
designers adopt design goals believe tools ought 
beliefs designers adopt high level design goals serve globally organize exploration design space 
examples general design goals literature include particular order automation 
designers may adopt goal try automate possible 
reduce cognitive overhead 
navigation viewed extra burden cognitive load focus reduction storey 
information provision formatting 
designer may think purpose software comprehension tools provide right sort information right format 
expectation may set goals pursue certain search visualization tools von mayrhauser 
skilled performance 
may adopt position goal design provide environments manual perceptual skills employed place intensive reasoning 
note goals directly operational generate designs just adopting 
note important aspect goal setting practice designers known follow habitual paths design space 
example carroll rosson aptitude applying psychology design noted design involves example learning pg 

design frequently group activity 
appropriate extensions group problem solving model may generalize extensions considered 
observation partly inspired rasmussen buckingham shum performed similar trick recursively applying design theory designing theory 

trouble theory 
constraints 
design constraints effectively prune design space identify parts design space avoided 
identify tools impossible unsuitable simply undesirable 
design constraints implicitly identify negative consequences tools undesirable implications tools usability problems 
instance tool may force user remember items violate constraint imposed memory limitations users 
respecting design constraints designers avoid usability problems 

possibilities 
design possibilities steps designers take achieve design goals 
designers typically try useful tools design possibilities correspond moves useful artifacts 
words design possibilities ways creating artifact features positive consequences 
theory applied construct aspects designer problem space 
previous subsection identified main classes theory application backwards artifact forwards goals informing theories help designer generally analyze understand design context 
composes classes theory application resource types gets matrix different possible applications theory 
shall consider categories defined forward backward negative consequences positive consequences case design goals inspired theory design stance 
types abbreviated fn fp bn bp stand backwards forwards stand negative positive consequences respectively 
categories theory application assists different category design reasoning 
categories called fn fp bn bp reasoning respectively 
fifth application providing design stance said enable strategic goal setting 
applications theory depicted ones applied circled 
theory guided reasoning applications theory provide way guiding design reasoning allowing designer theoretical resources establish consider goals constraints possibilities 
problem space designer may reason dependent forms theoretical resources 
table summarizes applications types concerned goals 
bn bn theory enables reasoning backwards artifact negative consequences embodies 
prototypical form theory hci 
methods invoking theories backward forward negative predict explain problems constrain design positive rationalize explain benefits expose solution space table types reasoning roles theory supporting 
trouble theory inform cognitive limitations problems tasks environment design context biases forwards synthesis design stance goals synthesis state fp fn possibilities constraints evaluation bp bn backwards artifact resource flow model theory application design artifacts include various forms cognitive walkthroughs execution programmable models 
role theory methods predict usability problems artifact testing explain source 
bp bp theory enables reasoning backwards artifact understand artifact considered useful beneficial 
role theory case rationalize design decisions explain source designed benefits 
costh chapter collection bp theories 
fn fn theory helps reason forward design goals anticipate possible negative consequences avoided 
normally means helping steer design away problematic unusable features need bn theory retrospective evaluation 
fp fp theory allows reasoning forward design goals features artifacts beneficial 
possibilities lay parts design solution space 
costh primarily bp theory potential enable fp reasoning identifies possible accomplished 
particular redistribution substitution cognitive rearrangement theories reengineering cognition create support 
fifth type theory application considered provision design stance order help generate goals 
theoretical frameworks carry way looking user problems 
trouble theory benefits artifacts 
theories provide design philosophy design stance designer 
colloquially speaking different design stances designers try differently glasses 
design stance serves highlight different problems design context develop goals achieving 
instance outlines design stance honors skill task execution way reducing cognitive burdens 
adopting design stance lead designer generate goals providing skill methods completing cognitively challenging tasks 
providing design stance theory serves bridge problem comprehension goal setting subsequently acts heuristic strategy searching design space 
designers tend follow habitual paths having collection differently coloured glasses open design space afford designers multiple ways tackling design problems 
summary implications designing design 
viewed way user interface gulf resource action 
unfortunately current cognitive models action generated throw light way resource exploited 
stephen payne looking hci pg 

section gradually constructed taxonomy ways applying theory hci 
taxonomy main orthogonal application dimensions direction reasoning types artifact consequences reason 
directions reasoning called backwards forwards 
backward reasoning characterized starting existing artifact prototype design idea working explaining predicting properties resulting artifact 
forward reasoning characterized starting design goal achieve coming artifact features achieve goal 
artifact consequences reason called negative positive 
negative consequences bad implications artifacts usability problems create positive consequences implications artifacts cognitive benefits provide 
taxonomy simple model design problem space considered applications theory guide designers constructing design space bn bp fn fp theories design stances help designers set design goals 
argued dc theoretical resources developed previous chapters potentially suited bp fp reasoning setting design stances 
terms designing cognitive artifacts applications theory definitely received attention past 
notably bn theory lesser extent fn theory 
instance human performance models primarily useful backwards reasoning 
returning lever example section performance models analogous engineering models determine load limits lever 
important complementary issue 
design theories suggest lever appropriate solution 
addition theoretical hci checklists usability inspection methods categorized resources 
cognitive support knowledge fit design fn bn reasoning 
chapters showed different studies cognitive support 
cognitive theories hci dominated performance theories theories useful predicting diagnosing usability problems 
particular focus 
payne implied hci researchers tend treat interfaces posing problems providing aid 
bias explain general tendency bn fn theories 
analysis earlier part section suggests current prioritization hci research unwarranted 
specifically types theories needed fp theories theoretical frameworks set useful design stance 
build priority list theories develop types theories top fp theory lays solution space design stance setting theories provide strategies navigating 
addition give higher priority broad brush theories provide global survey knowledge 
provide biggest cost benefit ratio designer 
executive summary useful details filled 
somewhat analysis section unnecessary prioritization acknowledged isolated instances 
unfortunately case result profile theory application hci reveals gaps places 
insight theory types priorities converted theories fit design 
propose cognitive support theories costh employed fill gaps 
clearly promise fp reasoning costh theory built primarily bp reasoning 
artifact costh understand benefits embodied artifact terms various types cognitive support 
question settle possible effectively reverse direction reasoning rods hasti costh provide useful usable design stance put form fp reasoning simpler 
question tackle section 
cognitive support knowledge fit design tacit assumption modeling world science modeling hard get results design little relatively easy 
fact greatest difficulties figuring designers models reasonable design method incorporate models 
theorists observed undergo severe culture shock required extract model theory piece information necessary answer design question 
stuart card theory driven design research pg 

main idea cognitive support artifacts partner cognitive 
support concept squarely aimed explaining tools beneficial merely tolerable hindrance 
exception section theories cognitive support treated method explaining support works tool properly speaking changes 
cognitive support knowledge fit design tool environment alters dc system way improve cognition 
words forms rods hasti costh tailored analyze existing tools fit bp reasoning 
bp reasoning important design necessary remember past successes 
resources contribute synthesis having tool hand analyze 
costh particular enable fp reasoning provide useful set design stances 
entirely resources better classified basic design theories applied design theories especially tailored practitioners 
question changed form suit designers better useful usable 
section argue 
shall put forward different ideas concepts rods hasti costh better suited application 
ideas theoretical resources novel rods hasti costh new applied novel ways 
exception tentative doing results distinct prior 
avenue research explored briefly tentatively 
poor substitute rigour shall strive convey promise approaches building applied design theories 
theories designed artifacts am proposing qualify early design skeletal prototypes beta versions 
think presenting early prototypes worthwhile 
exploring ideas briefly help point promising directions research 
hopefully help convince reader theoretical resources developed chapters reasonable chance providing knowledge fit design 
theory ideas building working vocabulary providing useful design perspectives reifying design space providing checklists 
outlined subsections 
exercise designing design knowledge effort necessarily tailored particular type design designer 
subsection introducing design idea pursued intended target audience design setting 
overview ways design idea conceivably implemented rods hasti costh 
section conclude brief summary design ideas 

cognitive support knowledge fit design engineering concepts vocabulary contribution cognitive science hci research provide conceptual background engineering principles understood 
barnard may cognitive modelling user requirements pg 

design ideas linguistics reasonably known hypothesis called hypothesis shapir whorf hypothesis languages person able speak determines think 
hypothesis may entirely founded certainly case concise appropriate vocabulary associated conceptual background effectively influence aid thought 
properly unpack idea needs consider properties content conceptual background question actual lexicon proposed 
terms conceptual background important concepts cognitive support cognitivist level 
wishes design tools improve cognitive software developers may analyze reason tools cognitive terms 
lessons implied lever scenario section 
reasoning tools cognitive terms abstracts away details implementation see section 
brooks fact argued appropriate conception artifacts critical foundation design theory engineering theories arise 
necessary kernel development appropriate abstraction discards irrelevant details isolating emphasizing properties artifacts situations significant design 
property abstraction may important extent abstraction gives rise formalisms prediction indicating properties artifact really significant abstraction may lead invention new artifacts produce aspects novel ways novel uses existing artifacts 
pg 
brooks relevant contentions abstractions provided may important modeling methods prediction abstractions crucial part synthesis invention 
true implications programme concept vocabulary building may ultimately important avenues providing theory designers 
wishes try support claims evidence research possible place look studies expertise 
experts competent novices capabilities experts may reveal competent cognitive support designers need 
numerous studies suggested experts owe performance advantages ability quickly away low level brooks uses term engineering theories purpose just considered specific term design theories 

cognitive support knowledge fit design details problem directly consider function goal relevant aspects problem soloway 
reasonable expect expert cognitive support designers able rapidly interpret tools cognitive terms especially functional roles terms aid performance 
cognition oriented set concepts include cognitive ideas relating design necessary prerequisite 
direct extension soloway argument teaching programming abstractions programmers needs teach cognitive abstractions cognitive support designers 
knowing support related abstractions automatically expert designing cognitive support hard imagine expert cognitive support designer inherently 
consider vocabulary go concepts 
vocabulary building effort influence moment moment thinking conversation designers 
vocabulary building kind conversation level analogue long standing belief mathematics coming appropriate notation important contribution 
vocabulary question relates concepts generating positive consequences 
useful vocabulary positive consequences ensures appropriate concepts employed smoothly analysis ideas cognitive support precise terms bring conversation connotation association important design issues options 
programme vocabulary building familiar acquainted design patterns taxonomic categorization 
idea common defined vocabulary simultaneously add control rigour existing design practices especially informal design practices brainstorming casual design argumentation 
mechanisms improving communication designers providing common vocabulary possible quickly establish common understanding common ground 
green petre say explicitly presenting ideas discussion tools believe new approach hci doing doing recognising discussion users carries corridors institutes internet 
hope improve level discourse influence design roundabout way 
pg 
open question lexicon developed tailored particular community existing terminologies conceptual 
instance easy envision separate vocabularies cognitive scientists hci theoreticians se researchers practitioners 
green weighed side common vocabulary arguing lingua franca important bridging various communities 
suggested psychology laden engineering oriented terms ensures interest acceptance communities 
currently dimensions green appears leaning single universal english vocabulary :10.1.1.134.5007
leave consider question single lexicon developed 
shall advance think suit se researchers 

cognitive support knowledge fit design target audience setting ability build powerful machine cognitive systems grown rapidly ability understand capabilities kept pace 
today describe cognitive tools terms tool building technologies tiled overlapping windows 
impediment systematic provision effective decision support lack adequate cognitive language description david woods commentary cognitive engineering complex dynamic worlds pg 

software tool researchers nearly software tool practitioner little tolerance enthusiasm applying real psychology oriented theory design 
small exaggeration say software developers actively dislike hci theory hci specialists tend eschew hci theory 
compelling challenging target audience tool researchers computing science savvy largely hci cognitive science theory majority 
vocabulary set concepts developed potential clients think informed practitioners day benefit similar resources 
indicated vocabulary building effort aimed initially informal design settings brainstorming sessions early design meetings 
resources science pace technological progress 
provides tools thought conceptually mechanically 
science effective helps see new way conceptualizing design space allows inventions aid intuitive design 
stuart card theory driven design research pg 

rods hasti costh contain important concepts tried choosing terms 
general naming rule established early prefer terminology familiar computing scientists terminology carries connotations important 
consequently key design related concepts couched computing science terms support principles support theories 
productive try reconstruct important concepts vocabulary built 
appropriate handbook produced green done cognitive dimensions framework 
list key terms group broad categories 
general dc view cognition 
important terms include joint system distributed processing shared processing distributed knowledge external knowledge external memory augmentation media 

cognitive support knowledge fit design 
modeling ideas 
virtual memory caching paging memory management agenda goal plan problem constraint operation problem state history snapshot trace path perceptual operator skills rules skill rule knowledge domain task overheads coordination device coping 

support principles support types 
distribution distribution specialization optimization substitution reengineering 
offloading allocation precomputation display problem solving mediation 
extended working memory 

support targets 
cognitive overheads overload cognitive limitations depth bias 

support features 
memory bandwidth access costs update costs locality localization effect working set effective working memory size page fault rate 
terms associated concepts tried provide workable definitions 
third groups terms critical 
names support principles design related issues engineer positive consequences 
fourth group list cognition related motivators finding support 
fifth group gives hints design tradeoffs may analyzed terms measurable variables dc system 
unfortunately defining useful vocabulary provides assurance whatsoever taken effectively 
may difficult get non psychologists think cognition oriented terms view bookmarks extended memory see compilation errors partial repair plans 
chance key relevant design issues response external memory 
access costs 
indexed plan constructed 
plan steps ordered 
execution state stored externally 
hope vocabulary building cognitive support discourse raised details keystrokes colour schemes cognitive level 
dc design stances required description level discourse supports valid descriptions human activities form meaningful system design 
easy task helped knowing 
electronic text domain suitable analytic framework provide designers means posing appropriate questions deriving relevant answers 
andrew dillon designing usable electronic text pg 

design idea design perspectives stances designers order decide ought 
sense philosophy science design 
design stances allow designer pose questions 
cognitive support knowledge fit design goals pursue designers consider certain options ones 
craft disciplines inherit culturally propagated design stances 
instance common theme keeps propagated se belief se researchers seek automate mundane 
designers embrace perspective tend set sights just mundane automatable 
necessarily bad design perspective right wrong absolute sense 
stance biases designer explore restricted area design space 
cognitive support multifaceted designers exhibit tendency follow habitual design paths broad collection available design stances desirable 
dc generally costh particularly provide different vantage points thinking design cognitive support 
documented passed hope researchers think critically broadening goals considering joint cognitive performance 
may provide productive existing design biases 
target audience setting particular concern se tools researchers researchers domains thinking practitioner benefit suitable design perspectives 
se tools researchers interest special type designer default trying bend status quo generally satisfied reusing prior tried true solutions 
alternative design stances may help matter steering habitual solution paths 
furthermore domain se cognitive costs central issue se researchers interested knowing reason lower cognitive costs technology 
background may receptive theoretical approaches average practitioner 
vocabulary building anticipated setting early design reasoning core functionality behaviour tools considered 
resources dc point view takes seriously ideas joint mediated cognition 
consider popular design stances se research show dc point view offer valuable alternative stances 
help generate distinct design goals 
automation 
important software development tasks near automated 
researchers pursue full automation resolve acknowledge limitations note points failure 
typically failures considered indicate directions research indications limitations full automation approach 
examples reverse engineering limitations full automation easily reached cluster analysis program recognition 
cluster analysis program recognition currently automated semiautomatic techniques eventually considered 
limitation full automation design stance widely acknowledged comparatively examples alternative design goals rationally developed 

cognitive support knowledge fit design counterpoint cooperative problem solving 
automation unrealistic goal interesting tasks give start 
carefully analyzing task look ways redistributing data processing computer human 
view design goal put human deeply intimately loop processing 
returning example clustering program recognition exist tries integrate human problem solving loop tool 
example joint clustering body rigi joint program recognition decode 
just consider rigi 
rigi general view joint clustering humans bring knowledge specialize run clustering algorithms computer performs 
human exercises manipulation results applies informed judgments 
rigi example design stance taken assumes joint performance tasks automated 
joint cognition considered existing design stances considerably expanded terms design goals developed 
instance jahnke argued useful design stance reverse engineering tools assume specific key objective redistribute imperfect knowledge knowledge tentative contradictory heuristic vague 
redistributed manipulated externally cooperatively processed 
design goals stance shift attention discovering types imperfect knowledge redistributed external medium discerning external knowledge manipulated cooperatively processed remove imperfections 
lone example clear dc design stance expand currently simple forms design reasoning push full automation 

right information right time 
entrenched perception reverse engineering program comprehension re pc community purpose re pc tools primarily display information 
von mayrhauser vans articulate stance identify programmer information best helps understand code significantly improve quality efficiency program understanding 
pg 
researchers adopt stance typically focus efforts methods information provision presentation 
resulting tools typically structured form called holy trinity re pc tool structures parse analyze display pipeline see tilley 
visualization circles architecture called visualization pipeline 
posing tools visualization pipeline channels attention techniques gathering parsing analyzing transforming clustering filtering data understandable visual presentation graphing layout 
guiding goal desired information simply easily precisely time needed agree call right information right time design philosophy short 
goal efficiently transmit information contained externally comprehender 
counterpoint hands mediated problem solving 
time design stance implicitly 
cognitive support knowledge fit design buys belief comprehension understanding simple way transference information knowledge tool user 
transference notion comprehension certainly limited 
viewing software comprehension simple transmission data channel certainly grossly simplistic 
modern education research groups stark contrast design stance 
fair say modern educational psychologists disagree principle simple transference models learning see mayer 
students learn complicated material simply listening talking head front lecture hall examples try hands experiments ask questions 
learning view simply transmitting knowledge channel 
field information retrieval usually defined terms able supply information satisfy user information demands wide recognition information seeking active process involving problem finding task bates savage 
heed limitations simple transference model comprehension necessarily alters designer stance 
trying achieve simple knowledge transmission conceivably reasonable stance system studied user understood breaks quickly understood 
cases comprehension necessarily hands problem solving activity 
frequently better categorized learning discovery activity see frequently experienced maintainers domain language application type understand nature problems solve 
design focus circumstances shift active processes problem solving problem finding support 
involve searching ways elicit subsequently resolve inadequacies comprehender conceptions 
involve helping comprehender perform experiments probe resolve uncertainties hypotheses 
dc perspective potential design goals adopt response includes provision medium thought reflection 
users medium externalize problematic aspects understanding reflect evolves see jahnke 

comprehension internal knowledge 
nearly universal aim software comprehension research effectively generate complete accurate model system mind comprehender 
success comprehension tool measured quantity veracity completeness knowledge internalized 
counterpoint distributed comprehension 
cognitive support point view design stance fundamentally misguided 
dc systems knowledge potentially distributed jointly processed albeit lesser greater degrees 
may legitimate reasons user appropriate holder processor system knowledge accepted priori immutable dogma design goal 
design stance redistribution seek offload knowledge human reduce cognitive burden 
need full internal representation external system represents worst possible 
cognitive support knowledge fit design situation complete failure support maintainers external memories external knowledge processing external media thought 
distributed comprehension design stance adopted attention shift addressing balance external internal knowledge determining needs internally held tasks trying build effective external memory systems shifting processing burdens tools comprehension burdens lessened 
comprehension tools evaluated avoid need comprehender unnecessarily aware memorize certain facts system truly needed case course easily ascertained 
goal reducing knowledge burdens need basis nearly universally recognized principle language design commonly forgotten comes maintenance tools 
reclaiming goal avoiding comprehension may lead productive exploration tools 
particular dc viewpoint suggests software development normally considered involve joint processing distributed understanding software system 
comprehension redistribution view attenuates comprehension internal knowledge stance important ways 
distributed comprehension view knowledge subject system distributed maintained internally important aspects essentially maintained externally certain expectation overlap externally internally maintained knowledge 
rule apply design minimize knowledge user needs subject costs maintaining distributed knowledge see section 
general rule 
butterworth utilized simple version screen design heuristic screen design screen contain intersection information necessary information difficult user maintain pg 

essentially argument minimizing human memory subject coordination externalization costs 
sides coin 
side issue knowledge externalization developers externalize knowledge order forget allow tool maintain 
issues minimizing developer internal knowledge requirements maximizing storage processed externally 
view goal allow developers internally maintain thin veneer key concepts cadre indexing knowledge 
developers knowledge crawl external knowledge sources simon ant crawls undulations beach 
knowledge maintained internally negotiate revelation needed knowledge sources 
design stance incidentally line observations actual software maintainers 
rarely sit fully comprehend system try avoid deep comprehension unnecessary comprehend parts programs instance automated memory management languages possible unaware memory allocation reclaiming issues 
maximal ignorance principle holds advantages adts data layout ignorance information hiding internal details 

cognitive support knowledge fit design needed frequently remember knowledge access knowledge full representations tend want interleave comprehension action switch back comprehending impasse occurs 
short field sees fairly systematic attempt minimize knowledge system frequently involves utilizing tools external representations effectively 
half story 
software developers sure knowledge available accessible externally 
carefully name organize systems tools exploit structure add documentation code refer forget wrote code write little scripts programs look facts programs needed 
take care external memories 
expert minimize personal knowledge system maximizing joint system knowledge 
ideals automation internal knowledge construction currently received wisdom re pc research field 
design ideals limited terms way set potentially fruitful design goals 
examples illustrate philosophical theoretical backdrop dc provide potentially useful alternative design stances 
wish mention design stances necessarily considered superior 
able state alternatives important stance develops quite distinct goals 
reifying design space purpose cognitive dimensions framework lay cognitivist view design space coherent manner possible exhibit cognitive consequences making particular bundle design choices position artifact space 
green petre usability analysis visual programming environments pg :10.1.1.22.1477

design idea possible reify concrete design space representing design options constraints goals 
terms costh data redistribution specifically problem redistribution pb 
reifying design problem way creates external structures structuring resources see section 
external structures act plans step systematically space design options 
familiar advantages external structure possible task progress easier help ensure important aspects missed exploration systematic 
advantages help remedy deficiencies craft design probably problem missing design issues notorious 
classic examples sorts external structures checklist cognitive model 
complicated inclusive external structures contemplated see 
cognitive support knowledge fit design current purposes checklists cognitive models consider 
checklists design principles guidelines lead designer list questions issues considered design 
known drawback checklists overwhelmingly large lists thousands items long uncommon 
cheap discount design analysis early tool envisionment lists ideally quite short 
cognitive model effectively complement checklists models compact ways representing summarizing related checklist items 
probably best known example cognitive model just role norman multi stage model interaction 
model depicts interaction cyclic stage activity involving activities goal intention setting planning acting perceiving 
model simple general applied situations 
design analysis compact structure walked hci specialist question prompts stage indicate type new claim may discovered stage pg 

norman pg 
generated specific checklist model models facilitate structured open ended reasoning informed analyst 
instance carroll explained came list negative positive consequences tool considering norman stage theory action 
stage imagined general kinds psychological consequences artifact translating possible consequences questions ask artifact 
pg 
sum checklists models alternative ways representing structure design reasoning 
terminology costh external structures correspond plans user tends walk structure consider turn 
challenge try supplant existing resources supplement unique capabilities rods hasti costh 
know really needed helpful air main problems current checklists models 
problems known 
instance frequently vague occasionally applicable 
essential complaints need especially considered 
principles guidelines apply low level details interfaces interaction higher level cognitive issues core concerns complicated tools 
instance mayhew pg 
lists display design guideline avoid saturated blues text small thin line symbols simply low level view properly address cognitive support issues ideally guidelines away details tool designer think cognitive system level 

checklists include principles guidelines actionable inert sense provide goals rarely indicate ways achieving 
example analysis mayhew pg 
suggests design goals implied limitations short term memory stm keep stm storage requirements time minimum cognitively relevant principle hard argue 
cognitive support knowledge fit design situations 
designers need hints sort steps taken achieve 
costh vocabulary positive consequences provide hints 
example redistributing data stm reduce cognitive burden 
full prescription design fundamentally replaces ends means 

checklists primarily contain items concerned negative consequences minimizing user tool communication efficiency 
easy directly state useful features constructed tool 
goal concentrate exclusively reifying space possibilities generating positive consequences 
problem implies need structures defined cognitive level implementational level 
problems imply contents structure design constraints designer produce action possibilities available designer steps solution 
terminology costh redistribute possible operations problem space pb 
constitute type ends means structure designer ends mind structures designate means achieving 
additional note possible uses external structures checklists models 
traditionally cited act plans help systematically search design space uses entertained 
possibility rarely cited intelligently drive research design context see 
prior synthesis step normally analysis step design context understood better observing users analyzing tasks understand domain problems see 
idealized setting design context fully understood design begins 
reality design context partially understood usually partially 
parts design context explore 
list design possibilities explore design context information concerning apply means may search ends apply 
example designer initially hypothesize users need support complicated planning 
knowing plan redistribution problem state redistribution possible means achieve support designer study users understand planning currently achieved determine sorts plans conceivably redistributed 
target audience setting think countless ways organize information want try design process 
think imagine trying variations 
marc hat understanding pg 

essentially vocabulary building trained designers performing early informal design 
design context trying understand features pursue 

cognitive support knowledge fit design resources 
model 
main resources building applied design models hasti combination costh 
hasti merged version modeling methods see section 
significantly model features explicitly associated support principles see section 
means stepping hasti iterate associated support principles 
words stage considering hasti features costh invoked consider design options possible 
example considering problem panel agent architecture hasti designer may prompted investigate possibilities redistributing constraints pb 
hasti presents compact catalogue model features consider 
group designers brainstorming build reverse engineering tool consider feature hasti turn determine applies reverse engineering situations mind 
turn costh consider add appropriate support relates features 
example stepping hasti manner provided section model distributed comprehension stepped examine ways redistributing data process 

checklist 
straightforward task generate checklist design questions costh 
example pg simply list items user need unnecessarily remember past progress states task constraints externalized checklist just linearized form costh written english sentences 
obviously costh hierarchical checklist hierarchically decomposed 
entirely clear transforming costh simple checklist form improvement 
fact doubt leads wonder checklists generally poor forms applied design resources 
checklist version costh roughly equivalent costh clearly organized preference costh checklist suggest existing forms checklists ideally replaced model design theories 
checklists alternative format theories best preference approximated design theories 
may reasonable case preferring checklist representation costh cases additional specific theoretical apparatus needed 
hasti contains psychological details part cost benefit tradeoff adding details model 
specialized checklist possibly appropriate place add details known relevant 
instance certain situations may helpful list perceptual operators see casner ware reasoning engineer perceptual substitutions 
checklist resemble expanded version user profile checklist provided mayhew pg 


tabular worksheets 
common prose question type checklist may consider graphical representations tables 
representations created form worksheet allow designer fill relevant information sketch design 
cognitive support knowledge fit design options 
worksheet collect related design issues 
collection especially motivated design issues involve tradeoffs address orthogonal aspects design 
certain graphic representations simpler express vague sketchy design reasoning prose form checklists forced strict dichotomies true false fixed categories 
possibilities encoding costh options looser graphical worksheet format 
example possibilities consider 
intent table enable designers think various ideas concerns 
example table meant taken seriously 
intended illustrate general idea directing designers important possibilities letting record thoughts format appropriate 
shows example designing debugging system 
instance check marks question marks indicate prior design 
underlined bug internal data column reminder designer unhappy bug programmer working needs remembered due high front cost externalizing 
remind prior todo markings related sense designer thinks reminder agent prioritized todo lists needed bug tracking bug base 
summary design ideas developers design representations thinking start eventual users techniques just hci community urges designers involve user initial conception software artifact 
buckingham shum hammond delivering hci modelling designers pg 

section explored possible ways packaging theoretically knowledge cognitive support designers 
vocabulary building design stance construction reifying design space various external structures 
theory ideas geared improving design reasoning earlier stages design envisionment analysis 
main purpose exercise show costh hasti rods potential create highly applied bridging representations 
bridging representations effectively hide away complications theories derive synthetic reasoning design 
primary sources optimism project possible reason support high level design alternatives artifacts prototypes designs constructed potential improve scientific foundations design practice approximated nature notwithstanding 
point theory packaging ideas explored tentative manner 
reason little way prior research suggest methods 
little believed package theoretical knowledge comes primarily guesswork researchers activity analyzing 
summary implications data processing extern 
pre costs int 
ext 
int 
ext 
learn 
computed 

coord 
goals prior remind plans todo day ends bug 
front operations 
constraints sets filter 
curr state history bug base window page focus bug map view wm set file 
localization hypothetical example tabular form worksheet testing theory delivery vehicles 
fact theories hci tend primarily authors 
suggests little currently known concerning theories useful usable designers large 
far scope aspect theory delivery problem little done think tentatively bridging representations 
shown previously proposed techniques delivering theory reasonably applied rods hasti costh 
prospects eventually creating useful bridging representations bright 
show promise provide valuable toolkit fp reasoning synthesis 
type design representation point proven elusive 
summary implications vantage point difficulties suggest need better understanding design theories useful design transfer theoretical knowledge practice hard engineering disciplines 
stuart card theory driven design research pg 

chapter argued theory hci fails especially fit design 
great deal research potential relevant design 
real risk research fail fit design nature design design reasoning taken account 
argued 
summary implications past various roles theory design properly understood 
ways prioritizing research field inappropriate 
argument casting design activities search fitness landscape posing problem design reasoning gulf synthesis 
metaphors argue important roles theory design provide survey knowledge fitness landscape provide ways performing termed fp reasoning reasoning forward design goals potential design actions bring positive consequences 
chapter essentially argued specific type theory important broad brush fp theories 
considered create broad brush fp theories cognitive support 
rods hasti costh design costh type design theory 
may ultimately usable realistic design contexts 
outlined different avenues trying transform theoretical resources bridging representations representations theories form fit design 
ways reformulating theories included building vocabulary matching set concepts help raise level designer discourse articulating alternative design stances principles dc reifying high level design options checklists models 
exists ongoing avenues 
suggested rods hasti costh may able provide valuable additions ongoing streams study 
may considered quite preliminary strongly indicates design practices need 
important consider broader implications chapter 
problem creating usable design theories cognitive support simply conquered 
chapter able initial evidence suggest theoretical resources costh hasti potential creating theories bridging representations truly fit design 
steps small point far reaching consequences theoreticians 
psychological theory failed hci design fields 
failure attributed theoretical methodological weakness existence usability problems bridging representations 
rarely suggested problem wrong sort theories pursued 
arguments chapter suggest may case 
hci driven nearly single minded pursuit finely accurate evaluation theories primarily serve help reason usability problems 
time working broad brush survey theories enable reasoning positive consequences cognitive benefits tools 
chapter application craft science meet cognitive engineering type applied cognitive science trying apply known science design construction machines 
surprising business 
hand quite lot known cognitive science applied 
hand lack knowledge 
donald norman cognitive engineering pg 

engineering tools research point great number questions floating regarding tool efficacy scientific answers 
knowledge cognitive support particular grounded entirely craft knowledge folk psychology 
status quo ideal 
doubt better craft basis replaced scientific foundation 
scientific basis currently sparse contentious difficult apply 
insist working rigorous widely accepted theories tiny islands knowledge unable talk important issues 
necessary science base long term proposition 
realistically speaking shall fully adequate scientific practice long time possibly forever 
interim 
se tools psychological implications simply ignoring satisfactory option 
tactic merely ensures explanations tool usefulness remain tacit grounded mainly folk psychology 
cognitive support tools continue hard compare difficult teach impossible test 
measures taken strengthen scientific basis tools research design middle ground rigorously scientific proof unreliable craft skill 
measures 
answer may turn best involve coordinated attack tools researchers applied theoreticians 
step forward making better claims cognitive support offered tools 
current level claim explicitness lead effective testing comparison tool ideas 
important open arguments claims explicit possible try diligent building arguments claims 
fail thoroughly convincingly scientific strive credible 
credibility demands competent exposure support claims due justifying 
realistic insist cognitive support claims empirically tested verified 
single tool may embody dozens interesting claims claim take months test tools research grind virtual 
developer standpoint purpose theory testing ensure theory applied need validating results 
simply decomposition research efforts 
tools researchers build tools claims justify applied theories 
scope research evaluate develop theories 
applied theories available status quo se research change 
cognitive support claims reasonable applied theory claims justification apt folk psychology 
application reaches science applicable theories 
changing practices tools researchers part story 
field may ways lack certain amount scientific just blame tools researchers 
important applied theoreticians supply se right applied theories tentative weak 
applied theoreticians knowledge basic sciences construct new theories suitable application 
way applied theories structures mediate se researcher interaction scientific knowledge disciplines 
cases theories abstractions idealizations basic science theories represent 
applied theories typically apply settings broader scope basic science theories draw 
scientists view shall undoubtedly unappealing 
required 
interim relaxing scientific needed interesting claims advanced 
important provide abstracted theories broad scope important argue claims interest tools researchers 
points argued young barnard albeit slightly different context 
proposed theoretical works hci test driven set scenarios act sufficiency filters 
collection scenarios test driving process involves theoretical approach attempting formulate account behavioral scenario 
accuracy account stake 
purpose exercise see particular piece theoretical apparatus capable giving rise plausible account 
scenario material effectively set sufficiency filters possible weed theories overly narrow scope 
approach capable formulating account interest focuses properties account offered 
pg 
idea weed theoretical treatments fail apply interesting situations fail say interest applicant 
aim establish way achieving markedly different goal theoretical works main reasons scenarios sufficiency filters try balance scope accuracy shifting trade point greater emphasis generality 
fact saying risk psychological societies belong empirical accuracy scenarios comparatively unimportant 
scenario claims happen wrong different statement right way serve purpose making sure theory sufficient scope cope scenario say 
pg 
point way favouring establishing generality relevance needed 
scenario method young best way doing ultimately important purposes 
important method established placing high priority applicability 
right way applied theories tend developed take pet theory try extend see conceivably applied 
tools researchers approach completely backwards 
eventually risks far slow undirected 
right way building applied theories determine sorts theories needed best supply tentatively filling missing knowledge approximations generalizations 
theory building light springs important issues domain application 
young proposal collection scenarios stand concerns hci practitioners 
scenarios embody criteria scope relevance proxies advocates developers seek apply 
applied theories reach application problems solve 
point reach main issue chapter 
important relationship theory application applied theory building 
craft disciplines depend applied theories effect scientific reform applied theory generation driven problems domains may apply 
mistake consider issues completely independently 
application craft science meet 
may considerable synergy applied theories evaluated applicability current research trends domain application 
particular may helpful test drive theories scenarios derived current research tools 
list points may drawn favour approach 
tentative idealized approximated theories partly anchored solid data experiment 
applying theories derived controlled settings brings question application uncontrolled situation warranted valid see wolf 
complementary way craft disciplines build wealth experience knowledge scientific explanations 
theories align received wisdom domain lends credence theory validity application 

symmetrical way craft knowledge aligns science backed theories adds credibility craft knowledge 
reformulating craft knowledge theoretical framework takes important step converting craft knowledge science knowledge see 
doing add new knowledge 
casting different theoretical angle add valuable layer understanding field 

easy estimate difficulty applying theories realistic situations 
examples applying theory pragmatically important applications 
situation theories past chapters novelties se researchers novices application rods hasti 
examples known invaluable learning situations see fischer 
examples bind theory accessible concrete instances 
concreteness may help researchers understand relevance theory 
theory application reused assuming judicious modification analyzing tools similar ones analyzed examples 
facility bound easily recognized unix programmer man pages cut paste example code programs 
similar way salient examples theory applications serve analysis templates analyst may reuse cutting pasting 
addition application examples may inspiring 
convey theory potential uses realize 
eminently sensible strategy promote new applied theories applicability topical examples client domain 
reasons chapter presents examples applying theoretical resources developed earlier chapters 
applied existing research tools program comprehension reverse engineering 
main example analysis reverse engineering tool called rmtool 
purposes establishing breadth second reverse engineering tool rigi considered 
rmtool rigi tools current research interest se community show encouraging promise explanations merits concerning cognitive support 
outstanding sufficiency filters 
analyses tools performed sections respectively 
examples theory application analogous identical scenario driven evaluation method proposed young barnard 
recall theories tools see section 
examples considered scenarios envisioned researchers users applying theories tools analyze design cognitive support 
issue theories applied scenarios say 
approach differs young scenarios detailed accounts interactions tools informal analyses theories applied analysis design situations 
approach analogous collection cases drawn intention capturing salient scope applicability theories 
result exploration theory application advances causes tools researchers se 
tools researchers experiences community new theoretical light adding credibility distinguished viewpoint 
provides salient examples sort analysis performed hasti costh 
time exploration continues evaluation hasti costh 
establishes applied analyze important tools issues research domain 
shows interesting things say 

rmtool example rmtool example rmtool prototype tool designed reverse engineering software comprehension 
really precludes applied tasks problem domains rigi original intent rmtool understand software systems 
consequently application scope adopted section 
rmtool interesting case examine reasons 
firstly relatively general tool perform different tasks 
test driving case 
immediately provides strong bias explanations support overly task specific explanations need generalize tasks 
furthermore relatively novel tool field 
differs tools way combines visualization automated software analysis 
terms tools research important understand novelty lessons learned easily applied 
addition rmtool craft credibility 
publications contain evidence gathered authentic realistic case studies tool 
research prototype tool successful received researchers adopted similar approaches clayton 
rmtool interesting tool analyze authors rmtool reasonably documented design iteration cycle 
iteratively refined design prototype tools engineers field 
possible travel back time earlier design stages see design theories anticipated changes designers 
able doing suggest theories generative capabilities 
section unfolds follows 
brief description rmtool readers encouraged refer literature thorough descriptions 
main features tool analyzed cognitive support hasti costh 
theory account compared experience reports rmtool 
section costh shown able reconstruct design insights gained experience 
tool usage description rmtool lightweight tool designed largely unix tradition flexibly programmed combines easily variety tools 
boundaries features somewhat difficult establish 
essence consists logical entities 
low level model llm extractor 
analyzes source code interpret features possibly weak semantic understanding functions variables function calls ontology see welty 
extractor produces low level model code 

high level model hlm editor 
rmtool implement editor user presumed able define hlm manner modeling head piece whiteboard model specified simple text format text editor 

rmtool example 
map editor 
maps specify relations 
maps represented text strings reality editor text processor user finds handy 
key enabling technology declarative map specification language 
main advantage map specification language simplicity flexibility leverage regularities way source entities textually represented regular naming 
map hlm combine form may called interpretation llm 

model calculator 
automatic tool takes input hlm llm map generates reflexion model 
loosely speaking reflexion model representation hlm map correspond actual structure system 
appropriately described evidence accuracy interpretation 
described detail scenario 

tools investigate reflexion models 
graph visualizer depicts reflexion model graphical form 
tool allows engineer examine evidence 
tool summarizes way declarative map interpreted 
software constituting rmtool consists items 
context rmtool designed situations experienced systems developer trying modify evaluate system unfamiliar 
experience great deal knowledge applied understanding system 
particular software development tasks pursued user important required understanding needed system structured 
scenario best ways understand rmtool scenario 
scenario software engineer understanding unix kernel 
scenario rmtool literature narrative modified slightly presentation purposes reader may refer literature details 
illustration general process technique shown 
goes follows 
extract llm 
engineer selects configures tools extract low level source features relationships interest 
example assume tool configured scan source code generate graph functions calling relationships 

define interpretation 
interpretation summarizes engineer current focus beliefs possible structure system 
defining interpretation involves defining entities 
rmtool example user actions tools system data extract llm extractor llm define modify interpretation map hlm editor hlm map compute reflexion model rm calculator reflexion model investigate evidence simplified flow rmtool sessions define hlm 
deep domain knowledge software engineer generates model expected structure unix system considered 
partial model 
model defines set high level entities relationships mapped llm 
simplified illustration appears 
diagram boxes represent logical entities arrows represent expected relationships 
example relationships presumed calling relationships modules 
define map 
engineer defines map hlm llm 
intention map map hlm features llm features map relationships hlm features relationships llm features 
example assume map hlm maps functions file pager pager node functions declared file filesystem node 
pager filesystem pager filesystem kernel fault handler hlm kernel fault handler reflexion model divergences legend illustrations rmtool hlm reflexion model outputs 
rmtool example 
compute reflexion model 
generates evidence 
illustration reflexion model appears 
reflexion model consists main classes entities relationships defined hlm entities supported analogous relationship llm 
shows pager kernel fault handler 
example means llm function calls occur functions pager 
divergences divergences relationships llm entities anticipated interpretation indicate expected relationships llm 
shows sets divergences set 
divergences mean function calls occur unaccounted functions defined pager pager 

investigate results 
reflexion model indicates interpretation llm accurate inaccurate 
engineer scenario believed interpretation matched llm structure step evidence implications validity engineer current beliefs 
engineer free investigate results way desired 
main aim investigation establish validity interpretation hlm map 
rule thumb generally indicate interpretation accurate divergences generally indicate problems interpretation 
specifically divergences usually indicate engineer anticipate relationships llm generally indicate engineer expected certain relationships reality 
potential circumstances rule thumb may broken engineer investigate evidence see unimportant unrelated issues 
instance engineer may find divergences result relatively minor unimportant violations modularity system 
may choose ignore exceptions 

go step refine interpretation 
evidence drives refinement 
process hopefully convergent evolution 
hlm map iteratively refined actual llm structure satisfactory degree 
investigation evidence drives refinement particularly investigation contradictory evidence divergences 
initial interpretation guess structure system length iteration cycle related initial guess words best reasons rmtool refine hlm inaccuracies user knowledge uncertainty accuracy 
tool externally represents imperfect knowledge 
addition engineer investigates contradictory evidence point 
engineer gains understanding system increased level confidence interpretation valid 
secondary aim establish suitability llm extracted tools 
scope may need expanded example 
activity significant analysis focuses primarily fixes hlm map 
repairing updating llm added ensuing discussion changing character left exercise reader 

rmtool example far reported experience rmtool indicated general process relatively simple quick successful 
knowledgeable engineers trouble defining hlm 
able specify maps quick browsing source base determine names candidates 
undue difficulties sorting evidence order discard superfluous arcs reflection model 
interpreting rmtool hasti rmtool literature job describing advantages rmtool approach 
literature thin advancing clear explanations apparent success rmtool 
knock rmtool authors done single dissertation papers 
problem adequate explanation remains 
wit psychological principles primary goal aid software comprehension task obviously laden psychological implications 
case tool aiding software comprehension successful part result principles psychological sciences 
subsection provides possible interpretation cognitive support principles underlying rmtool 
perform explanation hasti augmented domain specific model comprehension activities 
recall hasti framework modeling assumed framework augmented added required area application 
case analyzing rmtool features general comprehension task comprehension processes need added 
purposes done proposing modeling novelties 
possible directly refine hasti prior model software comprehension brooks model 
preexisting comprehension model lead directly design ideas employed starting point analysis 
specifically hasti augmented relatively straightforward costh examine rmtool distributes cognition section 
distribution analysis provides complementary understanding rmtool features viewpoint cognitive distribution 
addition realistic design scenario evaluated 
motivating context design scenario provided published reports design iteration 
analysis proceeds show aspects design improvements reconstructed costh 
explored section 
brooks top comprehension model years ago brooks proposed model expert comprehension software 
brooks original works studied modestly sized programs evidence suggests basic points generalize large scale system comprehension 
central argument brooks model circumstances expert software developers extensive knowledge drive comprehension processes 
knowledge process precisely context expected effective rmtool 
suggests wishes understand benefits rmtool may fruitful attempt brooks model starting point analysis 
specifically match brooks 
rmtool example model context rmtool suggests brooks model refine hasti point interesting arguments rmtool supports comprehension 
done follows 
brooks model contains key features cognitive task analysis suggestion mental representations comprehension analysis comprehension processes 
inserted augmentations agent model hasti 

cognitive task analysis 
brooks argues comprehending program amounts generating reconstructing hierarchical mapping models 
called domain bridging 
models start domain level proceed various intermediate levels mathematical methods system structure models 
model consists part set objects relations mapping models consists bindings higher level objects relations lower level objects relations 
particularly unusual hierarchical way modeling software systems resembles hierarchical models software systems byrne ller 
comprehension system posed problem generating internal representation hierarchical mapping mental model 
brooks explicitly argues specific tasks required model partial consisting partial mapping relevant aspects 
cognitive tasks involved generating model include retrieving relevant structures expert memory verifying binding searching evidence binding recognizing conditions contradict current assumptions backtracking refining model 
tasks described detail discussing processing model 

mental representation model 
point comprehension process assumed mental model system tentative collection hypotheses 
models level considered high level hypotheses system standard unix virtual memory system 
bindings lower level models considered sub hypotheses file system implemented functions 
evidence accumulated hypotheses comprehender certainty hypotheses assumed recorded 
way contradictory evidence comprehender determine refine model 

processing model 
brooks model called top 
partly portrays comprehension knowledge driven activity called top hierarchical mapping built starting high level domain models working downwards low level code models 
aligns called top software development methods propose programs hierarchically refined analogous manner 
brooks argues develop high level hypotheses meaning structure system studied program name 
set gross hypotheses hierarchically refined bindings considered verified 
verification hypothesis performed searching confirmations 
search fails encounters contradictory evidence 
leads failure verify hypothesized binding 
causes backtracking 
rmtool example occur resulting refinements higher level hypotheses 
processing occurs full partial hierarchical model constructed confirmed degree required 
significant aspects brooks model 
refining hasti brooks model aspects brooks model quite easily integrated agent model hasti 
call integration td hasti 
features 
mental model refines process panel primary contents 
history panel includes prior states revisions 

control agenda panels contain pointers mental model 
case control panel pointers indicate high level hypotheses model guesses organize plan exploration sub hypotheses 
case agenda indicate attention divided various related hypotheses different model levels 

main cognitive tasks brooks model assigned separate agents 
time relatively considerations stratification strata 
merely assume memory recognition processing occur rule level show verbal protocols remaining assumed occur knowledge level 
may helpful visualize resulting model sample 
simple extension agent model aspects td hasti lead consider properties comprehension process 
agent hardware map hasti possible anticipate hypothesis progress sub hypothesis exploration state agenda subjected restricted stm capacities 
suggests understanding complicated software complicated hypotheses difficult overload limited stm resources 
suggests pending hypotheses occasionally forgotten systematic hypothesis investigation suffer planning failures 
taxonomy suggests backtracking searching hypothesis verification processes effortful normally done skilled actions 
addition analysis generally suggests coping strategies may employed reduce number hypotheses explored 
tool analysis scenario td hasti essentially disembodied model comprehension 
tacitly assumed comprehension occurs context simple tools simple editor set code 
brooks model compatible projected applications rmtool 
trick analyzing cognitive support rmtool re conceive rmtool distribution td hasti 
exposes number cognitive supports 
re interpretation rmtool done viewing features 
rmtool example mk rs control traverse model backtrack agenda refine model verify hyp retrieve problem verify hlm llm map search recognize evidence evidence buffers source refining agent model brooks comprehension model mechanisms distributing data processing modeled td hasti hypotheses verification 
done follows 
data distribution hypotheses 
hlm identified high level hypothesis td hasti 
map considered collection sub hypotheses bindings associated model hypothesis 
construction interpretation rmtool version domain bridging 
key step rmtool externalization hypothesis refined pg state 
brooks notes initially extracted expert knowledge comprehender uncertain veracity 

processing distribution hypothesis verification 
hypothesis verification partially distributed rm tool 
involves externalizing search verify cognitive tasks td hasti see 
computing reflexion model uses interpretation effectively search possible small aside required 
brooks domain bridging complicated example interpretations rmtool literature high level structural interpretations 
consistent brooks theory preclude rmtool applied generally brooks mind terms domain bridging 

rmtool example evidence may confirm hypothesis 
arcs resulting reflexion model constitute potential sources evidence accuracy sub hypotheses bindings 
confirmation evidence evidence generated 
partial distribution verification arcs investigated engineer order determine implications reflexion processing capable determining evidence relevance user 
saves great deal individually navigated examined 
hypothesis exploration td hasti depends capability remember pending goals wholesale processing hypotheses suggests evaluation hypotheses systematic thorough 
view rmtool distributes computation td hasti significantly altering essential qualities 
visualize consider illustration 
shows rough illustration rmtool look drawn virtual blackboard architecture uninteresting features omitted partial hlm 
idea virtual blackboard architecture encapsulate details user computer share memory coordinate processing 
viewpoint virtual abstraction blackboard memory directly shared user computer processing done human computer 
view rmtool merely shuffles location data processing 
analysis main cognitive support rmtool provides distribution hypotheses processing 
externalizing hypotheses reduce cognitive burdens increase complexity hypotheses explored 
external processing means cognitive processing loads reduced 
new task burdens introduced course externalizing interpretation invoking tools overheads form device cooperation overheads 
burdens tolerated cognitive support provide 
evaluation cognitive support rmtool aligns nicely analysis murphy main difference accounts considerations stem entirely application pre existing task analysis theory cognitive support applied analysis 
evaluations completely independent eminently compatible 
human shared blackboard problem computer retrieve backtrack hlm llm map search verify pt recognize pt evidence evidence verify pt recognize pt virtual blackboard illustration rmtool processing 
rmtool example arguments cognitive support rmtool hasti costh significant supported rmtool documentation 
example consider visual presentations provided rmtool accessing evidence 
main facility provided source summary displayed arc reflexion model visualization clicked 
summary displays llm features interpretation bound 
presentation serves collect localize llm features 
source code viewed external knowledge held external memory localization viewed way collecting memory paging scrolling file loading need performed 
considered example automating memory management operations vh 
investigation informative test drive hasti costh 
tool evaluation scenario gives strong indication hasti costh broad scope say interesting things analyst 
rmtool real tool current research interest 
hasti quite easily refined applies rmtool 
costh able recast arguments rmtool terms instances cognitive support 
design envisionment scenario early prototypes rmtool lacked features added versions response user feedback 
type iterative development way unusual hci se 
instance software development tools frequently refined better match practices individual organizations users tasks singer 
question design theories help anticipate requirements tools necessary features discovered tools delivered users 
impossible fully answer question retrospective analysis prior design histories hindsight say 
results suggestive 
rmtool published design history provides case point 
analysis prior subsection types support may considered 
sensible suggest analyzing distribution turn points rmtool authors originally missed 
particular aspect analysis may quickly draw analyst attention partiality processing distribution 
specifically adopts design stance see section places high priority distributing problem solving data stance lead search design space see section additional ways doing 
presents summary sort design reasoning reasonably progressed costh 
thinking distributing td hasti evidence analysis automated rmtool partially checked user needs sort evidence provided refine interpretation appropriately 
example human computer coordinate efforts 
specifically coordinate resolution evidence 
computer fully evaluate evidence relies human able distinguish irrelevant important cases account 
user series decisions regarding salience meaning various bits evidence 

rmtool example computer take account processing user incrementally externalizing relevant decisions interpretations 
time may fine say user keep track decisions evidence hardware model state mapped limited memory suggests apt forgotten 
helpful offload knowledge 
computer display externalized state evaluation turn help regulate coordinate user actions 
addition external memory act shared memory coordination computer records displays action cues user 
note retrieval backtrack steps unsupported 
may pay dividends consider distribute sub process 
preceding analysis leads suggestions cognitive support 
pg state 
memory state evidence evaluation offloaded 
includes decisions ignore particular llm features remove consideration features understood important accounted interpretation 
term data evaluation tracking state 

vh vm 
evidence processing reflexion model calculation take externalized evaluation tracking state account 
reflexion model processing decisions ignore evidence improve display evidence 
prime candidate filter ignored evidence pare effective working set size problem state 
reduce contention working memory reduce display clutter 


display indicate system progress evaluating evidence 
specifically evidence visualizing programs externalized exploration state display visited unvisited status form 
combination elision unimportant links implies unexplored plan states hypotheses evaluated fully externalized pg state 
externalized plan execution state structure ensuing sub hypothesis resolution 
cases unexplored plan steps form agenda pending sub goals agenda 
user employ strategy externalized agenda determine sub hypothesis examine 
type externally cued activity form display problem solving 

sp 
assisted perceptual cues available determine action perform 
instance helpful visually highlight arcs reflexion model visualization contain unevaluated evidence 
user able visual search determine evidence examine 

sp sa generating initial hlm may simple matter recall user may able simply transcribe internal understanding system 
knowledge externalization difficulties known knowledge engineering community 
implication model externalization process problem solving step circumstances 
general notion refer section applied 
rmtool example hlm editing tool way helping users reflect knowledge encouraging 
rmtool current implementation currently allows roundabout form feedback 
immediate feedback gained externalizing model may helpful 
particular modeler able skills visually judging correctness model diagram externalized 
view externalization process minimally planned loop feedback serving quickly correct anomalies 
little mentioned rmtool literature regarding initial hlm generation users easily externalized working initial hypothesis 
instance mentioned users worked hlm suitable medium whiteboard scrap 
provide reasonable medium 
regardless specifics examined cases analysis suggestions possible usage contexts 
cases modeler uncertain structure employed system modeling tool may important externalizing working hypothesis 
cases modeling tool may closely resemble knowledge modeling tools brainstorming knowledge acquisition see kremer 
certain cases extensive modeling may considered prerequisite step trying map models code clayton 
cases support provided externalization medium may especially come fore complexity modeling process may require external memory 

pg state history 
backtracking expected hypotheses fail unanticipated interactions llm 
backtracking may involve unrolling decisions features hlm map commitments ignore certain aspects judgments interpretations supportive evidence 
problem solving states partly externalized mechanisms recording past states derivations may helpful 
specifically offload memory requirements user 
addition rollback methods available undo version management systems rollback processing distributed 
updated rmtool contains features implement cognitive distributions 
particular second version added tagging annotation features 
tagging features allow user tag specific arcs reflexion model indicating considered temporarily irrelevant 
visualization engine uses tags elide evidence arcs 
interpretation changed relevance evidence change tags undone 
annotation mechanism allows user externalize arc resolved 
visualization engine subsequently indicates resolution status visually displaying fraction evidence resolved arc diagram 
enable visual search goal examine enables form display processing 
tagging annotation facilities effectively implement cognitive distributions suggested 
experience shown features significant aspects rmtool approach 
fourth fifth sixth considerations visual search backtracking currently poorly 
rmtool example explored rmtool implementation 
point including illustrate relatively systematic way design considerations brought 
needed task analysis collection cognitive provided costh 
result reconstructed supports offered design iteration suggested additional design choices 
suggests costh limited purely retrospective analysis 
summary implications rmtool analyses analysis scenario design scenario described applying hasti costh problem rmtool design 
analyses generated scenarios demonstrate hasti costh powers reconstruct central rationales rmtool design 
analysis involved understanding rmtool reorganize cognition comparison relatively unsupported cognitive task analysis 
support analysis consisted costh theories reconstruct arguments specific design features 
design envisionment analysis consisted walking costh see different ways distributing supporting cognitive tasks performed 
important note hasti costh interact existing cognitive models 
hasti shown able sufficiently compatible existing cognitive model hasti guided support analysis proceed 
example able prior scientific jump start tool analysis 
time application costh highlights limitations prior cognitive modeling methods 
instance consider problems applying cognitive model software comprehension von mayrhauser 
model capture important roles externalized hypotheses automated reflexion analysis 
main reason obvious model explain rmtool changes cognitive processing better 
assumed model holds regardless tools employed 
comprehender modeled posing hypotheses trying answer contributions rmtool need accounted probably ad hoc fashion 
past experience sorts models led similarly methodological design argument reconstruction 
instance past model von mayrhauser primarily critique toolsets provide adequate information access methods constrained program investigation methods 
sufficiency filter analytic theories rmtool clearly demonstrates hasti costh encompass pragmatically important scope application say interesting things tool analysts 
design scenario enlightening props drive theory design 
main purpose design theory suggest design options understanding problem context 
costh clearly rmtool 
recall quoted singer asked knowing programmers top strategy understand code inform tool design 
doesn tell kind tool build 
concur 
required addition design theory similar form costh 
small design scenario demonstrates top model code comprehension td hasti helpful considered combination design theories 
design theories provide interesting theory backed explanations usefulness tools appear hold promise able suggest useful 
rigi example tool features 
rigi example prior section rmtool established general procedure applying hasti costh analysis design scenarios 
section considers reverse engineering tool rigi 
purpose looking rigi reinforce view example expand breadth scope show theoretical frameworks limited analyzing rmtool tools 
example emphasizes independence theory derivation presenting analysis program comprehension advance tool descriptions 
bottom comprehension bu hasti brooks model top comprehension reversed hierarchy mappings constructed bottom 
means processing primarily data driven inductively interpreting lower level inputs 
implied context comprehender suitable knowledge generate hypotheses code 
interpretation looking code inducing useful abstractions 
blackboard models assume processing mixture top bottom interpretation see carver 
consequently bottom model bu hasti defined relatively simple extension td hasti 
addition studies models bottom comprehension employed fill details td hasti 
analysis studies pennington order augment hasti 
case brooks model prior works primarily considered intra modular comprehension strong hints generalize inter modular comprehension see von mayrhauser 
research pennington supply cognitive task analysis 
certain aspects studies 
pennington contains important arguments irrelevant current analysis 
example strong important distinction external structures stimuli internal representations induced 
issue muted 
td hasti reversed help pennington models follows 
cognitive task analysis 
process comprehension modeled incremental construction partial hierarchical mapping td hasti 
involves number cognitive tasks including recognizing familiar structuring idioms idiom assigning functions files logical module cross referencing related items inducing higher level abstractions cross referencing 
abstraction generation task properties source cross referencing relationships judgments best interpretation source 
specifically cross help determine functional relationships entities close concert pg 

interpreted chunked forming cohesive functionally related units 
remain consistent prior terms abstractions 
rigi example referred 

mental representation model 
analogous td hasti binding evidence different sort cross entities llm combine support contradict particular abstracted interpretation 
specifically functionally related closely cross referenced entities tend interpreted forming entities 
similar manner loose bindings provide evidence separate entities hlm 
inter entity cross referencing densities combination functional cohesiveness primary evidence decide mappings 
instance se terms program modules normally decided collecting functionally related items coupling modules minimized 
hlm abstractions considered tentative collections hypotheses need refined evaluating cross referencing evidence 

processing model 
bottom processing means external cross referencing structures great degree drive comprehension processes 
evidence clich structuring standard structuring schemas ts schemas pennington model recalled organize ensuing interpretation 
instance function location conventions source base pager rmtool example regularities source base generate initial abstraction hypothesis engineer suppose initially functions pager form page management module 
iterative cross referencing presumed incrementally hierarchically build refine resulting 
costh analysis bu hasti analysis possibilities restructuring cognition bu hasti proceed similar manner td hasti 
points 
state 
stm limitations hardware model suggest small easy hold hierarchical abstractions internal memory 
sort external representation postulated offload data 
significantly representation need able represent evidence structure cross 

structuring 
looking system structuring clich known engineer may recalled 
basis constructing initial hlm hypothesis 
construction initial hlm externalized 
involve mechanism defining structure declarative map representing construct procedural methods 

evidence 
evidence evaluation partially externalized formalizing decision procedure metric space evaluating cross referenced entities 
case formalized decision procedure corresponds externalizing clustering mechanisms gd abstraction 

sp cluster evidence evaluation 
evaluating cross referencing evidence requires engineer integrate various pieces cross referencing data mentally 
rigi example create compare alternative groupings 
critical problem recognize functions belong 
help able substitute specialized perceptual operators 
visual cluster perception operator candidate visual cluster perception substitute analysis related functions 
require mapping cross referencing evidence suitable visual presentation classic cross tables 

vh vm layout 
processing may done computer lay visual presentation order invoke cluster perception 

sp sa visual presentation manipulated manually user cluster perception visual feedback order try arrange presentation better configurations 
visual interface medium generating feedback skilled manipulation 
matching features rigi rigi interpreted implement distributions suggested prior subsection 
state 
rigi primary external state resource flow graph 
logical entity represented formalism name 
represent hierarchically decomposed abstractions interconnections lower level entities 
contents available variety visualizations 

structuring 
knowledgeable engineers able script rigi recognized existing structures file naming conventions file hierarchy information clusters 

evidence gd abstraction 
rigi defines allows various metric spaces computing initial abstractions 
include business rules cohesion coupling metrics 
case evaluating rmtool evidence user verify interpretation examining evidence closely necessary 

sp cluster evidence evaluation 
cluster perception possible rigi representing entities cross referencing relationships nested box line graph presentation format 

vh vm layout 
rigi provides layout methods organizing nodes visualization 
layout algorithms chosen map logical clustering visual spatial clustering 

sp sa rigi provides different methods manipulating graph including spatially arranging nodes 
allows users move entities order get visual feedback 

summary summary rigi analysis rigi complicated research product 
contains features ones listed previous section rationales design ones covered 
detract way fact rationales features derived solely theory account cognitive support 
published rigi features consonant foregoing analysis particularly ller 
experience reports appear bear witness advantages expected predicted costh 
result rigi provides example applied theory field experience mutually reinforcing 
analysis rigi helps outline lesson possibilities design theories 
thing note design analysis may preceded tool feature elaboration 
asked hci theoreticians design come initially pg 

scenario answers may spring quite systematic application design theories 
tempting suggest rigi basic form originally developed relatively unremarkable theoretical resources 
required reasonably straightforward task analysis existing theories design theory similar costh 
far am aware rigi constructed systematic application design theory basic ingenuity combination long incremental exposure problems software developers face 
suggest basic design insights way underscore rigi genesis 
contrary rigi authors quite aware essential insights 
appeared craft design theory sorts 
contrast section explicit implicit design knowledge methods 
extra lesson rigi se prospects design theories 
suggests design cognitively supportive tools result insight relatively methodical analysis application design theories 
summary chapter paints picture may interpreted levels 
level deals benefits shared mutually applied theory evaluation theory application 
applied theory evaluation side demonstrates hasti costh broad scope deal high level tool design issues relevant tools research discipline 
rmtool rigi research tools current interest 
theories shown broad scope say things interest researchers discipline 
provide second interpretation experiences field 
particularly interesting reconstruct perceived advantages tools 
theory application side welcome sight 
applied theories provide mediated access underlying science theories 
tools research sorts science backed accounts 
certainly significant attempts past apply various theories explain development tools choi redmiles 
efforts infrequent far satisfying 
addition intuitions tools 
summary building similar lines field point lacked suitable powerful framework articulate ideas 
chapter demonstrates latent psychological claims existing research tools articulated 
means explicitly tested evaluating existing ideas designing new tools variations 
right little known systematically evaluate tools 
currently pit tools pick secondary evidence performance data 
able articulate psychological claims tools possible test claims directly 
instance perceptual judgments rigi substitute knowledge reasoning 
principle directly testable hypothesis 
deeper implication tool building expertise field founded exposing claims encoding independently validated theories 
domain wisdom raw materials tools knowledge applied theories appear catalyst scientific reform credible claims tools 
unfortunately sea tools analyze chapter worth claims analysis smallest advances 
symbolic move difficult 
second layer interpretation chapter concerns relationship applied theorizing tools research 
specifically chapter provides strong indication best performed hand hand 
tools research disciplines set motivating context theory breadth content applied research discipline provides parallel longitudinal accumulation experience suggesting theories generalize practice 
far tell close relationship received fair share attention 
building applied theories part seen problem existing theories trying adapt able apply widely possible see barnard 
alternative research discipline comes list interesting questions wants answer appropriate applied theories suitable 
side fence transforming craft discipline scientifically backed discipline treated process tiny point form results 
instance particular theory cognitive science may imported explain small aspect particular tool 
small experiment run validate explanation 
painting large picture dropping small points paint 
alternative broader stroke integrated applied theories mediate access science base 
akin drawing painting starting fuzzy panoramic outline result incrementally filling details 
starting integrated theories help avoid problem getting individual drops paint come coherent picture 
problem cognitive science past 
importantly intermediate results useful 
concluding chapter find impossible resist including small historical analysis comparing theory development tool development fields 
review history various works referred hasti costh chapter reveals curious facts 
selected year timeline appears 
publication dates cluster year cases merely placed rough proximity 
number relevant building blocks hasti 
summary costh shown right hand side 
rightmost column indicates main contributions theories 
left hand side listed early genesis dates tools section 
listed side points background works 
citations left hand right hand sides timeline listed table order top bottom 
seen timeline critical parts hasti costh clicking place fertile years 
analytic frameworks similar ways hasti costh conceivably constructed soon time version rigi decade rmtool 
grossly unfair tantalizing speculate possible create refine rigi rmtool theory design analysis methods 
likewise rationale rmtool tool conceived theory analysis time certainly years ago 
certainly brought suggest tools constructed earlier 
point field applying similar theory methods design analyze tools quite time 
chapter long time coming 
mentioned chapter integrated theoretical accounts cognitive support overdue important collecting functional theory order analyze design tools 
timeline suggest strongly argues case 
side secondary left right table summary 
summary simon sciences artificial st ed 
brooks coding model includ 
external memory brooks domain bridging analysis cognitive task analysis myers debugging strategies hayes roth opportunistic planning influential opportunism model shneiderman software psychology norman multi stage model precursor simplified model moran clg device vs domain analysis reflective practitioner brooks top model card psychology hci rasmussen srk model norman adapts model hci hypothesis binding model goms model human proc 
substitution hierarchy similar simplified model rigi origins esp workshop suchman plans situated action norman psychology everyday things house workshop hci theory ppig book hayes roth bb model card moran vm analysis hci study pennington bottom model larkin simon words green parsing model larkin display problem solving green cognitive dimensions boehm davis comprehension model hutchins studies precomputation important blackboard model early virtual memory analysis external memory tradeoffs cognitive task analysis comput 
explanation graphics cyclical external update model distributed problem solving broad brush design theory model integration attempt early dc casner perceptual operator analysis perceptual substitution analysis wpc workshop von mayrhauser vans model influential integrated model wcre workshop norman things smart analysis cognitive artifacts rmtool origins zhang norman dist representations hutchins cognition wild dc analytic framework seminal dc text timeline main ideas tools chapter field study cognitive support rods hasti costh proposed intellectual toolkit tools researchers developers 
candidate theories frameworks built specifically purpose raising answering questions cognitive support 
fully realize potential researchers access effective methods toolkit analytically empirically 
chapters developed ways applying rods hasti costh analytically 
chapter aim answering question apply empirically 
theories encode knowledge question empirically yield answers regarding tool design questions 
mean toolkit context laboratory field study purposes exploring cognitive support issues directly answered theories 
theories powerful lead important questions answering outright 
data gathered careful observation powerful way augmenting toolkit 
suitable techniques available theory driven empiricism may potential weapon arsenal methods systematically designing engineering cognitive support 
applying cognition related theories empirically way relatively unusual proposition 
cognitive science hci main reasons going lab field validate verify theories gain new understanding suitable deriving new theories refine knowledge context design 
instance consider research programme advanced von mayrhauser 
proposed apply cognitive model software comprehension field studies 
purpose proposing validate cognitive model understand new things comprehender behaviour 
type empirical study programme unusual 
proposals study tools typically place priority discovery theory building importing applying theories see redmiles 
theories models generally proposed developed empirically analytically goms 
empirically answer directed questions tools relative rarity sorts theories 
valid reasons combining theory empiricism 
question validity cognitive support theory say analytically 
may forced observe tools user study instance 
user study theoretical frameworks important assets see section 
theory guide interpretation activity focus observation analysis 
different types theories proposed way guiding user studies 
example cognitive dimensions framework helpful directing attention important issues hci :10.1.1.134.5007
furthermore theories models useful interpreting hci tool implications understood 
instance von mayrhauser cognitive model software comprehension interpret comprehender needs information 
needs compared information tool easily provides rendering judgment tool efficacy 
theoretical frameworks useful give answers computation prediction 
theories guide assist focused relatively open ended exploration 
key question understand potential various models theories know sort information yield observational studies 
theories models tools empiricism need user manual operator handbook 
main aim chapter explore possibilities hasti costh empirically 
essentially chapter primarily exploration techniques theories 
goal provide techniques useful exploring cognitive support questions pop tool design evaluation 
particular focus understanding possibilities leveraging theories yield directed insight observations tool 
objective possible perform routine efficient reliable theory investigations cognitive support realistic situations 
words chapter engineering oriented discovery oriented 
consonant goal choice focus efficient lightweight empirical techniques 
search lightweight empirical techniques important challenge meet 
research development contexts timetables measured months weeks days 
puts tight constraints sort empirical techniques 
existing theory application methods break constraints 
known incredibly tedious expensive see von mayrhauser 
needed experiments fieldwork lengthy costly difficult times analysis methods arduous 
result empirical techniques odds schedules tools developers 
suggestions reducing costs advanced especially making simpler collect process data fieldwork 
examples lightweight techniques include variations discount ethnography rapid ethnography motivated rapid observation techniques 
little done apply reasonably fine grained cognitive theories costh hasti suitably lightweight manner 
great extent possibilities theories costh remained 
goals exploratory field study software developers performed 
may useful study cognitive support laboratory conditions field studies effective 
furthermore field study provides litmus test lightweight methods chances observation technique applied field applied lab conditions controlled effectively 
field study performed order serve basis exploring different ways applying theories intended testbed sorts 
study provided corpus data set theories loose 
addition field study provided opportunity experience challenges collecting interpreting data hasti rods costh guiding frameworks 
added benefit study provides way establishing evaluations validity hasti rods 
possibility ignored see section central focus 
central focus remains exploring potential engineering oriented observation analysis 
choice collect observations practicing developers field strategically philosophically significant 
hutchins strong argument study cognitive processes wild study genuine ones 
get unnatural behaviour study lab 
contention detail section 
suffice say wild place natural cognitive support observed 
hutchins call study cognition wild appropriate discovery inquiry discovering situation specific facts particular cognitive ecosystem building novel theories 
chapter different aim 
attempt employing existing theory shed light uncertainties regarding support provided tools 
may choose wild may specific intentions bringing existing theory returning home new 
focus attenuates call study cognition wild 
chapter unfolds main sections 
section field study design objectives described initial experiences outlined 
section begins examine observation techniques lightweight 
specifically ways hasti costh perform situ shadowing observation methods considered 
second particular observation session chosen corpus collected data 
session test case applying hasti costh 
test case described section analysis performed enumerate cognitive support involved 
specific cognitive support issue question support repairing errors programs 
third section explores techniques coding analyzing test case 
analysis drive exploratory evaluation cognitive support 
effect sections provide context evaluating research scenarios 
purpose study explore methods study documented data collection analysis methods highlighted 
section begins consider scenarios techniques applied 
tool development scenarios considered adaptations scenarios chapter 
purpose scenarios argue analyses sections may useful answering certain support related questions 
scenario tool analyst built cognitive support claim wishes find evidence validity 
theory case allows analyst claims empiricism acts check theory application inexpensive alternative applying powerful theories 
second scenario scaled adaptation design scenario chapter 
scenario cognitive support designer wishes understand specific support types need investigated 
theory case acts heuristic examining specific design options empiricism acts fill parameters values missing theory 
manner fuels considerations tradeoffs 
section illustrates methods sections application scenarios 

field study description section provides brief evaluation field observations comment validity usefulness hasti costh 
study conducted validation experiment reasonable analysis evidence uncovered support theories 
merely responsible reporting 
reporting highly preliminary indications validity may helpful researchers wish expand validation studies 
chapter rounded brief section 
field study description means developing testbed exploring theory application methods field study software developers performed 
section incrementally introduces study 
basic mechanics outcomes described sections contain detailed theory analyses resulting data 
motivations study considered study design outlined observational techniques reported initial summary study described 
motivation background science mind assert science mind laboratory situation artificially relevant theories situation naturally artificially culture 
view way find mind stumble questions need understood fully study natural habitat 
mind set natural habitat need study habitats frequently finds wishes find 
moment wish find constant interaction computer systems track 
thomas landauer relations cognitive psychology computer science pg 

motivations study generated initially considerations tools developers theory developers 
studying designing software development tools theories frameworks important building analyzing support claims 
analytic techniques limits limits reached usually necessary augment empirical methods 
theories help answer question tool observing somebody tool extraordinary helpful 
going lab field observe users raises challenges see chapter 
cognitive support slippery thing observe understand 
easily goes unnoticed removes problems creating 
possibility cognitive support theories assist making observation effort field lab section 
field study performed attempt assess possibility 
field study chosen testing ground 
controlled laboratory study 
answers offered 

field study description reason field study concession needs particular dissertation 
proposes theoretical resources derived different cognitive science hci studies 
generated validated laboratory studies 
lab generated theories incorporated applied theory remains issue resulting theory works real world non laboratory settings 
generalize 
furthermore question models apply significant behaviour occurring field 
theories models relevant 
may possible answer questions completely clear controlled laboratory study little increase confidence generalizability applicability theories real world development contexts 
going field preemptive defense charge theory usable realistic tool deployment situations commercial settings 
section theories evaluated capability field 
limited study 
limited evidence validity collected 
impact evidence significantly task context manipulated laboratory generate expected behaviour 
study industrial strength tools semi professional developers examined field 
hard imagine controlling observation conditions 
theories strike believable apply real world design settings 
second reason attempting field study problems tools developers theory evaluation 
reasonable expect costh hasti controlled conditions field 
performing field studies generally presents greater technical challenge finding relevant behaviour collecting suitable observations 
instance field study normally impossible unnatural get subjects wear eye tracking crosby set video cameras capture behaviour forced task restrictive task environment 
unfortunately instruments eye tracker ways determining certain cognitive supports perceptual substitution effective 
field study quickly brings limitations lightweight theory application 
importantly guards attempting studies requiring unnatural task conditions unrealistic data gathering techniques 
observational constraints inherent field studies better reflects realities tools researchers 
keeps exploration realistic observation techniques honest 
final reason attempting field study behaviour tools developers wish study available field highly realistic simulated situations 
realistic scenarios set elicit ecologically valid behaviour difficult expensive 
reason developers may need observe tool wild 
third reason choosing field study significant theory user point view worth discussing detail 

field study description advantages field research studying cognitive support period months programmers generic skills programming design comprehension debugging ineffective 
programmers attempts thwarted lack facility concepts details new language software system myriad ancillary programs 
lucy berlin program understanding look programming expertise industry pg 

models cognition software development primarily disembodied history free models 
tend portray comprehension development processes essentially universal purely mental activities 
way ignore details capabilities tools fail acknowledge importance interactions tools 
remove consideration differences individual problem solving knowledge skills 
true different models novices experts proposed developers category painted brush 
assumed sampled random little concern expertise tool 
laboratory studies constrained studies packets considered sufficient exploring cognitive models 
sufficient purpose assumed environment impact aspects behaviour modeled 
tool cognitive modeling field tool precisely focus tools researchers 
model statements tools affect behaviour limited studying 
sense universality tool independence models great concern 
fact questions universality tool independence go hand hand universality models broken tool environmental dependencies 
specifically experts adapted differently specific environments individual ecological expertise 
studies expertise simply matter studying generalized expertise universal capable software developers 
expertise adapted environmental component 
different aspects adaptations important studying tools 
aspect adaptation development fluid skills enable higher level problem solving flow naturally 
user experienced tool skills employed frees cognitive resources pursue hard problems 
instance consider experience constructing tricky program unfamiliar editor 
figuring editor task requiring conscious problem solving intrude programming problem solving 
primarily reason classifications expertise hci usually single dimension skill novice vs expert 
example popular distinction domain tool expertise types having affect levels expertise 
aspect adaptation expert tools requires strategic knowledge 
strategic knowledge develops great deal experience applying tools various tasks 
shown true simple forms support 
example 
field study description demonstrated relatively simple tool features ignored users special training provided 
result holds simple forms cognitive support expect importance ecological expertise magnified routine problem solving 
deep strategic skill involved 
type skill question described section 
example skill flexible strategic uses grep certain experts 
grep simple tool describe requires great deal strategic knowledge cross referencing impact analysis 
example clever type checking perform impact analysis described cardelli 
cardelli example developer need call skill recognizing compiler solving problem finding program dependencies 
skill developed methods doubtless pursued 
third aspect adaptation number local ecosystems expertise involved software development hutchins called cognitive ecosystems 
cases ecosystem relatively uniform developers tool expertise relatively uniform 
example organization foster process tools similarly 
done formalized mechanisms tools training programs informal means junior developers senior ones 
corporate culture training lead similarity tool expertise 
frequently ecological expertise software developers created long years self directed exploration 
tool sets process differ greatly 
certainly accords observations experience 
jobs professions airline pilots navy crews air traffic controllers learning solve problems available tools significantly systematic explicit strongly apprenticeship 
contrast software developers tools users learn substantially doing 
learn tools available needs arise performing learning process 
learning haphazard 
result individual offices may develop vastly different tool cultures affect tool strategies workers 
furthermore real professional development environments rich complex 
undirected learning flexible space leads idiosyncrasies ch 

specific history problems tackled may lead different repertoire tool uses 
program editors simple prime example programmers greatly attached specific editors leads efficiency strategic individual command sets 
proficiency complicated editing tasks drop quickly unfamiliar editors 
developers may heavy programmable text editor may sophisticated users programmable tools sed awk 
fourth aspect adaptation comes specializations developers environment 
developers known adapt environment writing scripts macros customizing windowing environments organizing information space file systems documents strategically 
berlin true field study programmer expertise 
effectively developers construct local ecosystem best 
times leads familiar condition developer find significantly awkward developer environment setup 
cases adaptation user environment help blur distinction 
field study description adaptation low level skills strategic knowledge local cognitive ecosystems environmental customization problems laboratory studies expert users typically needed expert users typically needed population sampling problematic poor transfer expertise lab situations table potential problems caused dependency cognitive support adaptations humans topic study human tool systems topic study 
expert developers may quick adapt different environments point unfamiliar terrain able easily tools problem solving strategies familiar 
implications empirical studies cognitive support aspects ecological dependence pose potential problems studying cognitive support 
table summarizing problems table 
observe fluid cognitive supports subjects may need possess deep familiarity tools skills efficiently problem solving knowledge strategically 
requirement challenged idiosyncrasies tool expertise number local cognitive ecosystems developers 
furthermore knowledge skill elicited tool environment task demands may need closely match field 
contexts problems prominent may compensated way 
cases easiest route satisfying conditions observe tools actual settings 
need plays differently practitioners researchers 
practitioners interested developing cognitive supports real client settings 
quite polished comprehensive tools established client base 
practitioners develop commercial tools main implication adaptation dependency may need visit client order understand tool practice 
contextual factors impact tool observed 
times importance apparently mundane artifact features realized watching features 
tools researchers normally interested developing techniques generalizable 
frequently deal research prototypes truly called expert 
researchers main implication adaptation dependency usually unable find subjects experience tools tasks 
simple training sessions normally subjects tools effectively strategically 
relatively simple programming tasks week learning elicit informative uses development tool 
experts difficult get time study 
watching demanding subjects 
sum field studies frequently desirable studying cognitive support challenges sufficiency filters techniques proposed 
reasons 
field study description field study thought worthwhile method exploring cognitive support theory applicability 
study design subsection describes design study including stated objectives format participant recruitment procedures study session procedures interview session procedures 
objectives study designed exploratory investigation 
directed study usually clearly articulated study objective hypothesis test 
case objective discover novel observations show cognitive support effectively analyzed hasti costh 
addition assumed learned possibilities difficulties fieldwork just performing study 
time study design costh hasti early prototype form 
ideas eventually applied entirely clear time exactly done 
reasons considerable uncertainty study design phase 
uncertainty impacted study design creating objectives problems overcome 
unclear time data needed collected concerned recording rich collection data analyzed leisure 
wished corpus realistic observational data provide suitable testbed analysis 
main objectives fieldwork establish possible limited time constraints gather rich authentic observations developers tools 
important secondary objective try shadowing method situ coding determine advantages pitfalls 
described detail section 
study format study took place week span 
participants instructed contact suitable times prepared observe 
observation sessions scheduled specific times clear normally ready collect observations short notice full time study located site moderate walking distance participants 
participants encouraged initiate sessions informed number sessions zero maximum allowed 
session day permitted 
optional interview session encouraged 
format participant engaged sessions recruitment session study sessions optionally interview session 
participant initiated observation technique important part study strategy reasons 
firstly helped limit observations relevant development activities 
participants 
field study description expected perform variety activities day week 
initiating observation times participants ensure sessions observed productive filled primarily tool development activity 
wished collect data authentic tasks assigned tasks alternative follow great deal time 
doing difficult gather detailed data able capture 
secondly participant initiated protocol expected beneficial participants 
control sorts activities permitted observe 
allowed select activities comfortable observing permitted observe 
allowed schedule observation sessions convenient 
informal discussions participants impression satisfied time wasted 
noted circumstances self selection setup criticized suffering participant selection bias 
example charged participants select showcase tasks felt comfortable competent 
exploratory study threat accurate behaviour sampling considered inconsequential 
observations collected confidently say participants selected showcase activities appeared solving ordinarily challenging activities displayed considerable degree difficult problem solving 
participants participants recruited large research institution 
participants involved ongoing research development 
participation study cases expressed knowledge approval participants supervisors 
participants volunteers 
pre screened ensure years programming experience working programming related project lines code months experience general programming environment working 
recruitment protocol exception recruiting subject directly personal contact recruitment performed stage process 
supervising manager team approached general purpose study explained 
permission carry studies employees sought 
considered important receive permission recruit participants inclusion study 
addition supervising manager asked recommend potential participants aims study 
specifically supervisor asked recommend active software developers 
initial recruitment meetings participants general aims study explained methods collecting observations described 
potential participants advised participation entirely voluntary withdraw absolutely time 
informed request time collected data destroyed 
emphasized study concerned tools 
field study description performance particular 
told main aim study help researchers build better tools 
told session minutes 
informed schedule informal interview session finishing observation sessions 
recruitment session provided short questionnaire intended establish simple facts backgrounds 
text recruitment invitation research description card survey questionnaire participant instruction card respectively 
participant received copy items recruitment session 
key part recruitment meeting provision instructions establishing suitable time observation session 
participants informed goal sessions observe tool program maintenance program understanding 
told observe minutes certainly longer minutes 
instructed contact email schedule subsequent sessions informed respond email soon possible 
allowed schedule initial session right 
participants chose 
observation session description protocol main part study consisted sequence observation study sessions 
took place participants normal workplaces 
starting session recording software installed workstations see 
addition survey responses collected completed 
session instructions generate verbal report 
instructions closely matched appendix slightly modified instructions taken standard experimenter handbook 
subsequent study sessions asked wished review instructions verbal report generation 

session configured recording equipment see ensured workplace private shutting doors necessary 
participants worked normal office space shared office space 
working manner appeared routine activity participants 
observations interrupt participant fell silent extended period time time gently reminded think aloud 
happened twice 
interview sessions study protocol included optional post study interview session 
participants chose post study interview 
formal interview setting participants chose chat informally study sessions 
notes conversations 
formal notes far proven valuable interviews may better pursued vigorously conducted reviewing collected data 

field study description microphone participant workstation high speed network camera field view participant recording server video camera tripod laptop computer observer typical observation configuration observation methods data collected automated recording techniques combination 
illustrates typical configuration study session 
positioned side video camera camera outside participant line sight 
video audio video camera trained screen participant workstation wide field view capture screen participant normal interaction computer 
usually user screen filled roughly resulting field view 
intent video capture activities looking read printed documentation pointing screen basic features computer screen goal video record focus participant computer screen 
sensitive separate microphone placed nearby individual 
able create suitably crisp recording subject keystrokes mouse clicks verbalizations 
lapel type microphone clipped unobtrusive 
computer screen recording detailed recording computer screen specially modified instrumentation software 
recording software reminiscent commercial screen capturing products utilized similar observational settings graham 
verbatim capture screen critical study 
screen sizes participants ranged monitors high refresh rates 
impossible capture details screens resolution standard videotape certainly unobtrusively 
worthwhile describing software 
field study description key enabling factor sort field study 
recording software specially modified version free gnu licensed software called vnc 
vnc stands virtual network computing 
original purpose remotely view control computer including relatively slow network links 
software runs multiple platforms including unix windows macintosh computers 
portability software important study participants mixture unix windows nt 
software consists parts server client 
server machine control view case server participant machine 
standard unmodified vnc server software installed participants machines 
vnc software small small load machine common computer activities 
unix version client software modified record server participant screen data 
recording software kept running networked linux machine large hard disk see 
data participants machines saved automatically central location 
need recover captured data participants machines impossible forget data extremely difficult run disk space recording 
recorded screen updates mouse movement stamped date time 
time stamping done recording server inaccuracies advantage offthe shelf vnc server software installed participant machines matter participant machine clock inaccurate 
reaction installing software uniformly favourable 
server software easily removable participants asked remove 
participants interested functionality software 
participants glad able install software interested controlling machines home desks colleagues 
study session participants eagerly requested show worked network replay recorded session 
called workers discuss possibilities transform existing practices 
vnc recording software efficient type participants doing 
exception participant appeared notice appreciable slow downs machines asked report slow downs installing software 
partly way server software operates example screen updates sent update frequency throttled effective network bandwidth 
addition generated data files quite small 
largest computer protocols collected megabytes length minutes computer recording screen resolution bit kilobytes second average high burst rates 
computer logs megabytes minutes 
small data footprint feasible capture large quantity computer protocols 
size recording client side server side caused certain errors resolution accurately stamping time 
problem networking latencies caused stochastic skew arrival times updates 
arrival times recorded machine clock resolution microsecond arrival times randomly shifted 
test runs suggested time skew problem intranet study 
subjective experience specific network time skews perceptible significant better say ip telephony delays 

field study description time code text comm split screen represent search context context plan state 
comm note doesn rcs undo revision checkpointing system comm backup thinks going massive changes checkpointing comm temporary memory plan write comlex took time try documenting snippet coded field nodes verbatim 
inexpensive modern hard drives reasonable consider automatically collecting computer recordings months average days manner 
addition recording software small conversion program written convert resulting data avi file 
avi file standard windows file format encoding time synchronized data streams audio video 
compressor decompressor component codec written windows windows machine shelf display editing software display manipulate corresponding avi file 
experience best post process resulting avi file re compress free codec 
free codecs tried reduced quality recording expanded file size tradeoffs manageable 
main advantage recoding computer logs easier exploratory viewing protocol coding 
partly due fact large displays participants modestly resized recoding process sacrificing legibility 
possible view large screens modestly sized computer screens 
turn possible add synchronized display verbal protocol action codes 
accomplished simple perl script created closed captioning commands playing closed captioning commands standard feature windows media player 
advantage post processing recoding support efficient seeking skipping 
digitized recorded audio added avi file 
result post processing full recording computer screen synchronized playback verbal protocol synchronized display transcription 
avis played virtually windows machine mac linux machines 
probably better able record verbal protocol participant machine time screen data recorded 
useful streamlined way producing avis 
techniques recorded notes study session 
study session notes written laptop computer 
technique adaptation shadowing field technique singer 
technique real time coding activities performed observers keyframes introduced video stream 

field study description code description sample logs comm comment usually record thoughts participant questions research struct follow structure external environment external plan instance tool system extern externalizing information structures expert example strategic expertise tool program way wanted just answer wanted fluid motion finding debugger skilled note calling relationships incredibly simple didn know note history mechanism didn think testing environment explicitly structured quickly set state needs test new code scrolling gain context forward search function name stacking splitting window represented history table codes event types shadowing observation technique laptops 
laptop runs word processor simple macros help enter time stamped notes stylized manner 
time stamped note invoked typing simple control key sequence 
time stamp written record cursor left comment field observer type notes associate event 
different key sequence defined event type code 
codes study replicated table examples taken verbatim logs single session 
observations observer watches action tries interpret participants doing 
observer records events significant cognition distribution tool support 
sample notes reproduced 
practiced coding test run sessions coding method working envisioned 
felt productive coding technique directed useful 
instance comm code far common noted event events logged frequently felt directed coding scheme specific codes catch comm code 
reviewing notes clear assigning codes done post hoc just easily situ 
sessions changed comment style notes tagged time 
result situ time stamped log comments coded situ 
comments experience 
addition situ notes free form notes generated post hoc 
immediately session sat wrote notes impressions ideas trying deeply singer synchronized shadowing technique 
observers code different aspects interaction shadowing technique 
shadowing coder 
second observer coding computer automated computer logging 

field study description notes notes participant total situ post hoc id task description sessions minutes entries pages adaptive maintenance unit testing coding source change merging design coding totals table summary data collected study interpret 
staged technique tried theoretical practical reasons 
theoretical front rightly place great deal emphasis making notes field 
observer field access great deal context simply unavailable limited slice data collected automatically 
view situated observer type highly sensitive intelligent instrument notes secondary data aiding post hoc interpretation 
practical front notes considered possible way allowing researchers quickly zero interesting observations 
generally speaking protocol contain activity interest tools researcher 
highly directed observer may notice particularly interesting parts protocol right away 
notes effect direct post hoc coding relevant data quickly 
wished see notes way 
test run pilot study began test run protocol conducted volunteer 
volunteer student conditions observation closely resembled conditions participants study 
test run performed primarily ensure study session scheduling video techniques ran expected 
test run taken opportunity test subsequently tweak note coding scheme 
addition test run served rehearsal session introductions provided practice making useful field notes 
computer protocols recorded test run 
stage summary study continuing analysis data overview summary experiences reported 
overview data collected table presents summary observational data collected 
small fraction directly subsequent analysis 
partly due exploratory nature study questions investigated scope 
types activities qualities 
context research scenarios tool interactions vary considerably participant individual study sessions 
activities session may useful investigating theory application scenario 
point point terms study open ended analysis allowed permission granted archive collected data number years 
permit return data new analysis methods proposed 
example approach flor studies programmer pairs 
noted resistance obtaining ethical approval longer term data archival 
helped point methods typical fields cultural anthropology argue archiving data permanently 
study limited time frame appropriate type exploratory study open ended analysis requirements 
observation session examined remainder 
limited scope analysis reflects primarily limited amount time space devoted exploration 
addition limits partly function reporting techniques appear necessary 
problem details individual contexts need conveyed activity understood 
requirement difficult participant length chapter balloon considerably 
reasons particular participant observation session chosen early analysis stage analyze 
session relatively simple appears demonstrate types cognitive support 
taken mean sessions contained interesting observations 
notes shadowing technique attempted met mixed success 
synchronized shadowing singer key goal reduce reliance tedious time consuming post observation coding 
coding done situ real time field 
means observer rich context help interpret activity 
main problem encountered applying similar coding technique case looking extract particular observations data observations 
codes tried generic helpful time 
cases tools researcher may specific hypothesis evaluate specific issue investigate 
highly specific coding technique may helpful 
comments possibility section 
context research scenarios sections observations particular participant analyzed detail 
observations come study session participant table 
purpose section background context needed sections 
section participant motivations context described 
section analysis conducted cognitive support provided tools visual caf 
specifically visual caf examined ability distribute planning support plan 

context research scenarios type cognitive support analysis briefly chapter 
intent analysis simulate claims analysis cognitive support visual caf design quality assurance team generated 
chapter field study scenarios claims analysis background scenario 
description participant context description summary information known context 
description recorded data computer record verbal reports notes informal interviews 
developing software system java uml object oriented oo design method 
main tools modeling tool rational rose uml design integrated development environment visual caf java coding 
jargon case computer aided software engineering tool vendors rational rose upper case tool visual caf lower case tool 
developed code windows 
system working part large ongoing research development project contained web interface complicated ai information system 
familiar oo development 
recorded observations shown high degree familiarity oo design concepts uml design sequence diagrams cases java language coding idioms exception throwing memory management 
opinion classified expert developer 
judgment expertise am considering demonstrated behaviour consistent currently understood best practices software engineering 
wise reserve judgment expertise engineering largely normative idealized models behaviour development skills experience advanced warrant term expert developer common programmer expertise classification schemes adelson 
deals skilled tools notes need regarding qualities tool tool setup 
kept number applications running sessions frequently switched 
applications include visual caf rational rose netscape navigator 
switched applications clicking icons windows task bar alt tab keyboard shortcut navigate application mru stack windows maintains 
rational rose visual caf applications kept maximized full screen full time observed display side side overlapping 
displayed high level expertise familiarity applications 
look tool usage information printed help manual online help system appeared search menus actions perform 
navigation panes button bars menus fact practiced skilled effortless 
episodes reported verbalizations perform actions tools evident 
java rational rose visual caf netscape navigator windows registered trademarks 

context research scenarios distributed planning visual caf visual caf java compiler editing environment 
interface environment environment common integrated development environments ides see teitelman 
visual caf particular tool participant analysis intended evaluate tool bad respect 
analysis specific tool version tool mentioned broad class tools similar functionality 
main activity interest analysis interaction automated program checking manual program repair 
typical working context common edit compile debug iterative development cycle 
visual caf compiler portion generate list warnings errors regarding violations program partial correctness 
violations associated program position thought location cause violation 
simplicity call error warning simply error 
programmer invoke check program correctness nearly time hitting key sequence pressing button button bar selecting menu item 
output correctness check part list reports errors 
reports specified fixed list schematized report categories undeclared identifier type mismatch 
output displayed special error list panel scrolled 
error list panel simple text display panel effectively action menu 
user click error report forces editor window jump display location report associated 
error list panel maintains internal state currently visited report 
key sequence menu command invoked step internal state invoke corresponding display jump 
description straightforward highlight cognitive support offered developer 
simplified costh analysis similar sort environment section compile mode emacs 
prior analysis revisited related specifically visual caf expanded slightly consider support relates code fixing process 
analyses rmtool rigi trick perform bit task analysis tools reengineer cognition 
portion development task question concerns generating code correctness constraints 
java language defines partial correctness criteria valid programs syntax access control scoping rules typing rules 
constraints checked completely automatically 
automated checking visual caf distributes constraint checks cf 
cases programmer assisted manner pen pad long flight australia programmer check violations 
partial automation program correctness checking understood appreciated community 
somewhat appreciated partiality distribution subsequent human tool coordination design issues crop 
claims analysis costh bring sharper focus 
rmtool rigi examples correctness checking fractional part note historical efficiency reasons correctness checking object code generation compilation performed time 
common usage correctness checking code generation called compilation 
fundamental reason requiring performed simultaneously 

context research scenarios support type tool feature description cf correctness checking compiler cf planning error list generator generates repair plan plans error list plan steps repair program pb options error reports cue repair actions possible vh vm clickable reports automatically pages program location pg state error iteration count holds state sequential order goals error sequence holds sequence goals table list cognitive support claims visual caf programming task 
case rmtool human automated checking cooperatively refined shared representation hypothesized model system studied 
part cooperation consisted cooperative planning hypotheses check 
case automated program correctness cooperative planning high prominence 
programming context studied programmer correctness checker partially distribute program repair planning plan 
automated correctness checking context interactive programming environments offers merely check correctness checker reasonably interpreted repair plan generator 
partially distributes planning repair cf planning 
see merely correctness testing notice visual caf attempts find errors tries determine source line locations cause error renders ordered list messages intended diagnostic cue repair actions 
purpose merely test correctness simple answer suffice 
purpose create list errors way programmer effectively determine execute 
external resource structure programmer subsequent repair activities 
cases programmer refer external plan internal plans 
diagnostic reports suggest possible actions performed repair program reports reify portion space possible moves pb options 
error reports merely listed line numbers supportive role granted 
combination generating external plans visual caf contains features allow opportunistic systematic plan 
emacs compile mode visual caf error report clicked appropriate external memory location paged vh vm 
paging code remove error list panel display contents remain visible making unnecessary remember 
features allow random access plan enabling flexible ad hoc exploration error list clicking various reports 
addition visual caf provides facilities systematic traversal error list 
visual caf maintains internal iterator state traversing linear list errors key sequence advance state 
allows systematic iteration plan steps 
case iterator state distributes plan step state pg state 
programmer need decide goal select error state visual caf implicitly serves externalized agenda repair goals perform relatively new capability compile mode emacs 

context research scenarios sequence agenda 
plan step iteration facilities easier systematically step repair plan 
cases little need correctness checker re invoked low cost regenerate refresh error list 
sense frequent invocation correctness checker amounts type incremental re planning 
incremental planning accounts see young external plan updated result new knowledge result changes task context 
fact case visual caf plan step iteration facilities sensible follow strategy frequently updating repair plan re compiling 
reason strategy sensible stems fact visual caf way visually indicating plan completion status 
frequently recompiling gets limitation removing errors repaired 
simpler follow plan programmer need remember plan steps performed 
reason repairs may generate cascade newly necessary repairs may expose new errors checked automatically semantic errors usually caught syntax errors fixed 
incremental re planning visual caf rewards developer maintaining updated external plan referred determining subsequent action 
allows programmer adopt shallow individual planning strategy maintains minimum agenda internally pick error repair re run checker iterate errors disappear 
note error list reasonably interpreted repair plan context user goals invoking correctness check 
illustrate consider alternative context performing impact analysis 
example due cardelli cited earlier page 
cardelli example developer compiler create list uses particular type able systematic change uses 
requires trick changing name type question uses type generate errors 
case goal running check perform set repair operations perform sequence manual checks uses type 
situation systematic complete iteration error list important desideratum 
quick recap order tool usage contemplated 
context occurs programmer generated modified code wishes engage cycle program fixing 
programmer invokes checker find errors pf construct partial repair plan cf planning 
plan structures subsequent activities 
consults external plan engages sequence repair actions indicated plan 
error list plays role external plan action plans 
repair plan programmer follow systematic iteration strategy error sequence operator follow flexible exploration clicking items error list 
re invoking checker updates external plan 
analysis contains plausible support claims may visual caf imaginary researcher engineer 
claims listed table 
basis generating scenarios researchers perform field studies test examine claims 

exploration data analysis techniques exploration data analysis techniques theory cognitive support research stream blossom se critical component stream undoubtedly ways leveraging theories interpreting analyzing observations 
obvious context trying validate claim cognitive support trying verify proposed support exists predicted 
instance memory thought offloaded offloading looked real uses 
possible context measuring properties support 
instance may wish know memory offloaded compared cost doing 
purpose section explore ways interpreting analyzing field observations sorts questions answered 
consequently section observations participant analyzed claims analysis previous section 
analysis done form base analysis section 
section scenarios similar ones described investigated 
base analysis section starting point 
section proceeds follows 
overview general data analysis approach outlined section 
coding scheme described section coding collected protocols 
coding scheme key technology making focused observations relating cognitive support theory 
coding scheme tailored specifically cognitive support claims visual caf identified earlier 
relevant episodes protocol coded coding scheme 
results coding process described section 
results indicate utilized support expected manner 
visualization shown illustrate aspects explained instance distributed planning 
simple statistical measures applied results 
short discussion included section concerning potential applying similar techniques lightweight manner 
analysis methods technique analyzing observational data similar prior verbal protocol analysis methods 
consisted sequence main steps 
develop coding scheme 
identify possible activities relating claims develop specialized coding scheme identify tag activities 
goal phase generate codes activities related claim ignore activities 
goal adopted analysis focused possible 

extract activity episodes 
isolate activity episodes contain claim relevant behaviour 
start reviewing notes protocols order home activity interest 
review protocols times familiar 

transcribe segment episodes 
transcriptions protocols selected episodes perceived phrasing timing activity 
transcriptions verbal reports computer logs 
case verbal reports transcriptions 
exploration data analysis techniques annotated english 
case computer logs transcriptions short descriptions human computer interaction activity 
segmentation process breaking protocol stream atomic events 

code episodes generate trace 
code selected portions protocols coding scheme 
result coded protocols coded sequence events 
aptly called trace distributed computation 

visualize perform analyses trace 
extract measurements coded protocols relating cognitive support predicted 
exploratory situations mining exercise 
trace visualized comprehension 
classic verbal protocol analysis steps iterated especially coding scheme known advance 
case reported claims analysis able generate effective coding scheme 
tweaking coding scheme needed done change code names remove codes sequential plan exploration 
notes transcription segmentation short note required regarding transcription segmentation techniques 
transcription segmentation verbal reports relatively studied problem prior examples consider 
transcription verbal protocols typically just written english whichever language possibly augmented phrasing punctuation commas 
segmentation done lexical grammatical basis content inferred content verbal protocols goals questions type information studied 
techniques similar domains lightweight applications verbal protocol analysis nielsen 
transcribing segmenting human computer interaction activities varied ad hoc 
comments need performed 
computer actions user computer interactions transcribed simple descriptions level suitably course grained activities interest 
instance transcription types stream types types types 
attending information screen transcribed interaction 
self generated computer events popup menus coded necessary 
relatively similar types codings external actions frequently external action intermixed sequential flow verbal reports done flor 
clarity purposes segmentation purposes verbal transcriptions placed parallel interaction transcriptions see 
main reason doing segmentation segmentation heavy verbal reports computer logs 
verbal reports treated evidence stream internal events occurred asynchronously coordinated manner action computer events 
single coherent event consist user reading aloud expressing surprise computer 
issue planning plan program repair task segmentation took account 
segments constructed types codes 
instance 
exploration data analysis techniques code gi gp ge pi pe fi xe repair enable action description push goal plan gp stack internal push goal plan gp stack external push goal plan stack internal push goal plan stack external internal goal derive page planning replanning external code repairing action plan related enabling action episodes actions table coding scheme visual caf example added import line resolve missing declaration error considered single repair event typing occurred 
coding scheme considerations bear mind developing coding scheme cognitive support 
codes internal external cognitive action distributed cognitive task 
instance external memory examined offloading may need code memory storage retrieval management activities 
second codes couched cognitivist terms 
instance error list acting external plan actions error list coded planning plan 
context visual caf cognitive support claims examined coding scheme focusing distributed planning decided 
claims table fell outside particular scope 
coding scheme quite simple containing codes 
listed table 
small coding scheme probably taken signify tight focus study theoretical weakness 
naming scheme codes part hierarchically defined internal versus external resource dichotomy costh naming scheme 
naming code organizing scheme similar published coding schemes 
coding scheme broken distinct sections indicated dividing lines table 
top primary codes 
codes relate planning activity 
divided categories goal selection plan selection plan generation planning faulting 
labelled respectively 
faulting refers conditions developer runs internal goals accomplish new goals paged 
categories divided internal external action types action category correspondingly 
internal planning actions observed category xi coding scheme 
type plan coding scheme consonant published accounts goal plan action decompositions black 
code repair denotes error fixing activities 
include code fixing activities related repair plans considered 
observation session examined 
exploration data analysis techniques repairs directly associated goal repair plan associated studied episodes 
repair actions interpreted quite loosely correspond reasonable activity related fixing code flaw removing syntax error adding missing declarations 
repair actions prior codes may relatively macroscopic 
specifically single repair event may decomposed relatively extended sequence low level actions 
instance episode examined adds missing import statement 
adding import statement single repair action performed extended sequence keystrokes mouse movements selections menus 
code intended capture activity directly related planning executing sequence repairs 
enable action intended label actions clearly part utilizing cognitive support question contribute directly support question 
examples sorts enable actions include moving window position follow plan saving file disk analyzed putting tool mode planning actions invoked 
code assigned discrete event 
common catch category normally included protocol coding schemes 
distinct events identified segmentation protocol just previously described event types 
ensures events merged single macroscopic event 
interesting events assigned code hint coding scheme misses important aspects behaviour metacognition 
case coded activities signify activities outside highly focused attention repair planning plan 
analyst pressed time decide ignore enable events completely continue events question occur 
codes included scheme purposes certain analyses 
note enable actions coded events 
enable actions indicate strategic expertise toolset enable cognitive support effectively 
said actions discussion section 
results main activity session design coding method generated web page 
planned write method coded initial skeletal implementation began repair sequence get runnable form 
fraction entire minute session relevant features visual caf 
visual caf studied consisted sequence incremental code generation episodes minutes length total 
episodes coded coding scheme described 
complete contents codings reported appendix results analyzing episodes described 
results analyzing trace distributed planning state evolves 
technique constructing trace described analysis follows 
repairs may planned 
instance output line code programmer may need plan planned retrieved memory sequence tokens write 
planning decomposition broken 

exploration data analysis techniques methods generating distributed planning trace coding scheme focuses distributed planning activities activities revolving construction manipulation plans plans adopting goals 
dc point view trace events distributed computational system 
sense sequence coded events precisely analogous interesting events program visualization 
program visualization typical difficult identify classes interesting events order generate trace events 
function served coding scheme focus identify interesting events 
case events question ones manipulate goal plan states 
important objective support analysis understand plan goal states generated manipulated pursued 
traditional dc terminology aim trace propagation representational state 
simple term state meaning computational state sufficient 
problem analyzing coded protocols analyze visualize path states distributed computational system traces events generate path 
state transition path called system trajectory 
adequately represent understand trajectory imperfectly solved question 
technique explored adaptation standard techniques visualizing ai algorithms 
techniques ai textbooks show planning search algorithms 
understand algorithms understand aspects plans generated updated goals managed adopted 
instance planning visualization show contents goal stack point execution algorithm 
case essential difference planning distributed programmer tools 
trick display programmer internal state combination state externally 
words careful display distributed system state 
visualize goals plans generated stored modified 
order way determining plan related computational state point time required 
coded event sequence matched determine events serve modify 
programmer internal goal stack agenda obviously directly observed 
inferred verbal reports visible activities computer ability perform certain activities 
instance point able repair errors row appearing refer compiler error list repair events 
presumed internally maintained generated plan performing repair events turn 
indicated comments reading error list previously saying oh may need um import dtd interface stuff 
reasonable assume knows interface stuff includes classes internally maintained plan import 
external planning state determined examining contents computer logs relevant point interpreting terms cognitive state 
shows simple tabular visualization trace repair planning activity extracted repair episodes 
scheme reminiscent uml sequence diagram laid dimensions 
trace events laid vertical axis flow 
exploration data analysis techniques internal external time code goal stack plan action plan gi xe ge gi fault pe gi fault pe gi xe ge pe pi xe ge pe bold active goal faulted goal tuple compiler invocation read goal table trace table distributed planning activity episodes time going top bottom 
horizontal axis laid timelines internal external components storing state 
table joint system state composed external plan combination internal control plan agenda goal panels 
events generate modify joint system state actions represented column 
actions include commanding computer generate external plans reading plan elements external display 
event times indicated column cross referenced coded protocols appendix distinct goals plans different labels 
labels shown table 
plans represented flat structure goals achieve 
instance denotes plan labeled indicates intention solve goals order 
simplicity label description check see repairs needed fix error missing include fix error missing include fix error missing include fix error undeclared method call fix error missing include fix error missing include fix error uncaught exception java io ioexception fix sequence error list fix sequence second error list fix sequence third error list table description goal plan labels 
exploration data analysis techniques plan label allowed goal stack 
case meant represent intention follow plan 
internally may thought store plan pointer internal external memory lets fix errors effectively pointer external plan 
simple measures trace coded protocol trace joint system trajectory figures measures statistics taken help analyze contents 
table shows frequency codes episodes 
table different types shared internal memory uses collected shared internal categories 
table points backed simple statistical measures events coded events episode related generating manipulating plans goals 
high number gives confidence episodes examples planning activity 
evidence suggest significant internal planning repair activities performed joint performance point view code repaired quite systematically 
addition plan related events generated externally 
words action structuring activity external locus 
gives rough indication extent external planning resources relied 
deep planning obviously required particular task error fixes relatively independent complexity plan issue stake 
say statistic measure cognitive support provided relied 
statistic immediately argument 
trace shows shallow plan goal knowledge maintained internally may remembered multiple repairs relied external plan paging repair goals error messages internal memory needed 
discussions distinct issues discuss results analysis say cognitive support experience gained performing analysis implies lightweight theory application techniques 
sets issues described 
code type freq 
frequency chart xe shared memory internal memory repair enable table frequencies coded actions type 
exploration data analysis techniques discussion cognitive support points joint system activity cognitive support briefly outlined 

skilled interaction 
verbal reports computer interactions 
notable exception verbalize typing typed words missing report breath 
interactions appear consistent cognitive skill levels task execution noted card 

dependencies step ordering 
goal external plan chosen compilation invocation 
way explaining generally biased select elements plan possibly starting top list scanning 
may winning heuristic repair ordering 
reason java programs dependencies program elements single file concentrated initial portion file declarations imports concentrated 
repairing errors top may remove dependent errors list 
planning effective conditions dependencies constraints ordering actions 
sense compiler error ordering technique bias selecting element example planning 
fact compiler error listing ordering obvious irrelevant 
similar situations exploring hits search engine ranking techniques convoluted fundamentally significant 
raises possibility similar studies determine efficacy alternative error report orderings 

coping strategies plan 
repair episode goal selected indicating errors may opportunistically followed opportunistically selected list 
issues regarding visual search visual may affect ordering 
case unclear selected 
overlooked completely exhibited surprise seeing errors 
may pursued habit frequently re compiling refresh repair plan regularly systematically going error list 
long correctness checks quick may winning heuristic reasons 
automated error checking generally keeps errors resolved 
means usually little penalty missing plan step retained re planning 
circumstance important thorough executing plans 
second repair remove dependent errors list effortful errors dependent 
may better re compilation prune error list 
removes errors repaired checks repairs early making easier select new goal 
goal selection easier manner need remember determine errors selected 
sense frequent re compilation coping possible mask error making repair especially erroneous 
instance globally declared variable mask error local variable name undeclared 

exploration data analysis techniques strategy avoid need tracking state internally 
visual indication repair status reduce importance strategy 
example illustrates instance coping strategy identified need coping strategy may reduced provision cognitive support 

system level understanding planning 
external planning plan resources effectively remove repair planning personal workload 
goal stack internal plans shallow 
characteristic display problem solving actions cued display state explicit planning performed 
system point view action structured incremental planning 
difference evolving plan constructed maintained evolved externally point brought section discussing theory validity 
case distributed processing understood fully looking processing element system level understanding required see section 
obviously impossible generalize limited set observations comments consistent experience sorts tools 
theory application techniques evaluation preceding analysis fairly typical post hoc verbal protocol analysis terms procedure coding techniques 
acknowledged onerous 
previous techniques discussed reducing burdens form 
instance exist techniques automating guiding aspects protocol analysis including segmentation trace analysis visualization 
current experience imply sorts analyses lightweight 
experiences test case suggest potential ways realizing speedups limitations techniques 
way realizing speedup traditional techniques extremely targeted investigation 
particular example determined cognitive support claims investigated highly targeted search exemplary episodes invoked 
total minutes recorded data minutes data needed transcribed coded 
target episodes easily identified pass recorded logs 
known advance pursuing aspect cognitive support certainly note relevant activities 
note session initialization method participant initiated observations play important role strategy 
aspect highly targeted small set relatively macroscopic codes 
analysis interesting codes 
coding relatively simple aspects cognitive support falling outside scope ignored 
suggests time transcription coding burdens tolerable research development contexts 
key tight focus particular aspect cognitive support 
comparison notice controlled experiment testing variations tools faster way determining similar sorts support issues 

exploration data analysis techniques second way realizing speedup avoid transcription coding completely 
feasible particular issue considered 
instance consider case plan cognitive support pursued question plan steps accidentally skipped state sufficiently visible 
specific contexts may sufficient simply watch recorded tapes note instances errors explored systematically 
argument sufficiently narrow focus targeted issue relatively easy pick transcription coding techniques need systematic 
argument similar nielsen argument protocol analysis useful usability engineering realistic development situations hour thinking aloud observation probably needs followed half hour combined analysis report writing experimenter noticed important usability catastrophes occurred thinking aloud experiment 
pg 
differences case aspects support examined usability theory narrow focus rely heavily luck insight experimenter 
point brings third way realizing speedups analysis focused coding 
coding analysis example part set claims analysis 
protocol analysis 
times iterative coding re coding performed 
especially required novel aspect cognition studied see gray holistic fully bottom approach pursued see purcell 
experience interesting done applying cognitive support theory claims analysis 
left analysis establish codes execute straightforward analysis 
argument advanced discovery tool protocol analysis intensive theory search tool done 
way realizing speedup avoid verbal report recording post hoc transcription coding altogether 
done shadowing technique 
reported section situ coding technique attempted successful 
possible reason failure codes specific coder properly prepared 
known specifically look programmer goals actions look feasible perform situ coding verbal protocol 
depending aspect cognitive support studied easier harder situ coding 
experience aspect suggests situ coding possible assigning codes recorded protocol easy 
cases protocol analysis coding iterative unclear codes assign 
addition verbal report coding synchronized shadowing technique singer feasible way remove need recording low level data completely video audio computer logging 
clear limitation techniques tried certain forms cognitive support difficult observe measure field 
example lower level interactions reading graph manipulation tools highly skilled verbal reports generated 

theory application scenarios determining specialization substitution occurring visual operator substitution may challenging specialized data gaze tracking hardware 
may require manipulation task context providing different visualizations able determine impact skilled activity 
words main limitations sort field study type data easily observable field 
certain facts ascertained verbal protocols computer logs ordinary video 
limit types cognitive support readily analyzed 
limitation suggested experience circumstances shadowing technique sufficient post hoc coding protocols necessary 
problem activities rapid occur faster noted written 
synchronized shadowing singer goals generated relatively slow rate 
experience leaves issue unresolved 
events interest generated roughly minute span see 
trained observer may may able accurately pick write sequence goals pursued argued users limited processors pursue goals minute 
trained coders chance matching limited rate goal pursuit contrast example video game 
potentially testable supposition cases 
regardless rub occurs tries follow skilled activities visual search 
theory application scenarios theory tool evaluation design stream reality se necessary able efficiently test explore cognitive support claims 
section proposes plausible research scenarios looks results field study determine potential field research similar scenarios 
scenario claims check 
second scenario attempting measure support 
scenarios important contexts se tools researchers 
scenarios field investigation suggests potential ways empiricism answer important support questions 
claims check cognitive claims analysis important aspect tools research design 
claims generated may need evaluated different contexts 
obvious context trying validate claim purpose publishing scientific report tool 
important context normal course tool analysis design 
evaluation context implied scenarios chapter 
design iteration cycle type cognitive support may proposed tool may designed claim may need checked 
sorts cases researcher wish go field lab determine right track 
sort claim evaluation context explored section 

theory application scenarios claims check april usefulness engineer design team visual caf 
design team performed cognitive support claims analysis visual caf results similar table 
april concerned claim offloading plan steps 
doubt theory memory usefully offloaded uncertainties claims 
unsure design team done job matching visual caf features support presume provide error lists really plans 
uncertain various features windowing key bindings visual caf offloading effective 
true offloading realistic development situations 
continuing design analysis important april lay uncertainties rest 
april decides short user study 
knows capable programmer department uses visual caf support web presence 
programmer willing help study 
generates coding scheme code events related error step offloading error list steps internalized attended 
adds tracing statement internal development version visual caf logs error lists generated window events 
sets laptop coding system code error internalization events 
phone doing code writing 
development records errors fixed 
records error messages thinks reads screen errors appears recall memory 
back office april matches computer log timestamped codes 
rarely appear internal memory error messages 
instances notes interesting circumstances simplicity regularity fixes screen crowding 
april comes appreciate importance error list offloading progression fixes occur 
brings knowledge back design team better evaluate design choices highlighting errors scenario simple claims check 
empirical suggested modest extension current field study 
scenario may considered far fetched think experienced designer tool visual caf know error list memory 
compiler environment designers understanding importance frequently consulting error list 
point scenario 
scenario meant illustrative possibilities claims checks prejudice claim obvious reader 
case reasonable argument simple tightly focused user study performed gain confidence claims design 
circumstances claim appears obvious basic approach tried 
furthermore empirical approach important claim wrong 
instance may case seemingly reasonable ideas offload memory may turn thinking 
experienced designers may wrong 
main scenario envision case empirical cheap effective 
alternate spin usability engineer common title hci practitioners 
far know title existence argue equal sense 

theory application scenarios scenario speculative extension techniques tried participant claims analysis unusual assumed substantially 
main speculative part scenario observation analysis techniques 
notes differences order 
notable difference april techniques ones assumed april lightweight observation coding technique 
assumption reasonable 
able read error list item code fix seconds 
protocol readily apparent occasions read error list verbalized intention corresponding fix 
assumption borne april option performing traditional coding 
computer logs help regard determining sequences activity look 
main point note clearly defined cognitive support claim factor enabled tightly focused approach observation analysis 
addition note controlled experiment involving different design options yielded similarly informative results 
measurement scenario costh quantify cognitive support 
shortcoming common broad brush theories empirical techniques 
offloading measure rico usefulness engineer quality assurance team visual caf 
charge making sure cognitive support requirements met measuring quality delivered product 
goals visual caf team environment offloaded repair memory effectively 
factors including usability factors affect 
rico examined requirements decided measure offloading achieved order quantify usefulness targets met 
rico contacts beta testers visual caf located nearby willing focus group 
sure new user visual caf heavy developer extensive visual caf willing test new improvements third occasional developer 
brings usefulness testing lab visits heavy user site 
collects observational techniques deposited april design team repository design documents 
rico uses shadowing methods april usefulness lab video cameras set uses 
way double checks codings 
rico enters codes spreadsheet 
calculates frequency internal versus external plan step usage table total internal load goal stack depth plus plan step count carried developers 
armed measures rico reports back quality assurance team 
complaint raised usability engineering infrequently resembles quantifiable theory backed engineering practices 
argument put forward response charge may possible systematic design engineering 
theory application scenarios interfaces 
place start usability specifications 
usability goals met design included system specification just functional requirements 
specified guide development 
development goals set meet specification early prototypes evaluated meet specification 
usability issues quantification measurement problematic 
added usefulness form cognitive support may specified quantified measured 
context means measuring intermediate performance factor cognitive load chandler 
context measuring cognitive support claim measuring support principles offloading binds quantification features thought produce benefit 
summary discussion cognitive support theories costh generate explore claims tool development evaluation 
circumstances beneficial perform field laboratory study order examine claims 
section scenarios proposed empirical examinations cognitive support appeared important 
testing claim see founded measuring support claimed tool 
scenarios field study described earlier chapter employed argue possibilities empirical studies claims 
techniques similar ones study proposed 
reasonable exact field study techniques 
spirit exploring possibilities lightweight techniques discount investigation methods suggested 
methods tried context study suggest lines research 
attention techniques explored field study 
claim evaluation techniques possible 
instance proposed various forms intervention control effectively explore claims 
instance possible manipulate task demands order see cognitive supports various circumstances 
example study memory offloading 
difficult tasks user short term memory may great demand offloading may important user may systematic externally stored state 
instance useful increase cognitive load having users perform concurrent tasks articulatory suppression activity 
interventions test efficacy offloading varying task demands 
similarly changing cost structure operations tool may help expose aspects cognitive support 
instance fruitful see raising delay compilation cause users systematic passes error lists 

validity evaluation validity evaluation excerpt cockpit activity approximately minutes duration rich 
contains illustrations central concepts theory distributed cognition 
hutchins distributed cognition airline cockpit pg 

science theory proposed naturally call validate theory setting experiment collecting evidence veracity 
cognitive science variety criteria establishing validity cognitive model sufficient necessary psychologically plausible plausible see thagard 
theories costh models proposed meant broad brush approximations 
considered valid models strong sense similar sorts models probably thought tool inquiry 
evaluated primarily merits tools real investigation 
real debate scientific merit reserved basic science literature draw 
degree question validity purposefully simplified account built previously tested theories 
costh hasti theories models dc activity cognitive support establishing parameters validity desirable 
minimum wish sure validity lost purposeful simplification 
question remains type evaluation appropriate 
works similar aims key issue model theory says interesting behaviour analyze see wright 
validating models theories built insight normally consists relatively informally evaluating consistent observed behaviours 
dillon provides argument approach context framework modeling reading behaviours 
argues framework intended provide precise model human mental activity reading 
test pointless 
form generic description reading process level appropriate design proposed valid test relevant 
test suitable form examine readers behaviour verbal protocols document parse various components relate components framework 
framework valid protocols provide clear examples behavioural cognitive elements constitute framework 
invalid description protocols fail provide match indicate presence activities accounted elements framework 
pg 
hasti evaluated similar manner 
take dillon procedure apply hesitate follow dillon term valid 
usage defended think appropriate limit interpretation term 
shall restrict term valid stronger 
validity evaluation hasti costh hope find events accounted distributed computational interpretation consistent hasti attributions cognitive benefit consistent arguments costh 
revisit small segment visual caf analyzed section 
example taken uncontrolled field observations 
analysis claims involved visual caf minor elaboration support arguments different tool 
analysis joint action hasti modeling techniques distributed planning plan 
reasonable start analysis visual caf merely consider merits explanation 
unfortunately sample analysis uses limited portion hasti costh construction possible evaluate parts 
aspects analysis consistent hasti 
main aspects hasti applied example control agenda facets agent model 
protocol shows direct evidence internal plans goal stack drove part behaviour 
example fairly evident maintain goal trying fix number repairs external repair plan 
aspect hasti demonstrated incidentally episodes limitations memory encoded hardware model hasti 
protocols contain indirect evidence limitation form minimal internal memory plan step relied external memory furnish goal 
strong proof means short term memory limited show strong memory capability recalling error messages reading 
presents weak set evidence favour complicated model shows basic description consistent observable behaviour 
important fact hasti distributed model 
assumes plans goals located externally internally organize behaviour 
analysis section reveals quite strongly case 
internally maintained little goal plan state episodes beneficially viewed organized planning 
may opportunistically followed incrementally generated activity structured 
goals attended order 
shows limited opportunism 
external plans updated twice performance goal added changes limited removal goals achieved state need remembered 
shows limited incremental planning due feedback actions 
joint system computer acted systematic manner 
system set goal fix program systematically determined course action followed 
main point notice necessarily systematic goal driven activity fact distributed planning point view understanding apparent 
just programmer examined virtually planning performed just shallow cue directed activity 
pointed programmer behaviour structured external artifacts 
structure 
realization role external planning contributions compiler systematic activity lost 
looks concepts associated traditional cognitive science validation speak merely evaluation remainder section 

joint system sees joint system state evolves generating plan action quite routinely followed updated 
point helps validate importance hasti dc view activity 
episode consistent costh 
take stock consider turn cognitive supports analyzed table 
regarding constraint processing distribution difficult doubt automated checking reduced cognitive part programmer 
regarding distributed planning fairly easy see repair steps taken direct result repair plan 
result verbal reports contained virtually planning 
reasonable say planning offloaded 
third item table refers location control information 
protocol strongly suggests maintain control information plan internally kept externally referring internal goals available 
comfortably construed plan offloading 
remaining items table examined observed activity 
review clear account cognitive assistance costh consistent observed activity 
short review argued reasonably account hasti costh consistent real cognitive system behaviour 
dillon words provide clear examples behavioural cognitive elements constitute framework 
validation help evaluate reasonable hasti costh 
moment empirical evaluation existing tools benefited usefulness theories 
theories relatively unsuccessful systematically identifying tool benefits 
design similarly affected possible state test usefulness design goals 
cognitive support theory costh chance change state affairs 
empirical techniques lightweight 
methods effectively deploying techniques realistic scenarios explored ensure systematic engineering cognitive support possible 
date little known ways empirical investigations practical tools research engineering settings 
response chapter exploratory attempt investigating relatively lightweight field techniques 
example analyzing recorded set field observations worked 
analysis showed useful answers obtained relatively cheaply field study 
professional tool real practice 
observed behaviour matched hasti costh explanations field study provided assurance hasti costh reasonable trustworthy expected real world situations 
analyzed example served exercise poorly understood data gathering techniques gauge promise efficacy 
data gathering techniques situ shadowing technique computer logging technique generic reasonably lightweight deployed field scenarios 
situ shadowing technique effective study 
suggestions theory support analyses observations focused technique 

example observation session served highlight possibilities employing empirical studies answer support related questions 
argued claims checking validation performed efficiently 
capability important checking claims reasonable 
second suggested certain aspects cognitive support measured 
capability valuable software development settings including quality assurance settings 
scenarios bring focus question usefulness engineering real life cognitive support engineers techniques 
results tentative weak evaluated larger context aims dissertation 
overarching goal provide theoretical tool form cognitive support theories integrate working research eventually development practices 
chapter step direction 
chapter guiding thesis solid theory understanding cognitive support possible time come se research developing applied cognitive support theories 
strong need build tools undeniable cognitive consequences trade cognitive support ideas 
exists psychological scientific base far underutilized part due fragmentary nature 
craft knowledge folk psychology fill theoretical void 
evaluation design suffers inability systematically explore cognitive support level details features individual tools 
shame continue leaving existing theory collected simplified 
methods applying practical informal contexts rigorous studies 
critical contribution dissertation vision transforming se research putting theoretical science backed foundation set core theoretical tools methods needed 
basic necessary equipment research programme investigating cognitive support se 
core infrastructure 
bound tightly overarching thesis second thesis rods hasti costh suitable initial basis starting project injecting existing theory se research 
step scientific knowledge cognitive support form suitable se 
may useful broad contexts domain interest se particular software comprehension reverse engineering 
second major contribution toolkit theories models methods investigating cognitive support se 
overarching thesis specific thesis complementary 
suspicious argue se ought embark theory research programme able point credible basis doing 
rods hasti costh initial proof concept support primary thesis 
furthermore theoretical toolkit interesting vision transforming se research toolkit agent evolution field 
dissertation concerning se research infrastructure investigation applied theories cognitive support 

summary contributions main drawn study theory driven research programme se currently possible rods hasti costh resources lead way 
vision applied theories main contributions number secondary ones way 
contributions summarizes implications field 
summary contributions exposition purposes dissertation organized sequence topics suitable individual chapters 
groups contributions topics phenomena design theory possible categorize contributions types advances provide basic framework model 
method organization 
method decomposition primary contributions supporting contributions 
depicts incidence matrix showing contributions spread chapters 
short summations contributions follow 
primary contributions 
basis applied theorizing 
theoretical basis researching designing cognitive support se tools provided 
basic analytic framework 
dc framework detailed explaining cognitive support computational terms 
basic framework includes set dc understanding human computer systems joint cognitive terms 
framework needed order interpret tool contributions cognitive terms ii 
rods set support principles 
provided core principles explaining cognitive support computational advantage 
iii 
claims method way making cognitive support claims 
explains steps needed claiming tool feature supports cognition 
iv 
modeling methods dc architectures virtual hardware models proposed modest extensions current dc theorizing 
establish basis generalizing cognitive support arguments raising analysis level low level interaction 
part framework collection unification prior dc theory modeling techniques claims analysis 
selection collection integration adds value 
psychological research se appears fixated cognitive theories support theories little currently known field apply cognitive theory explain tool value 
dissertation provides solid foundation doing 
research vision 
vision provided cognitive support oriented research stream se tools research 
vision established roles boundaries tools research separate 
summary contributions chapter contribution primary basis applied theorizing basic analytic framework research vision model theory principles model decomposition framework support de composition framework models theories hasti costh theory application principles design representations empirical techniques secondary reviews summaries cognitive support phenomena applied model building principles chapter contents vision phenomena rods hasti costh design test drive field study debates clarifications inadequacies non theoretical se role theory design generated resources design idea cookbook theory application examples design stances table diagram contributions spread chapters cognitive support theory research provided glimpse theory research se tools research 

principles applied models theories cognitive support 
principles rules described constructing useful models theories cognitive support 
model decomposition framework 
key principle constructing hasti usefully decompose modeling issues interest match computational structure hasti decomposition 
framework critical structure deciding integrate disparate theoretical content literature 
support de composition framework 
different variations cognitive support ideas shown hierarchically decomposable main families 

summary contributions 
models theories 
integrative broad brush models theories proposed analyzing explaining cognitive support 
hasti 
modeling framework constructed variety different prior models 
main modeling components view kind integration known modeling methods model human processor blackboard models opportunism resources model skills rules knowledge framework 
costh 
hierarchically refined collection theories cognitive support 
fundamental level hierarchy merely elaboration tree generated applying support factors rods dc model framework hasti 
substantially existing theory 
shows integrative accounts premature 
collection hierarchical structuring brings added value 

theory application principles 
principles techniques outlined applying cognitive support theory tools research 
design representations 
methods vocabulary concepts design stances reified design space explored making cognitive support theory directly usable design 
empirical techniques 
ways cheaply applying theories experimental field contexts explored 
lightweight methods required cognitive support theories effectively deployed relatively informal commercial contexts 
secondary contributions order able primary contributions dissertation minor secondary advances fill missing details position argue main points 

reviews summaries 
rests collected wisdom hinging specific experiments theories papers 
reviewing summarizing prior works necessary bring diffuse elements coherent arrangement strong hang required arguments 
review support phenomena 
broad range cognitive support phenomena collected organized described 
breadth helped ensure applied theorizing limited scope especially useful 
applied model building principles 
principles building useful applied models se research summarized 
principles generally quite different typical principles cognitive science 
review important appears times assumptions ideals cognitive science imported se research explicit consideration 
review contrasting principles act foil acts organizing force defining applied theories 

summary contributions 
debates clarifications 
making progress presence conflicting positions views subject matter difficult 
debates clarifications positions engaged unnecessary conflicts 
cases issues complex briefly refuted introductory paragraphs various positions needed unfolded unimportant challenges needed pruned critical ones needed singled 
inadequacy non theoretical se 
central importance possibilities cognitive support theories debated 
debate countered contentions current course research adequate 
essentially debate served establish argument pursuing explicit cognitive support theories may realistic hope answering questions important se tools research 
role hci theory design 
metaphors fitness landscape gulf synthesis essential requirements qualities design theories hci related design considered 
useful taxonomy theory applications described emphasize importance fp reasoning forward reasoning positive consequences 
summarized crucial role broad brush summative approximations suitable reasoning positive consequences 
costh built exhibit qualities summary possible fully appreciate design decisions underlying construction hasti costh 

generated resources 
thesis improve tools research cognitive support theories investigated 
way artifacts value created useful right 
design idea cookbook index 
costh described combination explanations concrete examples 
collectively examples sample illustrate diverse range supportive techniques technologies 
sense provide simple preliminary catalogue design ideas useful thumb inspiration 
hierarchically organized types support offer 
design knowledge indexed solution type 
promising area development building reusable design knowledge repositories 
examples theory applications 
source useful reusable knowledge consists examples applying hasti costh analyze cognitive support existing tools 
similar tools similar analyses may mean able reuse reasoning modeling methods protocol coding techniques 
prime examples field reverse engineering rmtool rigi analyzed number smaller analyses various tools including commercial tool visual caf performed 
design stances 
small collection design stances supplied building reverse engineering software comprehension tools 
developed primarily basic dc commitment viewing engineers part joint computational system 
provided useful contrasts currently dominant limited design stances 

exaggeration say left resolution simple question new research 
real sense done complicated issues cognitive support theory development position research applied cognitive support 
ways expanding resources analyses dissertation 
possibilities applying improve se research 
listed possibilities promising time 
expanding current places clear consider theories models developed mere starting points works progress 
number promising ways expanding current resources 
expanded support analysis 
theory proposed tendency pointing inaccuracies fixing tweaking theory 
inward looking process 
instinct says main advantage costh comes primarily ability tackle variety different types support 
costh provides explanations interesting variety cognitive support nearly exhaustive 
shortcomings pointed section emerge 
key challenge temporarily resist temptation minor aspects framework try expand frameworks encompass important support concepts issues 

design tradeoffs 
limitation costh design tradeoffs explicit 
instance cost externalizing data data redistribution cost effective 
integrating analysis design tradeoffs costh important 
may help able quantify measure important costs benefits 

quantification measurement costs benefits 
external memories expand effective size problem solving memory large joint system effective working memory size 
external memory creates external memory maintenance costs maximum average external memory maintenance cost typical code refactoring tasks bear 
tool developed meet certain cognitive support requirements cognitive support offered measured assure quality 
memory offloaded tool 
create engineering discipline cognitive support quantification measurement methods needed 
support explanations firmly place possibility entertained 
may take reality extend costh related theories measurements regarding important system variables effective working memory size 
basic route successfully taken card building engineering models performance 
approximation calculation result appear important engineering applications 
analogous approximated theories measurable aspects cognitive support may feasible 


groups multi agent systems 
half tractable multi person systems considered 
dc theoretical framework attracted fair share attention able focus social group issues able integrate holistic account 
may fruitful expand hasti possibly costh needed consider multi agent systems 
sorts lists written particular order 
list 
order listed indicate consider appropriate priority list 
prevents exploring priorities feel listed 
applying current chapter recalled stating useful theory 
rods hasti costh effectively new weapons arsenal investigator se tools apply research design problems 
ultimately important impact realized taken integrated discipline cognitive claims analysis testing 
look attack level craft knowledge field applying theoretical toolkit number ways 
especially promising lines attack include 
generalizable reusable dc architectures 
humans highly adaptable tasks numerous varied practice number basic tool interaction types common 
instance software development ides similar windowing systems similar underlying logical structure particulars interaction change 
combines fact assumption tools part dc system strongly suggests fruitful search common dc structures apply different tools tool types 
true number common hasti analyses tend crop 
codified standard dc architecture pulled textbook required 
virtual architectures may need defined order able reason architectures higher level 

design catalogs patterns 
presentation costh chapter effectively provides indexing structure matches needs offloading knowledge examples means achieving wizards 
fundamental design resource 
addition section examples cognitive support appear compose particularly harmonious combinations patterned way 
analysis suggests costh theoretical apparatus mine existing craft knowledge base examples support techniques excellent patterns combination 
spark fruitful research programme mining codifying design knowledge cognitive support 

evaluating comparing software tools 
new tools created current crop tools poorly understood cognitive support point view 
may help expand analysis empirical investigations started chapters 

coda coda research involving se tools needs importing cognitive support theories avoiding topic trying build 
rods provides basic foundation doing 
hasti costh modeling framework cognitive support theory framework suitable starting points 
collect existing theories cognitive science 
demonstrably applicable analyzing current reverse engineering tools commercial development tools 
cognitive support important concern se 
far long lived just effectively scratch 
hope se toolkit explore nearly research stream applying cognitive support theories se tools 
appendix invitation participate invitation participate study invited participate study programmer tool 
studying programmer tools help hinder 
re hoping able help people build better programmer tools ones 
studies eventually help 
study description short minute study sessions come place watch record computer tools compiler editor 
ll asking talk re thinking recording video camera audio 
sessions obligated way participate sessions 
practical reasons day 
ll control come office take week occasionally call take lot longer allow months 
ll short questionnaire background set environment 
ll probably finish questionnaire minutes 
observation sessions ll chance meet discuss observed ask questions tools 
session entirely optional 
expect take half hour 
volunteer requirements volunteers meet criteria 
relatively experienced programmer 
specifically years programming experience 

currently working project involving programming 
involve understanding maintaining programs lines code 

significant months experience programming environment 
preference unix programmers working emacs vi grep involved integrated development environments centerline 
appendix research description 
study description wish study programming tools programmers 
programmers tools studied independently little known programmers tools interact field call real world am trying develop model theory programmer tools help programmers understand modify programs 
believe study help develop models theories 
theories may turn may help researchers build better tools programming easier reduce number bugs software developed 

main part study watching computer tools working environment solve problems face 
order understand re doing need understand re thinking ll asking talk aloud recording say 
ll video camera may audio tape record 
similar people quickly accustomed camera trouble ignoring 
people find talking working unproblematic 
ll recording programs computer 
depend setup tools concern 
ll deciding observation sessions occur know ll type program maintenance interested watching 
study sessions half hour won go past minutes 
watching tools main goal type observation research frequently requires help questionnaires interviews 
consequently ll want fill short questionnaire environment 
take minutes 
observation sessions may curious tools helped 
ll want set short typically half hour interview session ask questions ask questions back 
participation voluntary may choose cut meetings short study time ask erase part video records 
ask destroy records time study finished 
privacy confidentiality conversations observations considered private confidential 
qualified researchers research group direct access observations gather 
data gather held confidential full extent law destroyed finished studying 
mind hope able publish models theories derived observing 
scientific purposes certain facts observations may need published 
specific details identify published 
referring code actual details needed 
common practice scientific reporting works extremely 
publishing directly uses data contact give preprint ask consent 
likelihood harm little risk harm choose participate study 
chance feel somewhat uncomfortable observing 
people quickly quite accustomed observed 
monitoring computer running programs record keystrokes responses computer 
small possibility programs interfere computer operations 
free examine programs installed operated 
withdrawing may withdraw participation absolutely time part 
ask destroy observations gather 
obligation continue 
appendix questionnaire 
approximately years programming experience 
years years years years 
list programming language languages feel familiar 

approximately long editor editors regularly programming similar ones 
months months months months 
approximately long operating system primarily program similar ones 
months months months months 
customize program editor instance adding macros scripts 

customize windowing environment 

imagine computer error occurs customizations editor windowing environment destroyed restored automatically 
approximately long think take re establish customizations 
hours hours probably hours able don know appendix instruction card instructions study volunteers 
am trying study computer tool program maintenance program understanding 
expect understanding maintaining programs continually minimize interference request find parts allow observe 
ll arrange come observe tools 
am especially interested situations don understand program debugging understanding works 

please take time occasionally monitor 
aware starting program maintenance task interest experimental study asked hold come observe 
point email andrew email address cs sfu ca 
set time convenient 
endeavour near workplace normal working hours duration study 

generally speaking am interested tools understand modify programs relatively difficult program maintenance program modification 
points guideline evaluating activity interest study 
generally interest hold anticipate doing modifying program trying understand aspect don understand debugging 
expect take minutes hour 
uncertainty exactly accomplish task 
instance uncertain able successfully modify program wish 

please working maintenance problem arrive observe doing 
includes planning perform 
important understand tools right working hard understand process 
appendix instructions producing verbal reports study interested computer tools am interested think program 
order find am going ask think aloud program 
mean think aloud want tell thinking time start session 
talk aloud constantly 
don want plan say try explain saying 
just act room speaking 
important keep talking 
silent long period time ask talk 
please try speak clearly possible shall recording speak 
understand want 
notes phrases capitals mean emphasis placed words spoken 
practicing report generation session optional appendix coding participant appendix contains listing relevant observational data tool episodes studied chapter 
main contents series figures 
figures briefly listed notes describing contents notational conventions 
visual caf protocols figures coded protocols participant repair episodes 
notes apply figures episodes lines protocol transcripts included actual episode question 
intended help provide context activity episode 
episodes consecutively 
single horizontal lines indicate start episode double lines indicate 
computer interaction responses short descriptions action computer interface 
aim transcriptions convey content actions trying interpret significance meaning 
interpretation action accomplished coding scheme 
individual events combination verbalizations computer interactions 
individual event identified start time protocol 
times reported second 
case events labelled time events identified uniquely time code events code labelled time 
note finer time resolution generally solve issue multiple events time label 
system observed joint multiprocessing system multiple events occur effectively simultaneously 
furthermore humans multiprocessing 
participants observed verbalize thought performing usually skilled activities time 
italicized interaction transcriptions indicate inferred actions 
cases evidence points described action occurring action detected sufficient level error src cpp class org type declaration error src cpp class org int type declaration error src cpp class org int type declaration error src cpp class org void org org error src cpp class org type declaration error src cpp class org type declaration errors warning build failed participant error list certainty 
instance usually videotape indicated general area glancing impossible tell precisely gazes 
special codes verbal protocols minor points emotions inflections noted brackets multiple commas indicate pause 
commas indicate short pause indicate longer 
lengths pauses concern computer interactions occasionally annotated interaction method parentheses 
instance compiler may invoked menu selection key sequence denoted menu keys respectively 
symbol action code denotation immediately preceding code applies current event 
typically indicates composite action spans unit events 
term dropdown refers context sensitive menu drops near point typing 
protocol allow form word completion listing identifiers known valid current cursor insertion point 
visual caf error lists figures contain replicas compiler error messages generated repair episodes 
included action context better appreciated 
special visual indications visual caf bold facing colouring 
names files classes involved modified preserve anonymity 
addition space limitations error lines reformatted span lines 
participant screen error message appears single line 
line numbers output line displayed left help avoid confusion 
time verbal report computer interaction code start episode 
ready compile see got gi invokes compiler menu xe see compile error list displayed surprise ge error list enable import stuff reads error list sec 
gi fault notices item pe go back top scrolls manually top file enable types import repair import uh dot servlet types servlet 
dot clicks dropdown menu need import types https clicks dropdown starts new import line enable need import looking error list sec 
gi fault notices item pe ah java dot io dot types java io 
repair think print types scrolling dropdown class selects episode 
saves file keys enable ll try gi invokes compiler keys xe error list refreshed oh may need um ge table protocol codes visual caf episode episode error src cpp class org int type declaration error src cpp class org int type declaration error src cpp exception java io ioexception caught declared throws clause method errors warning build failed participant second error list error src cpp exception java io ioexception caught declared throws clause method errors warning build failed participant third error list time verbal report computer interaction code saves file key enable start episode 
ll try gi invokes compiler keys xe error list refreshed reads error list sec 
ge oh may need um notices item pe import dtd repair interface stuff starting new import line import org package uh types org uses storage storage interface pi begins new import line repair org dot package storage types org 
interface clicking episode 
saves file key enable invokes compiler key xe error list refreshed error get 
scanning errors ge table protocol codes second visual caf episode episode time verbal report computer interaction code saves file key enable start episode 
invokes compiler key xe error list refreshed error get 
scanning errors ge oh catch io exception reading error pe throws clause method um reading error report aloud episode 

sec 
interesting thing handle 
table protocol codes third visual caf episode episode time verbal report computer interaction code ready compile see got gi invokes compiler menu xe see compile error list displayed surprise ge error list enable import stuff reads error list sec 
gi fault notices item pe go back top scrolls manually top file enable types import repair import uh dot servlet types servlet 
dot clicks dropdown menu need import types https clicks dropdown starts new import line enable need import looking error list sec 
gi fault notices item pe ah java dot io dot types java io 
repair think print types scrolling dropdown class selects saves file key enable ll try gi invokes compiler keys xe error list refreshed reads error list sec 
ge oh may need um notices item pe import dtd repair interface stuff starting new import line import org package uh types org uses storage storage interface pi begins new import line repair org dot package storage types org 
interface clicking saves file key enable invokes compiler key xe error list refreshed error get 
scanning errors ge oh catch io exception reading error pe throws clause method um reading error report aloud table full visual caf protocol episodes bibliography sniff release user guide july ed 
product number sniff 
ackerman halverson reexamining organizational memory 
communications acm jan pp 

ackermann tauber eds 
mental models human computer interaction vol factors information technology 
north holland amsterdam netherlands 
adelson novices surpass experts difficulty task may increase expertise 
journal experimental psychology learning memory cognition pp 

adelson modeling software design problem space architecture 
program tenth annual conference cognitive science society montreal qu bec aug lawrence erlbaum associates pp 

adelson soloway model software design 
chi pp 

aho hopcroft ullman data structures algorithms 
addison wesley reading ma 
allen brown special issue multimedia interactivity 
instructional science mar pp 

allen information tasks user centered approach information systems 
academic press limited 
altmann episodic memory external information 
tech 
rep cmu cs carnegie mellon university school computer science aug 
phd thesis 
altmann larkin john display navigation expert programmer preliminary model memory 
chi pp 

anderson methodologies studying human knowledge 
behavioural brain sciences pp 

anderson cognitive science implications rd ed 
freeman 
anderson boyle farrell reiser cognitive principles design computer tutors 
modelling cognition 
wiley new york ch 
pp 

arias eden fischer gorman transcending individual human mind creating shared understanding collaborative design 
acm transactions computer human interaction mar pp 

bibliography arnold impact analysis framework comparison 
proceedings ieee conference software maintenance montreal qu bec sep card ed ieee computer society press pp 

cognitive processes program comprehension empirical analysis context software reengineering 
journal systems software pp 

bacon graham sharp compiler transformations high performance computing 
acm computing surveys dec pp 

baecker experiments line graphical debugging interrogation complex data structures summary 
proceedings hawaii international conference system sciences pp 

baecker buxton design principles methodologies 
readings human computer interaction multidisciplinary approach ch 
pp 

baecker buxton eds 
readings human computer interaction multidisciplinary approach 
morgan kaufmann los altos ca 
baecker posner user centred iterative design collaborative writing software 
interchi pp 

baker eick visualizing software systems 
icse pp 

ball applying ethnography analysis support expertise engineering design 
design studies july pp 

query outlines new paradigm help manage programs 
proceedings acm sigplan sigsoft workshop program analysis software tools engineering toulouse france sep association computing machinery pp 

bannon dker interface encountering artifacts 
carroll ch 
pp 

barnard may duke duce systems interactions 
acm transactions computer human interaction june pp 

barnard bridging basic theories artifacts human computer interaction 
carroll ch 
pp 

barnard harrison integrating cognitive system models human computer interaction 
hci pp 

barnard may cognitive modelling user requirements 
ch 
pp 

barwise surrogate reasoning 
cognitive studies bulletin japanese cognitive science society nov pp 

evolution technology 
cambridge university press 
basili plan empirical studies programmers 
esp pp 

basili mills understanding documenting programs 
ieee transactions software engineering se may pp 

basili building knowledge families experiments :10.1.1.17.1239
ieee transactions software engineering july pp 

bibliography bass kazman little software engineering model human computer interaction 
engineering human computer interaction proceedings ifip wg working conference finland aug north holland pp 

bates design browsing techniques online search interface 
online review pp 

leifer understanding information conceptual design 
cross pp 

bellamy strategy analysis approach psychological analysis artifacts 
gilmore pp 

bellamy pseudo code 
psychological analysis pseudo code experienced programmers 
human computer interaction pp 

bellamy gilmore programming plans internal external structures 
lines thinking reflections psychology thought keane erdos eds vol 

john wiley sons ch 
pp 

gall evaluation reverse engineering tool capabilities 
software maintenance research practice pp 

bellotti shum maclean hammond multidisciplinary modeling hci design theory practice 
chi pp 

berlin program understanding look programming expertise industry 
esp pp 

roe ward wong interactive situation models cognitive aspects user artefact interaction 
ct pp 

designs conducive efficient strategies 
dis pp 

john sufficient efficient usage analysis strategic knowledge 
chi pp 

john delegation faces efficiency 
chi pp 

john strategic complex computer systems 
human computer interaction pp 

bibby distributed knowledge head world interaction 
rogers ch 
pp 

black kay soloway goal plan knowledge representations stories text editors programs 
carroll ch 
pp 

activity theory cscw organizations 
monk gilbert ch 
pp 

blackwell metacognitive theories visual programming think doing 
th international ieee symposium visual languages boulder colorado sep ieee computer society press pp 

blackwell britton cox green gurr nehaniv petre roe wong young cognitive dimensions notations design tools cognitive technology :10.1.1.134.5007
ct pp 

bibliography blackwell engelhardt taxonomy diagram taxonomies 
proceedings thinking diagrams science diagrams pp 

blaha benson teaching database reverse engineering 
wcre pp 

blandford buckingham shum young training software engineers novel usability evaluation technique 
international journal human computer studies pp 

blandford harrison barnard interaction framework guide design interactive systems 
international journal human computer studies pp 

block shopping lists external memory aid grocery shopping influences list writing list fulfillment 
journal consumer psychology pp 

ethnography aligning field studies system design 
monk gilbert ch 
pp 

boehm davis software comprehension 
helander ch 
pp 

creativity design activities role analogies constrained cognitive environment 
proceedings third conference creativity cognition uk oct association computing machinery pp 

griswold automated support encapsulating data types 
proceedings nd acm sigsoft symposium foundations software engineering new orleans louisiana dec association computing machinery pp 

griswold software engineering tools organize programmer behavior task data encapsulation 
empirical software engineering sept pp 

boy intelligent assistant systems vol 
knowledge systems 
academic press limited 
boy cognitive function analysis human centered automation safety critical systems 
chi pp 

soloway whorf visualization tool software maintenance 
proceedings ieee workshop visual languages seattle wa sep ieee computer society press pp 

brooks miller roper wood criticisms empirical study recursion iteration 
tech 
rep university strathclyde empirical studies computer science department computer science 
brooks robust layered control system mobile robot 
ieee journal robotics automation mar 
brooks intelligence reason 
proceedings th international joint conference artificial intelligence sydney australia aug mylopoulos reiter eds morgan kaufmann pp 

brooks model human cognitive behavior writing code computer programs 
proceedings fourth international joint conference artificial intelligence georgia ussr william kaufman pp 

brooks theory cognitive processes computer programming 
international journal man machine studies pp 

bibliography brooks behavioral theory program comprehension software engineering 
proceedings rd international conference software engineering pp 

brooks studying programmer behaviour experimentally problems proper methodology 
communications acm pp 

brooks theoretical analysis role documentation comprehension computer programs 
proceedings human factors computer systems gaithersburg maryland mar schneider ed association computing machinery pp 

brooks theory comprehension computer programs 
international journal man machine studies pp 

brooks comparative task analysis alternative direction human computer interaction science 
carroll ch 
pp 

brooks jr silver bullet essence accidents software engineering 
computer apr pp 

brooks jr mythical man month essays software engineering anniversary edition 
addison wesley 
brouwer harrington eds 
human machine communication educational systems design vol 
nato asi series 
series computer system sciences 
springer verlag 
brown framework systematic evaluation software technologies 
ieee software sept 
brown earl mcdermid software engineering environments automated support software engineering 
mcgraw hill 
brown integrated hypertext program understanding tools 
ibm systems journal pp 

buckingham shum practise making hci design techniques usable 
annual conference swedish interdisciplinary interest group human computer interaction university uppsala sweden may 
buckingham shum hammond argumentation design rationale cost 
international journal human computer studies apr pp 

buckingham shum hammond delivering hci modelling designers framework case study cognitive modelling 
interacting computers pp 

bush may think 
interactions mar 
originally published atlantic monthly july 
butler range vol 
edition works samuel butler 
ams press 
butterworth blandford duke formal models explore display usability 
journal visual languages computing pp 

barnard may eds 
computers communication usability design issues research methods integrated services 
elsevier science amsterdam 
byrne conceptual foundation software re engineering 
proceedings ieee conference software maintenance ieee computer society press pp 

bibliography card moran user technology pointing pondering 
pp 

reprinted readings human computer interaction year baecker grudin buxton greenberg ed nd ed morgan kaufmann 
card theory driven design research 
applications human performance models system design proceedings nato study group workshop orlando fla mcmillan sutton eds plenum pp 

card moran newell psychology human computer interaction 
lawrence erlbaum associates hillsdale nj 
card robert keenan line composition text 
interact pp 

cardelli type systems 
handbook computer science engineering 
crc press ch 
pp 

carpenter just computational modeling high level cognition versus hypothesis testing 
sternberg ch 
pp 

carroll mack learning word processor doing thinking knowing 
human factors computer systems thomas schneider eds ablex publishing pp 

carroll psychology user interface science soft frontier 
proceedings graphics interface vision interface vancouver bc may canadian information processing society pp 

carroll ed 
interfacing thought cognitive aspects human computer interaction 
mit press cambridge ma 
carroll ed 
designing interaction psychology human computer interface 
cambridge university press 
carroll artifacts scenarios engineering approach 
monk gilbert ch 
pp 

carroll human computer interaction psychology science design 
international journal human computer studies pp 

carroll campbell artifacts psychological theories case human computer interaction 
behaviour information technology pp 

carroll kellogg artifact theory nexus hermeneutics meet theory design 
chi pp 

carroll kellogg rosson task artifact cycle 
carroll ch 
pp 

carroll mack robertson rosson binding objects scenarios 
international journal human computer studies pp 

carroll rosson usability specification tool iterative development 
advances human computer interaction hartson ed vol 
human computer interaction series 
ablex publishing norwood nj pp 

carroll rosson paradox active user 
carroll ch 
pp 

online www com columns paradox html checked 
carroll rosson getting task artifact cycle claims design scenario 
acm transactions information systems pp 

bibliography carroll singer bellamy alpert view matcher learning smalltalk 
chi pp 

choosing specifiers evaluation basic task models graphical perceptions 
human factors pp 

carver lesser evolution blackboard control architectures 
tech 
rep tr department computer science university massachusetts 
expanded version expert systems applications pg 

cary carlson external support development problem solving routines 
journal experimental psychology learning memory cognition pp 

casner larkin cognitive efficiency considerations graphic design 
proceedings th annual conference cognitive science society aug lawrence erlbaum associates pp 

casner task analytic approach automated design graphic presentations 
acm transactions graphics pp 

chalmers computational foundation study cognition 
id cog soton ac uk 
extended version implementing computation minds machines pp 

chandler cognitive load learning computer program 
applied cognitive psychology pp 

chandrasekaran design problem solving task analysis 
ai magazine pp 

reprinted knowledge aided design vol 
knowledge systems marc green ed academic press pp 

chen rada interacting hypertext meta analysis experimental studies 
human computer interaction pp 

chen better understanding idea processors 
information software technology pp 

cheng 
functional roles cognitive analysis diagrams problem solving 
proceedings eighteenth annual conference cognitive science society lawrence erlbaum associates pp 

chi glaser eds 
nature expertise 
lawrence erlbaum associates 
chignell hancock human computer interaction psychology augmented human behavior 
hancock ch 
pp 

chignell melo discount video analysis usability engineering 
pp 

chikofsky cross ii reverse engineering design recovery taxonomy 
ieee software jan pp 

chin quilici decode cooperative program understanding environment 
software maintenance research practice pp 

chipman cognitive task analysis 
ch 
pp 

bibliography choi von mayrhauser assessment support program understanding 
proceedings second symposium assessment quality software development tools may ed pp 

christensen jorgensen madsen design interaction computer materials 
dis pp 

christie just remembering location content sentences prose passage 
journal educational psychology pp 

documentation suite maintenance programmers 
proceedings ieee conference software maintenance monterey california nov ieee computer society press pp 

clancey ai inventing new kind machine 
acm computer surveys sept 
clancey situated cognition human knowledge computer representations 
cambridge university press cambridge uk 
clancey interactive coordination processes brain accomplishes take granted computer languages better 
pylyshyn ch 
pp 

clark putting brain body world 
mit press 
clark chalmers extended mind 
analysis pp 

reprinted philosopher annual 
clarke cox sim searching program source code structured text retrieval system 
proceedings nd annual international acm sigir conference research development information retrieval berkeley ca aug association computing machinery pp 

clayton rugaber taylor wills case study domain program understanding 
wpc 
psychology information technology study cognition organizations 
british journal psychology nov pp 

cole computer cognitive assistive technology treatment cognitive disabilities 
proceedings third international acm conference assistive technologies assets marina del rey ca apr pp 

cole cultural historical approach distributed cognition 
salomon ch 
pp 

cole algorithmic skeletons structured approach management parallel computations 
tech 
rep cst university edinburgh james clerk maxwell building king buildings mayfield road edinburgh eh jz oct 
phd 
thesis 
collberg thomborson low taxonomy obfuscating transformations 
tech 
rep tr department computer science university auckland auckland 
consens creating filtering structural data visualizations patterns 
tech 
rep csri computer systems research institute university toronto toronto canada feb 
phd 
thesis 
consens mendelzon hy hypergraph query visualization system 
acm sigmod record pp 

bibliography cooper shallice soar case unified theories cognition 
cognition pp 

coplien software patterns 
sigs books multimedia ny ny 
program understanding challenge 
ibm systems journal pp 

corkill blackboard systems 
ai expert sept pp 

craig blackboards agents 
online proceedings project spring workshop collaboration human artificial societies spain may 
retrieved www maths bath ac uk jap html 
crosby read algorithms 
case study 
computer jan pp 

cross eds 
analysing design activity 
john wiley sons 
long conception hci engineering design principles 
proceedings ecce ninth european conference cognitive ergonomics limerick ireland aug published online www cs vu nl ecce 
curtis way study real programmers 
esp pp 

curtis paradigms psychology programming 
helander ch 
pp 

curtis empirical studies software design process 
interact pp 
xl 
curtis non technological factors software engineering 
icse pp 

curtis krasner field study software design process large systems 
communications acm nov pp 

curtis walz psychology programming large team organizational behaviour 
hoc ch 
pp 

daly brooks miller roper wood empirical study evaluating depth inheritance maintainability object oriented software :10.1.1.39.1475
empirical software engineering pp 

daly replication multi method approach empirical software engineering research 
phd thesis department computer science university strathclyde glasgow 
davies characterizing program design activity strictly top globally opportunistic 
behaviour information technology pp 

davies role expertise development display problem solving strategies 
proceedings th annual conference cognitive science society lawrence erlbaum associates pp 

davies information coding activities effects expertise environment task 
esp pp 

davies display skills complex domain external information sources computer programming 
pp 

davies display problem solving strategies computer programming 
esp 
davies external information sources computer programming 
role textual graphical representations support complex problem solving activities 
iee colloquium thinking diagrams jan institute electrical engineers pp 

davies linking theory implementation models programming development programming tutors 
nato asi pp 

bibliography dawkins blind watchmaker 
london 
de cognitive support designing aiding supplement human knowledge 
international journal human computer studies pp 

de vries de jong design evaluation hypertext structures supporting design problem solving 
instructional science pp 

decker lesser coordination assistance mixed human computational agent systems 
proceedings second international conference computational agents mclean virginia aug 
available tech 
rep cstr computer science dept massachusetts 
coyle behavioral factors software development 
pp 

long planning aid human factors evaluation practice 
behaviour information technology pp 

dennett real patterns 
journal jan pp 

reprinted essays designing minds mit press ch 
dennett darwin dangerous idea evolution meanings life 
simon schuster new york ny 
eds 
computers cognitive tools 
lawrence erlbaum associates 
devanbu brachman selfridge ballard knowledge software information system 
communications acm may pp 

dillenbourg distributing cognition humans machines 
ch 
pp 

dillenbourg self computational approach socially distributed cognition 
european journal psychology education pp 

dillon reading versus screens critical review empirical literature 
ergonomics pp 

dillon designing usable electronic text ergonomic aspects human information usage 
taylor francis london 
dillon framework design usable electronic text 
van de mul ch 
pp 

dillon watson user analysis hci historical lessons individual differences research 
international journal human computer studies pp 

local sciences viewing design human computer systems cognitive science 
carroll ch 
pp 

strong assessing software maintenance tool utilization task technology fit fitness models 
software maintenance research practice pp 

strong supporting software maintenance software engineering tools computed task technology fit analysis 
journal systems software pp 

long conception cognitive engineering design problem 
ergonomics pp 

draper nature expertise unix 
interact pp 

bibliography draper notion task hci 
interchi pp 

duke barnard duce may modelling 
human computer interaction pp 

effect graphic organizers learning remembering information connected discourse 
forum reading pp 

eastman cognitive processes ill defined problems case study design 
proceedings international joint conference artificial intelligence ijcai washington dc may pp 

kelly cognitive foundations interactive generative systems early design 
proceedings th international conference engineering design communication cooperation practice science munich germany aug eds technische universit nchen 
edwards decision technology 
annual review psychology pp 

egan individual differences human computer interaction 
helander ch 
pp 

eick steffen sumner jr seesoft tool visualizing line oriented software statistics 
ieee transactions software engineering nov pp 

engelbart augmented knowledge workshop 
pp 

engelbart special considerations individual user generator retriever information 
american documentation apr pp 

annual meeting american documentation institute berkeley ca october 
engelbart augmenting human intellect boosting collective iq 
communications acm aug 
middleton eds 
cognition communication 
cambridge university press 
ki eds 
perspectives activity theory 
cambridge university press 
erdem johnson marsella user task tailored software explanations 
retrieved www isi edu isd doc ase ps 
erickson lingua design places pattern languages 
dis pp 

ericsson chase exceptional memory 
american scientist pp 

ericsson simon protocol analysis 
mit press 
fagan design code inspections reduce errors program development 
ibm systems journal pp 

reprinted ibm systems journal pp 

fensel motta structured development problem solving methods 
eleventh workshop knowledge acquisition modeling management banff canada apr 
fields wright harrison designing human system interaction resource model 
human factors enhancing productivity quality life proceedings st asia pacific conference human computer interaction singapore june 
fields wright harrison objectives strategies resources design drivers 
human computer interaction interact sidney australia jul howard hammond eds chapman hall pp 

bibliography davies lambert kelly optimum display arrangements presenting visual reminders 
hci pp 

holt kerr kontogiannis ller mylopoulos stanley wong software bookshelf 
ibm systems journal nov 
fischer grudin mccall redmiles reeves shipman seeding evolutionary growth reseeding incremental development collaborative design environments 
coordination theory collaboration technology olson malone smith eds 
lawrence erlbaum associates mahwah nj pp 

fischer henninger redmiles cognitive tools locating comprehending software objects reuse 
icse pp 

fischer lemke mccall making argumentation serve design 
moran carroll ch 
pp 

fisher advancing study programming computer aided protocol analysis 
esp pp 

fisher defining novice user 
behaviour information technology pp 

flach hancock vicente eds 
global perspectives ecology human machine systems 
lawrence erlbaum associates 
flach hancock vicente preface 
global perspectives ecology human machine systems pp 
xi xiv 
flach ecology human machine systems personal history 
flach ch 
pp 

taxonomies human performance description human tasks 
academic press boston ma 
flor side side collaboration case study 
international journal human computer studies pp 

flor hutchins analyzing distributed cognition software teams case study team programming perfective software maintenance 
esp pp 

flower problem solving strategies writing th ed 
harcourt brace jovanovich college publishers fort worth 
fogel evolutionary computation new philosophy machine intelligence 
ieee press 
foltz comprehension coherence strategies hypertext linear text 
ch 
pp 

ford interacting visual abstractions programs 
proceedings ieee symposium visual languages bergen norway aug glinert olsen eds ieee computer society press pp 

freed human system modeling principles pragmatic approach 
design specification verification interactive systems proceedings eurographics workshop spain jun harrison torres eds springer verlag 
retrieved preprint human factors arc nasa gov cognition papers freed html 
furnas generalized fisheye views 
proceedings acm chi conference human factors computing systems boston ma apr association computing machinery pp 

bibliography gaines shaw concept maps hypermedia components 
international journal human computer studies pp 

gamma helm johnson vlissides design patterns elements reusable object oriented software 
addison wesley 
cheng framework classifying comparing software reverse engineering design recovery tools 
proceedings sixth working conference reverse engineering atlanta georgia oct ieee computer society press pp 

garg scacchi designing intelligent hypertext systems information management software engineering 
proceedings acm conference hypertext chapel hill nc nov association computing machinery pp 

designers 
phd thesis cognitive studies lund university 
gibson ecological approach visual perception 
houghton mifflin boston ma 
making information systems fit user needs 
proceedings fifth international conference human computer interaction hci international orlando fla aug smith salvendy eds vol 
advances human factors ergonomics elsevier science pp 

gilmore methodological issues study programming 
hoc ch 
pp 

gilmore visibility dimensional analysis 
hci pp 

gilmore green comprehension recall miniature programs 
international journal man machine studies pp 

gilmore green programming plans programming expertise 
quarterly journal experimental psychology pp 

gilmore winder eds 
user centred requirements software engineering environments vol 
nato asi series springer verlag 
goel sketches thought 
mit press cambridge ma 
goel pirolli structure design problem spaces 
cognitive science pp 

goguen tossing algebraic flowers great divide 
people ideas theoretical computer science calude ed 
springer new york pp 

goldman reading writing learning hypermedia environments 
van de mul ch 
pp 

goldman biswas cognition technology group vanderbilt 
computer technology complex problem solving issues study complex cognitive activity 
instructional science pp 

golovchinsky hypertext interfaces programmers 

right tool task investigation external representations program abstractions task requirements 
esp 
programming paradigms information types graphical representations empirical investigations novice program comprehension 
phd thesis university edinburgh 
gould lewis designing usability key principles designers think 
communications acm mar pp 

bibliography graham kennedy benyon methodology developing visualizations 
international journal human computer studies pp 

gray altmann cognitive modeling human computer interaction 
pp 

gray john atwood project validating goms analysis predicting explaining real world task performance 
human computer interaction pp 

gray analyzing novel expertise unmarked road 
ch 
pp 

green protocol analysis practical implementation 
handbook qualitative research methods psychology social sciences richardson ed 
british psychological society ch 
pp 

green cognitive dimensions notations 
hci pp 

green cognitive dimension viscosity sticky problem hci 
interact pp 

green limited theories framework human computer interaction 
ackermann tauber ch 
pp 

green nature programming 
hoc ch 
pp 

green programming languages information structures 
hoc ch 
pp 

green describing information artifacts cognitive dimensions structure maps 
hci pp 

green software engineers don listen psychologists don tell anyway 
gilmore pp 

green looking hci 
hci pp 

green commentary conception conception 
ergonomics pp 

green instructions descriptions cognitive aspects programming similar activities 
proceedings working conference advanced visual interfaces avi italy may ges levialdi eds acm press pp 

green bellamy parker parsing model device 
esp pp 

green benyon skull beneath skin entity relationship models information artifacts 
international journal human computer studies pp 

green blackwell cognitive dimensions information artefacts tutorial oct 
www uk thomas green papers retrieved 
green davies gilmore delivering cognitive psychology hci problems common language knowledge transfer 
interacting computers pp 

green gilmore blumenthal davies winder cognitive browser oops 
international journal human computer interaction pp 

green petre usability analysis visual programming environments cognitive dimensions framework :10.1.1.22.1477
journal visual languages computing pp 

bibliography green petre bellamy comprehensibility visual textual programs test match mismatch conjecture 
esp pp 

green schiele payne models user knowledge human computer interaction 
working computers theory versus outcome van der veer green 
hoc murray eds 
academic press limited pp 

greenberg computer user reuse organization computer tools 
cambridge university press 
greenberg thimbleby weak science human computer interaction 
chi research symposium human computer interaction monterey ca 
situations mental models generative knowledge 
ch 
pp 

griswold coping software change information transparency 
tech 
rep cs university california san diego department computer science engineering apr 
griswold chen tool support planning restructuring data abstractions large systems 
proceedings acm sigsoft conference foundations software engineering fse san francisco ca oct association computing machinery 
grudin computer reaches historical continuity interface design 
chi pp 

guarino formal ontology conceptual analysis knowledge representation :10.1.1.29.3373
international journal human computer studies pp 

sawyer effective automated application development tools 
ibm systems journal pp 

guindon designing design process exploiting opportunistic thoughts 
human computer interaction pp 

guindon requirements design object oriented graphical interface intelligent software design assistant 
chi pp 

guindon curtis control cognitive processes software design tools needed 
proceedings acm chi conference human factors computing systems washington may association computing machinery pp 

hale model programmers cognitive processes software maintenance structural learning theory approach debugging 
software maintenance research practice pp 

hancock ed 
human performance ergonomics 
academic press limited 
hansen user engineering principles interactive systems 
afips conference proceedings afips press pp 

harnad interactive cognition exploring potential electronic quote commenting 
cognitive technology search interface mey eds 
elsevier ch 
pp 

harrison fields wright supporting concepts operator control design functionally distributed systems 
revisiting allocation functions issue 
iea press pp 

hartman metacognition teaching learning 
instructional science pp 

bibliography hatcliff thiemann eds 
partial evaluation practice theory vol 
lecture notes computer science 
springer new york 
hayes nash nature planning writing 
levy ch 
pp 

hayes aristotelian platonic views knowledge representation 
cs pp 

hayes roth bb architecture blackboard systems control explain learn behavior 
tech 
rep cs tr stanford university department computer science dec 
hayes roth blackboard architecture control 
artificial intelligence pp 

hayes roth architectural foundations real time performance intelligent agents 
real time systems international journal time critical computing pp 

hayes roth architectural foundations real time performance intelligent agents 
second generation expert systems 
david 
krivine simmons eds 
springer verlag pp 

hayes roth hayes roth cognitive model planning 
cognitive science pp 

hayes roth washington distributing intelligence individual 
tech 
rep cs tr stanford university department computer science nov 
hearst research support digital libraries xerox parc part ii digital documents 
lib magazine june 
retrieved www dlib org dlib june hearst html 
helander ed 
handbook human computer interaction 
north holland 
henderson jr card rooms multiple virtual workspaces reduce space contention window graphical user interface 
acm transactions graphics july pp 

implications external memory investigations mind 
applied cognitive psychology dec pp 

hoc ed 
expertise technology cognition human computer cooperation 
lawrence erlbaum associates 
hoc 
human machine interaction human machine cooperation 
ergonomics pp 

hoc green gilmore eds 
psychology programming 
academic press limited san diego 
hoc green gilmore theoretical methodological issues 
hoc ch 
pp 

chapter 
hockey commentary advancing human factors involvement engineering design bridge far 
ergonomics pp 

holbrook golden age 
macmillan new york 
hollan hutchins kirsh distributed cognition new foundation human computer interaction research 
acm transactions computer human interaction june pp 

hollnagel hoc 
technology fundamental issues 
hoc ch 
pp 

holt williams eds 
computers writing state art 
kluwer academic publishers 
bibliography howes cognitive modelling human computer interaction 
monk gilbert ch 
pp 

howes young role cognitive architecture modelling user soar learning mechanism 
human computer interaction pp 

eder design science needs scope organization engineering design knowledge 
springer verlag london 
hunt theory thought 
sternberg ch 
pp 

hunter memory everyday life 
applied problems memory morris eds 
academic press limited ch 
pp 

hutchins learning navigate 
understanding practice perspectives activity context lave eds 
cambridge university press ch 
pp 

hutchins cognition wild 
mit press 
hutchins cockpit remembers speed 
cognitive science pp 

hutchins hollan norman direct manipulation interfaces 
norman draper ch 
pp 

hutchins distributed cognition airline cockpit 
middleton ch 
pp 


user manual 
peterson external memory aids relation memory 
cognitive psychology applied ed 
lawrence erlbaum associates ch 
pp 

peterson external internal memory aids 
journal experimental psychology general mar pp 

jackson aspect detecting bugs dependencies 
acm transactions software engineering methodology apr pp 

jackson rollins abstraction mechanisms pictorial slicing 
wpc pp 

jackson soloway design guided learner adaptable scaffolding interactive learning environments 
chi pp 

jahnke management uncertainty inconsistency database reengineering processes 
phd thesis fachbereich mathematik informatik universit paderborn aug 
jahnke reverse engineering tools media imperfect knowledge 
wcre pp 

jarvenpaa dickson graphics managerial decision making research guidelines 
communications acm june pp 

jennings coordination techniques distributed artificial intelligence 
foundations distributed artificial intelligence hare jennings eds 
john wiley sons ch 
pp 

jennings sycara wooldridge roadmap agent research development 
autonomous agents multi agent systems pp 

john kieras goms user interface design evaluation technique 
acm transactions computer human interaction dec pp 

bibliography johnson johnson wilson rapid prototyping user interfaces driven task models 
design envisioning technology system development carroll ed 
john wiley pp 

jones applied human memory models memory extender personal filing system 
international journal man machine studies pp 

identify binary relations domain models 
proceedings th international conference software engineering berlin germany mar ieee computer society press pp 

human computer interaction context activity theory perspective 
east west international conference human computer interaction proceedings st petersburg russia aug ed international centre scientific technical information pp 

nardi macaulay activity checklist tool representing space context 
interactions pp 

ed 
international encyclopedia ergonomics human factors 
taylor francis new york 
kellner non technological issues software engineering panel session overview 
icse pp 

kieras meyer overview epic architecture cognition performance application human computer interaction 
human computer interaction pp 

kieras meyer role cognitive task analysis application predictive models human performance 
ch 
pp 

kim lerch simon internal representation rule development object oriented design 
acm transactions computer human interaction pp 

howard ames criteria evaluation visual programming languages 
journal visual languages computing apr pp 

modeling strategic behavior human automation interaction aid go unused 
human factors pp 

requirements psychological models support design ecological task analysis 
flach ch 
pp 

ecological expert acting create information guide action 
proceedings fourth symposium human interaction complex systems dayton ohio mar pp 

everyday life environments 
companion cognitive science graham eds 
blackwell ma ch 
pp 

cognition human machine systems experiential environmental aspects adaptation 
hancock ch 
pp 

kirsh complementary strategies hands think 
proceedings seventeenth annual conference cognitive science society lawrence erlbaum associates 
kirsh maglio distinguishing epistemic pragmatic actions 
cognitive science pp 

hansen unitary theories cognitive architectures 
hoc ch 
pp 

bibliography eds 
complex information processing impact herbert simon 
lawrence erlbaum associates hillsdale nj 
knuth computer drawn flow charts 
communications acm sept pp 

koenemann robertson expert problem solving strategies program comprehension 
proceedings acm chi conference human factors computing systems new orleans la apr may association computing machinery pp 

kontogiannis partial design recovery dynamic programming 
proceedings cas conference toronto ontario oct ibm centre advanced studies 
koschke atomic architectural component recovery program understanding evolution evaluation automatic re modularization techniques integration semi automatic method 
phd thesis institut informatik universit stuttgart oct 
kosslyn visual mental images re presentations world cognitive neuroscience approach 

salvendy cognitive performance super experts computer program modification tasks 
ergonomics pp 

kraemer stasko issues visualization comprehension parallel programs 
wpc pp 

kremer concept mapping informal formal 
cs 
architectural blueprints view model software architecture 
ieee software nov pp 

diagrammatic representation reasoning 
machine graphics vision pp 

activity theory potential framework human computer interaction research 
nardi ch 
pp 

rethinking cognitive tools augmentation mediation extended 
proceedings second international conference cognitive technology information age aizu japan aug pp 

el internally replicated quasi experimental comparison checklist perspective reading code documents 
ieee transactions software engineering may pp 

landauer relations cognitive psychology computer science 
carroll ch 
pp 

landauer get real position role cognitive psychology design humanly useful usable systems 
carroll ch 
pp 

landauer trouble computers usefulness usability productivity 
mit press 
landauer foltz laham latent semantic analysis 
discourse processes pp 

lang von mayrhauser building research infrastructure program comprehension observations 
wpc pp 

larkin display problem solving 
ch 
pp 

bibliography larkin simon diagram worth words 
cognitive science pp 

lave cognition practice mind mathematics culture everyday life 
cambridge university press 
law 
situated cognition view effects planning authorship computer program debugging 
behaviour information technology pp 

lehman process improvement way forward 
advanced information systems engineering th international conference caise jyv skyl finland jun lyytinen rossi eds springer verlag pp 

lehrer authors knowledge patterns hypermedia design 
ch 
pp 

lethbridge singer great grep 
implications program comprehension tools 
online experience report 
retrieved iit nrc ca pdf 
lethbridge singer understanding software maintenance tools empirical research 
proceedings ieee workshop empirical studies software maintenance wess bari italy oct pp 

letovsky cognitive processes program comprehension 
esp pp 

levy eds 
science writing theories methods individual differences applications 
lawrence erlbaum associates 
lewis inner outer theory human computer interaction 
carroll ch 
pp 

man computer symbiosis 
ire transactions human factors electronics hfe mar pp 

lieberman ed 
wish command programming example 
morgan kaufmann san francisco ca 
dumas visualizing program dependencies experimental study 
software practice experience apr pp 

littman pinto letovsky soloway mental models software maintenance 
esp pp 

lloyd lawson scott concurrent verbalization reveal design cognition 
cross pp 

long specifying relations research design human computer interactions 
international journal human computer studies pp 

long conceptions discipline hci craft applied science engineering 
hci pp 

long cognitive engineering human computer interactions 
psychologist july pp 

macaulay benyon ethnography theory systems design intuition insight 
international journal human computer studies pp 

mackay responding cognitive overload adaptation users technology 
pp 

bibliography maes modeling adaptive autonomous agents 
artificial life overview langton ed 
mit press cambridge 
marchionini information seeking electronic environments 
cambridge university press 
marshall irish guided tours line presentations authors existing hypertext intelligible readers 
ht pp 

mathewson visual spatial thinking aspect science overlooked educators 
science education 
keil interface ease task technology fit 
information management nov pp 

mayer learners information processors limitations educational psychology second metaphor 
educational psychologist pp 

mayhew principles guidelines software user interface design 
prentice hall englewood cliffs nj 
mccarthy applied experimental psychology 
monk gilbert ch 
pp 

reitman hirtle knowledge organization skill differences computer programmers 
cognitive psychology pp 

thinking visually strategy manual problem solving 
lifetime learning publications belmont calif 
jr programming contract designing correctness 
journal object oriented programming may pp 

mcphee design theory software design 
tech 
rep tr department computing science university alberta oct 
meyers reiss empirical study multiple view software development 
sigsoft pp 

published proceedings acm sigplan sigsoft conference 
millen rapid ethnography time deepening strategies hci field research 
dis pp 

miller applying meta analytical procedures software engineering experiments 
tech 
rep empirical foundations computer science university strathclyde 
miller daly wood roper brooks statistical power subcomponents missing misunderstood concepts empirical software engineering research 
information software technology pp 

miller macdonald statistical analysis experimental studies 
tech 
rep empirical foundations computer science university strathclyde 
miller macdonald empirical incremental approach tool evaluation improvement 
journal systems software pp 

moher schneider methodology experimental research software engineering 
international journal man machine studies pp 

monk modeling cyclic interaction 
behaviour information technology pp 

monk gilbert eds 
perspectives hci diverse approaches 
academic press limited 
bibliography monk walsh dix comparison hypertext scrolling folding mechanisms program browsing 
hci pp 

moore distribution distributed cognition multiple interpretations uses 
educational psychology review pp 

moran command language grammar representation user interface interactive computer systems 
international journal man machine studies pp 

moran guest editor applied psychology user 
acm computing surveys mar pp 

moran carroll eds 
design rationale concepts techniques 
lawrence erlbaum associates mahwah nj 
hare system pictures formal documentation large programs 
acm transactions programming languages systems oct pp 

framework describing evaluating software visualization systems case study prolog 
phd thesis knowledge media institute open university 
ller rigi model software system construction integration evolution module interface specifications 
tech 
rep tr department computer science rice university houston texas aug 
phd 
thesis 
ller jahnke smith storey tilley wong reverse engineering roadmap 
software engineering 
acm pp 

ller rigi system programming large 
proceedings th international conference software engineering singapore apr ieee computer society press pp 

ller orgun tilley uhl reverse engineering approach subsystem structure identification 
software maintenance research practice oct pp 

ller tilley orgun reverse engineering environment spatial visual software interconnection models 
sigsoft pp 

published proceedings acm sigplan sigsoft conference 
murphy lightweight structural summarization aid software evolution 
phd thesis department computer science engineering university washington 
murphy notkin reengineering reflexion models case study 
computer aug pp 

murphy notkin sullivan software reflexion models bridging gap source high level models 
proceedings third sigsoft symposium foundations software engineering washington dc oct kaiser ed association computing machinery pp 

murphy notkin sullivan extending managing software reflexion models 
tech 
rep tr university british columbia department computer science sept 
myers art software testing 
john wiley sons new york ny 
narayanan visual language theory human computer interaction perspective 
visual language theory marriott meyer eds 
springer verlag ch 
pp 

bibliography nardi studying context comparison activity theory situated action models distributed cognition 
nardi ch 
pp 

nardi activity theory human computer interaction 
context consciousness activity theory human computer interaction ch 
pp 

nardi ed 
context consciousness activity theory human computer interaction 
mit press cambridge ma 
nardi models metaphors visual formalisms user interface design 
journal visual languages computing pp 

naur program development studies diaries 
psychology computer stephen van der veer eds 
associated press pp 

naur computing human activity 
association computing machinery 
naur place strictly defined notation human insight 
computing human activity ch 

originally published proceedings workshop logic ed 
dybjer nordstrom petersson smith 
report programming methodology group univ teborg chalmers university technology teborg sweden may 
role external representations writing process implications design hypertext writing tools 
ht pp 

newell problems basic organization problem solving programs 
proceedings second conference self organizing systems jacobi goldstein eds spartan books pp 

newell heuristic programming ill structured problems 
progress operations research relationship operations research computer ed vol 

john wiley sons new york pp 

newell play questions nature win projective comments papers symposium 
visual information processing academic press pp 

newell knowledge level 
artificial intelligence pp 

newell unified theories cognition 
harvard university press 
newell pr cis unified theories cognition 
behavioral brain sciences pp 

newell card prospects psychological science human computer interaction 
human computer interaction pp 

newell simon human problem solving 
prentice hall 
newell simon herbert computer science empirical inquiry symbols search 
communications acm mar pp 

newell gregor extra ordinary human machine interaction learned people disabilities 
cognition technology pp 

newman preliminary analysis products hci pro forma abstracts 
proceedings acm chi conference human factors computing systems boston ma apr adelson dumais olson eds vol 
association computing machinery pp 

bibliography snake oil 
skeptical newsletter dec 
retrieved www org sb html 
distribution reflections 
salomon ch 
pp 

basic versus applied research 
sternberg ch 
pp 

nielsen virtual protocol model computer human interaction 
international journal man machine studies pp 

nielsen matters really matter hypertext usability 
ht pp 

nielsen evaluating thinking aloud technique computer scientists 
advances human computer interaction hartson hix eds vol 

ablex norwood nj pp 

nielsen layered interaction analysis direct manipulation 
unpublished online 
retrieved www com papers direct manipulation html 
nielsen usability engineering 
academic press boston ma 
nielsen mack eds 
usability inspection methods 
john wiley sons new york ny 
nii blackboard systems 
tech 
rep cs tr stanford university department computer science june 
nii blackboard systems 
ai magazine pp 

parts second pp 

revised version published handbook artificial intelligence vol barr cohen feigenbaum ed addison wesley 
nix editing example 
acm transactions programming languages systems oct pp 

norman twelve issues cognitive science 
cognitive science pp 

reprinted chapter perspectives cognitive science 
norman ed norwood nj ablex 
norman stages user activities 
interact pp 

norman cognitive engineering 
norman draper ch 
pp 

norman cognitive engineering cognitive science 
carroll ch 
pp 

norman psychology everyday things 
basic books 
norman cognitive artifacts 
carroll ch 
pp 

norman cognition head world special issue situated action 
cognitive science pp 

norman things smart defending human attributes age machine 
addison wesley reading massachusetts 
norman invisible computer products fail personal computer complex information appliances solution 
mit press 
norman affordance conventions design 
interactions pp 

norman draper eds 
user centered system design new perspectives human computer interaction 
lawrence erlbaum associates hillsdale nj 
notkin error reporting graduated color 
ieee software nov pp 

bibliography hara typology reading goals 
tech 
rep epc rank xerox research centre cambridge uk 
hara payne planning user interface effects lockout time error recovery cost 
international journal human computer studies pp 

olson moran commentary damaged merchandise 
human computer interaction pp 

design computer cognitive tools 
nato asi pp 

human cognition programming 
hoc ch 
pp 

paige simon cognitive processes solving algebra word problems 
problem solving research method theory carnegie institute technology apr ed pp 

social constructivist perspectives teaching learning 
annual review psychology pp 

designing automation human empirical studies quantitative models 
ergonomics pp 

parnas criteria decomposing systems modules 
communications acm dec pp 

parnas design development program families 
ieee transactions software engineering se pp 

parnas software aspects strategic defense systems 
communications acm dec pp 

parnas clements rational design process fake 
ieee transactions software engineering se feb pp 

seifert opportunistic planning reminded pending goals 
cognitive psychology oct pp 

paul prakash framework source code search program patterns 
ieee transactions software engineering june pp 

payne looking hci interact pp 

payne interface problems interface resources 
carroll ch 
pp 

payne mental models cognitive artefacts 
rogers ch 
pp 

payne psychology cognitive technologies 
psychologist july pp 

pea practices distributed intelligence designs education 
salomon ch 
pp 

pemberton external representations writing process support 
artificial intelligence education lisbon portugal sep oct 
pennington comprehension strategies programming 
esp pp 

pennington stimulus structures mental representations expert comprehension computer programs 
cognitive psychology pp 

pennington grabowski tasks programming 
hoc ch 
pp 

bibliography perkins fingertip effect information processing technology shapes thinking 
educational researcher aug pp 

perkins person plus distributed view thinking learning 
salomon ch 
pp 

perry cognitive artefacts collaborative design 
iee colloquium design systems users mind role cognitive artefacts pp 

perry thomas internal collaborative design dynamic problem visualisation 
hci pp 

adjunct proceedings 
perry distributed cognition computer supported collaborative design organisation construction engineering 
phd thesis department information systems computing brunel university 
peterson ed 
forms representation interdisciplinary theme cognitive science 
intellect exeter uk 
petre looking isn seeing readership skills graphical programming 
communications acm june pp 

petre blackwell mental imagery program design visual programming 
international journal human computer studies pp 

petre blackwell green cognitive questions software visualization 
software visualization programming multimedia experience stasko domingue price brown eds 
mit press pp 

petre green learning read graphics evidence seeing information display acquired skill 
journal visual languages computing pp 

evolution useful things 
new york ny 
pirolli unified model learning program 
nato asi pp 

reuse strategies software development empirical study 
information software technology aug pp 

polya solve new aspect mathematical method nd ed 
doubleday garden city nj 
poon maher emergent behaviour evolutionary design 
international conference artificial intelligence design th stanford ca gero sudweeks eds kluwer academic publishers pp 

preston cognition tool 
mind language pp 

price baecker small principled taxonomy software visualization 
journal visual languages computing pp 

purcell gero drawings design process 
design studies pp 

purcell gero edwards mcneill data design protocols issue data coding data analysis development models design process 
cross pp 

purchase performance layout algorithms comprehension computation 
journal visual languages computing pp 

pylyshyn role cognitive architecture theories cognition 
architectures intelligence van ed 
lawrence erlbaum associates hillsdale nj pp 

bibliography pylyshyn ed 
constraining cognitive theories issues options 
ablex publishing 
pylyshyn remarks theory practice gap 
carroll ch 
pp 

pylyshyn cognitive architecture hope science cognition 
pylyshyn ch 
pp 

quilici reverse engineering legacy systems path success 
th international conference software engineering seattle washington apr ieee computer society press pp 

buxton design evaluation 
baecker buxton ch 
pp 

rasmussen skills rules knowledge signals signs symbols distinctions human performance models 
ieee transactions systems man cybernetics pp 

rasmussen framework cognitive task analysis system design 
tech 
rep ris ris national laboratory dk roskilde denmark aug 
rasmussen information processing human machine interaction approach cognitive engineering 
north holland new york 
rasmussen mental models control action complex environments 
ackermann tauber ch 
pp 

rasmussen pejtersen virtual ecology 
flach ch 
pp 

rasmussen pejtersen cognitive systems engineering 
john wiley sons new york ny 
redmiles observations empirical studies developing knowledge software engineering tool 
proceedings eighth knowledge software engineering conference chicago illinois sep ieee computer society press sept pp 

redmiles reducing variability programmers performance explained examples 
inter chi pp 

software reuse external memory cognitive issues support tools 
ppig workshop proceedings open university milton keynes uk jan psychology programming interest group 
retrieved ppig org papers th pdf 
cognitive approach supporting reuse 
phd thesis university sussex june 
hat understanding 
communications acm oct pp 

rheingold tools thought history mind expanding technology 
mit press 
rich formal representation plans programmer apprentice 
proceedings th international joint conference ai vancouver bc aug ed pp 

rich waters programmer apprentice 
association computing machinery 
richardson stafford fraser wood hopper virtual network computing 
ieee internet computing jan pp 

rittel webber dilemmas general theory planning 
policy sciences pp 

ritter larkin developing process models summaries hci action sequences 
human computer interaction pp 

bibliography robbins hilbert redmiles extending design environments software architecture design 

robbins redmiles software architecture design perspective human cognitive needs 
proceedings california software symposium css university southern california los angeles ca apr pp 

robson bennett munro approaches program comprehension 
journal systems software feb pp 

rogers bannon button report interchi workshop rethinking theoretical frameworks hci amsterdam th april 
acm sigchi jan pp 

rogers ellis distributed cognition alternative framework analysing explaining collaborative working 
journal information technology pp 

rogers rutherford bibby eds 
models mind theory perspective application 
academic press limited 
rosenblum method programming assertions 
th ieee international conference software engineering melbourne australia may ieee computer society press may pp 

rosson role experience editing 
interact pp 

rosson maass kellogg designer user building requirements design tools design practice 
communications acm nov pp 

dillon eds 
hypertext cognition 
lawrence erlbaum associates mahwah nj 
task activity models hypertext usage 
van de mul ch 
pp 

rumbaugh jacobson booch unified modeling language manual 
addison wesley reading ma 
rumelhart norman representation memory 
stevens handbook experimental psychology atkinson luce eds nd ed vol 
learning cognition 
john wiley sons new york pp 

sagan demon world science candle dark 
random house new york ny 
program editing variable plans cognitive approach program manipulation 
proceedings third international conference human computer interaction boston ma aug salvendy smith eds elsevier science pp 

salomon ed 
distributed psychological educational considerations 
cambridge university press 
salomon nature pedagogic computer tools case writing partner 
ch 
pp 

sass wilkinson eds 
symposium computer augmentation human reasoning washington jun spartan books savage belkin interaction information retrieval trends time 
journal american society information science oct pp 

bibliography scaife rogers external cognition graphical representations 
international journal human computer studies pp 

schauble raghavan glaser discovery reflection notation graphical trace supporting self regulation computer laboratories 
ch 
pp 

sch reflective practitioner professionals think action 
basic books new york 
sch educating reflective practitioner new design teaching learning professions 
bass san francisco 
sch bennett reflective conversation materials interview donald sch john bennett 
bringing design software winograd bennett de young eds 
association computing machinery ch 
pp 

sch trade internal external information storage 
journal memory language pp 

sch retrieving texts external store effects explanatory context semantic fit text address 
psychological research pp 

sch memory control extended memory systems 
discourse comprehension essays honor walter kintsch weaver iii fletcher eds 
lawrence erlbaum ch 
pp 

chipman eds 
cognitive task analysis 
lawrence erlbaum mahwah nj 
sen liou role control model formulation process 
information systems research pp 

model understanding program impact design programming language grade 
psychology computer green payne van der veer eds 
academic press limited pp 

development cognitive model computer support collaborative writing 
journal computer assisted learning pp 

designs new writing environments 
van der ch 
pp 

writing creative design 
levy pp 

pemberton representing writing external representations writing process 
holt williams ch 
pp 

van der eds 
new writing environment writers world technology 
springer verlag london 
shaw larger scale systems require higher level abstractions 
proceedings fifth international workshop software specification design pittsburgh pennsylvania may association computing machinery pp 

published software engineering notes 
shaw prospects engineering discipline software 
ieee software nov pp 

shaw garlan software architecture perspectives emerging discipline 
prentice hall upper saddle road nj 
psychological study programming 
acm computing surveys mar pp 

bibliography shneiderman software psychology human factors computer information systems 
cambridge ma 
shneiderman carroll ecological studies professional programmers overview 
communications acm nov pp 

shneiderman mayer syntactic semantic interactions programming behaviour model 
international journal computer information sciences pp 

shneiderman shafer simon display strategies program browsing 
proceedings ieee conference software maintenance washington dc nov ieee computer society press pp 

shukla redmiles collaborative learning software bug tracking scenario 
workshop approaches distributed learning computer supported collaborative learning boston ma nov nov 
shum hammond transferring hci modelling design techniques practitioners framework empirical 
people computers ix proceedings hci glasgow scotland aug cockton draper weir eds cambridge university press pp 

engines mind history computer 
norton new york 
knowledge toolkit software visualisation 
pp 

sim clarke holt archetypal source code searching survey software developers maintainers 
wpc 
sim holt ramp problem software projects case study software 
proceedings th international conference software engineering kyoto japan apr ieee computer society press apr pp 

simon architecture complexity 
proceedings american philosophical society dec pp 

simon forms mental representation 
perception cognition issues foundations psychology vol 
minnesota studies philosophy science university minnesota press pp 

simon sciences artificial rd ed 
mit press 
singer lethbridge just time comprehension vs full coverage strategy 
proceedings workshop empirical studies software online bethesda md nov 
position 
retrieved www cs umd edu wess papers singer html 
singer lethbridge studying practices assist tool design software engineering 
wpc pp 

singer lethbridge examination software engineering practices 
proceedings seventh centre advanced studies conference toronto ontario nov ibm centre advanced studies nov pp 

carroll synthesis analysis modes reasoning guide design 
moran carroll ch 
pp 

carroll alpert psychological design rationale intelligent tutoring system smalltalk 
esp pp 

bibliography carroll alpert incidental reification goals intelligent tutor smalltalk 
nato asi pp 

sinha vessey cognitive fit recursion iteration empirical study 
ieee transactions software engineering may pp 

skillicorn talia models languages parallel computation 
acm computing surveys pp 

smith collective intelligence computer collaboration 
lawrence erlbaum associates mahwah nj 
smith cognitive basis computer writing environment 
computer writing environments theory research design britton glynn eds 
lawrence erlbaum associates hillsdale nj ch 
pp 

smith designing theory systems case study 
chi pp 

smolensky proper treatment connectionism 
behavioral brain sciences pp 

snelting concept analysis new framework program understanding 
proceedings acm sigplan sigsoft workshop program analysis software tools engineering paste montreal canada jun pp 

soloway learning program learning construct mechanisms explanations 
communications acm sept pp 

soloway adelson ehrlich knowledge processes comprehension computer programs 
chi pp 

soloway ehrlich cognitive strategies looping constructs empirical study 
communications acm pp 

soloway ehrlich empirical studies programming knowledge 
ieee transactions software engineering se sept pp 

soloway jackson klein reed studer eng scala learning theory practice case studies learner centered design 
chi pp 

sommerville software engineering 
addison wesley reading massachusetts 
spence tweedie attribute explorer information synthesis exploration 
interacting computers pp 

clarkson eckert ai approach supporting human decision making design 
th computers information engineering conference proceedings asme design engineering technical conferences 
baltimore md sep american society mechanical engineers 
detc cie 
star working symbolic activity theory information systems 
middleton ch 
pp 

sternberg ed 
nature cognition 
mit press 
storey 
cognitive framework describing evaluating software exploration tools 
phd thesis school computing science simon fraser university 
bibliography storey 
fracchia ller cognitive design elements support construction mental model software visualization 
journal systems software jan pp 

storey 
wong fong hooper hopkins ller designing experiment evaluate reverse engineering tool 
third working conference reverse engineering wcre monterey ca nov ieee computer society press nov 
storey 
wong fracchia ller integrating visualization techniques effective software exploration 
proceedings ieee symposium information visualization infovis phoenix az oct pp 

storey 
wong ller program understanding tools affect programmers understand programs 
science computer programming mar pp 

suchman plans situated actions problem human computer communication 
cambridge university press new york 
sugiyama misue graphic interfaces idea organizers 
interact pp 

sutcliffe effective reuse hci knowledge 
acm transactions computer human interaction june pp 

sutcliffe carroll designing claims reuse interactive systems design 
international journal human computer studies pp 

purcell gero macroscopic analysis design processes scheme coding designers cognitive actions 
design studies pp 

tversky architects see sketches implications design tools 
chi pp 

bodily mathematics 
fingers infinity journey history mathematics 
open court chicago 
neal eds 
structure editors environments 
academic press limited 
software visualisation support program comprehension 
phd thesis university exeter department computer science july 
applying traditional unix tools maintenance experience report 
wcre pp 

tauscher greenberg people revisit web pages empirical findings implications design history systems 
international journal human computer studies pp 

taylor layered protocols computer human dialogue 
principles 
international journal man machine studies pp 

program comprehension skills acquisition call ecological paradigm 
nato asi pp 

teitelman display oriented programmer assistant 
international journal man machine studies pp 

instructional design theory research models 
instructional design international perspectives dijkstra eds vol 

lawrence erlbaum associates ch 
pp 

bibliography jorgensen supporting designers reaching users 
ch 
pp 

thagard mind cognitive science 
mit press cambridge ma 
tichy computer scientists experiment 
computer may pp 

tilley canonical activities reverse engineering 
annals software engineering may pp 

tilley paul smith framework program understanding 
wpc pp 

tilley whitney ller storey 
personalized information structures 
acm eleventh international conference systems documentation oct association computing machinery pp 

welsh systematic evaluation design choices software development tools 
software concepts tools pp 

tweedie interactive visualisation artifacts abstractions inform design 
hci pp 

tweedie characterizing interactive 
chi 
holt hybrid process recovering software architecture 
proceedings cascon toronto canada nov 
holt algorithm comprehension driven clustering 
proceedings seventh working reverse engineering wcre brisbane australia nov pp 

ulam adventures mathematician 
new york 
reflective practice design teams 
design studies july pp 

van de velde cognitive architectures knowledge level structural coupling 
biology technology intelligent autonomous agents steels ed vol 
nato asi series computer systems science 
springer verlag pp 

van de mul eds 
cognitive aspects electronic text processing vol 
advances discourse processes 
ablex publishing norwood nj 
van van der veer eli ns ontology task world models 
proceedings th international eurographics workshop design specification verification interactive systems uk jun 
vans multi level code comprehension model large scale software 
phd thesis colorado state university department computer science nov 
vessey expertise debugging computer programs process analysis 
international journal man machine studies pp 

vessey cognitive fit theory analysis graphs versus tables literature 
decision sciences pp 

vicente cognitive analysis safe productive healthy computer 
lawrence erlbaum associates mahwah nj 
bibliography vicente implications ecological approach human factors 
flach ch 
pp 

sen liou blackboard approach model formulation 
proceedings fifth hawaii international conference system sciences jan shriver nunamaker sprague eds vol 
pp 

sen liou operationalizing opportunistic behavior model formulation 
international journal man machine studies mar pp 

visser plan design opportunistic deviations specification 
international journal man machine studies pp 

visser planning organization expert design activities 
gilmore pp 

visser hoc 
expert software design strategies 
hoc ch 
pp 

von mayrhauser maintenance evolution software products 
advances computers volume zelkowitz eds vol 
advances computers 
academic press limited pp 

von mayrhauser lang evaluating software maintenance support tools support program comprehension 
proceedings ieee aerospace conference mar pp 

von mayrhauser lang coding scheme support systematic analysis software comprehension 
ieee transactions software engineering july pp 

von mayrhauser vans code comprehension model 
tech 
rep cs computer science department colorado state university fort collins 
von mayrhauser vans code comprehension model tool capabilities 
proceedings international conference computers information may chang eds ieee computer society press pp 

von mayrhauser vans code understanding needs reverse engineering tool capabilities 
proceedings sixth international conference computer aided software engineering institute systems science national university singapore singapore jul 
lee reid eds ieee computer society press pp 

von mayrhauser vans program comprehension tool requirements industrial environment 
proceedings second workshop program comprehension capri italy jul ieee computer society press pp 

von mayrhauser vans comprehension processes large scale maintenance 
icse pp 

von mayrhauser vans dynamic code cognition behaviors large scale code 
wpc pp 

von mayrhauser vans industrial experience integrated code comprehension model 
software engineering journal sept pp 

von mayrhauser vans program comprehension software maintenance evolution 
computer aug pp 

von mayrhauser vans program understanding models experiments 
advances computers volume zelkowitz eds vol 
advances computers 
academic press limited pp 

bibliography von mayrhauser vans identification dynamic comprehension processes large scale maintenance 
ieee transactions software engineering june pp 

von mayrhauser vans role hypotheses opportunistic understanding porting large scale code 
wpc pp 

von mayrhauser vans increasing knowledge large scale software comprehension 
empirical software engineering pp 

von mayrhauser vans program understanding behavior debugging large scale software 
empirical studies programmers seventh workshop alexandria va oct wiedenbeck scholtz eds association computing machinery pp 

von mayrhauser vans program understanding software adaptation tasks 
proceedings international conference software maintenance csm bethesda md nov ieee computer society press pp 

von mayrhauser vans howe program understanding behaviour enhancement large scale software 
journal software maintenance research practice pp 

von mayrhauser vans howe program understanding behaviour enhancement large scale software 
software maintenance research practice pp 

cognitive theory educational technology 
nato asi pp 

de glaser eds 
international perspectives design technology supported learning environments 
lawrence erlbaum associates 
developing designer toolkit software comprehension models 
proceedings th ieee international conference automated software engineering honolulu hawaii oct ieee computer society press pp 

ware foundations experimental semiotics theory sensory conventional representation 
journal visual languages computing pp 

ware information visualization perception design 
morgan kaufman san francisco 
ware franck evaluating stereo motion cues visualizing information nets dimensions 
acm transactions graphics apr 
warren jr constructing 
flach ch 
pp 

axtell interplay cognitive organizational factors software development 
proceedings interact fifth international conference human computer interaction norway june gilmore eds chapman hall pp 

webb cognitive bias software engineering 
communications acm june pp 

weiser programmers slices debugging 
communications acm july 
weiser lyle experiments slicing debugging aids 
esp pp 

weiser shneiderman human factors software design development 
handbook human factors ergonomics salvendy ed 
john wiley sons pp 

bibliography weizenbaum computer power human reason judgment calculation 
freeman san francisco 
welty augmenting syntax trees program understanding 
proceedings international conference automated software engineering ase lake tahoe ca nov nov 
welty integrated representation software development discovery 
phd thesis rensselaer polytechnic institute department computer science july 
wexelblat maes footprints history rich tools information foraging 
proceedings acm chi conference human factors computing systems pittsburgh pa may association computing machinery pp 

model engineering design process derived hearsay ii 
interact 
constructing appropriate models computer users case engineering designers 
cognitive ergonomics human computer interaction long eds vol 
cambridge series human computer interaction 
cambridge university press cambridge uk ch 
pp 

distinguishing tasks enabling tasks 
interacting computers pp 

discussion improving human computer interaction quest cognitive 
carroll pp 

whitley visual programming languages empirical evidence 
journal visual languages computing feb pp 

wiecha henrion linking multiple program views visual cache 
proceedings ifip interact human computer interaction stuttgart germany sep shackel eds ifip north holland pp 

wilde cognitive dimensions classroom discussion tool visual language design 
chi 
han sequential experimentation human computer interface design 
advances human computer interaction hartson hix eds vol 

ablex norwood nj pp 

wills automated program recognition graph parsing 
tech 
rep tr mit artificial intelligence laboratory 
phd thesis 
account readers search information diagrams 
contemporary educational psychology pp 

winograd programming environments environments designing 
communications acm june pp 

winograd flores understanding computers cognition new foundation design 
ablex norwood nj 
wolf carroll landauer john role laboratory experiments hci help hindrance ho hum 
chi pp 

wong tilley ller storey 
structural case study 
ieee software jan pp 

bibliography woods commentary cognitive engineering complex dynamic worlds 
cognitive engineering complex dynamic worlds hollnagel mancini woods eds 
academic press limited 
originally published international journal man machine studies pp 

woods quilici yang constraint design recovery software reengineering theory experiments 
kluwer academic publishers 
situated cognition classroom example 
cognitive science pp 

wright cognitive overheads prostheses issues evaluating hypertexts 
proceedings third annual acm conference hypertext san antonio tx dec association computing machinery pp 

wright textbook 
hypertext psychological perspective mcknight dillon richardson eds 
ellis horwood pp 

wright fields harrison distributed information resources new approach interaction modelling 
proceedings ecce eighth european conference cognitive ergonomics spain sep 
wright fields harrison analyzing human computer interaction distributed cognition resources model 
human computer interaction mar pp 

young barnard scenarios human computer interaction research cumulative science 
proceedings acm chi gi conference human factors computing systems graphics interface toronto canada apr association computing machinery pp 

young green simon programmable user models predictive evaluation interface designs 
chi pp 

young simon planning context human computer interaction 
proceedings conference people computers iii exeter uk sep diaper winder eds cambridge university press pp 

zachary le ryder interface agents complex systems 
human interaction complex systems conceptual principles design practice park eds 
kluwer academic publishers pp 

zelkowitz wallace experimental models validating technology 
computer may pp 

zhang representational analysis relational information displays 
international journal human computer studies pp 

zhang nature external representations problem solving 
cognitive science pp 

zhang norman representations distributed cognitive tasks 
cognitive science pp 

zimmermann framework assessing group memory approaches software design projects 
dis pp 

ziv osterweil research issues intersection hypertext software development environments 
pp 

bibliography chi 
proceedings acm chi conference human factors computing systems austin tx apr may association computing machinery 
chi 
proceedings acm chi conference human factors computing systems seattle wa apr association computing machinery 
chi 
proceedings acm chi conference human factors computing systems monterey ca may association computing machinery 
chi 
proceedings acm chi conference human factors computing systems denver colorado may association computing machinery 
chi 
guest tauber eds 
proceedings chi conference human factors computing vancouver bc apr association computing machinery 
chi 
pemberton ed 
proceedings chi conference human factors computing atlanta ga mar association computing machinery 
chi 
proceedings acm chi conference human factors computing systems los angeles ca apr association computing machinery 
cs 
dick sowa eds 
conceptual structure current practices proceedings second international conference conceptual structures college park maryland aug vol 
lecture notes artificial intelligence springer verlag 
ct 
benyon nehaniv dautenhahn eds 
instruments mind proceedings fourth international conference cognitive technology vol 
lecture notes artificial intelligence springer verlag 
dis 
proceedings designing interactive systems processes practices methods techniques brooklyn ny aug association computing machinery 
dis 
proceedings designing interactive systems processes practices methods techniques dis netherlands aug association computing machinery 
esp 
soloway iyengar eds 
empirical studies programmers washington dc jun ablex publishing 
esp 
olson sheppard soloway eds 
empirical studies programmers second workshop washington dc dec ablex publishing 
esp 
koenemann robertson eds 
empirical studies programmers fourth workshop new brunswick nj dec ablex publishing 
esp 
cook scholtz spohrer eds 
empirical studies programmers fifth workshop palo alto ca dec ablex publishing 
esp 
gray boehm davis eds 
empirical studies programmers sixth workshop alexandria va jan ablex publishing 
hci 
jones winder eds 
people computers iv proceedings fourth conference british computer society human computer interaction specialist group university manchester sep british informatics society cambridge university press 
hci 
sutcliffe macaulay eds 
people computers proceedings fifth conference british computer society human computer interaction specialist group university nottingham uk sep british informatics society cambridge university press 
bibliography hci 
diaper hammond eds 
people computers vi proceedings hci conference edinburgh scotland aug british informatics society cambridge university press 
hci 
kirby dix eds 
people computers proceedings hci england aug sep cambridge university press 

anzai ogawa mori eds 
symbiosis human artifact computing design human computer interaction tokyo japan jul vol 
advances human factors ergonomics elsevier science 
proceedings acm conference history personal workstations palo alto ca jan association computing machinery 
ht 
proceedings second annual acm conference hypertext pittsburgh pa nov association computing machinery 
icse 
th ieee international conference software engineering austin tx may ieee computer society press 
icse 
ieee international conference software engineering may ieee computer society press 
interact 
shackel ed 
proceedings ifip interact human computer interaction london sep ifip north holland 
interact 
diaper ed 
proceedings ifip interact human computer interaction cambridge aug ifip north holland 
interchi 
ed 
interchi conference proceedings bridges worlds amsterdam netherlands apr association computing machinery 

proceedings eleventh knowledge software engineering conference syracuse ny sep ieee computer society press 
nato asi 
du boulay eds 
cognitive models intelligent environments learning programming vol 
nato asi series 
series computer system sciences nato springer verlag 
nato asi 
eds 
technology learning environments psychological educational foundations vol 
nato asi series 
series computer system sciences nato springer verlag 
nato asi 
computers exploratory learning vol 
nato asi series 
series computer system sciences springer verlag 

taylor coutaz eds 
software engineering human computer interaction icse workshop se hci joint research issues sorrento italy may springer verlag 
sigsoft 
proceedings acm sigplan sigsoft conference washington dc dec vol 
association computing machinery 
published proceedings acm sigplan sigsoft conference 

gero tversky eds 
visual spatial reasoning design mit ma jun key centre design computing cognition university sydney 
wcre 
proceedings th working conference reverse engineering brisbane australia nov ieee computer society press 
bibliography wcre 
proceedings working conference reverse engineering baltimore maryland may ieee computer society press 
wpc 
proceedings program comprehension workshop ieee computer society press 
wpc 
ed 
proceedings third workshop program comprehension washington dc nov ieee computer society press 
wpc 
cimitile ller eds 
proceedings fourth workshop program comprehension berlin mar ieee computer society press 
wpc 
proceedings fifth workshop program comprehension michigan may ieee computer society press 
wpc 
proceedings sixth ieee international workshop program comprehension italy jun ieee computer society press 
