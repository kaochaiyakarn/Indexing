artificial intelligence formalizing sensing actions transition function approach tran cao son baral knowledge systems laboratory computer science department stanford university stanford ca usa department computer science engineering arizona state university tempe az usa received april received revised form december presence incomplete information world need distinguish state world state agent knowledge world 
case agent may need disposal sensing actions change state knowledge world may need construct general plans consisting sensing actions conditional statements achieve goal 
develop high level action description language allows specification sensing actions effects domain description allows queries conditional plans 
give provably correct translations domain description language axioms order logic relate formulation earlier formulations literature 
analyze state space formulation develop sound approximations smaller state spaces 
define regression knowledge formulas conditional plans 
elsevier science rights reserved 
keywords sensing actions action description languages conditional plans regression knowledge formulas incomplete information approximate reasoning 
motivation actions change world sensing knowledge producing actions change agent knows world 
consider example high security door 
action pushing door push door executed world lock door initially unlocked change world corresponding author 
mail addresses ksl stanford edu son asu edu baral 
see front matter elsevier science rights reserved 
pii son baral artificial intelligence action performed door open 
action executed door locked jam door 
similarly action flipping lock flip lock unlock locked door lock unlocked door 
hand sensing action checking lock door check locked result agent knowing door locked 
sensing actions play important role agent needs plan presence incomplete information 
consider case agent initially initial situation know door locked knows door open goal open door 
assume actions perform ones described earlier check locked flip lock push door 
argue agent just construct classical plan consisting sequence actions regardless real state world succeed reaching agent goal 
consider plan consisting push door 
plan door initially locked 
fact jam door subsequent action sequence result door open 
consider plan consisting flip lock push door 
plan door initially unlocked 
fact jam door subsequent action sequence result door open 
plan starts cases 
fact action check locked change world sequence flip locks equivalent zero single flip lock conclude exist classical plan possible initial situations 
simple conditional plan door locked push door flip lock push door appropriate 
agent knowing door locked true execute plan 
correct conditional plan achieve goal uses sensing action check locked follows check locked door locked push door flip lock push door 
sensing actions important planning presence incomplete information 
past sensing actions formalized planning presence incomplete information studied :10.1.1.15.5194
motivate briefly review earlier formalizations sensing actions 

moore formalization best knowledge sensing actions formalized moore dissertation papers example 
moore uses possible son baral artificial intelligence world semantics represent knowledge treats accessibility relation worlds fluent reasoning sensing non sensing actions 
describes knowledge agent may change executing action defining accessibility relation worlds may reached executing action possible worlds result execution worlds compatible agent knows exactly worlds result executing world compatible agent knows 
formally written follows acc acc 
formula formula simplified version moore original formula 
function situation calculus acc denote accessible compatible assume single agent world 
describes knowledge agent may change executing sensing action defining accessibility relation worlds may reached executing suppose action agent perform know true 
world represented result happening world compatible agent knows exactly worlds result happening world compatible agent knows truth value 
formally written follows acc 
acc 
scherl levesque formalization 
scherl levesque adapted moore formulation situation calculus proved important results formulation knowledge producing actions affect fluents knowledge fluent actions knowledge producing affect knowledge fluent appropriate 
showed regression applied knowledge producing actions 
slight simplification moore formulation formulas note relation follow rest denotes world reached executing action world son baral artificial intelligence arguments reversed normal modal logic 
read situation accessible situation 
situation term constructed repeated application initial situation 


simplification goals easy visualize state space deal searching plans presence sensing actions incomplete information 
formulations planning example research decision theoretic planning assume existence transition function defining transition states collection fluents due actions necessarily depend logical formulation defining function 
questions answer state need distinguish state world state knowledge agent 
state transitions due actions sensing non sensing defined 
answer question introduce notion state combined state pair consisting real state world ii state agent knowledge world set states agent thinks may 
transition states due actions denoted defined terms original transition states defined function res way non sensing action state defined pair res res sensing action senses fluent state defined pair iff consider example section 
possible initial states explicit representation negative fluents example locked locked locked fig 
give fragment state space diagram example illustrating transitions take place state actions 
logical formalization simplify moore scherl levesque formulation assuming need proceed relation initial situation possible situations 
formulas modified follows 
son baral artificial intelligence fig 

transition states door opening example 
formulas successor state axioms actions information initial situation reason known true situation 
discuss formulation detail section 

goals goal augment high level language allow specifications reasoning sensing actions :10.1.1.34.7448
call new language ak semantics domain descriptions ak defined transition functions introduced previous subsection 
motivation doing simplicity high level languages fact knowledge particular logics necessary understand concept 
pay price general formalization done standard logical language classical logic possibly augmented circumscription logic programming default logic 
give formalizations logic prove correctness logical formalization respect son baral artificial intelligence original formalization 
initial formalization high level language simpler follow play role benchmark formalizations standard logical languages 
second goal important aspect approximations language ak motivation possible state space explosion ak fluents possible states possible states 
develop approximations smaller state space varying complexity computing transitions 
show soundness approximations 
relate formulations earlier formulations sensing actions particular scherl levesque formulation lobo formulation show translate domain descriptions language scherl levesque formulation obtain similar ii certain assumptions knowledge initial state domain descriptions language semantics semantics defined lobo 
discuss earlier planning sensing actions compare formulations briefly describe earlier regression adapt simplified version regression define regression respect conditional plans :10.1.1.15.5194

language ak section introduce ak extension language allows reasoning sensing actions :10.1.1.34.7448
strictly speaking ak variation extension allow observations hypothesis non initial situations domain descriptions 
language components defines domain descriptions defines queries 

syntax ak disjoint nonempty sets symbols called fluent names fluents action names actions 
fluent literal fluent name fluent name preceded 
fluent mean mean 
domain descriptions ak proposition value proposition expression form fluent literal 
intuitively proposition means fluent literal initially known true 
propositions describe initial state world agent knows initial state world proposition slightly different meaning 
proposition means fluent literal true initial state world 
son baral artificial intelligence propositions said contradictory ef proposition effect proposition expression form pn action pn fluent literal 
set fluent literals pn referred precondition ef proposition referred effect ef proposition 
intuitively proposition conveys meaning guaranteed true execution action state world pn true 
drop part simply write ef propositions preconditions pn qm respectively said contradictory describe effect action complementary pn qm 
ex proposition executability proposition expression form executable pn action pn fluent literal 
intuitively proposition conveys meaning action executable state world pn true 
drop part simply write executable proposition knowledge proposition expression form determines action fluent 
intuitively proposition conveys meaning executed situation resulting situation truth value known 
proposition proposition ef proposition ex proposition proposition 
domain description set propositions contain contradictory propositions ii contradictory ef propositions 
actions occurring ef propositions propositions called non sensing actions sensing actions respectively 
avoid distraction main points assumption set sensing actions set non sensing actions disjoint 
example domain description language 
example 
consider agent disarm bomb done safely exploding special lock bomb switched locked explodes 
agent determine lock locked looking lock 
turn lock locked position unlocked position vice versa 
execute actions bomb exploded 
initially agent knows bomb disarmed exploded 
describe story domain description 
son baral artificial intelligence initially disarmed initially exploded disarm causes exploded locked disarm causes disarmed locked turn causes locked locked turn causes locked locked look determines locked executable look exploded executable turn exploded executable disarm exploded 
queries ak discussed section presence incomplete information knowledge producing actions need extend notion plan sequence actions allow conditional statements 
definition formalize notion conditional plan 
definition conditional plan 
empty sequence action denoted conditional plan 
action conditional plan 
cn conditional plans conjunction fluent literals mutually exclusive necessarily exhaustive conditional plan 
refer plan case plan 
case 
cn endcase conditional plans conditional plan 
conditional plan 
intuitively case plan case statement agent evaluates various respect knowledge 
knows true executes corresponding ci 
true case plan fails execution conditional plan contains case plan fails 
kind queries ask domain descriptions 
form knows son baral artificial intelligence conditional plan fluent formula 
intuitively query asking domain description entails fluent formula known true executing conditional plan initial situation second query asking domain description entails fluent formula known true known false executing conditional plan initial situation 

semantics ak ak kinds states world state referred state representing state world knowledge state state representing state knowledge agent combined state state pair consisting world state state 
mentioned earlier semantics domain descriptions ak defined terms models pairs consisting initial state transition function maps pairs actions states states 
small letters possibly indexes denote world states uppercase greek letters possibly indexes denote states lowercase greek letters possibly indexes denote states 
letter possibly indexes exclusively denote conditional plans possibly indexes denote sequence actions 
state set fluents state set states 
combined state state agent pair state state 
intuitively state state real state world set possible states agent believes 
say state grounded 
intuitively grounded states correspond assumption world state belongs set states agent believes may 
fluent state say holds true iff holds false iff truth propositional fluent formula respect defined usual 
say states agree fluent iff 
state say fluent respectively known false true respectively false state andf known iff known true known false fluent formula say known true respectively false state true respectively false state 
action executable state exists ex proposition executable pn pn hold action state ifa executable fluent exists ef proposition pn pn hold fluent exists ef proposition causes pn pn hold res 
son baral artificial intelligence executable say res undefined 
intuitively res state resulting executing allow contradictory ef propositions domain description pair action state disjoint uniquely determined 
res deterministic function 
ready define transition function states 
definition 
function actions states states called transition function state action executable undefined denoted executable non sensing action res res executable executable sensing action propositions determines determines fm agree executable res deterministic function easy show proposition 
domain description possesses unique transition function 
notice definition transition function stipulate special requirement res function defined 
action description language semantics depending state transition function res extended allow sensing actions 
features action description languages multi valued fluents ramification causality concurrent actions directly added framework 
example extend formulation multi valued fluents extend propositions able denote different values fluents ii extend notion states interpretations fluents 
definition transition function remain notion agreeing fluent mean value keep focus main issue formalizing sensing actions include features formulation directly added desired 
definition 
state called initial state domain description value proposition form initially respectively initially true respectively false 
state initial state initial state set initial states son baral artificial intelligence say initial state complete set initial states 
intuitively completeness initial states express assumption agent complete knowledge knows know initial state 
refer complete awareness assumption 
believe assumption indiscriminately reduces number initial states examples 
definition 
model domain description pair grounded initial state transition function model called rational complete 
transition function defined far tell state reached executing action state need extend function able reason action sequences conditional plans 
call extended function define follows 
definition 
domain description transition function 
extended transition function denoted maps pairs conditional plans states states defined follows 

action 
case 
cn endcase ci known true known true 
wherec conditional plans 
conditional plan say conditional plan executable state 
ready define entailment relation domains ak definition 
domain description conditional plan fluent formula 
say turner similar assumption called complete initial situation assumption model logic programming formulation actions complete information initial state 
easy see pair state conditional plan exists unique state 
son baral artificial intelligence ak knows executable known true model ii ak executable known true known false model rational entailment queries respect denoted defined similarly ak considering rational models examples elucidates definitions 
example 
domain description consisting propositions 
causes determines executable executable 
possible complete initial states transition function 
known true known false conclude 
ak known true known ak false furthermore ak ak knows knows 
example consider conditional plans 
example 
consider domain description example 
states locked exploded locked exploded disarmed disarmed exploded disarmed locked disarmed locked exploded 
son baral artificial intelligence set initial states complete initial states transition function 
definition rational models wehave look look disarm look turn look turn disarm look look disarm look turn look turn disarm computation ak knows disarmed look disarm ak knows disarmed look turn disarm 
proposition appendix show exists sequence actions knows disarmed exploded 
ak consider conditional plan look case locked turn locked endcase disarm show knows disarmed exploded ak definition computation disarm look disarm look disarm disarm disarm turn locked known true disarm turn disarm disarm son baral artificial intelligence disarm look disarm look disarm disarm disarm locked known true disarm disarm disarmed exploded known true state definition knows disarmed ak exploded 
translating domain descriptions order theories section give translation domain descriptions theories order logic show translation sound complete respect ak answering queries language ak 
translation inspired translation kartha uses axioms notations 
section standard notation having variables start small letters constants start capital letters 
consistent notation domain descriptions 
consider domain description assume contains sensing actions kn propositions ki determines fi value propositions initially gi 
simplicity assume action occurs executability condition sensing action ki occurs proposition 
domain description translated sorted theory follows 
objects sorts action fluent 
distinguish states denoted possibly subscripts previous sections possibly subscripts denote situations 
vocabulary signature consists constant type situation constants type action correspond different actions constant action constants type fluent correspond different fluents constant fluent function symbol type action situation situation predicate symbol holds type fluent situation predicate symbol type situation situation need notations 
fluent holds stands holds 
conjunction literals pn holds denotes holds pi 
son baral artificial intelligence fluent action def holds def poss def causes causes executable holds holds 
axioms described 
successor state axiom reiter formulation ordinary fluent action poss holds holds 
successor state axiom borrowed action poss poss kj kj holds fj holds fj recall kn sensing actions determine fn respectively 
contains holds gi recall gm fluent literals known true initial state 
axioms accessibility relation initial situation holds gi 
domain closure assumption dca fluents son baral artificial intelligence domain closure assumption dca actions unique name assumption una fluents 
distinct unique name assumption una actions 
distinct relate entailment entailment queries regarding fluent values sequence actions 
notation holds shorthand corresponding formula holds fluents argument 
example holds denotes holds holds 
similarly holds denotes holds holds mentioned holds denotes holds 
knows denotes formula holds 
sequence actions ak denotes denotes ak ak poss true poss denotes poss ai ai 
proposition 
domain description fluent formula sequence actions ak knows iff knows poss 
proof 
appendix step relate queries conditional plans 
introduce sorted predicate apply intuitive meaning conditional plan executed situation takes situation example conditional plan example situation locked holds real world 
apply disarm turn look true 
intuitively means executed reach situation disarm turn look executed action sequence executed left right look turn disarm 
definition apply similar formula rdo 
formulation represent case plan list pairs conditions conditional plans son baral artificial intelligence constructor functions constructs list constructs pair constructs case plan 
conditional plan represented list actions case plans 
example conditional plan example represented look case locked turn locked disarm 
nested abnormality theory nat block 
bapply min apply apply poss apply apply poss apply apply case apply knows apply apply apply case knows apply case apply case nested abnormality theory conditional plans list pairs conditions conditional plans 
note case denote conditional plan 
nat defines predicate apply circumscription equivalently written circ apply wheret set axioms min apply 
consider models predicate apply minimized 
guarantees situation result execution conditional plan initial situation 
nested abnormal theories please see appendix nat bapply defined words follows apply true apply true apply poss true 
apply true apply poss true 
apply case true apply true apply case true knows apply apply true 
apply case true knows apply case true 
rules applicable apply false 
explain definition entails apply assuming poss true 
son baral artificial intelligence apply true poss apply true second rule 
apply true poss apply true second rule 
apply true poss apply true second rule 
apply true rule 
proposition 
domain description corresponding order theory 
conditional plan fluent formula 
knows iff bapply knows apply proof 
appendix point proposition holds slightly different translation simpler successor state axiom formulas section successor state axiom poss poss kj kj holds fj holds fj 
state space analysis section analyze size state space reasoning ak easy see fluents states grounded states 
suppose fluents initial situation know truth value fluents 
know truth value fluents initial states size follows definition transition function fact knowledge loosing actions state reached executing sequence actions son baral artificial intelligence initial state size account size reachable initial states state space larger consider formulations states kripke models 
case fluents different possible worlds accessibility relation subset elements 
total number different kripke models complexity results planning presence incomplete information developed 
results polynomial plan existence problem complete presence incomplete knowledge initial situation restriction sensing actions executed limited number bounded constant times looking feasible polynomial length plans 
restrictions complexity higher 
tremendously large size state space ak formulations mentioned complexity results necessitates search provably sound approximations manageable state space lower complexity 
focus section 

approximating ak section define approximations semantics ak approximations valued states call states approximate states represent state knowledge agent 
state normally represented pair wheret disjoint sets fluents 
intuitively respectively set fluents true respectively false state state said complete set fluents domain description 
abuse notation represent complete state states 
say state extends state denoted ift extends say extension 
denote pair denotes set 
set fluents write denote 
fluent state say true respectively false respectively known respectively unknown respectively 
positive respectively negative fluent literal said hold respectively 
ready define approximations ak difference approximations case analysis done reason actions agent incomplete knowledge world 
start approximation case analysis done 
son baral artificial intelligence 
approximation domain description state fluent respectively hold respectively 
set fluent literals fn said possibly hold fi possibly holds action said executable state exists ex proposition executable pn pn hold wenow introduce notations 
fluent exists pn ind pn hold 
fluent exists causes pn ind pn hold 
fluent exists pn ind pn possibly hold 
fluent exists causes pn ind pn possibly hold 
fluent determines ind 
intuitively respectively set fluents true respectively false executing respectively set fluents respectively false executing set fluents known executing action define result function approximation denoted res follows 
res illustrate definitions example 
example 
domain description example initial state disarmed exploded locked locked holds wehavethat disarm turn disarm turn 
locked locked possibly hold wehavethat disarm exploded disarmed turn locked look locked 
disarm turn locked ef proposition action look look look look look 
son baral artificial intelligence res disarm res turn disarmed exploded res look disarmed exploded example disarmed exploded false executing disarm unknown 
face counter intuition frame problem values fluents remain unchanged situation action changes 
case action disarm effect propositions applicable preconditions locked locked respectively hold 
naive application frame axiom lead conclude disarmed exploded remain false situation executing disarm 
sound possible real world locked true executing disarm disarmed true 
possibility just disarmed true resultant situation unsound locked true real world 
account possibilities reason agent know disarmed true false executing disarm 
resultant state disarmed unknown 
straightforward definition res encodes skeptical reasoning 
res define transition function 
executing action result undefined state denoted 
definition 
domain description transition function defined follows executable executable non sensing action res executable sensing action 
definition transition due sensing action results set states corresponding particular set sensing results 
condition elements sure fluents sensed ones proposition condition elements sure fluents mentioned propositions action true false value allow actions able sense change world action succinctly defined extends res res res 
transition function extended transition function maps pairs conditional plans states set states defined 
definition 


case plan son baral artificial intelligence case pn endcase pj holds holds 
conditional plans 

conditional plan executable state 
state called initial state fluent literal holds iff isin easy see domain description initial state unique 
definition 
domain description model pair initial state transition function similarly proposition prove transition function unique 
definition define approximate entailment relation entailment model 
definition 
domain description fluent formula conditional plan wesay knows executable holds state belonging model executable known state belonging model example 
domain description disarm turn disarmed exploded look locked disarmed exploded locked disarmed exploded 
locked look knows locked look knows locked look 
son baral artificial intelligence example show conditional plan bomb example analyzed approximation 
example 
reconsider domain conditional plan example 
look case locked turn locked endcase disarm initial state disarmed exploded prove knows disarmed exploded compute follows 
look locked look locked disarmed exploded disarmed exploded locked disarm look disarm disarm 
locked holds locked holds wehavethat disarm disarm disarm turn disarm 
furthermore disarm disarmed locked exploded turn turn locked disarmed exploded 
disarm disarm disarmed locked exploded 
summary disarmed locked exploded implies knows disarmed exploded approximation correctly analyze example weaknesses entail queries entailed ak semantics 
example illustrates 
example 
consider domain causal rules executable initial state intuitively expect knows entailed entailment holds ak 
son baral artificial intelligence example doing case analysis intuitively conclude true executing initial situation 
analyze initial situation true false cases conclude true executing reasoning mechanism approximation lacks case analysis 
section introduce notion approximation case analysis able intuitive example 

approximation approximation improves approximation defining new result function incomplete state action considers complete extensions applies extensions considers true false resulting states 
transition function intuitive reasoning respect example 
formally define new result function 
state set complete states extend result function res maps state state res defined follows 
res res 
comp notion executability changes slightly 
action said executable state executable states comp 
transition function defined 
definition 
domain description transition function defined follows executable 
executable non sensing action res 
executable sensing action 
model defined pair initial state transition function notion extended function entailment defined definitions transition function model respectively 
example show approximation allows reason cases 
example 
consider domain example 
initial state set complete extensions comp set complete states 
precisely comp res res res res res model 
conclude knows son baral artificial intelligence state relation approximation approximation domain descriptions ak proposition soundness respect 
domain description fluent formula conditional plan 
knows knows proof 
sketch 
similar proposition prove domain description model model uniquely determined 
furthermore initial state approximation initial state approximation 
denote model model respectively 
states 
action prove exists ii exists 
ii prove conditional plan iii iv exists exists 
iii proves executable executable 
iv fact proves proposition 
example shows approximation able intuitive ak semantics 
example 
consider domain description causes causes causes causes executable executable initial state wherep unknown 
intuitively rational semantics ak executing followed initial state true approximation able capture 
approximation reasons cases level 
reasoning cases level summarizes reasoning pair able capture fact executing initial state true 
overcome limitation approximation illustrated example define approximation reason cases levels 
break full proof 
recall allow contradictory propositions contradictory ef propositions anonymous aaai reviewer pointed 
son baral artificial intelligence reasoning cases levels necessary 
section define approximation allows reasoning cases multiple levels setting limit number levels 

approximation intention approximation reason cases levels possible 
number limited structure plan 
reason cases sequences non sensing actions 
reason sequence actions define longest prefix consisting non sensing actions single sensing action denoted pre follows sensing action pre contain sensing action pre aj sensing action aj 
sequence actions obtained removing prefix pre called remainder denoted rem 
sequence non sensing actions considering complete extensions applying determining intersection 
corresponds doing case case reasoning levels 
formally res res res res 
comp action executable executable complete extensions sequence non sensing actions executable executable complete extensions approximation defined function called transition function maps pair sequence actions state set states denoted follows 
pre executable res contain sensing action executable extends sensing action executable 
pre rem sequence actions executable 
model domain description defined pair initial state transition function extend function pairs conditional plans states need observation 
observation 
conditional plan represented sequence conditional plans cn son baral artificial intelligence ci sequence actions case plan sequence actions ci case plan 
write conditional plan sequence cn ci satisfy conditions observation 
extended transition function denoted 
conditional plan state wherec sequence actions case 
cl endcase ci holds holds cn sequence actions cn case 
pm endcase pi cn holds holds conditional plan notion entailment defined definition model 
example shows generalization overcomes problem approximation example reasoning cases multiple levels 
example 
consider domain description example 
complete extension complete holds holds res res 
contain ef proposition effect res 
holds res res complete state holds res 
son baral artificial intelligence definition holds initial state 
sequence actions 
knows 
prove soundness respect proposition 
proposition soundness respect 
domain description fluent formula conditional plan 
knows knows proof 
proof similar proof proposition 
proof 

soundness approximations respect ak semantics previous subsections discussed different approximations ak 
goal show approximations sound respect ak shown propositions sound respect sound respect show approximation sound respect ak 
proposition soundness respect ak 
domain description fluent formula conditional plan 
knows ak knows proof 
appendix approximation reason approximation match ak semantics 
example illustrates 
example 
domain description 
causes determines causes initially executable executable executable initial state 

complete extensions implies res res res son baral artificial intelligence furthermore 
knows knows 
show ak knows lets 
initial states wehavethat easy check known true 
knows 
ak 
complexity progression subsection compare complexity progression various approximations 
suppose number fluents andd size domain description 
state size complexity computing res res res andres different approximations follows approximation complexity computing res number domain description 
order approximation need compute res 
order approximation need compute res 
order easy see sensing action determines fluents state fluents known states 
analysis clear progression done faster approximation 
hand significant difference doing progression approximation approximation 
formal result shown computing state res polynomial time procedure computing res conp complete 
son baral artificial intelligence 
related research section discuss expressiveness limitations formulations compared formulations literature detailed comparisons works closest 

expressiveness limitations ak main goal formalize sensing actions avoid distractions purpose limited expressiveness rest language 
example allow multi valued fluents static causal laws concurrent actions narratives section briefly discuss restrictions lifted :10.1.1.22.1218
additional assumptions limit expressiveness language 
briefly discuss assumptions 
follow approach having full order language :10.1.1.34.7448
allows avoid additional induction axioms described 
full order language allow variables propositions variables move causes proposition viewed schema representing set propositions bound 
assume domain finite 
assume finite set actions fluents 
assume single agent planning acting interest formalizing knowledge world vis vis real state world 
assumptions modal logic hard code semantics 
allows simpler states kripke models 
show section leads smaller state space 
similar approach followed chapters 
assume sensing actions operation sensors perfect 
bacchus halpern levesque extend situation calculus approach allow noisy sensors 
plan extend approach case 
operations research literature pomdps partially observable markov decision processes formulating noisy observations 
plan formulate sensing actions pomdps compare current formulation 
follow high level language doctrine approach databases limited query language 
allows simpler formulation 
query language easily extended allow knowledge temporal operators straightforward favor generality allowing quantifiers :10.1.1.15.5194
interest progression verification conditional plans 
words description possibly partial initial state conditional plan goal verify plan executed initial state take goal 
limited interest son baral artificial intelligence simpler formulation 
simpler formulation add observation form knows find limitation logical formulation semantic level 

relationship scherl levesque formulation section gave translation domain descriptions order theory scherl levesque successor state axiom moore formulation showed equivalence respect queries language ak scherl levesque directly formalize order logic formulation general terms allowing general descriptions domain able choose modal logic observations non initial situations ii terms allowing general queries 
hand goal simpler formulation cost generality 
example state agent knowledge scherl levesque formulation moore formulation kripke model 
planning state space state kripke model difficult simpler notion state call state 
instance fluents number different kripke models number different states mentioned earlier state components real state world set possible states agent thinks may 
state equivalent kripke model consider logic 
goal things simpler sacrifice generality priori decision logic knowledge 
develop high level language ak independent semantics depend standard logics serve role benchmark languages sensing actions restricted class queries ak highlevel language easier prove soundness approximations manageable state space 
having sound complete translations domain descriptions ak theories order logic scherl levesque axioms sound approximations way sound approximations scherl levesque formalism 
mention loop free robot programs special cases conditional plans 
particular statements seq branch recursively translated conditional plans case endcase son baral artificial intelligence respectively 
allow loops conditional plans 
ideas extend conditional plans allow loops 

relationship lobo semantics lobo goal similar terms developing high level language allows sensing actions giving translations theories standard logical language 
list major differences approaches represent state agent knowledge set states refer situation transition function model defined sensing action situation subset consists states agree fluent values determined sensing action drawback approach domain descriptions lot models 
importantly possible domain description sensing actions determine fluent models words may true states false states 
find models unintuitive 
semantics ak general semantics lobo sense formulation assumption models rational hard wired semantics 
hand high level language lobo general 
allow conditional sensing preconditions propositions 
allow preconditions propositions allow executability conditions 
lobo give translations domain descriptions theories epistemic logic programs 
translations disjunctive logic programs simpler epistemic logic programs :10.1.1.158.9180
give translations order theories 
consider sound approximations language 
part section show semantics equivalent theirs 
approximations sound approximations formulation 
give quick overview formulation restricted common syntax ak language 
show rational semantics equivalent semantics restricted case 
semantics defined transition functions map pairs actions situations situations situation set states 
situation consistent empty 
domain description situation consisting initial states denoted called initial situation said true situation 
fluent formula said true situation true state belonging 
need definition 
definition 
consistent situation fluent 
consistent situation compatible iff son baral artificial intelligence domain description function pairs actions situations situations called interpretation definition 
interpretation domain description model consistent situation non sensing action res sensing action determines determines fn propositions occurs 
consistent situation fi compatible situation action 
lobo extend function plan evaluation function allows conditional plans 
definition similar definition omit brevity 
example show difference models models lobo example 
consider domain description example 
states locked exploded locked exploded disarmed disarmed exploded disarmed locked disarmed locked exploded 
initial situation compatible situations model look look approach lobo different models differ transition functions 
hand approach rational models differ initial states 
entailment relation respect lobo semantics defined 
definition 
ltm knows iff model true 
son baral artificial intelligence proposition relates lobo semantics 
proposition equivalence ak ltm 
domain description fluent formula conditional plan ak knows iff ltm knows proof 
:10.1.1.158.9180

past research planning sensing past planners developed plan extent presence incompleteness planners sensing actions 
section briefly describe planners semantics compare semantics 

golden weld golden weld colleagues developed planning languages planners plan presence incompleteness sensing actions plan knowledge goals 
languages uwl sadl :10.1.1.15.5194
list main contributions compare formulation 
evident title representing sensing actions middle ground revisited goal develop middle ground formulating sensing actions :10.1.1.15.5194
reading golden thesis communicating formulation close approximation approximation case case reasoning necessary desired example 
soundness result implemented incorporated planner softbot agents 
main contributions notion local closed world reasoning making inferences updates 
similar notion 
introduce minimal extremely useful set knowledge temporal goal 
uwl annotations satisfy hands sadl satisfy hands initially 
intuitively annotation satisfy means reach state true agent knows true annotation hands means execution plan truth value change annotation initially specify goal sensing truth value time goal idea agent finished executing plan know truth value started 
formulate regression respect goals formulated annotations 
small reservation annotation initially 
golden says initially achievable action changes fluent action obscures initial value changing determining initial value fine 
son baral artificial intelligence think condition restrictive determine initial value change value 
consider case know value action action effects described follows causes causes causes causes determines action changes value find initial value executing plan 
believe annotations important contribution additional research necessary developing general knowledge temporal language representing expressive queries trajectories states 
example may want maintain knows execution plan want state know value different hands allowed change value don know value trajectory 
important difference approach focus combining planning execution focus close classical planning paradigm generate complete plan possibly conditional statements sensing actions starting execution 
difference focus shows difference characterization sensing actions 

goldman boddy kr goldman boddy single model world representing planners state knowledge 
consider actions executability conditions conditional effects explicit effects may fluents unknown 
define progression knowledge state reached executing action regression respect actions 
extend action definition include conditional actions set mutually exclusive exhaustive possible outcomes exactly outcomes result action 
suggest conditional actions describe observation operators requiring action supposed observe fluent executability condition action 
argue difficulty adding conditional effects model representations state world planner state knowledge 
points compare contrast approach single model represent world planners knowledge world formulation similar approximations single model 
formulation shown sound respect full formulation 
son baral artificial intelligence formulation sensing actions observation operators call wrongly consider tossing coin action sensing action state coin heads tails unknown coin tossed 
believe formulation restricted common subset language sound respect formulation 
allow actions absence conditional effects explicitly fluents unknown 
actions conditional effects actions fluents unknown 
extend classical planning allow conditional plans contextdependent actions non deterministic outcomes argue necessity separately modeling planner information state world state 
propositional dynamic logic express conditional plans reason information gathering sensing agent information state 
idea propositional dynamic logic results appreciate goal explore middle ground having full formulation sensing actions allowing incompleteness 
coincides motivation exploring approximation 
carefully reading times believe details formulation necessary fairly comprehensively compare approach 

regression focus far progression plan verification 
considering success model planning propositional satisfiability formulation geared approach 
briefly comment notion regression role conditional planning sensing actions 
regression respect simple actions studied 
scherl study regression respect sensing actions 
intuition regression formula respect action find formula holds situation hold situation 
regression verify correctness plan regressing goal initial situation verifying regressed formula holds initial situation 
regression commitment approach planning 
regression rules regressing knowledge formulas respect conditional plans 
rules adapted simplified 
simplification due modal logic level knowledge sufficient 
regression conditional plans original contribution 
fluent action ef propositions causes causes regression fluent formula non sensing action regression knows knows regression 
son baral artificial intelligence fluent sensing action senses fluents fn fn set conjunctions literals representing interpretations set fn 
fluent formula 
regression knows knows 
fn regression formulas regression regression regression regression regression regression regression regression 
regression conditional plans formulas 
equations formulas fluents formulas 
regression regression regression regression sequence actions regression case pn endcase knows regression pi regression cn regression regression cn cn ci conditional plans satisfying conditions observation 
proposition proves soundness completeness regression formula 
proposition 
domain description formula set grounded initial states conditional plan executable grounded initial states regression iff 
proof 
appendix 
high level action description language takes account sensing actions distinguishes state world state knowledge agent world 
gave sound complete translation domain descriptions language theories order logic similar translations disjunctive logic programming :10.1.1.158.9180
compared formulation analyze state space formulation 
gave sound approximations formulation smaller state space 
believe approximations important developing practical planners 
example senses 
knowledge formula formula formula form knows fluent formula say knows holds state holds states 
combined formula formula formula constructed fluent formulas formulas propositional connectives formula holds state defined straightforward way 
son baral artificial intelligence plans analyze existing planners construct conditional plans sensing actions develop efficient planners approximations described 
head start direction implementing simple generate test planner prolog 
explore notions approximation approximation 
follow satisfiability planning smodels planning adapting classical logic logic programming formulations plan sensing actions 
adapt formulation sensing action description languages particularly action description language narratives develop notions diagnosis diagnostic repair planning respect narrative 
intuitively means develop plan possibly sensing actions leads unique diagnosis system 
anonymous reviewer valuable comments help improve ways 
carried author doctoral student university texas el paso 
appendix proposition 
sequence actions ak knows disarmed exploded 
proof 
locked 
initial states arbitrary sequence actions longest prefix contain action disarm 
action changes value fluent exploded conclude executable 
prove induction length denoted 
base case 
definition wehavethat 
holds 
inductive step assume proved need prove disarm turn look 
ifa turn wehave quote uwl sadl individual literals truth values expressed valued logic unknown :10.1.1.15.5194
approximation 
analyze planner kind approximation sound respect formulations discussed 
son baral artificial intelligence res res res res 
look wehavethat 
furthermore definition conclude res 
similarly 
inductive hypothesis proven 
prove proposition 
recall models 
construction cases disarm disarm proper prefix 
case true disarmed known true 
definition knows disarmed ak case disarm 
follows res disarm belongs disarm disarm exploded holds conclude exploded known true disarm disarm 
definition ak knows exploded 
case disarm proper prefix 

disarm actions executable conclude executable initial states 
definition knows disarmed exploded ak cases show knows disarmed exploded 
ak proves proposition 
appendix soundness completeness translation prove propositions 
recall assume domain description propositions initially initially gm sensing actions kn propositions determines kn determines fn 
assume action contains executability condition action sensing action occurs proposition 
write denote second component state respectively 
words denote respectively 
state action sequence ak denotes empty sequence actions executable res denotes state res ak res ak res res undefined 
situation interpretation defined sequence actions executable denoted interpretation theory write denote set tuples belonging extent predicate denotes object function maps ary function symbol simplify 
definition 
domain description model interpretation denoted defined follows 
son baral artificial intelligence universes universe actions denoted action set actions action 
universe fluents denoted fluent set fluents fluent 
universe situations denoted situation situation interpretations situation action sequence executable denotes impossible situation 
interpretations fluent constants action constants interpreted 
situation interpreted situation interpretation 
particular 
interpretation predicate holds defined holds iff res defined holds res 
interpretation predicate defined inductively follows ands conditions satisfied executable res res non sensing action sensing action senses fluent res res agree 
interpretation function defined executable res 
interpretation extended predicates introduced section poss example situation interpretation holds iff holds res iff exists ef proposition causes holds poss iff exists ex proposition executable holds prove lemmas relationship model interpretation proving propositions 
convenience formula language true write 
lemma 
model domain description fluent action situation interpretation iff res ii iff res 
proof 
situation interpretation implies executable res defined 
son baral artificial intelligence iff exists ef proposition causes holds definition iff exists ef proposition causes holds res item definition iff res 
proved 
similarly prove ii 
lemma 
model domain description action situation interpretation poss iff executable res ii poss proof 
situation interpretation executable res defined 
definition poss wehavethat poss iff exists ex proposition executable holds iff exists ex proposition executable holds res item definition iff executable res 
second item follows immediately item definition 
lemma 
model domain description satisfies axiom 
proof 
consider action situation positive fluent literal axiom true poss 
need prove true poss 
poss lemma executable res 
definition 
holds iff holds iff holds iff holds res item definition iff res res iff res son baral artificial intelligence res res definition res iff lemma holds lemma definition iff holds similarly prove negative fluent literal 
satisfies 
lemma 
model domain description satisfies axioms 
proof 
consider situation 
means 
item definition fact conclude 
model initial state gi holds executable item definition conclude gi holds holds gi 
holds conclude satisfies 
model wehavethat 
item definition 
satisfies 
initial state conclude satisfies 
lemma follows 
lemma 
model domain description satisfies axiom 
proof 
consider action situation similar lemma suffices prove satisfies axiom poss 
lemma implies res defined executable res 
cases case situation 

prove formula true 
poss ki ki holds fi holds fi 
son baral artificial intelligence implies 
item definition executable res res non sensing action sensing action say ki res res agree fi situation 
follows lemma poss 
furthermore conclude ki ki holds fi holds fi satisfies 
case assume formula true 
want show 
similar case poss conclude executable res 

follows ki ki holds fi holds fi non sensing action sensing action say ki res res agree fi 
follows definition 
implies proves true follows cases satisfies 
lemma 
model domain description interpretation model 
proof 
follows lemmas satisfies axioms 
easy see closure assumptions unique name assumptions fluents actions satisfied 
model 
lemma 
situation interpretation statements equivalent ii executable res prefix 
proof 
induction 
son baral artificial intelligence base case 
item definition iff 
fact executable conclude base case 
inductive step assume proved lemma need show 
consider cases ii item definition wehavethat executable res res senses fj res res agree fj 
inductive hypothesis conclude executable res 
fact executable executable 
fact res conclude res 
inductive step direction follows 
ii executable implies executable 
furthermore prefix prefix 
inductive hypothesis 
executable implies executable res res 
res andres implies sensing action say ki res res agree fi 
follows item definition 
concludes inductive step direction 
inductive step proved 
mathematical induction conclude lemma 
lemma 
state action sequence executable iff poss 
proof 
induction 
base case 
lemma trivial executable state poss state son baral artificial intelligence inductive step assume proved lemma need show wehavethat executable iff executable executable res iff poss inductive hypothesis poss lemma iff poss 
lemma 
domain description model exists model fluent formula sequence actions executable iff knows poss 
proof 
interpretation 
model 
prove satisfies lemma 
executable iff executable iff poss lemma iff poss 
known true iff holds definition iff suchthat executable res prefix holds res iff lemma holds item definition iff knows definition knows lemma follows 
prove counterpart lemma 
domain description model 
contains dca una axioms actions fluents assume domains actions fluents respectively action fluent follows say situation mean ground situation term 
define definition 
domain description model 
ground situation term lets holds true fis positive fluent literal 
initial state denoted 
true 
recall holds stands holds 
son baral artificial intelligence call initial state transition function defined definition model lemma 
domain description model model model proof 
consider arbitrary proposition initially gi ofd 
cases gi positive literal 
model holds gi true definition gi gi holds 
gi negative literal say gi model holds true false definition gi holds 
follows initial state 
consider 
definition conclude exists true axiom holds gi true similar prove initial state 
initial state 
furthermore axiom grounded initial state 
definition indicate transition function initial ground state model corollary follows immediately definition 
corollary 
model fluent formula situation holds holds iff holds lemma 
model fluent situation action true iff ii true iff 
proof 
true iff causes true definition iff exists ef proposition causes holds corollary iff 
son baral artificial intelligence proved 
similarly prove ii 
lemma 
model situation action poss true iff executable ii poss true res 
proof 
poss true iff exists ex proposition executable holds true iff exists ex proposition executable holds iff executable 
poss true fluent iff holds true iff holds true axiom iff lemma res 
lemma follows 
lemma 
model situation sequence actions poss true iff executable ii poss true res 
proof 
induction 
base case 
trivial poss true definition executable state 
ii follows immediately definition 
case proven lemma 
inductive step assume proved lemma need show wehavethat wehavethat poss true iff poss true poss true definition iff poss true exists ex proposition executable holds true iff executable inductive hypothesis item exists ex proposition executable holds res inductive hypothesis item ii executable 
son baral artificial intelligence 
lemma res inductive hypothesis res 
res res res res 
inductive step follows 
lemma 
domain description model 
exists model fluent formula sequence actions knows poss iff executable known true 
proof 
prove model satisfies lemma 
lemma model lemma poss true iff executable iff executable 
prove induction length satisfies lemma properties 
true iff 
base case 
lemma trivial definition 
equivalent true iff follows immediately item definition fact true proves base case 
inductive step assume proved lemma need prove 
follows construction true iff poss kj nj kj holds fj holds fj true iff inductive hypothesis res definition kj fj iff fj iff son baral artificial intelligence consider fluent formula wehavethat knows poss iff poss true holds true iff executable holds iff executable known true 
prove inductive step lemma 
lemma proved 
prove proposition 
proposition 
domain description fluent formula sequence actions ak knows iff knows poss 
proof 
assume ak knows 
prove knows poss 
assume contrary knows poss 
definition exists model knows poss 
lemma exists model knows 
implies ak knows contradicts assumption ak knows 
assumption incorrect proved knows poss 
conclude ak knows knows poss 
assume knows poss 
prove ak knows 
assume contrary ak knows 
means exists model knows 
lemma exists model knows poss 
implies knows poss contradicts assumption 
ak knows 
knows poss ak knows 
conclude ak knows iff knows poss 
extend lemmas conditional plans 
need notation lemmas 
conditional plan define number case plans denoted count inductively follows 
son baral artificial intelligence 
action count 
conditional plans case count count 
case plan form case 
cn endcase count count ci 
follows directly definition bapply lemma 
lemma 
situations conditional plan 
formulas entailed bapply apply ii apply case iii apply 
proof 
assume entailed bapply 
exists model bapply apply true 
easy see apply model bapply 
violates minimality true model bapply 
similarly prove ii iii 
lemma 
situations action fluent formula sequence actions conditional plans 
formulas entailed bapply apply poss apply poss ii apply case knows apply apply knows apply case iii apply apply proof 
assume entailed bapply 
means exists model bapply action sequence actions situations apply true poss apply poss true definition bapply model apply model bapply 
contradicts assumption minimal model bapply 
assumption true incorrect proved valid sentence bapply 
similarly prove item ii 
proof item iii induction count omitted 
son baral artificial intelligence lemma 
cn arbitrary conditional plans 
formula entailed bapply apply cn sn sn apply apply cn sn sn 
proof 
prove lemma induction base case 
right hand side apply left hand side apply 
follows item iii lemma apply apply 
proves base case 
inductive step assume proved lemma need prove 
cn cn conditional plans definition cn cn conditional plan 
inductive hypothesis plans cn wehavethat apply cn sn sn apply apply sn sn 
inductive hypothesis plans cn cn wehavethat apply sn sn sn apply cn sn sn apply cn sn sn 
inductive step follows 
lemma proved 
lemma 
case plan form case pl endcase 
formula entailed bapply knows apply knows apply pj 
proof 
model bapply 
obviously knows false formula true need prove case exists knows true consider cases left right assume knows apply true mutual exclusive conclude knows true item ii lemma pj wehave apply pj apply true 
item lemma equivalent apply pj true 
son baral artificial intelligence follows assumption knows true knows apply pj true proves 
right left assume knows apply pj holds similar argument concludes knows true fori definition apply case sequence pj pj pl wehavethat knows apply pj apply apply case pj holds furthermore lemma 
conclude apply knows holds proves 
lemma follows 
lemma 
assume cn conditional plan cn sequence conditional plans satisfying conditions observation 
case plan form case pl endcase situation term 
model bapply knows bapply apply apply pj cn 
proof 
lemma exists sn apply apply apply cn sn true bapply 
knows lemma knows apply knows apply pj true bapply 
follows bapply knows apply knows apply pj apply apply cn sn implies bapply apply apply 
lemma lemma follows 
son baral artificial intelligence lemma 
assume cn conditional plan cn sequence conditional plans satisfying conditions observation 
sequence actions case plan form case pl endcase situation term 
model bapply knows bapply apply apply pj cn 
proof 
knows conclude poss true lemma exists sn apply apply apply cn sn holds bapply 
sequence actions 
knows lemma bapply apply apply pj 
follows bapply apply apply apply pj apply apply cn sn implies bapply apply apply 
lemma lemma follows 
lemma 
domain description model exists model fluent formula conditional plan executable known true iff bapply knows apply iff bapply apply 
proof 
observation assume cn ci sequence actions case plan ci sequence actions ci case plan 
interpretation lemma model 
prove induction count satisfies lemma 
base case count 
items iii lemma prove bapply apply poss poss 
son baral artificial intelligence lemma executable known true iff knows poss 
follows executable known true iff bapply knows apply 
proves item lemma 
complete base case need prove second item 
sequence actions iff executable iff poss lemma iff bapply apply 
second item lemma proved 
base case proved 
inductive step assume proved lemma count need prove lemma count 
case executable known true 
show knows apply true bapply 
consider cases case case plan 
assume case plan case pl endcase executable known true 
implies exists known true 
pj cn 
definition 
known true 
count count inductive hypothesis conclude knows apply true bapply 
follows lemma bapply apply apply 
bapply knows apply 
case sequence actions 
case plan 
assume case plan 
son baral artificial intelligence case pl endcase executable known true exists known true 
pj cn 
definition wehavethat known true 
count count count inductive hypothesis conclude bapply knows apply 
lemma bapply apply apply 
prove bapply knows apply 
cases prove executable known true bapply knows apply 
case bapply knows apply 
prove executable known true 
consider cases case case plan 
assume case plan case pl endcase bapply apply items ii lemma conclude exists knows 
pj cn 
lemma bapply apply apply 
implies bapply knows apply 
furthermore definition known true 
implies 
son baral artificial intelligence count count count inductive hypothesis conclude executable known true executable known true 
case sequence actions 
case plan 
assume case plan 
case pl endcase similar case conclude exists bapply knows apply 
pj cn 
lemma bapply apply apply 
inductive hypothesis executable known true 

count count count inductive hypothesis conclude known true 
proves executable known true 
cases prove bapply knows apply executable known true 
cases prove executable known true iff bapply knows apply 
proof inductive step item lemma iff apply true bapply cases similar cases 
show case 
cases similar omitted 
assume cn case plan case pl endcase show apply true bapply 
consider cases son baral artificial intelligence exists known true 
lemma knows true applies definition apply times apply apply case true bapply cn third item definition conclude apply apply true bapply inductive step proved 
exists known true 
lemma knows true knows false lemma bapply apply apply pj cn 
fact inductive hypothesis implies apply true bapply 
cases prove inductive step second item lemma 
lemma follows 
lemma 
domain description model 
exists model fluent formula conditional plan bapply knows apply iff executable iff bapply apply 
proof 
observation assume cn ci sequence actions case plan ci sequence actions ci case plan 
model lemma model prove induction number case plan count satisfies lemma 
base case count 
item lemma prove bapply apply poss poss 
lemma knows poss iff executable known true 
proves bapply knows apply iff executable known true 
furthermore sequence actions bapply apply iff poss true lemma equivalent executable 
base case third item lemma proved 
son baral artificial intelligence base case lemma follows 
inductive step assume proved lemma count need prove lemma count 
case executable known true 
show bapply knows apply 
consider cases case case plan 
assume case plan case pl endcase executable known true 
implies exists known true 
pj cn 
definition known true 
lemma bapply apply apply 
count count count inductive hypothesis conclude bapply knows apply proves bapply knows apply 
case sequence actions 
case plan 
assume case plan 
case pl endcase executable known true 
implies exists known true 
pj cn wehavethat 
follows lemma bapply apply apply 
son baral artificial intelligence count count count inductive hypothesis conclude bapply knows apply proves bapply knows apply 
cases conclude executable known true bapply knows apply 
case bapply knows apply 
prove executable known true 
consider cases case case plan 
assume case plan case pl endcase bapply knows apply lemma conclude exists knows 
pj cn 
lemma conclude bapply apply apply 
assumption bapply knows apply wehavethat bapply knows apply 
furthermore definition known true 
implies 
count count count inductive hypothesis conclude executable known true conclude executable known true 
case sequence actions 
case plan 
assume case plan 
case pl endcase similar case conclude exists bapply knows apply 
son baral artificial intelligence pj cn 
lemmas bapply apply apply 
bapply knows apply 
sequence actions known true 

count count count inductive hypothesis conclude executable known true 
proves executable known true 
cases conclude bapply knows apply executable known true 
cases show executable known true iff bapply knows apply 
proof third item lemma iff bapply apply similar proof second item lemma omitted 
proves inductive step lemma proves lemma 
proposition 
domain description corresponding order theory 
conditional plan fluent formula 
ak knows iff bapply apply knows proof 
assume ak knows prove bapply knows apply 
assume contrary bapply knows apply 
definition exists model bapply knows apply 
possibilities bapply apply 
lemma exists model 
implies ak knows case happen 
bapply apply bapply knows 
lemma exists model knows implies ak knows contradicts assumption ak knows case happen 
conclude assumption incorrect proved bapply knows apply 
ak knows bapply knows apply 
son baral artificial intelligence assume bapply knows apply 
prove ak knows assume contrary ak knows means exists model knows subcases 
lemma exists model bapply apply 
bapply knows apply contradicts assumption 
case happen 

known true 
lemma exists model bapply knows apply 
bapply knows apply contradicts assumption 
case happen 
ak knows knows apply ak knows 
conclude ak knows iff bapply knows apply appendix soundness approximation section prove soundness approximation respect semantics ak 
section denote arbitrary fixed domain description 
need notations lemmas 
state state 
say agrees state 
state true false denote set respectively 
sequence actions state res denote state res res 
similarly res denotes state res res state 
observations trivial proofs section 
observation 
state grounded state agrees fluent formula holds holds action grounded state true comp sequence non sensing actions complete true res res true son baral artificial intelligence sequence non sensing actions executable executable 
proof proposition lemmas 
lemma 
domain description state grounded state agrees 
sequence non sensing actions res agrees 
proof 
assume true res 
true res 
definition res comp comp true res 
comp res true 
item observation res 
item observation 
false res 
false res 
definition res comp comp false res 
comp res true 
item observation res 
item observation 
lemma follows 
lemma 
domain description state grounded state agrees 
sensing action executable exists agrees 
proof 
assume occurs propositions determines determines fn definition fn 
assume grounded state 
assumption agrees 
definitions implies 

prove agrees 
consider arbitrary definition fn fn fn fn son baral artificial intelligence 
agrees 

holds state wehavethat agrees proves lemma 
lemma generalization lemmas sequence actions consisting sensing non sensing actions 
lemma 
domain description state grounded state agrees 
sequence actions executable executable ii exists state agrees 
proof 
ns number sensing actions occurring 
prove lemma induction ns 
base case ns sequence non sensing actions 
item observation proves executable 
furthermore lemma res agrees pre definition wehavethat res 
proves base case 
inductive step assume sensing action occurring contain sensing action 
res 
lemma agrees 
grounded state sequence non sensing actions item observation easily prove grounded state 
executable implies executable 
lemma executable agrees 
assumption executable conclude executable 
ns induction hypothesis conclude executable agrees 
res definition 
definition wehavethat 
agrees conclude induction step 
lemma proved 
lemma extend result lemma arbitrary conditional plan 
son baral artificial intelligence lemma 
domain description state grounded state agrees 
conditional plan executable executable ii exists state agrees 
proof 
observation know represented sequence conditional plans cn ci sequence actions case plan ci sequence actions ci case plan 
prove lemma induction count number case plans base case count proved lemma 
prove inductive step assume lemma shown count prove lemma count 
consider cases case plan 
assume plan case pl endcase assumption conclude exists holds pj cn 
definition 
count count inductive hypothesis executable exists state agrees 
agrees holds conclude holds implies executable 
agrees 
proves lemma case 
sequence actions 
cn 
definitions 
agrees grounded state lemma know exists state agrees executable executable 
furthermore starts case plan count case conclude son baral artificial intelligence executable executable exists state agrees 
executable agrees 
inductive step proved case 
inductive step follows cases 
ready prove proposition 
proposition soundness approximation respect ak 
domain description fluent formula conditional plan 
knows ak knows proof 
initial state grounded initial state definition wehavethat agrees 
knows definition wehavethat holds 
lemma executable exists state agrees 
implies known true 
hold model ak knows proposition proved 
appendix proof regression proposition section prove regression proposition 
shorter notation write respectively denote holds respectively hold 
prove lemmas proof 
lemma 
fluent literal action state 
assume executable holds res iff regression holds proof 
consider case non sensing action fluent 
assume causes causes anda causes causes ef propositions action regression holds iff exists ef proposition causes holds son baral artificial intelligence holds exists ef proposition causes holds iff iff iff holds res 
similarly prove holds negative fluent literal 
consider case sensing action 
res recall assume set sensing actions non sensing actions disjoint regression lemma trivial case 
lemma follows 
corollary follows immediately lemma fact regression fi regression fi 
corollary 
conjunction fluent literals action executable holds res iff regression holds lemma 
fluent formula action state executable holds res iff regression holds proof 
boolean expression represented cnf formula assume conjunction fluent literals 
lemma follows directly corollary fact regression regression 
lemma 
fluent formula action grounded state 
assume executable state belonging 
regression knows holds knows holds regression knows hold knows hold 
proof 
consider case non sensing action 
regression knows knows regression 
regression knows holds implies regression holds state 
implies holds res state executable lemma 
knows holds 
implies executable grounded state 
son baral artificial intelligence regression knows hold means exists regression hold executable lemma conclude hold res 
implies knows hold 
consider case sensing action senses fluent regression state agrees regression knows knows knows holds implies respectively implies knows respectively knows holds respectively respectively implies holds 
words agree holds 
known true knows holds 
regression knows knows knows hold implies knows hold ii knows hold assume knows hold holds 
means holds knows 
exists state hold 
case implies knows hold 
second case impossible grounded state 
holds knows hold 
similarly ii holds show knows hold 
lemma follows cases 
lemma 
formula action grounded state executable state belonging regression regression proof 
follows lemmas fact formula represented disjunction conjunction fluent literals formulas form knows fluent formula 
lemma 
formula conditional plan 
regression ac formula 
proof 
proof done inductively count number case plans base case sequence actions follows immediately items sub items item definition regression formulas 
inductive step follows inductive hypothesis sub items item definition regression formulas 
proof case senses fluent gn similar omitted 
son baral artificial intelligence lemma 
formula action sequence grounded state executable grounded state regression regression 
proof 
induction length 
base case 
regression lemma trivial 
notice lemma follows lemma base case proved 
inductive step assume proved lemma need prove lemma 
regression regression regression 
inductive hypothesis regression regression 
lemma 
regression regression 
lemma 
lemma 
formula grounded state conditional plan executable state regression regression 
proof 
previous proofs related conditional plans assume sequence conditional plans cn ci sequence actions case plan ci sequence actions ci case plan 
prove lemma induction count number case plans base case count 
sequence actions 
base case follows lemma 
inductive step assume proved lemma count need prove lemma count 
construction cases case cn case plan form case pl endcase cn wehavethat regression cn regression regression cn 
count count count cn count cn count furthermore lemma regression cn formula 
consider cases son baral artificial intelligence case regression 
inductive hypothesis regression cn regression cn 
executable conclude exists knows knows fact regression cn knows regression pi implies knows regression pj 
regression pj 
applying inductive hypothesis time conclude pj 
cn pj wehavethat cn 
case regression 
inductive hypothesis regression cn andc regression cn 
executable conclude exists knows knows fact regression cn knows regression pi implies knows regression pj 
regression pj 
applying inductive hypothesis time pj 
cn pj wehavethat cn 
inductive step case follows 
case cn sequence actions 
cn 
wehavethat regression cn regression regression cn 
follows observation cn case plan 
case inductive hypothesis regression cn andc regression regression cn 
lemma conclude cn 
regression regression cn 
cn 
proves inductive step lemma proved 
prove proposition 
proposition 
domain description formula set grounded initial states conditional plan executable grounded initial states regression iff 
proof 
grounded initial state easy see grounded state grounded initial state item lemma regression 
son baral artificial intelligence second item lemma prove regression 
lemma follows fact hold appendix overview nested circumscription nested abnormality theories nats novel circumscription technique introduced lifschitz 
nats possible circumscribe predicates respect parts theory interest opposed previous techniques parallelized circumscription theories circumscription done respect axioms underlying theory 
furthermore complications arising interaction multiple circumscription axioms theory avoided nats blocks 
block characterized set axioms possibly containing abnormality predicate ab describe set predicate function constants cm 
notation theory cm ai may block form 
description cm block may depend descriptions embedded blocks 
interference circumscription different blocks prevented replacing predicate ab existentially quantified variable 
lifschitz idea ab local block abnormality predicates play auxiliary role interesting consequences theory contain ab 
section contains formal definitions concepts 
definitions 
second order language include ab 
natural number language obtained adding ary predicate constant ab cm block cm predicate function constant formula lk block 
nested abnormality theory set blocks 
semantics nats characterized mapping blocks sentences ifa formula language lk stands universal closure cm ab ab ab circ ab cm 
recall circ means circumscription theory minimizing predicates varying objects nat stands 
amodel model sense classical logic 
consequence sentence language true models suggested abbreviation cm min son baral artificial intelligence denote blocks form cm ab 
notation suggests type block necessary circumscribe particular predicate block 
shown cm min equivalent formula circ cm ai sentence 
baral reasoning actions non deterministic effects constraints qualification proc 
ijcai montreal quebec pp 

baral gelfond representing concurrent actions extended logic programming proc 
ijcai chamb ry france pp 

baral gelfond reasoning effects concurrent actions logic programming 
baral gelfond representing actions laws observations hypothesis logic programming 
baral formalizing narratives nested circumscription artificial intelligence 
barrett golden penberthy weld ucpop user manual version technical report department computer science engineering university washington seattle wa 
bacchus halpern levesque reasoning noisy sensors situation calculus proc 
ijcai montreal quebec pp 

baral planning approximate planning presence incompleteness proc 
ijcai stockholm sweden pp 

baral son formalizing sensing actions transition function approach technical report department computer science university texas el paso tx cs edu html 
dimopoulos nebel koehler encoding planning problems non monotonic logic programs proc 
european conference planning pp 

etzioni hanks weld draper lesh williamson approach planning incomplete information proc 
internat 
conference principles knowledge representation reasoning kr cambridge ma pp 

erdem lifschitz transformations logic programs related causality planning proc 
th international conference logic programming non monotonic reasoning 
erdem application logic programming planning computational experiments draft www 
cs utexas edu tag 
fagin halpern moses vardi reasoning knowledge mit press cambridge ma 
goldman boddy representing simple planners proc 
internat 
conference principles knowledge representation reasoning kr bonn germany pp 

goldman boddy expressive planning explicit knowledge proc 
aips pp 

gelfond strong introspection proc 
aaai anaheim ca pp 

golden etzioni weld planning execution incomplete informations technical report tr department computer science university washington seattle wa february 
giunchiglia kartha lifschitz representing action indeterminacy ramifications artificial intelligence 
son baral artificial intelligence gelfond lifschitz representing actions extended logic programs proc 
joint international conference symposium logic programming pp 

gelfond lifschitz representing actions change logic programs logic programming :10.1.1.34.7448
golden planning knowledge representation softbots ph thesis university washington seattle wa november 
golden weld representing sensing actions middle ground revisited proc :10.1.1.15.5194
internat 
conference principles knowledge representation reasoning kr cambridge ma pp 

haas syntactic theory belief action artificial intelligence 
kartha soundness completeness theorems formalizations action proc 
ijcai chamb ry france pp 

kartha lifschitz actions indirect effects preliminary report proc 
internat 
conference principles knowledge representation reasoning kr bonn germany pp 

kautz mcallester selman encoding plans propositional logic proc 
internat 
conference principles knowledge representation reasoning kr cambridge ma pp 

gini empirical study sensing defaulting planning proc 
st conference ai planning systems pp 

kautz selman planning satisfiability proc 
ecai vienna austria pp 

kautz selman unifying sat graph planning proc 
ijcai stockholm sweden pp 

levesque planning presence sensing proc 
aaai portland pp 

lifschitz circumscription gabbay hogger robinson eds handbook logic ai logic programming vol 
oxford university press oxford pp 

lifschitz nested abnormality theories artificial intelligence 
lifschitz components action language ann 
math 
artificial intelligence 
lin embracing causality specifying indirect effects actions proc 
ijcai montreal quebec pp 

lin reiter state constraints revisited logic comput 

lin shoham concurrent actions situation calculus proc 
aaai san jose ca pp 

lobo taylor adding knowledge action description language proc 
aaai providence ri pp 

mccarthy applications circumscription formalizing common sense knowledge artificial intelligence 
moore reasoning knowledge action ph thesis mit cambridge ma 
moore formal theory knowledge action hobbs moore eds formal theories commonsense world ablex norwood nj 
miller shanahan narratives situation calculus logic comput 

mccain turner causal theory ramifications qualifications proc 
ijcai montreal quebec pp 

pryor collins planning contingencies decision approach ai res 

pednault adl state transition model actions logic comput 

peot smith conditional non linear planning proc 
st conference ai planning systems pp 

reiter frame problem situation calculus simple solution completeness result goal regression lifschitz ed artificial intelligence mathematical theory computation academic press new york pp 

reiter knowledge action logical foundation describing implementing dynamical systems mit press cambridge ma manuscript 
scherl levesque frame problem knowledge producing actions proc 
aaai washington dc pp 

son baral artificial intelligence smith weld conformant graphplan proc 
aaai madison wi 
son reasoning sensing actions application diagnostic problem solving ph thesis university texas el paso tx 
turner signed logic programs proc 
international symposium logic programming pp 

turner representing actions logic programs default theories logic programming 
weld anderson smith extending graphplan handle sensing actions proc 
aaai madison wi pp 

weld commitment planning ai magazine 
