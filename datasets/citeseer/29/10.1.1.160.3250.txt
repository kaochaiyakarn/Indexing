scheduling timing analysis safety critical real time systems submitted degree doctor philosophy iain john department computer science university york 
november scheduling tasks safety critical systems timing requirements reliably met di cult 
safety critical systems di erent systems failure meet requirement catastrophic ect example accident leading loss life 
reason greater emphasis veri cation validation software types systems 
safety critical systems wide range industries including nuclear chemical aerospace automotive industries 
particular area interest thesis avionics industry particular engine controllers 
provides greater emphasis hybrid systems software responsible performance mechanical components 
frequently systems developed problems caused insu cient resources leads costly timing requirements having altered met 
major contributor problems nature cyclic scheduler 
began xed priority scheduling proposed potential solution problems 
additional required xed priority scheduling practice 
areas covered task attribute assignment development new modi cation existing infrastructure production appropriate timing analysis 
course thesis solutions developed required areas uniprocessor distributed systems 
measure success rolls royce actual engine controller 
followed joint aviation authority relevant certi cation authority approving 
addition guards project multi esprit funded collaboration developing new techniques critical real time systems parts analysis developed 
fact technology transfer achieved indication acceptability industry 
transition cyclic executive scheduling fixed priority scheduling fixed priority scheduling solution problems cyclic scheduling 
solving problems fixed priority scheduling 
fixed priority scheduling support domain application requirements 
remains fixed priority scheduling complete solution 
summary 
infrastructure choice associated timing analysis implementing analysing task release mechanism 
handling timing overruns 
summary 
task attribute assignment calculating response 
meeting transaction deadlines uniprocessor systems 
jitter 
separation 
task attribute assignment 
contrast techniques 
summary 
case study br engine controller purpose electronic engine controller system 
technical details system 
technical transition fixed priority scheduling 
details ect process 
summary 
analysis task sets feature sets analysis task sets feature sets assuming critical instant 
exact analysis 
composite approach 
evidence ectiveness 
improvement composite set analysis 
summary 
transition uniprocessor distributed system composite set analysis 
explanation distributed systems timing analysis composite set analysis 
simulation demonstrate relative ectiveness different computational models 
summary 

final comment 
list figures typical control loop embedded system 
diagram illustrate timing analysis transaction 
illustration blocking model pessimism 
task executions illustrate edge ect 
task executions illustrate edge ect 
worst case task execution deadline monotonic priority ordering 
worst case task execution priority ordering 
diagram illustrate approach meeting timing requirements 
timing requirements 
time line transaction illustrated 
time line transaction 
timing requirements 
time line transaction 
time line transaction 
time line transaction 
timing requirements transaction 
time line transaction 
time line transaction 
timing requirements transaction 
time line transaction 
time line transaction 
overview electronic engine control unit 
diagram illustrate system transactions requirements diagram illustrate attributes tasks transactions time line transaction involving tasks attributes modi ed 
time line transaction involving tasks attributes modi ed 
operation hybrid scheduler 
diagram illustrate word format 
comparison approaches free variable argument comparison approaches free variable argument comparison composite approach new blocking model resource range 
comparison composite approach new blocking model resource range 
comparison approaches 
basic architectural structure 
diagram illustrate timing analysis 
phasing tasks di erent processors 
comparison simulation results tasks 
comparison simulation results tasks 
comparison simulation results tasks 
list tables schedulability improved blocking model 
schedulability dmpo 
schedulability dmpo 
basic task set 
analysis tick driven scheduler tclk single task model overheads 
analysis tick driven scheduler tclk multiple tasks model overheads 
analysis time driven scheduler 
analysis hybrid scheduler tclk single task model overheads 
task attributes 
task attributes schedulability analysis results 
example task set 
results simple analysis 
results exact analysis 
number task releases veri ed 
results composite analysis 
task set characteristics 
transaction characteristics 
task set characteristics schedulability analysis results task set characteristics schedulability analysis results transaction characteristics 
schedulability analysis results composite approach results generated composite approach 
table abbreviations abbreviation spark ima tta tdma fifo cots dmpo lcm comp meaning spade ada real time kernel integrated modular attitude orbital control system time triggered architecture time division multiple access commercial shelf deadline monotonic priority order common multiple joint air authority composite task worst case response task table symbols symbol ci ti umax ri bi ii di wi pi ji ni clk meaning worst case execution time task period task maximum processor utilisation worst case response time task th iteration calculation ri blocking time task interference time task deadline task worst case response time task th iteration calculation wi priority task release jitter task instance analysed task task representing overheads due clock tick occurring task representing overhead releasing rst task particular sub si oi td rj re rc time task representing overhead releasing tasks subsequent task particular time separation requirement task set task deadline requirement transaction worst case response time calculated release jitter approach worst case response time calculated exact approach worst case response time calculated composite set approach iwould colleagues real time systems high integrity systems engineering groups university york engineers rolls royce fruitful discussions taken place 
particular acknowledge support tim kelly professor andy wellings dr andrew vickers praxis critical systems dr ben whittle union bank switzerland stuart rolls royce 
main goes professor alan burns supervisor professor john mcdermid kate support tolerance completed thesis 
performed contract rolls royce plc support am grateful 
declaration certain parts thesis appeared previously published papers specifically marked principal author technology transfer integrated culture friendly approach approach proceedings technology transfer workshop part th international conference software engineering berlin germany th march 
putting fixed priority scheduling theory engineering practice safety critical systems burns audsley proceedings nd real time applications symposium pp 
boston 
usa june 
fixed priority scheduler aircraft application burns mcdermid vickers proceedings th euromicro conference real time systems ieee system press pp 
italy june 
flexible scheduling advanced engine controllers burns audsley iee hybrid control real time systems th december flexible scheduling engine controllers burns patent ce uk patent application number patent application number may 
schedulability analysis fixed priority real time systems sets burns proceedings th euromicro workshop real time systems ieee system press toledo spain june 
building preliminary safety case example aerospace burns kelly mcdermid proceedings australian workshop industrial experience safety critical systems software october 
dependable distributed architecture safety critical hard real time system burns iee colloquium hardware systems dependable applications november 
role timing analysis certi cation ima systems audsley iee symposium certi cation ground air systems february 
investigation pessimism distributed systems timing analysis burns th euromicro workshop real time systems june 
chapter safety critical systems di erent systems failure meet requirement may lead catastrophic ect accident leading loss life 
example de nition catastrophic taken mil std death system loss severe environmental damage 
reason greater emphasis veri cation validation software safety critical systems types systems 
importance veri cation indicated fact software ort boeing areas analysis testing 
typically costs producing safety critical systems signi cantly higher domains 
greater potential process improvement initiatives savings potential pay investment costs 
safety critical systems wide range industries including nuclear chemical aerospace automotive industries 
particular domain interest thesis avionics particular engine controllers 
aspects safety critical systems considered thesis control supervise operation system functionality 
relatively context safety critical systems considered years control systems implemented entirely hardware hydro mechanical operations 
problems hardware solutions including cost producing systems high hardware provides control large heavy hardware nite rate performance limits system responsiveness 
need cheaper operating costs lifetime system lead advanced controllers reduced weight 
need seen gradual computers form embedded systems provide hybrid control 
hybrid control embedded system calculations control system 
computer controlled systems advantage great deal functionality canbe implemented single processor leading reduced cost weight 
added bene software non recurring cost due fact produced ignoring ects maintenance hardware adds cost system produced 
comparison established engineering disciplines control systems engineering software engineering considered infancy particularly safety critical systems 
part reason high cost safety critical systems development systems prone large amount change 
systems susceptible change systems produced concurrent life cycle parts system produced dependent parts fully considered 
production concurrent parts system longer supply lead times 
di erent parts system evolve change parts system 
activities implementation veri cation safety critical systems meeting timing requirements 
mechanism controlling system timing behaviour scheduler dictates run time order functionality units performed 
thesis presents research performed scheduling timing analysis context safety critical systems 
term timing analysis taken mean process guaranteeing system timing requirements met 
current scheduling practice evaluation industrial practice systems con rms majority safety critical systems currently employ cyclic scheduler 
operation cyclic scheduler involves constituent parts minor cycle major cycle 
major cycle sequence tasks executed periodically 
major cycle consists number minor cycles split major cycle uniform parts 
schedule produced allocating task speci positions number minor cycles timing requirements met 
principal reasons splitting major cycle minor cycles having single cycle tasks 
reasons ease synthesis reduction jitter synthesis problem simpli ed divide conquer strategy system developed split number parts 
parts initially handled separately integrated unit 
splitting major cycle minor cycles reduces jitter synchronisation points provided 
cyclic schedulers similar characteristics largely dictated nature systems developed 
characteristics 
tasks tendency large number small tasks small terms worst case execution times processor 
reason smaller task gaps balancing packing minor cycles full 
production schedule system seen manageable 
number tasks representative natural decomposition software leads maintenance development problems 

heavily loaded systems tendency high processor utilisation 
part due designers needing try maximise available hardware 
number reasons choice processor tends older generation powerful date available 
older generation processors operational experience increases likelihood design errors known 
design software account discrepancies design hardware may cause problems 
jitter change time task released 
jitter caused variations time tasks take execute 
jitter increases course cycle starting value zero start cycle 
example processor chosen power pc range technically advanced provides greater performance 
reasons partly safety critical systems design errors known applications 
applications include personal computers 
reasons include design simpler power pc processor making easier analyse likelihood mil spec components available increased cheaper purchase 
cheaper cost processor may insigni cant compared system 
commercial version may cost pounds military version costs hundreds pounds 
particularly important hardware recurring cost lifetime system software front cost paid maintenance 
simpler processor design helps ease certi cation process 
factors point choice older generation processor 
older generations processor processing capability modern processors 
practice whichever processor chosen system heavily loaded engineers invariably nd extra functionality included 
powerful processor may necessarily solve problem system heavily loaded 

single processor currently computing infrastructures tend distributed physical system controlled 
single processor may replicated performs necessary functionality 
bene approach uniprocessor simpler certify distributed system easier reason tasks interactions located processor 
context distributed system considered number processors communicate messages fully interconnected data bus 
drawback single processor approach functionality executed needed 
example data calculation performed remotely actuator uses 
required leading increase weight 
discussions engineers industry number problems cyclic scheduling highlighted 
locke discusses similar problems cyclic scheduling 
brief points highlighted 
cyclic scheduler hard maintain due di culty synthesising scheduler poor robustness change 
great deal resource wasted due restricted computational model having periodic tasks rate integer multiple minor cycle 
di cult assess system schedulable nal system available 
problems discussed greater detail section 
alternative approaches scheduling number trends going greatly uence development systems primarily need cheaper development maintenance 
number papers example describe novel architectural approaches simplify design maintenance systems 
achieved facilitating technology transparency ability system behaviour speci environment interchangeability ability run software number platforms systematic reuse process architecture encourages reuse system components 
principal enabling technologies trends successful provision exible predictable scheduling technique 
having recognised need di erent scheduling approach cyclic scheduler issues dealt 
issues suitable scheduling approach current framework safety critical systems 
largest body research scheduling performed scheduling variants xed priority dynamic priority 
approaches rely tasks having priority runnable tasks executed priority order 
fundamental di erence priority approaches xed priority scheduling task static priority assigned line dynamic priority scheduling tasks changing priorities run time dependent particular metric 
example xed priority scheduling task priorities assigned higher priority tasks smaller periods referred rate monotonic scheduling 
dynamic scheduling task priorities assigned higher priority tasks closest deadlines referred earliest deadline rst scheduling 
scheduling approach acceptable safety critical domain technique predictable 
context scheduling predictability ability state time task executed 
predictable scheduling approach allows analysis demonstrates timing requirements met 
forms part justi cation integrity ofthe system 
predictability determined entities method selecting task priorities mechanism releasing tasks priorities 
respects xed dynamic priority schedulers predictable 
key point worst case schedule timing perspective approaches deterministic 
context scheduling deterministic ability state execution commences run time ordering tasks 
principal di erence cyclic scheduling approach approaches cyclic approach deterministic static runtime ordering tasks priority approach predictable dynamic run time ordering tasks general 
safety critical systems industry conservative xed priority scheduling viewed di cult certify 
problem certifying xed priority system simpler dynamic priority scheduling 
dynamic scheduling scheduler complex overheads larger compared techniques decisions taken line 
contrast xed priority scheduler run time model relatively simple 
reasons xed priority scheduling investigated thesis solution problems cyclic scheduling 
solution viewed smaller evolutionary step dynamic priority scheduling 
thesis seen simpli ed version xed priority scheduling advocated ease technology transfer problems 
locke problems cyclic scheduling highlighted xed priority scheduling viewed best context best minimal technological change capable solving problems solution problems 
akey observation locke deals purely academic scheduling model consider technique industry 
domain speci change great deal academic performed claimed suitable safety critical systems 
little adopted industry 
problem general nature trying cope number domains wide range systems 
solutions result possibly support necessary constraints particular system ciently ectively 
reason thesis speci cally targeted industrial projects developing systems 
strategy allows development tighter solution speci system purpose 
applicability systems general 
systems chosen multitude options application information available due personal experience british aerospace plc rolls royce plc 
having information available increases actual relevance 
particularly important depth details actual safety critical systems generally available public domain 
systems classed critical highest integrity level systems 
systems feature hard real time requirements 
hard real time requirements de ned guaranteed met 
timing aspects system controlled scheduler 
scheduler responsible controlling functionality performed fundamental exibility predictability system 
scheduler ected maintenance system 
techniques producing systems evolve scheduling advanced 
thesis investigates evolution scheduling support development safety critical systems 
speci change caused domain may considered important resulting technical commercial bene ts 
recognises adapts existing body xed priority scheduling accordingly 
certainly technical bene ts ensure adoption proposed change 
practice commercial factors cost risk normally greater uence 
basic change system developed considered 
certi cation safety critical domain traditionally conservative 
signi cant change requires great deal assess risks show system safe change 
measure success su cient evidence approach integrity generated satisfy certi cation authorities 

su ciency reasons cost technique developed exible cient allow engineer design implement maintain system minimum ort 
measure success set requirements met feasible 

understanding akey di cult assess criterion understandable apply industrial context 
purpose thesis measure success criterion industry accepted adopted 
addition important engineers technique need specialist knowledge signi cant amounts re training 

reuse great deal investment exists current systems service currently developed 
possible change ect rest system 
approach allow majority components existing systems reused 
measure success hardware software system needs changed 
industry risks probable cost associated change assessed decision taken change acceptable 
changes current practice thesis considered respect criteria 
thesis proposition central proposition thesis proposed simpli ed version xed priority scheduling ease problem meeting timing requirements immediate industrial safety critical embedded systems 
strands thesis 
firstly thesis concerned supporting transition cyclic scheduling xed priority scheduling 
secondly thesis addresses transition uniprocessor distributed systems 
thesis structure chapter contains description current role approach taken scheduling timing analysis safety critical systems domain 
description intended encompassing statement meant general purpose description systems domain 
aim chapter provide basis changes proposed explain problems currently encountered developing systems 
chapter contains literature survey supporting rest document giving background information history xed priority scheduling 
chapter considers transition cyclic scheduling xed 
addresses bene ts xed priority scheduling current literature subject su cient implement systems kind discussed chapter 
part chapter derive appropriate computational model timing analysis investigate pessimism timing analysis may 
context scheduling pessimism de ned analysis indicates system fact schedulable 
course chapter areas need attention allow complex control systems implemented safety critical domain 
firstly approach required allows reuse current infrastructure application derived chapter 
secondly mechanism needed assigning attributes tasks timing requirements met derived chapter 
chapter presents case study techniques applied real system order demonstrate concepts appropriate capable 
system chosen currently uses cyclic scheduler 
chapter presents timing analysis task sets tasks feature sets 
set delay known task released 
approach provides solution need timing analysis features low pessimism low computational complexity understandable 
chapter addresses transition uniprocessor systems distributed system 
chapter provides computational model scheduling distributed system proceeds develop timing analysis relatively low computational complexity pessimism 
extensive simulation evaluate derived solution 
timing analysis approach uniprocessor timing analysis chapter 
task attribute assignment technique adapted improve schedulability robustness change 
uses set analysis developed chapter 
chapter summarises achievements contained thesis provides suggestions avenues research 
chapter current approaches scheduling safety critical systems purpose chapter de ne current techniques mechanisms employed scheduling timing analysis safety critical systems domain 
aim provide baseline ect transitions properly assessed 
transitions uniprocessor cyclic scheduling xed priority scheduling scheduling distributed systems 
aimed general safety critical systems particular emphasis systems 
chapter introduces requirements relevant scheduling safety critical systems 
typically scheduling requirements types application speci case systems provide control supervision operation domain speci case general constraints safety critical systems 
related producing scheduler principal categories requirements timing functional safety 
assumed appropriate techniques exist guaranteeing functional correctness scheduler 
covers timing aspects safety related timing 
main parts discussion timing requirements section certi cation requirements section process issues section infrastructure details section 
nal part chapter section contains detailed discussion speci problems cyclic schedulers 
timing requirements met safety critical embedded systems developed commercial applications details publicly disclosed 
realistic examples timing requirements hard nd 
purpose section discuss general characteristics system implemented domain establish typical timing requirements 
discussion uses contents main sources mos project general system system knight 
sources examples derive typical timing characteristics summarised section 
discussion supplemented information obtained anumber years experience working avionics industry 
considering sources possible provide outline typical timing requirements 
course discussion necessary introduce control system concepts order place requirements context 
discusses general timing requirements project 
aim project investigate theories design rules needed applying distributed computer solutions 
systems control complex machinery industrial robots production machines vehicles aircraft 
speci cally consider needs safety critical systems 
discussed invariably classed critical high integrity 
requirements project relevant 
sensor analogue digital transformation digital analogue actuator continuous domain discrete domain feedback signal processing engine transformation discrete domain continuous domain analogue digital validation signal typical control loop embedded system overview basic control systems de nes control system basic modelling entities transformation sampling feedback 
type system illustrated 
illustrates transformations principal means controlling operation system 
transformation ectively applies mathematical function signal input 
transformations part feedback loop 
intention having output current output latest input 
routes feedback signal illustrated signal output actuator read actual actuator value 
bene actual actuator value system characteristics inertia cause non ideal operation accounted 
feedback path allows error checking actuator operation 
drawback extra requirements functionality 
feedback rate change output ectively damped slowed increases stability output signal reduces impact infrequent signal errors spikes signal 
stability measure ease signal ected leading unpredictable behaviour 
stability control system considered important 
stability controlled system performs expected 
poor stability control result system going operational bounds leading mechanical damage 
control stability reduces performance system constraining response stimuli 
optimum performance obtained operating system limit stability 
sampling stages analogue digital digital analogue conversion allow system convert continuous discrete domains 
continuous de ned connected space time value ability change 
continuous systems process analogue signals 
analogue signal assume value permitted range 
computers control systems entirely produced continuous signals hydro mechanical components 
discrete described discontinuous nite interval value change 
discrete components microprocessors process digital signals 
digital signal nite set values chosen 
simplest form binary signal values zero relate true false 
shows transformations performed discrete values 
tasks complete path sensor input transformation function actuator output processing engine represented transaction 
transaction number tasks executed pre de ned order normally speci ed time limit 
transaction contain sequence data capture followed transformation followed data output deadline constrain latency 
outside transformation stages feedback loops actual system relies information form 
problems discrete domain number observations concerning relationship discrete time control systems programmable electronic control systems continuous time control systems traditional analogue systems 
discrete control system classical result time delays deteriorate performance ideal example noise introduced signal 
drawback moving computer controlled system calculations actions longer occur virtually instantaneously 
signals latency jitter 
latency delay rst point time value arrived signal arrive 
output signal latency ect time just generation initial input signal actual output 
jitter de nes maximum variation periodicity function 
jitter considered variation latency 
purpose de ning latency jitter provide constraint instability 
direct relationship stability jitter jitter increases stability reduced 
example ect jitter shown di erentiation function left hand side equation 
di erentiation function frequently control loops de ned rate change function respect time 
value di erentiation function normally dependent value typically function implemented discrete domain regularly sampled values approximation right hand side equation 
change value samples time samples 
cyclic schedule sampling function implemented periodic task 
di erence calculated successive samples sampling rate assumed constant 
ect jitter cause value change 
control algorithms considered di cult allow varying changing time samples referred multirate control 
di culty trim values gains ampli ers transformation function account changing rates 
constant assumed correct particular case usually average case 
calculation di erentiation function contains inaccuracies manifests noise cause instability 
continuous domain function implemented zero latency simple electrical circuit instance single capacitor 
latency means stability signals ected latency introduced moving continuous discrete domain 
great deal performed analysing ects time varying delays control system behaviour including ect stability latency jitter data loss 
considering earlier example di erentiation function missed sample latency similar ect jitter actual value di erent value calculations 
basic ect factors increase stability control system decreases 
con rms management factors fundamental controlling system performance 
important approach scheduling caters factors discussed section 
experience control systems designed requirements assume actions occur pre de ned times purely hardware systems 
practice ect jitter actions occur systematically times 
scheduling control systems advanced scheduling timing analysis approaches provide statistical estimate functionality performed 
functionality performed irregular times computation times software invariably changes due vast number paths navigated 
change time events occur ect control algorithms 
identi es number properties period deadline jitter speci ed 
properties related tasks transactions 
aim properties provide control execution software order provide upper limit possible latency 
period de nes average time updates 
period de ned order provide required responsiveness system stimuli 
addition regular updates actuators correct mechanical drift 
deadline de nes maximum delay task ready release task completing 
observation engineering practice implies task rates possible maintained regular multiples 
iteration rates transactions tasks form possible 
adopting tactics system function ectively scheduling overheads reduced resource usage minimised data ow simpli ed 
general avionics system report general avionics system contains speci cation general functions systems 
functions data interactions timing constraints mission control system typical existing navy marine corps aircraft 
noted system described distributed functionality exists single processor 
speci cation system signi cantly simpler discussed reviewed section transactions considered 
requirements tasks subset discussed section 
extra knowledge timing requirements obtained 
general system speci cation includes requirements importance particular requirement met considerations 
general avionics system speci cation con rms requirements described accepted applications 
importance requirement re ects potential need multiple integrity levels processor 
simplest case requirements importance safety critical non safety critical 
respect timing importance considered having met hard deadlines met soft rm deadlines 
particular software executed system certain status 
practical systems necessary safe execute software time 
example software operating landing gear aircraft needed ight 
system knight examines production safety kernel may easiest way achieve enhance integrity particular system 
safety kernel kernel schedules usual functionality aswell enforcing safety policies 
software provides fundamental system services scheduling fault tolerance handling hardware devices safety policy requirement control particular functionality normally purpose policing certain hazards 
original concept safety kernel introduced rushby 
rushby states bene safety kernel philosophy embedding functionality application kernel small produced rigorous standard example formal methods 
philosophy allows powerful argument certi cation process formal techniques applied key areas reduce likelihood hazards 
particularly important systems certi ed def stan advocates formal methods design lifecycle systems 
papers example opinion stated formal methods impractical real systems scale large systems leading high costs 
compromise formal methods key areas seen su cient ful llment requirements 
system analysed safety policies enforced 
system device steers powerful magnets process detecting brain 
incorrect control magnets harm kill patient 
lead number safety policies derived design referred requirements 
number design derived requirements aimed making kernel police system operation order prevent unsafe actions 
example ray source turned seconds command executed 
separation requirement task separated task seconds de ned ensure time gap task performing operation task performing operation 
highlights number safety related requirements need protect failures 
provides support existing terms kernel scheduler thesis term mechanism controls task execution 
types requirements raised examples project general systems 
summary timing requirements evaluation industrial practice avionics area con rms requirements discussed section realistic 
statement supported case study chapter 
number examples similar types requirements ones discussed including attitude orbital control system mine pump system 
principal categories timing requirements considered associated tasks existing processor involving messages transfer data processors existing associated transactions exist processor include tasks messages derived related system design 
timing requirements task 
period tasks considered period 
sporadic tasks modelled periodic task period equal sporadic task minimum inter arrival time 
sporadic task task released regular rate certain event occuring 

deadline deadline task maximum time allowed expected task release completion task execution 
importance timing requirement normally categorised deadline hard soft 
hard real time requirements met cases 
soft real time requirements met majority cases matter occasional deadline missed 
locke introduces third category rm deadlines met majority cases 
rm deadline similar soft deadline rm deadline missed task completed 
task soft deadline completed anyway 
safety critical systems requirements considered hard realtime 
reason di culty assessing soft requirements ect hard requirements 
soft requirements tend implemented lower integrity standard hard requirements means may predictable 
easier assume tasks hard deadlines 

jitter jitter constraint task allowed variation task completion precise periodicity 
jitter generally caused variations worst case execution time tasks 
jitter constraints normally placed outputs system ensure occurrence actions vary 
sequence tasks executed xed order referred transaction 
timing requirements transaction 
period similar task transaction periodic requirement 
unusual tasks transaction executed di erent rates 
cases transaction period equal common multiple tasks form transaction period 
reason common chosen lower value tasks execute required precedence order 

deadline transactions normally requirement tasks executed particular order amount time 
transaction deadlines fall categories tasks hard rm soft 

jitter similar task transaction may jitter constraint 
general jitter constraint applied tasks transaction gather inputs produce outputs 
tasks jitter ect refer section details 
implement transaction tasks executed xed order number possibly just processors 
transactions featuring tasks di erent processors message scheduled communications system transfer data 
example system illustrated implemented part distributed control system functionality sensor actuator transformations executed separate processors 
reason necessary processing placed physically needed reduce amount 
messages communicate required data sensor processor performing transformation message communicate data actuator 
message design derived requirements 
period message periodic requirement equivalent period task sends 

deadline deadline message maximum time allowed earliest message release time time receiving task due released 
addition number requirements obtained sources predominantly product design process 
derived requirements related scheduler include 
precedence precedence requirement may speci ed ensure particular set actions occur required order 

separation particular sequence events may minimum time separation enforced ensure correct operation 
separation requirements may provide controlled access di erent device di erent tasks allow resource contentions occur 
approach derived scheduling able provide proof requirements met 
need scheduling policy approach task attribute assignment ectively deals requirements 
uence certi cation requirements scheduling system aspect thesis di erent performed scheduling targetted speci domain demands certain guarantees justifying system integrity 
purpose section help understand constraints imposed certi cation standards scheduler timing aspects system 
multitude certi cation requirements safety critical systems 
accurate relevant observation tannenbaum nice thing standards choose 
thesis united kingdom certi cation standards production systems 
standards include military standards def stan internationally agreed civil standard 
standards considered relatively high level order away speci characteristics capture key points 
consideration uence standards may separated number parts includes timing requirements met schedule scheduler implementation veri cation techniques 
timing requirements certi cation standards purpose section explore certi cation standards implicitly lead timing requirements system 
requirements relate ability tolerate faults 
example section responses failure conditions consistent safety related requirements 
aim requirements provide control faults dealt 
requirements deal faults derived reliability measure long system risk replicated version component unavailable 
systems encountered requirement faults identi ed tolerated recovered possible bounded time 
modern aircraft particularly military ones tend unstable inorder improve 
aircraft relies computers assist pilot 
aircraft example system failure ight control system milli seconds catastrophic 
timing requirements fault tolerance may need 
meet timing requirements event certain failures 
restrict time risk parts system unavailable 
limit time entire system unavailable catastrophic event happening 
timing perspective failures tend manifest timing overruns 
approach provide adequate control timing overruns commensurate integrity 
uence certi cation standards scheduler implementation similar observation section explicit requirements certi cation standards producing software ect scheduler implementation implicit ones 
implicit requirements related certain architectural features di cult verify 
speci uences related software execution established contact companies developing safety critical systems 
rst uence related ow control provided arbitrary interrupting application tasks advisable increased di culty attaining su cient test coverage 
arbitrary interruptions lead vast increase potential paths software compared code interruptions 
certi cation standards prohibit interrupts simply highlight potential di system integrity 
culties guaranteeing second uence concerns multiple levels interrupt raises issues interrupt handler functions correctly 
correct functionality includes 
interrupt handled returning execution point interrupt occurred 
interrupt disrupt execution current execution lower integrity level including applications correctly relinquishing control 
interrupts nested 
nested interrupts interrupts occur interrupts handled 
certi cation authorities tend interrupts di culty guaranteeing function correctly relation rest system 
normally signi cant attention paid relatively simple problem interrupt signi es start minor cycle cyclic scheduler 
multiple levels interrupt cause signi cant increase ort required certify system 
uences considered implicit certi cation standards discussion testing 
example section def stan states su cient testing performed show dynamic performance requirements met assumptions formal methods valid target system 
clearly achieve goal full test coverage easier system interrupts system arbitrary interrupts 
trivial example complete test coverage considered impossible 
system having interrupts allows testing come closer achieving complete coverage system interrupts 
uences scheduler implementation implicit explicitly stated older version interim defence standard 
removal re ection need allow systems advanced desire unnecessary design constraints 
minimise occur ensure ones occur predictable outcomes 
uence certi cation standards veri cation software key part certi cation requirements issue veri cation performed 
veri cation provide evidence system meets requirements 
requirements cover number areas fall categories functional inputs translated outputs non functional properties related infrastructure timing memory communications safety 
uence timing requirements dealt section 
certi cation standards tend advocate veri cation performed analysis testing ensure requirements su cient correct provide extra veri cation evidence 
analysis ensure requirements consistent ambiguities exist 
analysis feasible comprehensive testing mandated 
addition traceability required parts system documentation order show requirement achieved 
requirements advocated certi cation standards 
depth survey certi cation requirements refer papadopoulos mc 
key contribution papadopoulos consideration commonalities di erences standards 
certi cation standards papadopoulos common elements related scheduling 
argument safety dependability procedural technical evidence 
helps justify bene timing analysis compared test part veri cation process evidence precise 

safety process drives system development process 
implies timing analysis fundamental part lifecycle performed event 

safety requirements established functional hazard analysis risk assessment 
relates need safety policies requirement detect tolerate recover failures bounded time 
current lifecycle producing schedule scheduler technology transfer exercise ects way companies operate 
understand impact new technique change scheduling policy necessary assess current process modi ed accommodate change consequently change provides bene understanding changes accepted 
section tries de ne existing process model su cient level detail assessment ect change take place 
facets discussion production appropriate scheduler production appropriate schedule 
experience processes industry di cult de ne process complex individual working project slightly di prone change process project negotiated customer 
statements contained section process rolls royce design controllers 
description considered equally applicable processes 
change scheduling regime consider attributes current process attempt trade impact change process bene obtained 
ne balancing act judging changes may bene cial hand radical change lead signi cant bene scheduling hand radical change greater system wide impact increased risk 
changes scheduler need considered wider scope system 
number stages lifecycle mentioned con guration management important particularly scheduling 
lifecycle stages relevant scheduling system considered requirements design implementation veri cation certi cation 
great deal literature software engineering lifecycle detail 
general de nition produced order allow impact change assessed 
clearly process de ned perfect match develop systems considered su cient representation 
requirement speci cation requirements speci cation mechanism capturing specifying system terms functional non functional requirements 
purpose requirements convey system design team implementation design veri cation purposes 
key need show requirements consistent complete correct 
scheduling requirements tend expressed natural english form free owing sentences express requirements 
experience timing requirements legacy original hydro mechanical systems 
key issue iteration rates may chosen prior knowledge available iteration rates cyclic scheduler leading practical actual requirements 
signi cant obtained addressing real timing requirements criterion successful technology transfer su ciency 
design design practice determining requirements implemented 
key part design justifying demonstrating requirements met parts design relate requirements 
respect schedule informal techniques generally design 
cyclic schedule initially synthesised rst build tool places tasks number minor cycles scheduling requirements met 
synthesis performed estimated values worst case execution times tasks 
schedule re synthesised 
requirements change cycle overrun schedule list manually altered 
approach adopted ect data control ow system easier judge allowing reduction level regression testing 
schedule re synthesised complete re veri cation system required built safety evidence lost 
represents weakness relying having static run time ordering provided cyclic scheduler 
weakness ordering may easier guarantee deterministic ordering changed basis guarantee lost 
implementation implementation mechanism building components meet requirements su cient integrity 
akey part stage justifying demonstrating eventual implementation meets software speci cation design 
united avionics industry currently implement systems spark spade ada real time kernel ada subset spark annotations 
spark subset eliminates parts language implementation characteristics di cult determine 
likelihood safe software increased 
spark annotations support information required perform static analysis 
key point ada intends introduce philosophy design add bene resultant system 
basis spark technique promotes software engineering encourages designer reason design produced 
bene subset language spark ada operation code predictable 
means worst case execution time analysis built model system timing behaviour 
veri cation veri cation mechanism ensuring system meets requirements 
terms cost time veri cation stage expensive systems developed safety critical standards 
testing system timing properties involves measuring worst case execution time period tasks followed analysing timing requirements met 
worst case execution times tasks measured simulation vast range realistic scenarios 
time taken measure worst case execution times needs large provide su cient degree con dence measured value close actual worst case 
tasks worst case execution times prove system meets timing requirements 
test system scripts derived requirements establish sub system operates correctly part larger system 
problems test orientated approach time taken perform comprehensive tests large values obtained certainly optimistic 
value optimistic worstcase path exercised simplest cases due large number possible paths 
optimistic values may occur especially paths rarely exercised example paths deal failures 
paths lead uncertainty analysis show requirements met means cycle overruns occur system service 
cycle overrun execution tasks minor cycle extends minor cycle 
reason analysis techniques rarely establishing task worst case execution time results tend overly pessimistic 
pessimism may veri cation results imply system timing requirements met 
vast body research attempts solve problem pessimism worst case execution time analysis examples 
techniques industrial systems 
reason techniques rely support compiler processor vendors supplier providing necessary information product product providing output appropriate form currently available 
problem worst case execution analysis rarely portable di erent targets leading di erent version required 
timing analysis contained assumes actual worst case execution times available problem matter showing timing requirements met 
certi cation certi cation mechanism arguing system meets safety obligations derived knowledge risk severity likelihood hazards 
development process speci evidence needs captured allows safety system argued 
safety argument certi cation case 
certi cation case evolve development life time system 
simpli ed view current approach certi cation number known techniques example fault tree analysis technique determine particular fault occur information obtained stages lifecycle results timing analysis 
techniques strategy required argue system safe 
basic strategies applied combined evidence argue system safe 
strategies 
software safety analysis analysis techniques show system appropriate integrity 
analysis justi es previous stages lifecycle requirements speci cation design implementation veri cation leads correct complete consistent requirements 
requirements re ned system predictable manner 
projects perform software safety analysis due di culty task immaturity techniques 
software produced deemed appropriate process 
software safety analysis considered relatively immature compared areas engineering 
instance recognised technique evaluating software reliability needed justify system reliability 
reliability calculations system hardware reliability accounted software reliability assumed ideal probability failure zero 

infrastructure safety analysis di erent approach produce software safety analysis applications system lower integrity concentrate correctness infrastructure 
amount software safety analysis needs performed reduced 
similar philosophy safety kernels discussed section deemed impractical produce software formally 
safety argument justi cation system reasonable quality infrastructure manages integrity 
approach requires infrastructure implement safety policies derived system hazard assessment exercise 
single technique su cient guarantee integrity 
independent software safety analysis performed safety case need justi cation infrastructure detects tolerates failures manner consistent needs system 
experience systems tend combination approaches justify integrity system 
particular scheduler considered key part infrastructure system 
great deal ort applied ensuring tasks released expected timing overruns detected correctly timely fashion 
actual schedule considered slightly important 
infrastructure cyclic scheduling new technique ects 
scheduling major impact infrastructure system may need altered cient ective operation 
understand transition typical architecture cyclic scheduler outlined 
discussion section possibly represent form system produced meant representative example 
typically infrastructure cyclic scheduler generates clock tick form interrupt signify start minor cycle 
tasks released pre de ned order 
key feature task release mechanism tasks released executed completion 
referred non preemptive execution 
main software minor cycle nished executing control passed background scheduler 
background scheduler executes important functions clock tick arrives signify start minor cycle 
software scheduled background implemented arbitrary interrupts ect system integrity 
implementations take advantage clock initiate timing watchdog functionality 
purpose timing watchdog detect tolerate timing overruns 
frequently taken strategy timing watchdog modes operation executing tasks 
main scheduler executed supervisor mode higher interrupt level background scheduler executed user mode 
system operating timely fashion tasks executing supervisor mode nished clock tick 
timing watchdog simply detects mode system clock tick arrives 
supervisor mode means timing overrun occurred user mode means overrun occurred 
supervisor user mode normally observable electrical signal processor 
simple timing watchdog may produced hardware triggered clock tick 
timing watchdog hardware checks mode processor fault recovery performed processor supervisor mode 
typical fault recovery strategy controlling system replicated version reset lane fault exists 
assumes lane available lane probably actively redundant 
timing watchdog approach considered ective software involved test functionality simple 
problems cyclic scheduler approach projects develop safety critical systems problems related timing 
problems include resource budgets exceeded timing requirements met unexpected failures arise service resources wasted 
fact projects frequently experience problems timing related number widely recognised weaknesses cyclic scheduling model documented locke 
weaknesses include exibility poor maintainability lack support needs 
weaknesses considered sub sections 
exibility leading wasted resources exibility ofthe cyclic schedule restrictions 
limited amount iteration rates available tasks periodic 
exibility results requirements expressed suit model periodic tasks harmonics minor cycle rate 
exibility leads wasted resource worst case scenario considered caused 
tasks executed faster necessary meet period requirement 
example implement task rate units cyclic scheduler minor cycle rate means task queued minor cycle rate 
queuing task cycle result average rate requirement met 
resulting waste resources 

sporadic tasks having implemented polling periodic 
polling periodic task executes regular rate check particular event occurred 
polling periodic average case may similar performance worst case pessimistic 
example sporadic task minimum inter arrival rate average rate implemented periodic task rate 
average rate waste resources 
alternative example sporadic task minimum inter arrival rate deadline implemented periodic task rate deadline 
reason periodic task period deadline task su er release jitter equal period due uncertainty event occurs 
waste resources 
matters worse cyclic nature schedule 
tasks placed minor cycle cycles ow 
prevent ows space reserved cycle act timing margin 
type schedule invariably produced timing margin cyclic scheduler number minor cycle matters worse 
signi cant proportion valuable resources available 
waste especially signi cant considered safety critical systems older generation processors reasons explained section 
invariably shortage processing resource 
resource major driver research reported thesis 
maintenance di culties cyclic scheduler maintenance di culties cyclic schedule arises need correctly order tasks task transaction requirements met 
heavily loaded system minor cycle nearly full 
execution times tasks change frequent need move tasks minor cycles balance load prevent ows 
lead complicated juggling acts 
cases maintenance di culties scheduler convince people appropriate solution necessary 
garey johnson show bin packing problem equivalent tothe synthesis maintenance schedule np complete 
problem di cult transaction requirements met 
transactions means job moving tasks complicated interactions particular tasks maintained 
simply moving tasks balance minor cycles consideration transactions break precedence constraints previously met 
computational complexity synthesising schedule suggests tool automation 
di erent techniques proposed problem synthesising cyclic schedules 
burns performed analysis available techniques reducing complexity problem 
looks di erent techniques simulated annealing brute force genetic algorithms heuristic search stochastic evaluation synthesising schedule 
burns concludes technique bene ts drawbacks technique chosen depends speci needs system 
automated synthesis may result better scheduling solution cost 
cases tool automation solution adopted 
safety critical systems introduce speci problems 
main problem automated tools related regression testing 
stated veri cation largest cost projects develop safety critical systems 
tool synthesis gives new schedule task interactions may di erent 
leads signi cant ort required re veri cation 
commonly recognised characteristic safety critical systems development systems prone large number changes 
automated tool vastly increase cost veri cation due regression testing needed functional requirements 
approach taken attempt di cult may lead requirements met 
ect change easier assess 
general system maintenance problem introduced cyclic schedule summarised sha liu goodenough cyclic approach meeting responsiveness schedulability stability requirements di cult job practitioners sacri ce program structure code right time slots 
system case study chapter software split tasks need small chunks software organise cyclic schedule having tasks represents principal functional partitions system 
number side ects splitting tasks including tasks scheduled veri ed 
software may longer decomposition dictated software engineering practice 
supporting requirements system designers going place functionality software trend move away uniprocessor systems 
move distributed systems expose weaknesses cyclic scheduler 
maintenance cyclic schedules involving processor di cult processors working complicated 
instance distributed transactions results number schedules cooperating meet common requirement 
presents example known timing problem related di culty handling distributed systems cyclic schedule 
describes rst launch space shuttle columbia delayed due failure synchronise computers distributed system 
implication distributed transactions change schedule processor knock ect schedules 
greatly increases computational complexity maintenance costs multiplied 
problem exaggerated trend multi worse multi national collaborations need keep changes localised large 
may prohibitive systems designed manner involving tight cohesion schedules di erent processors 
cyclic schedules implement distributed transactions necessitate cooperation schedules 
industry recognises problems cyclic schedules systems currently produced maintained fact exaggerated 
change scheduling approach required particularly needs 
summary chapter principal subject addressed identifying systems currently developed 
subject addressed relatively generic manner transitions discussed thesis widely applicable 
purpose identifying systems currently developed baseline identi ed transitions start 
baseline de ned main areas life cycle infrastructure typical timing requirements certi cation requirements 
summary current systems includes 
periodic tasks executed non preemptively 
tasks execute integrated fashion transactions 
control tasks jitter critical correct operation system 
single regular interrupt facilitate task release mechanism timing watchdog 
problems cyclic scheduling discussed 
section suggests xed priority scheduling solution problems cyclic scheduling 
remainder thesis explore claim 
literature survey chapter provides details performed xed 
chapter uses information literature survey details chapter derive suitable approach xed priority scheduling safety critical systems single processor 
manage transition criteria successful technology transfer certi cation su ciency understanding reuse considered making design decisions 
chapters identify existing theory 
chapters develop new theory ll necessary gaps providing argument techniques adoption 
ndings chapters demonstrated case study chapter 
chapter literature survey fixed priority scheduling technique chapter highlights fact xed may provide solutions problems encountered cyclic scheduling safety critical systems 
purpose chapter investigate literature xed priority scheduling order understand existing subject 
number areas surveyed justify transitions cyclic scheduling xed priority scheduling uniprocessor distributed systems actual technical contained transitions 
section computational model priority assignment timing analysis xed introduced 
section survey support transition interest uniprocessor distributed systems 
new issues meeting distributed transaction requirements introduced solutions investigated 
section mars referred time triggered architecture approach developed university vienna discussed 
mars approach deemed best currently available public domain approaches safety critical systems 
section looks integrated modular ima systems represents proposed architecture systems 
fixed priority scheduling uniprocessor systems purpose section review literature scheduling uniprocessor systems 
xed priority early fixed priority scheduling early xed priority scheduling published 
discuss xed priority scheduling simple conceptual framework task executing highest priority task runnable 
tasks execute preemptive fashion 
liu layland model tasks assigned priorities highest priority task shortest period referred rate monotonic scheduling 
liu layland shows rate monotonic scheduling model optimal task sets zero sets deadline equal period 
set classed time task release separated common time 
typically time coincides majority tasks released 
liu layland propose schedule veri ed simple utilisation test 
test expressed equation 
umax nx ci ti number tasks task set tasks ci worst case execution task ti period task umax maximum processor utilisation equation indicates utilisation test value dependent number tasks system system schedulable 
equation equal umax equal percent task set schedulable 
tends nity equal task set schedulable 
test provides pessimistic results 
example pessimism task set tasks period deadline equal worst case execution times 
utilisation tasks test implies task set equation umax 
task set schedulable tasks simultaneously released task dispatched immediately execute time dispatched execute time tasks execute deadline 
lehoczky sha ding shows typical task sets large number tasks approaching schedulable 
despite utilisation test indicating task set 
liu layland identi ed critical instant point time tasks simultaneously released 
task instance de ned release execution completion task 
key results related critical instant 
tasks execute worst case time tasks subsequently released maximum rate tasks worst response 
timing behaviour monotonic monotonic identi able worst case scenario timing requirements guaranteed met case met 
worst case response time task response time task instance released critical instant 
instance task needs demonstrated meeting timing requirements 
liu layland observation critical instant monotonic behaviour signi cant subsequent timing analysis simpli ed ease computational complexity helping meet understanding criterion relatively simple understood accepted analysis 
initial xed priority scheduling small amount published 
late xed priority scheduling began attract attention publications written presumably complexity systems started demand greater exibility ciency 
systems relates computerised control systems hydro mechanical control 
analysis tasks worst case response time number observations katcher include utilisation test pessimistic priority assignment algorithm sub optimal 
rate monotonic assignment priorities suboptimal tasks deadlines equal period tasks non zero sets 
pessimism utilisation test indicates need better timing analysis 
categories timing analysis 
su cient necessary analysis indicates schedulable solution task set schedulable 
category timing analysis desirable 

su cient necessary analysis indicates schedulable solution task set schedulable 
cases task set schedulable contrary results analysis 
category analysis acceptable cases su cient necessary analysis considered infeasible available 

su cient necessary analysis indicates schedulable solution task set fact schedulable 
form analysis undesirable 
original consideration timing analysis leung whitehead shows instance task particular processor schedulable period maximum set task common multiple task periods maximum set task task set schedulable 
audsley improved analysis duration maximum set task common multiple task periods brackets 
indicate range rst value included second value excluded 
example refers time range 
maximum set task 
lehoczky presents busy period analysis provides reductions duration analysed 
achieved considering intervals higher priority tasks queued cause interference 
leung audsley analysis frequently referred exact analysis de nitely helps reduce pessimism utilisation test classed su cient necessary 
problem analysis task sets featuring irregular periods particularly primes result di cult obtain 
value common multiple task periods large 
large value common multiple means large number task instances checked 
computationally feasible analysis tasks worst case response time harter presents complexity problems exact analysis 
rst attempts solve computational harter developed timing analysis performed pseudo time show task set schedulable tasks meet deadline 
timing analysis individual processor solved equation taken 
analysis valid task sets critical instant 
harter analysis assumes tasks period 
xed unique priority zero set deadlines greater ri ci ii bi set tasks node ri worst case response time task ci worst case execution time task bi blocking time task ii interference task blocking time bi longest time lower priority task prevent execution task analysed runnable 
blocking time dependent computational model 
idealised preemptive model blocking time zero 
cases exist particularly shared resources blocking may need accounted 
interference task su ers maximum utilisation critical instant higher priority executes rst time 
interference calculated equation 
interference sum duration interest higher priority tasks task utilisation product number times task execute worst case execution time 
number times higher priority task execute rounding result time interference may occur response time task analysed divided period higher priority task 
ii hp hp set higher priority tasks task ri tj cj equation solved forming recurrence equation shown equation 
ci bi hp ci terminates rn orr di 
di deadline task tj cj analysis section derived published independently joseph time dilation algorithm audsley 
worst case response times calculated harter equations liu layland model critical instant tasks execute worst case execution time worst case situation 
audsley shows certain conditions tasks zero set tasks executed preemptively deadlines equal period test su cient necessary 
equations verify system schedulable pseudo polynomial time 
analysis tasks release jitter implementing practical systems ideal timing analysis model section su cient lead optimistic results 
areas model de cient assumes tasks released correct time 
practice tasks may su er release jitter number reasons including imperfect task release mechanisms 
example sporadic task modelled polling periodic task rate release jitter units time 
accounts worst case event arrival just task polled event 
expanded analysis account extra interference caused release jitter modifying equation form equation 
principal di erence equation duration interference occur augmented allow priority tasks released ideal 
ii ri jj cj hp tj jj release jitter task worst case response time ex analysis converges pressed ri ji deadline monotonic priority ordering limitation rate monotonic scheduling fact mechanism dealing criticality 
cause problems tasks long periods need high priority 
burns provides real example satellite telemetry system software transfer data ground station needed day 
execution software tight window opportunity critical system ectiveness 
rate monotonic policy telemetry task lowest possible priority consequently deadline 
solve problem rate monotonic approach requires task shorter period higher priority task meet deadline 
wasted resources may cause tasks deadline 
solution problem criticality deadline monotonic policy task priorities assigned relative deadlines 
highest priority isgiven task shortest deadline 
original deadline monotonic policy published leung whitehead 
deadline monotonic approach analogous rate monotonic approach tasks deadlines equal period 
leung whitehead show deadline monotonic scheduling approach optimal task sets scheduled preemptively tasks sets zero deadline equal period 
deadline monotonic approach problem scheduling telemetry task satellite solved giving task appropriate deadline 
ectively gives task high priority meet deadline having waste resources unnecessarily increasing task period 
restrictions computational model prevent applicable systems 
important lack support sets lesser extent fact deadlines equal period 
timing analysis arbitrary release times practical systems frequently necessary set execution tasks 
sets real systems actual requirements design derived requirements met 
number reasons wish sets system including 
ensuring particular action task performed releasing task 
example task may request data hardware device data may available time milli seconds 
associated task required read data available requires appropriate separation enforced 

spreading processor resource requirements time frame jitter reduced 

ensuring precedence relations maintained allowing task released completed execution 
existing analysis equations may applied sets assigned tasks ignored 
results pessimistic analysis ignores phasing task execution 
performed timing analysis task sets featuring sets 
audsley states main problem analysis task sets feature sets determining worst case release time task critical instant 
equations parameter ected tasks having sets interference 
determine particular task critical instant requires interference known 
challenge derive approximate measure worst case interference computationally complex whilst giving minimal pessimism 
audsley approach inexact analysis provide functions approximate interference su ered task particular point intime 
interference calculated value obtained exact analysis ensures test optimistic 
problem audsley approach interference equations complicated follow may technology transfer di cult 
felt part reason complexity introduced analysis tries general purpose 
practice system considered may relatively uniform nature requirements legacy cyclic scheduling 
derive timing analysis keeps pessimism computational complexity low 
investigation alternative approaches dealing sets dealt chapter 
claim simpli ed form analysis ective analysing task sets type commonly systems 
related need improved timing analysis fact deadline monotonic priority assignment longer optimal sets 
audsley thesis provides optimal approach priority assignment 
approach involves 
performing schedulability analysis 
analysis shows task schedulable swap priority levels highest priority nish 
possible priority orderings exhausted reached return step 
whilst approach optimal relies performing iterations timing analysis considered computationally complex 
timing analysis derived chapter account need practical priority assignment technique 
task attribute assignment additional issue borne characteristics system considered section tasks interact schedule form transactions 
timing analysis priority assignment discussed far consider individual tasks 
ectively ignores potential interactions fundamental correct operation system 
di erent approaches problem uniprocessor task attribute assignment gerber 
task attribute assignment process assigning attributes period set priority deadline tasks timing requirements met 
approach task attribute assignment priority inheritance 
gerber approach gerber hong investigated issue deal transactions 
show careful attention requirements intermediate tasks transaction may lead increased likelihood task set schedulable 
approach heuristic algorithms derive set task attributes meet system requirements 
task attributes calculated stage may feature non zero sets deadlines equal period 
technique referred fourier elimination applied try eliminate sets deadlines equal period 
aim fourier elimination simplify subsequent implementation analysis 
technique whilst powerful di cult understand justify straightforward techniques bene main barrier adoption approach assumes attributes changeable 
ignores fact intermediate tasks may functions outside transaction 
changing period cause problems 
approach approach related previous approach developed 
sets deadlines manipulated heuristic algorithm transaction requirements met 
distinction tasks periods free variables 
approach di erent emphasises need maximise scalability 
context scalability refers ability increase tasks worst case execution times whilst meeting timing requirements 
ability scale system important quality assigning task attributes 
shortcoming technique di cult determine attributes meet requirements 
analysis derived justi es requirements met ability understand requirements met lost 
ability understand requirements met crucial certi cation process justifying correctness 
priority inheritance approach control task precedence di cult exibility altering intermediate task attributes 
solution scheduler control order tasks executed precedence relationships met 
ensure tasks permission execute time 
supervisor function probably kernel control task 
problem rate monotonic scheduling theory ensuring higher priority tasks delayed necessary form part precedence relationship 
lampson redell identi ed known priority inversion problem higher priority task blocked lower priority task due need conform precedence relationship 
rst solution suggested problem priority inversion priority inheritance protocol described rajkumar sha lehoczky 
priority inheritance protocol means lower priority inherit priority higher priority task necessary prevent higher priority task blocked 
analysis section caters cases blocking may exist 
clearly lower priority task inherits higher priority blocking may allowed analysis 
problem priority inheritance protocol semaphore software synchronisation deadlocks may occur 
example suppose time job locks semaphore enters critical section 
time job attempts nested access lock semaphore 
job higher priority job ready time 
job preempts locks semaphore 
job tries lock semaphore deadlock formed 
number solutions suggested problem deadlocks priority inheritance protocol 
common solution priority ceiling protocol sha rajkumar lehoczky 
priority ceiling protocol allows task enter critical region complete critical region lock necessary semaphores 
priority ceiling protocol allows executing task blocking higher priority task inherit priority higher priority task 
ceiling priority highest priority task lock particular semaphore 
problem priority ceiling protocol task blocked lower priority tasks complete execution lower priority locks necessary semaphores 
situation lead tasks su ering blocking deadlines missed 
tasks su er lot blocking due priority raised number stages resource contentions identi ed 
time contention identi ed priority raised overheads incurred 
rajkumar sha lehoczky developed semaphore control protocol help minimise amount blocking occur system avoiding deadlocks 
protocol task locked semaphore task priority immediately raised ceiling priority 
ceiling priority highest priority tasks lock semaphore 
semaphore control protocol reduces blocking preventing tasks unnecessarily interfering task locked semaphore immediately inheriting ceiling priority prevented 
timing analysis simpli ed assume priorities priority ceiling priority 
timing analysis performed worst case 
worst case tasks considered inherit maximum priority 
drawback semaphore control protocol potential signi cant pessimism timing analysis 
problems approaches ceiling protocols additional complexity introduced kernel making design certi cation di cult timing analysis pessimistic extra functionality causes overheads run time 
chapter proposes technique task attribute assignment caters transactions ective understandable manner added bene complexity taken line 
technique examines correct manipulation deadlines leads task interaction correctly controlled 
timing analysis tasks arbitrary deadlines analysis addressed need timing analysis tasks arbitrary deadlines tasks deadlines greater period 
issue analysis expanded multiple instances task queued time 
standard schedulability analysis shown equations expanded shown equations 
equation converges wn wi 
solution ti 
condition relates situation instance task considered waiting executed 
ri maxq wi ci bi hp jj tj cj particular instantiation task range 
wi case response time qth instance task iteration calculation 
equations iterate instances particular task takes latest instance task converge worst case response time equal task period 
analysis stopped task response time exceeds deadline 
considering particular instance response time calculated iteratively 
response time greater equal task period instance task released 
earlier instance task executed rst 
latest instance task completing instance released means instances task remain run queue 
actual worst case response time maximum response time task instances convergence achieved 
analysing kernel overheads analysis far assumed ideal system kernel overheads associated task release 
section survey kernel overheads analysed drawing principal 
irrespective task release mechanism employed cost associated context switches task 
independent times task preempted task su ers context switches task task 
reason context switches associated preemption analysed part task causing preemption task su ering preemption 
equation presents analysis context switches 
analysis basically increases task worst case execution time allow context switches 
equation simpli ed version assumes cost context switch tasks 
ci cs cs ci actual worst case execution time task modi ed worst case execution time task allowing context switches cs worst case execution time context switch task cs worst case execution time context switch task ci cs cs worst case execution time context switch task 
commonly adopted way releasing tasks regular clock tick 
clock tick arrives tasks waiting released released highest priority task executed 
tasks released clock tick cost modelled 
basic variants modelling single task multiple tasks 

single task single task model clock tick 
single task period clock tick worst case execution time encapsulates time taken update run queues 
task update run queue highest priority system preempted su ers blocking 
worst case time update run queues tasks released time 
principal problem single task approach clearly pessimistic tasks released clock tick 
results improved equation taken provide pessimistic estimate worst case time update run queues 
equation allows relationship tick period minimum period set tasks 
represents number tasks system tmin shortest period tasks tclk period clock tick cost releasing rst task cost releasing subsequent tasks tmin tclk 
multiple tasks task system additional task model updating run queue 
additional task iteration rate actual task worst case execution time equivalent worst case overheads obtained analysis release particular task 
tasks released value real time clock time driven manner 
pre de ned points task execution task executing run queue updated highest priority task executed 
time driven model analysed task having worst case execution time augmented amount worst case time determine task runnable release 
practice constant 
typically task information stored priority order tasks searched determine highest priority runnable task 
expressed shown equation 
frequently implementation optimised cut search time leading execution time equation pessimistic 
example tasks released current highest priority runnable task executed search optimised 
starting highest priority task search start highest priority task task just executing 
equation represents worst case 
nished pi worst case time release task worst case time determine task isn runnable pi priority range highest 
reasons simplicity taken constant analysis complicated 
value chosen value lowest priority task largest value 
resultant worst case execution task task released time driven approach equation 
ci case study attitude orbital control system attempts put xed practice real industrial systems 
section looks case study attitude orbital control system 
satellite launched july world largest powerful civil axis stabilised communications satellite 
sub system exists acquire maintain desired spacecraft position orientation 
case study commissioned investigate technical issues bene ts xed priority scheduling ground demonstrator 
case study normal mode system complex mode greatest percentage satellite lifetime 
application selected contains typical features real time software 
periodic tasks 
sporadic tasks 
hard real time tasks 
soft real time tasks 
background tasks 
communications feature real time software part case study transactions considered signi cant exclusion 
comparative testing original satellite equipment yielded 
signi cant di erence quality 
systems judged equivalent signal responses noise magnitudes functional area 
study highlight disadvantages technique lead increased cost 

overheads increased run time support system support ada tasking 
need invest support tools training achieve maximum bene ts approach 
addition papers case study consider issues reuse certi cation proposing solution 
issues considered fundamental solution accepted 
case study suggests fact positive bene ts far outweigh disadvantages 
include 
sound engineering approach mathematical basis provides exact results reduced ort 
exible run time scheduling allows changes application structure costly re development cyclic scheduler 
tool support enables techniques engineers academic theoreticians 
fixed priority scheduling distributed systems purpose section survey existing literature available xed priority scheduling timing analysis distributed systems 
techniques utilising existing uniprocessor timing analysis particular interest 
reasons 
may great deal time money ort invested existing theory tools 
bene cial allow tools reused 

treating processor individually eases synthesis maintenance ort facilitating modular approach design 
release jitter approach distributed scheduling early event driven model scheduling distributed systems performed clark 
approach uses periodic tasks rst task transaction 
subsequent tasks messages triggered sporadic tasks preceding task completed 
purpose timing analysis sporadic tasks modelled periodic tasks period equal minimum inter arrival time 
account variability sporadic task release task release jitter equal worst case response time preceding task 
noted case consecutive tasks transaction execute processor di erent 
case tasks released simultaneously priorities control ordering task execution releasing task earlier task completed executing 
release jitter approach system timing properties may accounted uniprocessor level 
subsequent tasks messages processor processor processor processor messages time key represents time execution may occur best case release time deadline diagram illustrate timing analysis modelled periodic tasks characteristics period transaction period release jitter worst case response time previous task message transaction relationship release jitter completion time illustrated 
shows particular transaction messages released tasks tasks released messages 
example task released worst case arrival time message 
release jitter task equal worst case arrival time message 
equation helps show release jitter accounts distributed transactions 
jt rt refers tth task message transaction rt worst case response time task start transaction 
equations provide analysis caters release jitter 
transaction deadline requirement ed considering worst case response time task transaction 
worst case response time equal deadline transaction requirement met 
uniprocessor schedulability analysis section verify system timing requirements 
clark show timing analysis arbitrary deadlines equations may cases transaction deadline greater tasks form transaction periods 
approach modi es tasks form transaction deadlines equal transaction deadline 
verifying tasks deadlines equations met veri es transaction deadline 
harbour garcia demonstrate approach pessimistic 
task release jitter greater period multiple task instances assumed arbitrary deadline timing analysis section 
practice multiple task instances exist tasks deadlines equal period 
harbour approach maintain original task deadlines 
veri cation transactions dealt separately schedulability analysis tasks 
harbour approach requires relevant instance task respect transaction determined response time transaction calculated 
relevant instance chosen release time greater equal worst case response time preceding task transaction 
advantage harbour approach analysis pessimistic 
disadvantage extra analysis required verifying transaction requirements met 
veri cation transactions automated analysis understandable 
harbour approach viable technique 
advantage release jitter approach existing uniprocessor analysis may 
principal disadvantages release jitter approach 
sporadic tasks safety critical systems due inherent di culty analysing operation ect task release arbitrary points time ect omission commission failures release mechanism 

sporadic tasks additional problem implementing distributed transactions 
computational model means tasks transaction order release jitter 
output jitter transaction frequently important 
output jitter equal variation time output transaction 
taken variation completion time task transaction 
variation task completion time greater equal task release jitter 
approach described section considered prohibitive applications 

pessimism associated approach considered prohibitive 
release jitter increases number tasks transaction reaches stage system 

release jitter approach robust change 
small changes processor easily lead system requiring re veri cation 
set approach distributed scheduling alternative approach distributed timing analysis exact analysis approach leung whitehead discussed section 
context distributed systems exact analysis rst phase modi cation protocol sun liu 
approach serves ideal way assessing ectiveness approach developed 
exact form analysis takes approach showing individual release task processors messages schedulable 
phase modi cation protocol approach provides implementation veri cation advantages release jitter approach 
phase modi cation protocol approach uses periodic tasks implementation 
precedence constraints transactions enforced sets giving task message set equivalent worst case response time predecessor 
drawback set approach implementation requires global time base 
additional bene approach correct phasing tasks removes need protocols priority ceiling protocol 
appropriate phasing tasks prevents tasks trying access resource time 
resource contention avoided priority inheritance needed 
obvious disadvantage maintenance appropriate phasing di cult reason cyclic scheduling discussed section 
time task message may execute controlled 
example case task duration allowed execution commences message de nitely arrived ot rm 
message scheduled task completed om rt 
giving task set dispatch release simplicity greater worst case response time event trigger case task worst case arrival time message precedence maintained distributed system 
equation shows phase modi cation protocol accounts distributed transactions 
ot rt ot set task critical instant phase modi cation protocol adopts approach release jitter caused variable release times sporadic tasks removed 
drawbacks associated phase modi cation protocol 
firstly new analysis required may di cult understand may high computational complexity 
realistic systems analysis intractable due common multiple periods large particularly tasks periods primes 
secondly design veri cation system timing aspects robust change change task worst case response time leads system wide change 
simple change functionality related processor may lead changes task attributes system complete re analysis 
task attribute systems number approaches proposed problem task attribute assignment distributed systems 
aim techniques assign task attributes heuristic methods results timing analysis 
problem basing task attributes results timing analysis lack robustness change 
rst papers deals issue task attribute assignment distributed systems produced liu 
deals scheduling distributed systems ow shop scheduling 
flow shop scheduling tasks executed rst come rst served basis 
demonstrates assigning local deadlines evenly tasks transaction practical technique meeting timing requirements whilst minimising ect change 
approach states transaction deadline task assigned non overlapping window number tasks transaction 
third task transaction set deadline approach simplifying assumption tasks identical worst case execution times 
assumption true approach optimal 
clearly assumption realistic 
stankovic produced approach called time slicing intended xed priority scheduling simplifying assumption 
uniformly sharing available time tasks transaction time slicing approach shares time task laxity 
case laxity di erence task execution time deadline 
aim technique increase chance schedulability increase resilience change 
stankovic shows technique optimal sense laxity ofeach task maximised 
shin demonstrates time slicing ective size execution time slices chosen adaptive manner 
shin uses heuristic approach tasks computation time 
approach leads increase likelihood schedulability acceptable increase computational complexity 
alternative approach proposed harbour garcia 
number iterations task attribute assignment schedulability analysis order derive set task attributes 
initially task attributes assigned local processor level 
schedulability analysis performed determine requirements met 
task attributes changed heuristic deadline missed 
greater amount time deadline missed task deadline increased task set re analysed 
harbour approach provides simple approach choosing task attributes drawback solution take long time compute 
great deal performed search algorithms annealing genetic algorithms 
approaches provide solutions scheduling problem 
drawbacks search algorithms searches take long time complete results hard justify explain clear reason results 
problem techniques system changed complete re synthesis necessary 
necessitates complete re veri cation cost regression testing great practical purposes 
chapter examines problems distributed timing analysis greater depth improved timing analysis derived 
signi cant amounts simulation purpose 
approach derived sets control precedence 
approach timing analysis chapter 
time triggered architecture section discusses performed university vienna time triggered architecture 
purpose build understanding addressed needs safety critical systems 
mars kernel considered appropriate published approach safety critical systems 
reason mars project viewed superior projects speci cally targeted safety critical systems domain 
approaches compromises dependability performance obtain general purpose architecture 
mars paid great deal attention providing complete picture including fault tolerance dependability timing analysis tool support 
issues important safety critical systems 
date mars considered relevant thesis 
time triggered architecture tta evolved mars kernel project advantage lessons learnt 
section brie reviews projects 
tta project intended complete process system solution problems designing embedded distributed systems safety critical systems market 
best source information tta kopetz 
mars kernel developed years intention developing infrastructure meet system requirements including certi cation methodical tool assisted manner 
basic architecture tta system split number clusters 
cluster autonomous responsibility set system requirements 
particular cluster system hard real time requirements 
data ow clusters hard real time 
principal interest scheduling timing analysis cluster 
task scheduling performed cyclic scheduling technique message scheduling time division multiple access tdma technique 
tdma sequence slots executed repeatedly 
slot known size occurs pre de ned time 
single message assigned slot 
cyclic scheduling tdma considered similar 
prevent criticism related synthesis maintenance cyclic scheduling discussed section tool support available 
unfortunately tool allow need minimise amount regression testing change control problem tool support schedule synthesis 
major part mars design ensuring kernel system operates reliably 
system level components redundant components 
processing nodes handle redundancy nodes transmitting outputs node remaining silent 
silent node detects error nodes stops silent 
errant node provide error containment hardware inhibit connection communications bus 
technique relies trusted voter identify faults 
voter means comparing similar values produced di erent sources determine error occurred 
ensure communications data su ciently reliable data communicated twice network 
reason probability items corrupted considerably probability node failing 
performing reliability calculations ect node failure ignored calculations concentrate data corruption analysis exists 
addition mars kernel adopts communications protocol referred membership service determining processing nodes failed 
distributed system membership set may change time active node departs membership set node failure inactive node may join node previously failed may recovered repaired 
aim protocol guarantee time interval active node consistent knowledge membership set 
viewpoint mars tta relevant safety critical system completeness solution 
detailed design important dependability issues fault tolerant clock synchronisation timely membership service recon guration management provision fail silence temporal domain performed 
completeness raises con dence approach taken 
principal problem time triggered architecture cyclic scheduler 
integrated modular avionics integrated modular avionics ima initiative isan attempt solve problems currently faced systems 
problems include obsolescence caused components going production lifetime system large size systems necessitating design split manageable independent parts ima system architectures considered provide modularity technology transparency order solve problems 
modularity architecture provides facilities control di erent partitions software communicate de ned interfaces 
main aims modularity allow di erent parts software written isolation integrated ease ease problems change reducing scope change allow di erent integrity levels software exist safely processor 
objective technology transparency allow processor software executing changed minimal rework 
toachieve technology transparency portable code required java byte code execute similar manner wide range platforms 
aim technology transparency prevent obsolescence 
fletcher recognises ima provides signi cant number technical certi cation challenges 
akey challenge scheduling timing analysis nature maximum reuse system certi cation evidence occurs underlying platform changed 
audsley proposed solution reservation scheduling may provide solution 
short term xed seen candidate 
little likelihood cyclic scheduling supporting technology transparency low robustness change 
summary chapter surveyed existing xed priority scheduling uniprocessor distributed systems 
chapter looked time triggered architecture currently considered state art safety critical systems 
survey investigated uences ima may uence scheduling approaches derived 
survey highlighted number problems current approaches necessitate change cyclic scheduling inhibit traditional form xed 
chapters far give indication xed priority scheduling modi cations suitable safety critical systems domain 
remainder thesis assess xed priority scheduling may justify claim appropriate technique 
chapter transition cyclic executive scheduling fixed priority scheduling basic aims chapter 
section investigates xed priority scheduling represents solution problems cyclic scheduling highlighted section 
section considers problems xed priority scheduling example case study section locke solved 

section examines xed priority scheduling technique may replace cyclic scheduler existing system 
implications changes standard xed priority scheduling model considered 

section highlights remaining required xed priority scheduling form complete solution 
fixed priority scheduling solution problems cyclic scheduling 
section number problems cyclic scheduling raised maintainability cient resources supporting requirements 
problems cyclic scheduling derived issues raised contact industry 
locke describes weaknesses cyclic scheduling identi es xed priority scheduling technique smallest technological leap capable solving problems cyclic scheduling 
locke view xed priority scheduling natural progression cyclic scheduling commonly supported belief 
supporting locke viewpoint stankovic burns audsley 
claim xed priority scheduling solve problems cyclic scheduling 
justify claim problems cyclic scheduling considered turn examine xed priority scheduling may provide desired solution 
cient resources section describes basic reasons limited iteration rates lack sporadic tasks waste resource cycle cyclic scheduler considered resources ine ciently 
reasons related restricted computational model 
xed priority scheduler problems computational model limited cyclic arrangement non static schedule 
fact schedule arranged cyclic structure removes need reserve time cycle wasted resource 
time processing resource unused xed priority scheduling run queue empty 
lack cyclic structure non static ordering means periodic tasks iteration rate 
non static ordering allows sporadic tasks implemented 
increased exibility model means actual requirements may implemented imposed scheduler 
leads cient resources possibility system performs better 
maintainability section highlights maintenance problem cyclic scheduler arises need support task transaction requirements leads di cult synthesis change control problem 
principal reasons xed priority scheduling easier maintain cyclic scheduling ease synthesis robustness change ease veri cation reduced regression testing 
ease synthesis xed priority scheduler easier synthesise cyclic schedule 
garey johnson show bin packing problem cyclic executive scheduler np complete 
leung whitehead shows problem synthesising xed priority schedulers pseudo complex 
xed priority scheduler easier synthesise cyclic scheduler synthesising priorities simply matter assigning place order 
cyclic scheduler task assigned number places dependent task iteration rate minor cycle rate number minor cycles dependent minor major cycle rates having order tasks individual minor cycle 
robustness change xed priority scheduler robust change cyclic scheduler 
reason xed priority scheduler matters timing requirements met 
change scheduler necessary requirements longer met 
cyclic scheduler timing requirements met 
task worst case execution time may lead minor cycle owing necessitates schedule changed 
extra condition means changes schedule occurs particularly heavily loaded system 
addition xed priority scheduler failure meet deadline solved simply swapping adjacent priorities 
cyclic schedule completely re synthesised 
xed priority scheduler easier change cyclic scheduler 
ease veri cation veri cation xed tends take ort cyclic scheduler 
reason xed priority scheduler veri ed analysis cyclic scheduler veri ed test 
test veri cation static run time ordering important behaviour deterministic 
analysis performed automatically short amount time minimum amount ort 
test considered expensive activity analysis 
reduced regression testing related previous point xed priority scheduler veri cation system dependent static run time ordering 
xed priority scheduler changes need repeat functional testing system 
cyclic scheduler changed system data ow changed 
ort required perform regression testing functional requirements considerably increased 
supporting requirements system section describes cyclic scheduler prohibit systems need developed 
consideration ima systems section provides example cyclic scheduler inappropriate 
fact xed priority scheduler computation model restricted cyclic scheduler appropriate types system needed 
important part claim related fact systems de centralised nature 
de system maintenance signi cantly complex eventually leading cyclic scheduler practically infeasible 
problem maintaining set minor cycles single processor meet task transaction requirements di cult 
processors communications bus connecting complexity greater 
reason schedules including interact meet distributed transactions 
change processor cause system schedules need re synthesis 
system scheduled support transactions 
move ima type systems involving multi projects means important partition systems engineering problem includes scheduler 
reason xed priority scheduler suitable systems computational model restrictions design means system better placed support needs 
restrictions probably arise di culty certifying general computational model 
restrictions traded needs system 
solving problems fixed priority scheduling xed priority scheduling capable removing problems cyclic scheduling achieved widespread adoption 
reason fact cyclic scheduling advantages xed priority scheduling 
locke highlights disadvantages xed priority scheduling frequently reliant ada tasking model characteristics di cult predict kernel overheads tend larger 
main disadvantage xed priority scheduling safety critical systems domain sceptical resistant change current practice 
tasking model locke states implementation ada tasking model hard predict 
reason originally highlighted sha goodenough state ada tasking model requires priorities speci ed entry rendezvous queue exercised fifo order 
rendezvous means achieving synchronous communication receiver acknowledging ready receive message correct recipient 
whilst argued scheduling model predictable computer rmware logic fifo harder analyse synthesise schedule cyclic scheduling 
disadvantage tasking model di cult predict simply overcome engineers implementing scheduler 
locke observations respect ada version ada language 
di culties associated tasking model ada may avoided ada version language standard includes revised tasking model support important scheduling paradigms 
include priority inheritance implemented priority ceiling protocols 
despite change spark subset ada precludes tasking models 
equally strong uence desire minimum changes deemed necessary spark version ada 
alternative safe subset ada proposed iso wg includes 
despite updated tasking model ada schedulers preferred 
main reason tasking model may implementation may complex particular application part compiler 
ectively cots software product system 
number reasons commercial shelf cots product considered appropriate safety critical systems 
main reasons product rarely designed domain trusted cost ective re engineer product appropriate standard 
product carry lot baggage functionality needed 
increases kernel overheads certi cation ort 
point criticism higher kernel overheads xed priority scheduling apparent 
reasons discussed section assume scheduler produced 
part reason decision cyclic schedulers normally implemented manner 
likelihood changes necessary software tasks reduced 
addition investigate best support tasking model perspective infrastructure 
kernel overheads overheads incurred xed cyclic scheduler generally increased 
reason cyclic scheduler execute tasks de ned order 
xed priority scheduler great deal functionality including releasing tasks determining tasks runnable searching highest priority runnable task dispatched 
alleviate problems kernel overheads issues addressed 
rst issue designed bearing mind criteria particular reuse criterion successful technology transfer de ned section need minimise overheads 
reuse criterion important existing hardware software including applications new infrastructure minimal amount rework 
ability system timing requirements forgotten 
second issue pessimism analysis overheads reduced 
fundamental part transition cyclic scheduler xed priority scheduler development kernel certi ed 
main design aims kernel ability reuse existing hardware architecture allow system timing requirements met having reasonable overheads having responsive infrastructure 
overheads appropriate scheduling policy handicapped overheads large tasks 
responsive infrastructure releases tasks su cient time deadlines met 
xed assumes ideal computational model overheads failures 
need investigate best implement analyse kernel 
chapter investigate issues related kernel 
predictability versus determinism key di erences cyclic scheduler xed cyclic scheduler deterministic xed priority scheduler predictable 
di erence cyclic scheduler static task ordering xed priority scheduler dynamic task ordering 
causes signi cant impact area veri cation 
consequence xed rely analysis cyclic scheduler rely test analysis 
positive aspect change analysis provides accurate better results 
problems change type certi cation evidence provided major step needs justifying change increases number paths performing functional testing 
approach derived xed priority scheduler address problems signi cant attention needs paid justifying change safe 
fixed priority scheduling support domain application requirements 
purpose section examine xed priority scheduling system currently uses cyclic scheduler 
parts discussion 
establishing task execution model 
determining deadline monotonic priority ordering dmpo optimal execution model 
establishing appropriate task release model 
tailoring timing analysis computational model 
determining dmpo optimal computational model 
dealt sub sections 
choice execution model scheduling texts generally assume xed priority scheduling policy implemented preemptive support provided periodic sporadic tasks 
timing analysis widely available forms general model 
chapter provides survey xed priority scheduling including 
ways veri cation timing characteristics relatively small job compared verifying functional properties 
wider implications actual scheduling model considered section 
computational model cyclic scheduler non preemptive ow control 
non preemptive scheduling task executed completion 
principal di erence preemptive non preemptive scheduling task execution preempted time release higher priority task 
leads greatly increased number possible program paths means functional testing di cult fully achieve 
importantly data ows updates interrupted causing task preempted data calculation partly nished 
data transient state ect di cult determine 
transient state issue solved preemptive scheme de ning critical sections code preventing preemption execution enters critical sections 
application scheduler software complex 
transition non preemptive preemptive system requires existing software design implementation thoroughly examined determine problems occur 
software modi ed re implemented solve problems 
additional advantage having non preemptive scheduler longer need preserve context task execution suspended nishes 
real bene preemptive scheduling obtained completely new design chance re allocate functionality tasks 
instance section highlights non preemptive execution software cyclic scheduling framework leads software broken small parts 
re allocating functionality natural decomposition functionality code obtained leading improved maintainability 
potential problem strategy reuse criterion successful technology transfer introduced section broken 
additional barrier overcome culture industry ally uses test veri cation 
despite fact xed priority scheduling provides analysis quicker ective desire test systems 
particular concern need test system functional perspective 
part reason cyclic scheduler currently static ordering tasks means system deterministic 
preemptive scheduler clearly signi cant increase potential number program paths making complete path coverage 
making testing problem di cult reduces likelihood successful technology transfer 
section discusses certi cation authorities reluctant allow increased certi cation ort results 
non preemptive scheduling advocated 
terms timing analysis principal di erence preemptive non preemptive scheduling degree blocking su ered 
blocking time caused lower priority tasks non preemptive model expressed equation 
equation represents maximum worst case execution time set tasks lower priorities task comparison blocking times preemptive scheduling tend lower 
bi maxk lp ck lp set lower priority tasks task equation iteratively calculating task worst case response times non preemptive scheduling model represented equation 
ci maxk lp ck rn cj hp tj ci maxk lp ck terminates rn orr di 
di deadline task optimality deadline monotonic priority ordering non preemptive scheduling leung whitehead shows dmpo approach optimal preemptive computational model conditions tasks zero sets deadlines equal period 
dmpo optimal restricted computational model non preemptive scheduling 
theorem 
dmpo optimal non preemptive scheduling 
proof dmpo optimal task set schedulable priority scheme schedulable dmpo 
proof optimality dmpo involves transforming priorities assigned ordering dmpo 
step transformation schedulability 
tasks adjacent priorities pi pj di dj 
pi priority 
de ne scheme identical tasks swapped 
consider conditions schedulability reason italics condition met 
tasks priorities greater pi una ected changes lower priority tasks 
non preemptive scheduling model ful lls constraint ect schedulability related lower priority tasks 

tasks priorities lower pj una ected experience interference tasks irrespective priority order 
set tasks priorities task remains unchanged impact remains bi maxk lp ck 
condition holds 
proof adapted proof burns wellings dealt preemptive form xed priority scheduling 

task schedulable higher priority means su ers interference 
condition true non preemptive computational model higher priority tasks ected swapping tasks priorities 
blocking time task bj greatly increased value ci large 
increase blocking time bj decrease interference ij task executed 
left need show task priority lowered schedulable 
stated rj dj dj di di ti 
task interferes execution tasks priorities switched new response time task equal old response time task orderings cj ci true priority amount computation time completed level interference higher priority tasks 
task released rj interferes execution task 
follows rj dj di concluded task schedulable change priorities 
priority scheme transformed choosing tasks wrong order dmpo switching 
task switch preserves schedulability 
eventually tasks switch ordering exactly dmpo task set schedulable 
dmpo optimal general non preemptive scheduling model 
choice task release model section states general xed priority scheduling model assumes sporadic tasks exist periodic tasks 
similar reasons choice nonpreemptive control ow computational model primarily considered featuring periodic tasks 
sporadic tasks excluded timing analysis hard subsequent functional veri cation di cult tasks release time unpredictable 
equally applicable computational model sporadic tasks 
applicable explicit statement 
improved blocking model drawback non preemptive scheduling model preemptive model tasks tend su er greater blocking 
systems blocking time prohibitive especially considered lower priority tasks computationally intensive 
investigation performed section aim reducing pessimism 
discussion contained section purely related computational model features just periodic tasks 
section stated computational model consist entirely periodic tasks 
sporadic tasks part task set equations blocking contained equation 
stated tasks 
common critical instance tasks set harmonic iteration rates 
worst case response time lower priority task equal period higher priority task blocking 
help illustrate blocking doesn occur case 
presents worst case response time tasks task update rate zero set task update rate zero set 
shows second release task task blocked blocked task reason task completed task re released 
shaded boxes represents worst case response time particular task release 
due fact systems evolved systems previously cyclic scheduler large number tasks harmonic iteration rates 
revised blocking model expressed equation 
bi max ck clock cycle tasks set tasks cause blocking satisfy conditions 
task priority 
task non identical release time task case response time greater period task formal representation equation represented equation 
representation included completeness 
lp nj tk ti ok oi rk ti task task time task execute key best case release point worst case response time illustration blocking model pessimism allow improved blocking model proven correct necessary show su cient test 
theorem 
lower priority task block task lower priority task released time instance task completes instance task proof lower priority task task cause blocking executing task task analysed released 
case blocking avoided execution tasks overlaps 
guaranteed task released time task period task integer multiple period task task period 
condition represented equation 
ti ti ok oi task cause blocking able execute task released condition equation true 
rk ti blocking occur condition equation hold 
rk ti blocking occur conditions equation arise 
usual expression bi max ck equation uses term bi max ck 
observation 
blocking time clock cycle worst case execution time task causing blocking 
argument reason blocking time clock cycle worst case execution time task illustrated 
shows blocking interference occur task started executing 
stated clock cycle task occurred 
clock cycle task contribute blocking su ered task task simultaneous released task task task execution clock cycle clock cycle period preempted non preemptive scheduling model point considered interference may occur non preemptive scheduling model point considered interference may occur preemptive scheduling analysis model task executions illustrate edge ect completes task re released 
tasks execute shorter time blocking occur 
blocking model equation correct 
noted computational model feature sets simpli ed version equation equation 
lp nj tk ti rk ti table illustrates example improved blocking model increases chance schedulability 
table column results schedulability analysis old blocking model whilst column rnew new blocking model 
table clearly shows worst case response time tasks reduced new approach 
id bold bnew rnew table schedulability results improved blocking model columns table represents id identi er task period task worst case execution time task deadline task priority bold blocking time calculated equation bnew blocking time calculated equation worst case response time calculated value bold rnew worst case response time calculated value bnew improved interference model schedulability analysis section area pessimism introduced interference model 
purpose section investigate pessimism arises may reduced 
interference term equation maximum amount time higher priority tasks execute task analysed 
interference calculated equation 
interference sum duration interest tasks higher priority task utilisation product number times task execute worst case execution time 
number times higher priority task execute rounding result time interference may occur response time task analysed divided period higher priority task 
interference calculated equation 
hp max 
executions cj max 
executions worst case response period ri tj ii hp ri tj cj hp set higher priority tasks task equation clearly pessimistic numerator interference term assumes preemptive model 
non preemptive model higher priority task commence execution lower priority task begun executing 
higher priority task wait lower priority task complete 
maximum number executions task improved shown equation 
equation numerator reduced worst case execution time task whichis task interference calculated 
prevent edge ects task released simultaneously dispatched clock cycle added prevent anomalies 
max 
executions ri ci tj help illustrate impact edge ects 
boxes represent worst case response time task 
consider time indicated vertical dotted line 
shows higher priority task task released lower priority task task highest priority runnable task 
task highest priority runnable task virtue previous highest priority task task completing execution 
term equation task released 
practice task released 
results optimistic 
term correct worst case execution sequence maintained analysis su cient form timing analysis 
term discussed improved blocking model 
increasing priority task task task time task executions illustrate edge ect revised interference equation equation 
reduced value numerator signi cant means instances higher priority released 
ri ci tj hp cj optimality deadline monotonic priority ordering restricted computational model section shows dmpo optimal unrestricted computational model non preemptive scheduling 
computational model restricted having periodic tasks 
resulted changes analysis 
optimality dmpo needs re assessed conditions 
change computational model associated analysis means set tasks cause blocking dependent tasks response times 
change priorities cause blocking 
example demonstrates dmpo optimal computational model 
consider schedulability task set illustrated table tasks table ordered dmpo tasks table id met 
table schedulability results dmpo id met 
table schedulability results dmpo alternative ordering 
columns meaning table column met 
represents task schedulable 
table shows blocking caused task dmpo leads solution 
table shows priorities tasks swapped task set schedulable 
dmpo sub optimal purely periodic non preemptive computational model 
optimal task set includes sporadic tasks 
noted table blocking time task smaller units value calculated equation 
reason originates performing exact analysis task set refer section details 
worst case response tasks duration common multiple task periods priority orderings tables illustrated figures respectively 
seen latest time task dispatched clock cycles task released second time 
blocking term calculated ck calculated ck leads improvement equation 
equation accounts reduced impact task nature worst case dispatch time 
bi max ck tij time increasing priority tasks deadline missed common multiple tasks periods worst case task execution deadline monotonic priority ordering time increasing priority tasks common multiple tasks periods worst case task execution priority ordering support criteria technology transfer equations necessary task set requirements met original equation easier understand 
remains fixed priority scheduling complete solution having considered contents chapters chapter immediately apparent current theory adequately support system timing requirements 
section raises principal issues need provide support xed priority scheduling infrastructure need assign attributes tasks 
infrastructure support fixed priority scheduling issue considered xed priority scheduler interacts infrastructure system 
main parts infrastructure interest scheduling mechanism timing overrun detection mechanism 
chapter investigate xed priority scheduler may interact existing infrastructure left cyclic scheduling application 
part derive ective timing analysis 
solution derived consider criteria successful technology transfer particularly reuse criterion 
need task attribute assignment current scheduling assumes task speci ed period deadline enables system timing requirements met 
practice key roles system designer calculate deadlines need order meet system timing requirements 
particular cyclic scheduler deadlines xed priority scheduling relies deadlines purposes analysis synthesis 
task deadlines need de ned 
academic texts assume task attributes known simply setting task deadline equal period su cient 
allow needs transactions tasks jitter requirements 
priority inheritance proposed solution needing transactions 
chapter explains priority inheritance ideal technique solving problem 
challenge assign task attributes timing requirements section met 
chapter investigates system timing requirements met infrastructure proposed chapter deadline monotonic priority ordering 
perceived disadvantage xed priority scheduling lack determinism 
certi cation purposes useful developer able easily justify requirements met 
approach derived support need 
summary chapter achieved aims 

xed solve problems cyclic scheduler 
problems xed priority scheduler mitigated 
ective move cyclic scheduling achieved 
necessary support domain application 
chapter provided improvements standard schedulability analysis taken section restricted computational model 
restricted computational model tasks periodic executed non preemptively 
technique compares favourably criteria successful technology transfer 

certi cation approach provides analysis guarantees system timing behaviour 
results analysis part certi cation evidence system 

reuse advantage proposed non preemptive approach high level reuse orded 
changes software limited scheduler module need change application software 

understanding satisfaction criterion demonstrated fact approach technology transferred industry successfully applied 
evidence case study chapter 
su ciency approach facilitates better support exible computational model cyclic scheduler 
su ciency criterion satis ed 
chapter identi ed areas support uniprocessor solution scheduler 
modify infrastructure left cyclic scheduler system xed priority scheduler including appropriate timing analysis dealt chapter 
attributes timing requirements met dealt chapter 
chapter infrastructure choice associated timing analysis chapter presents investigation existing infrastructure left cyclic scheduler may utilised transition xed priority scheduling resultant overheads analysed 
starting position considering transition model cyclic scheduler discussed section 
deciding changes infrastructure criteria de ned section certi cation su ciency understanding reuse successful technology transfer considered 
aim cause minimum possible change way system operates whilst harnessing advantages xed priority scheduling 
chapter split parts task release mechanism implemented section timing overruns detected section 
parts basically de ne scheduler 
part key rst parts analysing overheads scheduler 
analysis scheduler overheads area received little attention 
majority academic assumes ideal mechanism handling tasks highest priority task executed overheads zero faults occur 
implementing analysing task release mechanism purpose task release mechanism release tasks ective manner allows timing requirements met 
section investigates best release tasks 
criteria considered need reuse system cyclic scheduler applications possible need keep kernel overheads low need responsive system 
criteria derived su ciency criterion section 
tick driven task release section states cyclic scheduler model regular clock tick triggers sequence tasks corresponding particular minor cycle 
xed priority scheduler implemented available clock tick resulting virtually change system operation 
time clock tick occurred decision taken tasks released 
ticks runnable tasks dispatched priority order 
non preemptive scheduler clock tick occurs task executing interrupted allow run queue updated 
case updating run queue nished interrupted task resumed 
section literature survey explains clock tick may accounted analysis 
approaches single task multiple tasks 
trade simplicity pessimism single multiple task approaches 
multiple task approach ers greater accuracy respect response times 
multiple task approach requires information obtained 
noted key points chapter independent way overheads due clock tick modelled 
problem tick driven approach tasks released harmonic rate clock tick su er release jitter 
tasks release jitter great period clock tick task due release instant current clock tick 
audsley states periodic task release jitter equation 
equations section shows release jitter accounted schedulability analysis 
ji tclk gcd tclk ti gcd greatest common divisor tclk clock tick rate release jitter great task iteration rates clock tick rate may altered task deadlines met 
signi cant problem cyclic scheduling caused exibility computational model having change task rates suit infrastructure 
option altering task iteration rates release jitter reduced ectively constrains task iteration rates harmonics clock tick rate 
strategy adopted bene ts xed priority scheduling ectively lost 
alternative changing clock tick period 
eliminate ects release jitter need term gcd tclk ti equation equal tclk tasks task set 
condition equation satis ed 
tasks gcd ti tclk tclk problem altering clock tick period period dependent tasks periods 
clock tick period prone change quite small 
consequence tclk small overheads system signi cantly increased 
equation gives overheads caused clock tick mechanism 
equation equation 
represents worst case execution time function performing tick driven release mechanism multiplied thenumber times performed duration interest common multiple tasks periods 
value tclk chosen minimum value overhead obtained 
lcm tj tclk utilisation due overhead clock tick cost releasing rst task cost releasing subsequent tasks task set tasks executed tclk clock constrained condition equation tasks task set period integer multiple clock tick rate number tasks task set lcm tj common multiple periods tasks task set observation 
best value clock tick period minimising utilisation clock overheads 
argument solving equation provides value tclk utilisation clock overheads minimised time tasks take repeat common multiple clock periods 
reducing utilisation overheads minimum considered best solution optimal 
reason optimal particular phasing tasks mean minimal overheads needed particular time frame general 
time driven release alternative approach releasing tasks time driven approach 
time driven approach releases tasks dependent real time clock regular clock tick 
task nishes executing clock read allow run queue updated tasks released 
highest priority task dispatched 
discussion time driven release mechanism analysis refer section literature survey 
section compares tick driven time driven approaches 
comparison tick driven time driven task release mechanisms task release mechanism chosen impact principal areas hardware architecture kernel overheads responsiveness 
hardware architecture infrastructure system ected scheduling policy 
tick driven scheduler requires hardware clock tick time driven scheduler requires real time clock 
advantage tick driven approach system previously cyclic scheduler hardware generate clock tick reused 
noted assumption clock tick rates available completely exible 
practice may leading design changes reduce release jitter 
reuse advantage reduced 

kernel overheads kernel overheads normally relatively small comparison resource available overheads cause scheduling problems 
easy kernel implemented ine cient manner excessive resources take valuable resources critical times worst case theoretical analysis greater actual worst case 
general task release mechanism attempts update run queue largest kernel overheads 
reason overhead incurred independent task released 
assumes mechanisms similar overhead searching highest priority runnable task subsequently releasing task 
assumption quite realistic 

responsiveness responsiveness ability meet deadlines related release jitter blocking time 
time driven approach considerably responsive tasks released soon currently executing task complete 
execution time task allowed analysis blocking term interference term 
additional release jitter introduced 
bad points associated methods discussed releasing tasks 
try decide technique best easier say approach ideal circumstances attempt derive better solution 
hybrid approach task release alternative task release mechanism proposed hybrid tick driven time driven scheduling approaches 
hybrid approach releases majority tasks clock tick carefully selected tasks released time driven manner 
tasks released time driven approach rate harmonic clock tick rate 
bene hybrid approach allows compromise kernel overheads task responsiveness minimum change task release mechanism cyclic scheduler 
kernel overheads reduced tasks requiring quick response need checked release 
time task nishes executing kernel overheads time task nishes executing reduced compared time driven approach 
responsiveness improved tasks released harmonic clock tick period su er unnecessary release jitter 
actual clock tick period chosen minimise amount overheads 
clock overheads represented equation 
equation derived equations remembered implementations may re programmable may limited selection iteration rates available clock tick 
value tclk minimises overheads considered best 
claimed optimal particular phasing tasks exist task table basic task set better overheads occur speci times minimise magnitude 
overheads due tick driven release mechanism overheads due time driven release mechanism lcm tl tclk lcm tl tk cost releasing task time driven fashion set tasks released tick driven manner set tasks released manner set tasks lcm tl common multiple tasks periods example illustrate di erent forms task release analysis section presents example demonstrate hybrid mechanism applied associated analysis 
table presents task set scheduled analysed 
initially system analysed assuming tick driven approach single task model clock overheads 
task set table extended include id met 
table analysis tick driven scheduler tclk multiple tasks model overheads computation times equal 
results analysis table 
case tasks deadlines 
results appear worse single task model 
analysis repeated task set scheduled time driven approach 
initially computation times tasks table increased account cost updating run queue equation 
assumed 
noted release jitter time driven approach 
table gives results analysis shows tasks meet deadlines 
reason time driven approach produces better results kernel overheads coincide tasks released overheads occurring critical instant 
hybrid approach considered 
clock rate assumed left cyclic scheduler 
eliminate jitter tasks scheduled time driven fashion remainder tasks tick driven 
single task clk highest priority account tick driven overheads 
id met 
table analysis scheduler id met 
clk table analysis hybrid scheduler tclk task model overheads single parameters tclk tmin tclk computation times tasks increased values table include overheads time driven scheduling 
results analysis table shows tasks schedulable 
tables seen response times tasks better hybrid approach time driven approach 
hybrid release mechanism provides better worst case response times time driven approach period task question greater period clock tick 
time driven approach provides better response times 
reason general hybrid scheduling approach causes overheads time driven approach 
hybrid approach phases part overheads associated task clk critical instant causes impact tasks shorter period clock tick 
majority tasks tend period greater clock cause great problem 
hybrid scheduling provides useful alternative time driven scheduling 
particularly case reuse systems previously cyclic scheduler important 
summary section clearly shown hybrid approach may release tasks ectively 
advantage hybrid approach tick driven approach exibility reduce ects jitter minimise overheads whilst largely maintaining existing clock tick architecture 
whilst recognised example prove strategy better philosophy reducing jitter overheads enhance schedulability task set 
advantage hybrid approach time driven approach change occurs way majority tasks handled infrastructure transition cyclic xed 
criteria acceptability change hybrid approach deemed successful 

reuse existing tick driven architecture reused schedulability system dictates change time driven approach necessary 
minimum amount change necessary way tasks interact infrastructure 
key problem hybrid scheduling approach arise system real time clock 
mean tasks released period multiple clock tick rate 
circumstance options eliminate release jitter include alter task period leads exible computational model alter possible may ect tasks provide real time clock means infrastructure longer completely reused 
clearly options ideal developer decision particular system 

su ciency amount overheads minimised necessary release jitter eliminated increases chance schedulability 
arti cial restrictions iteration rates enforced 

certi cation veri cation produced gives de nitive statement system schedulable important evidence certi cation case 

understanding tick driven time driven approaches considered simple understand 
hybrid approach decision tasks released technique straightforward 
tasks iteration rate multiple clock released time driven approach 
handling timing overruns section justi es successful certi cation argument needs demonstrate timing overruns detected bounded time 
timing overruns may caused faults system incorrect application analysis 
integrity timing overrun detection mechanism particularly important safety critical systems 
mechanism deal random systematic failures 
cyclic scheduler failures detected testing task belonging minor cycle executing clock tick arrives indication error occurred 
timing watchdog detect systematic failures caused di culty synthesising schedule inexact methods estimate worst case execution times 
importance detecting timing overruns cyclic scheduling model lead high integrity trusted watchdogs developed 
section provides overview timing watchdogs may cyclic scheduling model 
key advantages xed priority scheduling viewed graceful degradation system event timing overruns 
ect timing overrun tasks may deadline 
higher priority tasks rst chance execute lower priority tasks ones deadline 
missed deadlines tolerated cases critical tasks ected 
cases system considered degrade gracefully 
safety critical systems go ort trying establish type faults allowed frequently taken strategy assume fault recoverable 
technique adopted reset particular lane fault occurred change lane controlling system 
lane considered processor executing software associated peripheral hardware including memory timing watchdog 
strategy assumes safety critical systems active replication support fault tolerance 
bene obtained allowing lane attempt fault recovery 
number recognised techniques fault recovery including recovery blocks check pointing 
independent fault tolerance strategy need recognise failures timing watchdog 
main requirement timing watchdog identify timing overruns enabling functionality fault tolerance assess action needed 
principal approaches providing protection timing overruns tick driven approach countdown timer approach 
tick driven watchdog tick driven watchdog approach regular rate normally multiple clock tick rate check performed ensure software exceeding time bounds 
xed priority scheduling approach check ensuring su cient number tasks executed checks 
check assess sum worst case execution times tasks executed clock ticks larger period timing watchdog 
alternative method check tasks execute clock ticks tasks execute period deadline equal clock tick rate 
response time tick driven watchdog detectable faults twice period timing watchdog 
reason failure may detected rst time timing watchdog executes second time 
overheads may accounted creating new task period equal clock tick appropriate worst case execution time derived analysis 
clock tick interrupt task execution preemptive fashion 
failed task continue execute forever 
timing watchdog check completed successfully interrupted task resumes immediately 
preemptive nature timing watchdog means modelled conventional task non preemptive model 
schedulability analysis allow interference timing watchdog preemptive shown equations 
ri ci bi ii ri ctw interference due timing watchdog software ctw worst case execution time timing watchdog software 
countdown timer watchdog countdown timer watchdog approach time task commences execution countdown timer started 
duration countdown timer greater worst case execution time task task set 
task execution complete countdown timer restarted 
countdown timer reaches zero fault recovery performed 
assumed task executes longer worst case execution time failure occurred 
response time fault equal duration countdown timer 
overheads countdown timer approach may accounted increasing worst case execution time tasks shown equation 
ci ci ctw comparison timing watchdog approaches timing watchdog approaches assessed respect parameters task release mechanism hardware architecture kernel overheads responsiveness 

hardware architecture clear answer approach better hardware architecture perspective 
hand tick driven approach obvious advantage existing architecture reused reduces amount rework 
hand countdown timer approach advantage existing architecture contradiction 
countdown timer approach uses interrupt fault occurred 
countdown timer watchdog combined time driven task release mechanism possible remove system fault free conditions 
signi cant advantages certi cation engineers struggle justify need safety interrupts system 

kernel overheads clearly countdown timer approach cause greater interference due fact watchdog software executed times 
assumes checks similar overhead time performed 
overhead approaches relatively small relation system processing resource 

responsiveness countdown timer approach considered responsive reasons 
firstly timer approach detects overrun bounded amount time set duration timer 
tick driven approach take long clock periods detect overrun 
secondly countdown timer approach obvious advantage speci task causing overrun identi ed guaranteed tick driven approach 
intelligent fault tolerance possible countdown timer approach 
choice watchdog mechanism considered respect criteria successful transfer technology 

reuse obviously making existing tick driven watchdog mechanism better reuse perspective having develop certify new timing watchdog mechanism 

certi cation mechanisms satisfy safety goal detecting timing overruns 
tick driven watchdog advantage trusted countdown timer watchdog advantage better fault identi cation facilitating accurate diagnosis correction 
removal interrupts system certi cation straightforward 

su ciency systems quicker accurate response faults necessary provide intelligent fault tolerance maintenance countdown timer driven approach clear winner 

understanding mechanisms considered simple understand implement change 
satisfaction criterion demonstrated fact approach transferred industry successfully applied 
evidence case study chapter 
summary chapter addressed issues infrastructure left cyclic scheduler support xed priority scheduling ects infrastructure analysed ectively 
primary parts consideration task release mechanism detection timing overruns 
improve ability meet timing requirements system su ciency criterion hybrid scheduler derived task release 
hybrid scheduler combines best features tick driven time driven task release 
hybrid scheduler allows maximum reuse obtained whilst restricting system computational model 
bad points timing watchdog mechanism discussed leading best technique depends system requirements 
tick driven approach better reuse paramount 
countdown timer certi cation ort supports intelligent fault management 
chapter task attribute assignment purpose chapter investigate issues related task attribute assignment individual processor 
majority xed priority scheduling assumption tasks attributes pre assigned making priority assignment trivial 
academic papers task attributes normally considered period priority 
practice deadlines sets considered 
signi cant challenge derive task attributes meet system timing requirements way understood non specialist 
approach proposed task attribute assignment caters timing requirements complex control systems imposed scheduler 
section timing requirements summarised 
task period deadline jitter separation 
transaction precedence tasks period deadline jitter secondary aim try ensure set analysis task schedulability analysis veri es timing characteristics system bene separate veri cation tool needed transaction timing requirements 
priority assignment process assigning priorities timing requirements met 
deadline assignment process assigning priorities timing requirements met 
assumed tasks priorities derived deadlines dmpo shorter deadline higher priority 
timing calculation task schedulability requirements task attributes attributes analysis schedulability analysis results tasks worst case execution times diagram illustrate approach meeting timing requirements approach meeting timing requirements providing evidence met illustrated 
basically parts approach rst involves deriving task attributes knowledge tasks worst case execution times second uses tasks worstcase execution times verify timing requirements met 
number parts chapter 
section derives analysis proving transaction requirements met task set attributes 
section investigates transaction requirements may met uniprocessor systems cases 
cases transaction deadline equal tasks form transaction periods transaction deadline greater tasks periods 
section investigates task jitter requirement met 
section investigates tasks separation requirements met 
section combines product earlier sections provide approach task attribute assignment 
calculating response times transactions prime driver task attribute assignment represent system timing requirements task attributes tasks deadline met system timing requirements met 
independent aim useful analysis available allows transactions requirements veri ed 
task task task transaction deadline transaction period timing requirements transaction observation 
verify transaction requirements met check instance transaction immediately critical instant case tasks execute worst case time 
argument liu layland prove worst case response times tasks occur rst instance critical instant tasks execute maximum rate maximum execution time 
similarly transaction worst case scenario rst instance task transaction delayed maximum amount possible 
causes maximum amount interference tasks transaction 
consequently nal task completes longest possible duration release rst task 
transaction worst case response 
ectively execution scenario transaction relates critical instant coinciding instance interest plays completion transaction task transaction 
consider timing requirements 
illustrates task set consisting tasks single transaction requirement tasks 
periods deadlines tasks respectively 
transaction period deadline 
speci ed tasks initially deadline equal period 
common deadline requirements speci ed especially requirements legacy cyclic scheduled system 
phases calculation transaction response time establishing particular release task transaction completion time releases interest 
carried starting rst task working tasks de ned precedence order 
equation calculating task instance relevant transaction 
nt nt tt rt rt tt tt th task assuming tasks ordered precedence transaction nt instance th task nt nt worst case response time th instance task worst case response time task nt transaction critical instance time zero equation 
nt nt tt rt theorem 
value nt represents worst case response time tth task transaction tasks ordered de ned precedence constraint 
proof consider task task transaction precedes task instance required 
worst case response time th instance task nt represented equation 
nt nt tt rt instance task satisfy condition equation response time task task previous instance task task 
nt tt rt nt nt tt rt equation nt tt rt nt tt rt nt nt tt rt rt tt tt nt tt rt nt tt rt nt nt tt rt rt tt tt state tasks transaction ni conditions equations clearly satis ed value nt equation 
nt nt tt rt rt tt tt initial value response time task transaction calculated starting consider example rst task task turn 
worst case response time transaction 
analysis verifying transactions developed approach 
preference scheduling technique eliminates need analysis task schedulability analysis 
meeting transaction deadlines uniprocessor systems basic requirement transaction sequence tasks executed speci order xed amount time 
general tasks transaction expected identical iteration rates transaction deadline expected equal period 
reason tasks transaction dependent need executed rate 
transactions may exist tasks execute rate 
case assumed transaction repeats rate equivalent common multiple task periods 
consultation systems engineers working real systems assumption deemed reasonable acceptable 
section proposes types requirements deadline jitter separation precedence handled task attribute assignment 
attributes manipulated deadline set priority 
techniques example gerber approached problem considering attributes intermediate tasks changeable 
systems domains type approach acceptable 
problem approach neglects highly complex systems interactions 
changing task characteristics may lead requirement met cause broken 
reasons constraints placed approach tasks periods altered deadlines reduced 
reason approach developed described unique 
attributes controlled simpli ed assigning priorities deadlines dmpo tasks shortest deadlines highest priority 
requirements met just setting task priorities fact run time behaviour similar 
additional analysis section required prove transactions timing requirements met 
manipulating task deadlines task attributes represent system timing requirements 
consequently task schedulability analysis veri es system timing requirements 
reason manipulating deadlines priorities veri cation easier understand 
easier see system timing requirements met assumed task allowed execute time possible window di 
simply illustrating worst case execution tasks critical instant allows system timing requirements veri ed 
analysis section just tasks response time equal deadline mean system timing requirements met 
proposal necessary timing requirements handled just setting deadlines sets appropriate values 
proposal demonstrated proven course chapter 
system timing requirements veri ed simply proving task sets enforced scheduler schedulability analysis show task deadlines met 
approach meeting transaction requirements reducing task deadlines systematic manner task deadlines reduced minimum possible 
technique number examples building general purpose algorithm 
assumption sum worst case execution times tasks equal transaction deadline 
demonstrate approaches time lines produced shown 
purpose time lines illustrate worst case response times tasks transactions 
time line depicts worst case situation tasks transactions critical instant tasks tasks response times equal deadlines 
accordance observation time lines tasks execution release rst task transaction 
time lines instances task required precedence ordering achieved case task set task executes followed task followed task deemed necessary instances task instance corresponding transaction release task shown 
producing time lines assumed priorities calculated dmpo 
block time lines represents worst possible response time task corresponds task released early possible com task instance task instance task instance instance instance response time time line transaction illustrated late possible deadline 
blocks time lines represent actual execution tasks 
producing time lines ectively analysing transaction requirements met steps taken 
assume rst task transaction completes worst case time deadline 

find appropriate instance terms precedence task transaction 
appropriate instance response time task greater completion time preceding task transaction 
rule task lower priority preceding task identical release time current release considered 
release considered 

assume task completes worst case time deadline 

task transaction return step 
test response time transaction meets deadline 
task attribute assignment transaction deadline transaction period purpose section propose strategy assigning task attributes transaction requirements met simplest cases transactions deadlines equal periods 
attribute controlled tasks deadlines 
important consideration trying meet transaction deadline relationship tasks deadlines 
consider tasks task released time task tasks deadlines dt dt 
conditions task follows task nt nt equation 
advantage deadlines conforming relationship worst case response time task transaction kept minimum tasks logically phased 
considering equation response time transaction minimised value ni tasks transaction kept small possible 
transaction deadline met 
addition dealing deadlines way easier justify precedence ordering met 
observation 
tasks transaction executed perfect precedence rst task transaction rst execute response time task equal transaction deadline transaction deadline met 
argument response time task transaction schedulability analysis equations condition met 
condition tasks transaction execute perfect precedence task transaction rst rst execute 
reason tasks transaction ni leading ni equal ri 
necessary check case response time task transaction equal transaction deadline 
task instance task instance task instance response time time line transaction demonstrate approach task attribute assignment consider timing requirement illustrated 
time line indicates worst case response time task characteristics outside allowed band 
tasks deadlines assigned starting task transaction working backwards rst task 
reducing deadline tasks clock cycle respectively case response time transaction requirement met 
time line demonstrates requirement met 
important constraint deadlines decreased increasing deadline ect ability meet requirements 
original deadline task task deadline increased transaction met 
run time ect obtained simply altering priorities tasks task higher priority task higher priority task disadvantage priority approach extra analysis task schedulability analysis required resultant priority ordering 
addition constraint deadlines tasks technique section de nes maximum possible set deadlines 
tasks priorities manipulated tasks meet deadlines calculated approach section 
observation 
giving task transaction deadline clock cycle task nal task deadline equal transaction deadline transaction requirement met tasks schedulable 
argument dmpo preceding task transaction larger deadline task considered deadline order maintain precedence ordering 
dmpo deadline needs clock cycle task 
perfect precedence order transaction meet deadline task transaction complete transaction deadline 
deadline task initially greater transaction deadline altered equal transaction deadline 
task attributes represents transaction requirements leading schedulability analysis verifying transaction requirements task requirements 
fact observations combined give observation observation 
transaction deadline equal transaction period reducing tasks deadlines minimum necessary advocated technique section achieve perfect precedence optimal 
de nition optimal domain taken approach nds solution exists 
argument observation argues transaction requirement met priority ordering discussed section 
observation stated maximum deadlines tasks result minimum necessary changes deadlines achieve perfect precedence 
fact dmpo optimal method assigning task attributes cater transaction requirements optimal 
argued task assignment algorithm section optimal case transaction deadline period 
experience computational model considered section restrictive transaction deadlines greater periods 
section relax restriction 
task attribute assignment arbitrary transaction deadlines aim section develop approach task attribute assignment cases transactions deadlines arbitrary value 
aim deadline assignment priority assignment toavoid need separately analyse transaction requirements met 
transaction deadline dealt approach section 
ability schedule task set may unnecessarily reduced making deadlines needed 
reason transaction deadline constrained equal period 
potential solution problem increase deadline task transaction value deadline transaction 
task deadlines assigned precedence achieved described section 
transaction deadlines veri ed schedulability analysis arbitrary deadlines discussed section 
problems adopting approach form timing analysis pessimistic tasks may constraints transactions preventing deadlines increased 
appropriate approach sought 
task task task task transaction deadline transaction period timing requirements transaction task instance task instance task instance instance task instance instance instance instance instance response time time line transaction characteristic requirements task period longer period task follows transaction 
case may necessary possible reduce deadlines perfect precedence tasks transaction maintained 
example consider timing requirements 
requirements transaction iteration rate deadline 
periods tasks respectively 
case task follow task task update rate 
shows altering tasks deadlines requirement met transaction response time 
previous approach section transaction requirements met shown 
task attributes illustrated sub optimal timing requirements met larger deadlines shown 
having larger deadlines means tasks priority 
bene task instance task instance task instance task instance response time time line transaction impact change deadlines rest system minimised tasks schedulable 
task attributes generated algorithm 
algorithm simply rely tasks deadlines reduced perfect precedence maintained 
transaction requirement met highest deadline reduced causes preceding sequence tasks transaction deadline deadline reduced case task set tasks deadlines repeatedly reduced transaction deadline requirement met 
bene approach algorithm deadlines larger greater chance schedulable solution 
algorithm contains manipulation task deadlines changing ag 
ag apparent chapter 
algorithm 
algorithm generalised approach task transaction task equivalent deadline reduce task deadline assign value false task deadlines changing ag transaction deadline met assign value true task deadlines changing ag take longest deadline reduce task transaction task equivalent deadline reduce task deadline assign value false task deadlines changing ag task instance task instance task instance task instance instance instance response time transaction task task task task transaction deadline transaction period timing requirements task instance task instance task instance task instance response time time line transaction optimality approach approach important ascertain optimal 
optimal de ciencies highlighted appropriate action taken necessary 
impressions suggest approach may optimal deadlines tasks maximum possible whilst meeting timing requirements 
trying prove optimality di cult ect complex interactions tasks transactions 
consider transaction requirement 
presents solution derived approach algorithm presents task instance task instance task instance task instance instance instance response time time line transaction alternative solution 
impossible judge better solution knowledge tasks execution times priorities deadlines 
hand task attributes cause interference tasks tasks cause interference interference associated task increased 
stated approach algorithm optimal 
experience task attribute assignment approach speci examples issue raised section caused problems 
chapter contains example technique develop tasks attributes complex set real system timing requirements 
approach algorithm insu cient solution optimal priority assignment technique audsley 
audsley approach involves methodically raising priority tasks task set schedulable solution deemed possible 
audsley technique intended deal transaction requirements 
audsley approach extended check system timing requirements making decision change priority 
advantages approach section approach audsley optimal priority assignment algorithm time lines helps convince engineer approach correctness approach signi cantly lower computational complexity 
jitter purpose section explore jitter requirements handled manipulation task attributes 
important constraint frequent criticism xed priority scheduling related control jitter 
conventional model xed priority scheduling said su er worse jitter cyclic scheduler 
reason regular clock tick cyclic scheduler causes entire run queue regularly refreshed 
task su ers jitter length minor cycle 
xed priority scheduler tasks large periods deadlines exist run queue longer time leading greater variations completion time 
section discusses jitter requirements important variability time inputs outputs performed 
prime driver enable schedulability analysis tasks verify jitter requirements 
similar reasons section jitter requirement handled deadlines priorities 
task deadline equal jitter requirement requirement met window allowed execution constrained critical instance time allowed jitter requirement 
approach pessimistic minimum processing time task adds variability task execution time vary best case response time worst case response time 
deadline calculated equation 
di ji best case response time task best case response times tasks generated stages 
initially value set zero task set harder schedule deadlines lower 
value evolved results analysis available 
best case response times taken best case execution time calculated exact analysis techniques method proposed harbour garcia 
clearly seen having deadline de ned equation constrains variation task computation time jitter requirement met 
fact choice deadline controls jitter means standard schedulability test veri es jitter requirement met removing need extra analysis 
problems approach equation 
cases illustrated 
case whilst technique described section provides task attributes result requirements met optimal 
main problem tasks jitter requirements may abnormally large number tasks short deadlines 
short deadlines means tasks execute shortly critical instant easily lead solution 
solution case phase execution tasks spreading execution sets 
sets phase execution avoided possible due increased maintenance problems having slots 
maintenance problems slots analogous problems cyclic scheduling 
case area concern related transactions transaction deadline equal period 
realistic assumption jitter requirement imposed transaction invariably relates rst task transaction tasks input output transaction 
jitter requirement placed task transaction lead preceding tasks having shorter deadline ect schedulability 
example consider task set illustrated represents transaction requirement includes jitter requirement task 
task task task transaction deadline transaction period timing requirements task instance task instance task instance response time time line transaction equation calculate jitter requirement task results applying technique algorithm leads tasks deadline time line illustrates execution tasks 
shaded area represents allowed variation task execution time unit non variant equal task best case response time part execution 
problem solution tasks execute 
solution case solution problem sets 
proposed solution demonstrated better solution demon task instance task instance task instance response time time line transaction 
basis solution constrain variation task execution allowed execution time transaction appropriate set 
set calculated shown equation 
allowed execution time task equal deadline calculated equation 
precedence tasks enforced making tasks execute task released 
task deadline equal set task algorithm applied tasks preceding task approach choosing task deadline task set represented algorithm 
set transaction deadline time allowed execution window task set transaction deadline jc noted transaction deadline greater period problem case arise algorithm unnecessarily enforce precedence case 
longest deadline reduced algorithm 
algorithm dealing jitter task denoted system task jitter requirement task task particular transaction di ji transaction deadline transaction period di ji di transaction deadline task deadline transaction deadline oi di ji preceding tasks denoted transaction transaction deadline met dj transaction deadline ji dj transaction deadline ji requirements met 
reducing task deadline meet jitter requirement necessarily lead tasks deadlines reduced enforce precedence 
approach de ned algorithm described optimal 
large number tasks speci cally ones part particular transaction phased execute time interval oi di approach may lead solution 
circumstance approach entirely equation algorithm may increase likelihood schedulable solution 
practice case 
optimal approach published dealing jitter 
separation purpose section technique assigning task attributes separation requirements handled 
tasks separation algorithm 
algorithm accounts separation task system task denoted separated earlier task denoted oi si di oi ci di di di si oi assign value true task deadlines changing ag requirement si requirement satis ed manipulating sets deadlines tasks 
technique gives second tasks set si deadline earlier task 
expressed equation 
oi si di si separation requirement tasks task precedes task di deadline task 
resultant set great oi ci di task chance meet deadline 
case appropriate metric altering deadline rst task required 
approach equation 
approach basically splits available execution time tasks 
achieved making relative deadline equal task deadline minus set preceding task equal relative deadline current task 
condition equation satis ed 
approach developed represented algorithm 
noted manual intervention may deemed necessary dependence characteristics system 
di di si oi algorithm 
algorithm priority assignment initialise task deadlines changing ag true apply algorithm task deadlines changing ag true assign value false task deadlines changing ag transaction set transactions apply algorithm apply algorithm apply priorities tasks deadline monotonic approach perform schedulability analysis task set task attribute assignment combining various techniques discussed chapter results algorithm 
algorithm works steps 
task deadline assigned deadline equal period 

tasks jitter requirement assigned deadline algorithm 
transaction system algorithm update task deadlines meet transaction requirement 

apply algorithm deal separation requirements 

complete run transactions causes deadline take place task deadlines changing ag true return step 
assign priorities dmpo 

check task deadline met schedulability analysis 
method priority assignment considered optimal particularly obscure events discussed chapter 
example case section 
shown approach su cient typical system timing requirements encountered demonstrated case study chapter 
real problem encountered far approach caused impractical requirements related circular arguments 
instance consider requirements requirement task precede task requirement task precede task requirements resolved algorithm 
case algorithm obtain result deadlines tending 
reason transactions deadlines periods requirement met perfect precedence achieved 
achieve perfect precedence earlier task transaction deadline reduced shown algorithm 
process repeated transactions tasks attributes converge happen 
clearly solution requirement stated requirement allowed exist 
implementing algorithm circularities recognised agged user appropriate manual intervention take place 
ability algorithm deal complex requirements demonstrated case study chapter 
case study generate priorities complex set realistic timing requirements 
comparison task attribute assignment approach chapter chosen criteria successful technology transfer 
reuse reuse criterion really applicable technique derived xed priority scheduling expected cyclic scheduler 
approach means single tool needed analysis 

certi cation technique provides approach determined drawing time lines worst case execution critical instant system timing requirements met 
evidence correctness expressed manageable form 

su ciency approach places minimum constraints possible execution tasks provides greatest exibility 
likelihood able schedule system improved exible approach 

understanding experience engineers including certi cation authorities able understand apply technique short time typically hour little previous knowledge scheduling 
satisfaction criterion demonstrated fact approach technology transferred industry successfully applied contrast techniques bene ts priority assignment approach need form priority inheritance eliminated 
need priority inheritance protocols eliminated sharing resources dealt priority level 
priority inheritance borne exibility rate monotonic approach deal transactions way 
consider task set task attributes assigned rate monotonic approach response time system shown deadline missed 
meet transaction deadline control tasks deadlines requires tasks inherit higher priority task number mechanisms inheriting priorities reviewed section 
priority inheritance give similar response shown 
problem priority inheritance design complex additional run time overheads 
problem extra veri cation schedulability analysis required show transaction requirements met 
technique approach compared gerber discussed section 
di erences techniques main ones exist 
firstly gerber approach straightforward demonstrate requirements met 
secondly gerber approach assumes intermediate task attributes completely exible iteration rates changed deadlines increased ignores uence timing requirements interaction tasks transactions 
domain interest technique developed chapter advantages 
summary chapter addressed attributes assigned tasks represent system timing requirements priorities sets deadlines 
primary bene ts 
standard schedulability analysis assumes critical instant verify system timing requirements 
approach easy understand 
approach removes need complex mechanisms priority inheritance 
approach derived signi cant advantage enforcing tasks precedence rules dealt line kernel having enforce precedence rules run time 
implementation easier produce maintain easier verify precedence constraints achieved 
cases approach su cient obscure cases 
additional advantage approach explained relatively straight engineers regulators helps technology transfer process 
ease time lines produced assists technology transfer helps arguing correctness 
techniques described section illustrated chapter part case study 
purpose case study demonstrate techniques show may applied real system 
chapter case study br engine controller purpose chapter case study demonstrates techniques described chapters real system 
chapter demonstrate techniques purpose particularly relation criteria successful technology transfer 
criteria reuse certi cation understanding su ciency 
case study performed rolls royce moved aircraft electronic engine controller application cyclic scheduling xed priority scheduling 
technical originally performed author adopted rolls royce 
techniques lead system scheduled xed priority scheduling veri ed actual engine 
discussions taken place certi cation authorities xed priority scheduling technique aircraft agreed 
con dentiality reasons details changed task names 
example realistic 
discussion divided parts 
actual purpose electronic engine controller 
technical details concerning system controlled cyclic scheduler 
technical details change xed priority scheduling performed including timing analysis 
process details change xed priority scheduler ect working practice organisation 
purpose electronic engine controller system modern aircraft engines tted electronic engine controller essentially computer executes engine controller software 
computers aircraft control functionality implemented hydro mechanical components 
overview operation system 
electronic engine controller uses sensors monitor engine condition fuel ow components monitor aircraft operation thrust request 
electronic engine controller controls engine operation actuators valves pumps 
electronic engine controller accepts pilot commands provides status information engine back cockpit 
electronic engine controller embedded safety critical normally featuring replicated components provide fault tolerance 
particular characteristic electronic engine controllers transactions common place fundamental safe operation 
transactions consist reading data number sensors performing calculations available data output results appropriate actuators 
system tasks provide functionality health monitoring maintenance 
important factors implemented system normally uniprocessor processor resource heavily loaded 
engine airframe control unit actuators sensors electronic engine controller cockpit overview electronic engine control unit technical details system purpose section details system implemented cyclic scheduler order place transition context 
section uses discussion chapter existing ways implementing cyclic scheduler basis 
basic infrastructure system periodic clock tick period time units arbitrary 
clock tick signify start minor cycle control timing watchdog implemented hardware 
implementation features minor cycles major cycle 
overhead ctw ctw worst case execution time timing watchdog software 
timing requirements certain characteristics system table 
presents transaction details id id table task attributes transaction deadlines transaction deadline transaction deadlines transaction deadlines diagram illustrate system transactions requirements area maintenance 
greater bene may scheduling model allowing valuable resources saved 
exible consider problem implementing cyclic scheduler system case study 
di culty synthesising scheduler means tasks split small units computation tasks small units 
fact major cycle rate means scheme required schedule tasks update rate 
task executing units sub schedule tasks 
tasks iteration rate dispatched fth time sub scheduling task executed 
added complexity having multi level scheduler helps illustrate need exible scheduling policy 
rolls royce experience application suggests task periods changed 
tasks need executed frequently frequently 
requirements produced assuming cyclic scheduler deemed appropriate alter nature purpose case study 
technical transition fixed priority scheduling purpose section show timing requirements table implemented xed priority scheduling theory developed course thesis 
section examine technical issues section investigates lifecycle issues 
parts technical discussion task attribute assignment task release timing watchdog schedulability analysis 
task attribute assignment table presents results task attribute assignment 
attributes calculated algorithm described chapter 
basic categories columns timing requirements calculated task attributes schedulability analysis results 
addition tasks synthesised represent overheads task tw timing watchdog task clk clock overhead 
product timing analysis xed priority scheduler represent actual tasks 
columns table additional de ned table represent calculated task attributes calculated value deadline calculated value set priority derived deadline dmpo schedulability analysis results values considered section result schedulability analysis worst case response time allowing set met 
indicates timing requirement met represents actual worst case execution time tasks including overheads tasks non zero sets meet jitter requirements 
example task jitter requirement initial deadline 
due fact information tasks best case execution times value zero assumed best case response 
algorithm task available execution window 
task deadline modi ed task set modi ed deadline 
deadlines derived algorithm chapter 
clearly tasks deadlines met jitter requirements met 
tasks attributes modi ed transactions requirements met 
modi ed version illustrates system transactions includes modi ed task attributes deadline set jitter bold 
consider transaction involving tasks order transaction deadline 
presents time line illustrate worst case execution deadlines modi ed 
clearly response time transaction id met 
tw clk id met 
table task attributes schedulability analysis results transaction deadlines transaction deadline transaction deadlines transaction deadlines diagram illustrate attributes tasks transactions signi cantly greater required 
tasks deadlines reduced signi cantly respectively 
net result deadline reduction tasks precede task deadline response tasks 
remaining tasks andp response periods 
presents time line illustrate worst case execution deadlines modi ed 
comparison figures shows modied task attributes leads requirement met signi cant reduction response time 
shows easy demonstrate requirements met 
noted figures instance interest represented shaded box 
sets deadlines tasks chosen task meets deadline precedes 
noted response time time line transaction involving tasks attributes modi ed response time time line transaction involving tasks attributes modi ed larger deadline ordering andp guaranteed 
transaction response time deadline met 
section shown complex system timing requirements broken task attributes technique developed chapter 
task release purpose section show speci tasks table released details section hybrid task release mechanism works analysed basis 
hybrid approach releases majority tasks clock tick carefully selected tasks released time driven manner 
tasks released time driven approach rate harmonic clock tick rate 
system clock tick left cyclic scheduler 
reuse perspective tasks possible released available clock tick 
overheads associated approach ctw cost releasing rst task cost releasing subsequent tasks ctw worst case execution time timing watchdog software 
table seen tasks periods tasks released zero jitter 
table shows tasks non zero sets means tasks su er release jitter respectively 
hybrid scheduling approach tasks released time driven manner whilst tasks released tick driven manner 
tasks execution time increased account overheads time driven release 
column table represents actual worst case execution time tasks includes overheads 
table features task clk 
task clk represent clock overheads tasks 
task clk characteristics tclk calculated equation shown equation 
section shown system timing requirements supported infrastructure available technique developed chapter 
practice exibility scheduling model lead system engineers wanting release tasks rates 
engineering guess taken changes fact rolls royce thesis changed requirements 
new requirements ability direct comparisons cyclic scheduler xed priority scheduler lost 
early experimentation iteration rates indicated adjusting tasks periods provide bene ts 
period increased resources saved 
precise saving depends actual application 
example application discussed chapter processor utilisation saved 

cases stability cyclic scheduler marginal tasks periods increased jitter requirements imposed significant improvement stability obtained 
timing watchdog purpose section timing overruns detected 
enable reuse assumed tick driven watchdog described section 
technique detect overruns occurred check expected tasks executed clock ticks 
expected tasks periods deadlines equal clock tick period 
overheads due timing watchdog table represented task tw characteristics ctw 
tasks clk tw highest priorities task set 
implementation details section discuss scheduler implemented 
key fact implementation hybrid scheduler 
xed priority scheduler queues controlled release dispatch tasks 
run queue contains tasks runnable 
delay queue contains tasks awaiting release 
task execution run queue updated highest priority task executed 
illustrates task dispatch mechanism implemented 
key feature implementation search mechanism employed nd highest priority task 
search highest priority task started task executed tasks just released case search starts highest priority task 
reason approach search time reduced 
method employed release tasks delay queue run queue de ne number words bits long number tasks 
task allocated position word priority highest priority task relates signi cant bit 
value logic mean task active runnable run queue delay queue logic 
illustrates format words 
words de ned run queue delay queue words 
delay queue word represents set tasks identical release points word task order reduce number operations scheduler perform 
associated word referred iteration rate word indicates number clock ticks task set runnable 
task due released run queue ed relevant word produce queue word 
shows run queue updated regular clock tick trigger timing watchdog 
implementation decisions taken uenced need implement system spark ada 
instance xed sized arrays represent task released reset current search position highest priority task search highest priority task current search position clock tick occurred 
dispatch highest priority task runnable release appropriate tasks execution task voluntarily suspend remove task run queue check current time real time clock modify value 
release tasks operation hybrid scheduler bit bit bit bit bit task value runnable task value runnable task value runnable task task value value runnable runnable diagram illustrate word format queues systems deemed critical dynamic data allocation memory 
schedulability analysis results table presents results schedulability analysis 
worst case response time columns result schedulability analysis assuming critical instant modi ed value accounts task set tasks response times table deadlines indicates task set schedulable 
despite processor utilisation maximum possible 
concluded system timing requirements met 
time taken derive task attributes minutes 
schedulability analysis performed hour automatic tool employed repeated task attribute assignment performed schedulability analysis 
tool completed job virtually instantaneously 
ease attribute assignment subsequent analysis may performed manually indication understanding criterion met 
respects task attribute assignment case study demonstrated technique chapter capable calculating attributes real complex system 
prove su ciency criterion met suggests satis ed 
rolls royce engineers technique successfully hand produced scheduler tool intended compliant 
stated certi cation criterion met approach considered understandable 
key fact existing software hardware scheduler reused strong indication approach meets principle objectives 
reuse criterion entirely met tools producing cyclic schedulers reused 
details ect process section describes typical process currently industry designing safety critical systems cyclic schedulers 
purpose section consider xed ect way inwhich system produced 
consideration stages life cycle 
requirements 
design 
implementation 
veri cation 
certi cation requirements general nature requirements captured altered change scheduling regime 
reason requirements dependent application design domain 
scheduler simply means provide timeliness 
requirements change functional requirements scheduler expected change 
experience shows change exible scheduling regime may cause impact requirements written 
requirements need stringent whilst advantage improved exibility model 
requirements need stringent static nature current scheduler leads requirements implicit explicit implementation 
example task may low jitter cyclic schedule placed start minor cycle 
implement task successfully xed priority scheduling necessitates jitter constraint explicitly stated 
similarly precedence requirements separation requirements may implicit implementation cyclic scheduler static control ow 
xed priority scheduler requirements need explicitly stated 
increased exibility scheduler causes problems engineers determine real requirements 
existing requirements derived speci ed knowledge harmonic iteration rates clock 
example tasks periods chosen 
engineers know rate particular task know works 
existing requirements tend largely historical reasoning poorly understood 
means system re engineered establish real requirements 
new requirements established analysis simulation testing 
problems caused having establish real set requirements 
changing requirements ects reuse system basis different 
certain amount re veri cation necessary 

part certi cation argument con dence timing requirements generations engine controller 
argument produced change requirements positive ect negative ect resulting system safe 

control system complex di cult analyse establishing real requirements may di cult 
great deal ort cost committed real bene ts obtainable 
noted cost 

experience shown practice engineers decide functionality execute faster particularly outputs actuators 
processing resource liable demanded 
bene xed priority scheduling easily lost helping reduce processor utilisation providing greater exibility choice tasks periods better control system may result 
single biggest impact change exible scheduling need re assess requirements 
considerable bene ts doing system perform better safer requirements correct 
addition possible reduce amount testing necessary 
reason great deal testing performed check system operation requirements may proven correct 
design xed priority scheduling implications design process task attributes assigned meet system timing requirements new scheduler needed 
chapter describes task attributes assigned section demonstrates point 
design kernel requires consideration top level requirements 
scheduler non preemptive 
tasks released tick driven manner time driven manner 
software tick driven timing watchdog correctly determine system operation proceeding planned 
scheduler designed manner consistent safe programming practices advocated spark ada 
instance memory usage decided hand static fashion excludes pointers 
pointers design scheduler task information stored dynamically number tasks unknown 
safety critical system number tasks known hand 
easier static data structures case system dynamic nature 
implementation change xed priority scheduler causes changes implementation stage life cycle 
relate scheduler software worst case execution time tasks 
scheduler implementation meet design account need safe subset language 
implementation produced worst case execution time analysis performed described section 
worst case execution time analysis performed reasons allow schedulability analysis take place establish execution budgets exceeded 
execution budgets assigned requirements phase help manage resource usage 
impact worst case execution time analysis xed priority scheduling greater emphasis placed analysis 
contrast veri cation cyclic scheduler generally relies test 
analysis means greater importance attached having correct worst case execution times 
veri cation single biggest change adopting xed priority scheduler longer static ordering tasks 
section discussed dynamic task ordering means stringent requirements necessary 
problem caused veri cation related fact run time ordering longer deterministic 
timing requirements veri ed test approach 
accommodate change scheduling policy veri cation strategy changed primary evidence timing correctness obtained timing analysis 
reduced amount performed cyclic scheduler test provide extra con dence correctness system timing properties 
stated scheduling predictable xed priority scheduling 
change xed priority scheduling raised joint authority met approval analysis viewed better testing 
determinism stipulated current process test philosophy 
ability observe system operates important 
argument worst case deterministic schedule task laid typical cases 
production time lines demonstrates point 
stated worst case xed priority schedule analogous cyclic scheduler 
functional veri cation system ected necessary timing requirements precedence relations speci ed 
necessary requirements speci ed anomalies may arise task ordering changes 
terms testing slight increase number paths software restricted module contains scheduler 
slight increase amount testing necessary 
part functional veri cation system show scheduler correctly implemented 
tests includes showing periodic tasks released correct rate speci ed set 
certi cation distinct parts certi cation stage life cycle 
parts structuring safety argument justify system safe showing additional hazards introduced change 
structuring safety argument considered scope 
great deal argument structured example 
interesting challenge argue additional hazards introduced system safe change 
stated fault free conditions ability guarantee timing requirements met increased analysis test 
problem matter showing fault tolerance ability deal timing overruns ective cyclic scheduler 
impact interface rest system assessed 
fault tolerance respect scheduling una ected requires demonstration timing overruns detected ciently cyclic scheduler 
assumed fault recovery strategy initially remains unchanged 
section contains discussion various techniques including pros cons implementing timing watchdog xed priority scheduler 
principal technique fault recovery lane change followed reset faults lane 
main techniques considered tick driven watchdog countdown timer watchdog 
technique detecting timing overruns timing watchdog cyclic scheduler 
aspects interaction rest system time ordering tasks interface 
fact tasks executed di erent order dealt 
interface rest system scheduler una ected 
need alter way call outs tasks handled exactly variables passed actual procedure calls way 
scheduler interface timing watchdog including event handling 
fact interface rest system una ected proof scheduling correctness mathematical evidence means certi cation evidence derived fact improved 
stated section consulted relevant certi cation authority con rmed opinion 
summary contributions chapter demonstrate 
scheduling techniques described chapters relate change scheduling policy real system 
shown techniques su cient handle complexity provide de nitive results whilst comprehensible 

impact process need actual real requirements expressed guaranteed met analysis 
combined improved certi cation evidence analysis test change adds great deal bene ts nal product 
chapter helped show implications product process lifecycle change cyclic scheduler xed priority scheduler real system 
xed priority scheduling technique rolls royce actual engine controller 
trials problems engine controller change 
chapter analysis task sets feature sets purpose chapter address issue timing analysis task sets feature sets 
majority timing analysis published date contents thesis assumed critical instant 
liu layland state task sets feature sets critical instant tasks simultaneously released 
circumstances variety tests exist su cient necessary 
practical systems necessary set execution tasks 
cases test critical instant pessimistic analysis account phasing tasks 
sets real systems actual requirements requirements met 
include 
actual requirement ensuring particular action performed releasing task 
example task may request data hardware device data may time 
associated task required read data 
task set appropriate amount 
approach algorithm chapter uses sets enforce separation requirements 

design derived requirement spreading processor resource requirements time frame jitter reduced speci task 
achieve jitter requirement task deadline reduced 
ect change task higher priority increase interference lower priority tasks 
prevent great impact tasks task phased occur appropriate time 
task attribute assignment approach chapter uses sets part algorithm dealing jitter requirements 
timing requirements tasks case study chapter presents example nature 

design derived requirement ensuring precedence relations maintained allowing task released completed execution 
section shown sets may enforcing precedence part distributed scheduling mechanism 
chapter similar sets 
useful observation requirements exible nature 
example consider separation requirement tasks 
minimum separation tasks maintained second task meets required deadline actual set matter 
approach taken chapter utilises exibility available 
section literature survey describes existing approaches attempted analyse tasks non zero sets 
number problems approaches 
chapter investigate new techniques solving problem optimised context pessimism understandable computational complexity types application expected 
section discusses existing approach task sets ignored assumed critical instant 
section discusses exact analysis approach individual task release checked schedulability minimum period execution order takes repeat 
section presents new approach entails forming composite task set represent tasks sets 
section investigates ective composite approach compared critical instance exact approaches 
section investigates improvements composite model may 
analysis task sets feature sets assuming critical instant simple analysis task sets sets carried ectively ignoring sets assuming single critical instant 
task set tasks transformed illustrated equations 
transformation ect tasks having zero set 
modi ed value task set di original value task set di oi oi main problem approach analysis especially pessimistic ability resources lost 
consider design derived requirement list start chapter tasks tight jitter requirements phased 
analysis ectively ignore phasing 
task set characteristics outlined table example 
id table example task set table columns columns represent id identi er task period task set task deadline task worst case execution time task table contains results schedulability analysis approach described section 
table illustrates resultant task set schedulable task misses deadline 
columns table superset table 
additional columns represent worst case response time task met 
indicates task schedulable analysis table timing analysis non preemptive scheduling model described chapter priorities assigned deadline monotonic priority ordering 
id met 
table results simple analysis table helps show simple form analysis lead pessimistic results caused tasks period having resource distributed time 
tasks fail meet deadline mainly due interference caused higher priority tasks inspecting task set shows tasks interfere sets deadlines mean executions overlap 
appropriate analysis 
exact analysis section literature survey rst discusses exact analysis document 
exact analysis takes approach showing individual release task schedulable assuming tasks execute worst case execution time 
original consideration timing analysis leung whitehead shows instance task particular processor schedulable period maximum set task common multiple task periods maximum set task task set schedulable 
instance task de ned release execution completion 
audsley improved analysis duration maximum set task common multiple task periods maximum set task 
exact analysis approach su er pessimism approaches discussed section section 
pessimism approaches originates areas 
firstly analysis assumes task set single critical instant ectively removes phasing provided having sets 
secondly model timing analysis critical instant introduces pessimism assumed lower priority task block task analysed 
clearly pessimistic relies assumption task analysed runnable lower priority tasks run 
true 
table presents results schedulability analysis derived exact analysis task set table 
results show task set schedulable analysed exact approach 
contrast table demonstrates task set approach ignores sets 
problem exact analysis approach task sets feature prime periods number releases require checking may prohibitively large 
table gives number releases example task set table 
tasks added task set iteration rates number releases checked 
number task instances need checked large 
considered task sets typically contains upwards fty tasks computational complexity may result problem ectively infeasible 
id met 
table results exact analysis id releases lcm ti ti ti table number task releases veri ed composite approach experience performing timing analysis real industrial systems leads observation pattern types set 
sets analogous cyclic scheduler processing frame split manageable chunks tasks allocated di erent partitions sets 
table illustrate type requirement result 
table tasks sets computation spaced relatively evenly period units 
purpose section investigate timing analysis approach may derived 
timing analysis tailored type timing requirements expected intended easily understood 
de ning composite task section presents approach formation composite tasks analysis purposes composite task feature part implementation run time 
motivation approach composite task zero set represent tasks non zero sets analysis section may 
bene composite task approach computational complexity kept su ciently low allowing resource spread time 
principal bene ts technique fact existing analysis limited amount pre post processing 
number bene ts able reuse analysis including fact tools training limited amount extra certi cation evidence needed 
number steps followed derive composite task 
steps backed threaded example italics task set table 
composite task created period tasks non zero sets 
reduce pessimism task included set tasks form composite task 
task zero set period rest tasks set 
task chosen meet criteria zero set period tasks set 
task period zero set exist just tasks non zero sets represented composite task 
task set table need composite task represent tasks tasks non zero sets period 
composite task represents task period tasks zero set 

composite task de ne set st consists tasks period non zero sets maximum task exists period zero set 
task set table set st consists tasks virtue having period non zero set task virtue having period zero set 

composite task de ne set st consists tasks period non zero sets 
composite task represent task zero set additional task added set st period tasks set equal period 
additional task intended represent second instance task zero set 
words set st represents instances tasks set st time range period tasks set st 
task set table set st consists tasks denoted task period equal period tasks set equal period 

composite task worst case execution time assigned equal maximum execution time task set st task set table composite task worst case execution time ccomp cb cc cdg ccomp 
composite task de ne set st ordered version st 
ordering accordance increasing value set tasks set st 
task set table set st de ned task set followed task set followed task set followed task set 
st fb xg 
composite task de ne set st members ordered set st 
value members altered equal set member set st divided index range set st 
task set table set de ned ob st index oc index member set st od index member set st ox index member set st st 
composite task task minimum value member set st 
task set table period composite task minimum 
period composite task 

composite task task deadline equal minimum relative deadline task set st minimum relative deadline classed task deadline minus task set 
task set table composite task deadline equal minimum da oa db ob dc oc dd od 
replace tasks form composite task members set st composite task task set analysed 
task set table tasks replaced task comp 
resulting task set consists tasks comp 
perform standard schedulability analysis task set includes composite task 
table illustrates results schedulability analysis 
results show task set schedulable composite approach 
table shows tasks bya single composite task characteristics period deadline worst case execution time 

task replaced composite task tasks members set st determine task worst case response time equation 
task set table worst case response times ra oa rb ob rc oc rd od id met 
comp table results composite analysis proof correctness obviously approach timing analysis su cient test 
su cient test test indicates system meets requirements practice 
results suggest system meet requirement practice system may 
respect test considered pessimistic 
shows test su cient necessary interference experienced priority tasks decrease compared su cient test 
prove composite analysis su cient compared standard schedulability analysis interference caused composite task tasks form need compared 
theorem 
interference caused composite task experienced lower priority tasks decrease compared tothe interference caused bythe tasks form composite task 
proof su cient test comparison exact analysis section 
de nition composite task section stated composite task higher priority tasks formed 
shown condition equation true test su cient 
equation represents statement maximum interference composite task greater equal maximum interference tasks created 
left hand side equation interference caused composite task time time respect time periodic tasks zero set composite task formed equation true 
left hand side equation expressed shown equation 
tcomp tk tcomp tk tcomp tk tcomp tk alternatively tcomp tk equation tk tk st oj tk de nition composite task section equation stated 
condition equation true 
oj condition equation true 
causes greater interference tasks form 
composite task theorem 
worst case response time tasks task set composite task lower composite task formed 
proof ect composite approach priorities system may change 
means lower priority task previously causes blocking particular task may visa versa 
theorem shown composite task causes greater interference tasks formed blocking 
de nition composite task section stated composite task equivalent higher priority tasks created 
reason minimum deadline priorities assigned dmpo 
set lower composite approach superset lower priority tasks composite approach 
blocking interference increased 
selection sets rigorous treatment sets new area allows scope optimise chosen timing constraints 
known need sets system de nition date 
example consider separation requirement speci ed tasks 
long minimum separation maintained second task meets required deadline size set may increased 
proposed extent sets deadlines treated free variables 
aim choose values sets enforce necessary requirements optimise schedulability analysis 
referred free variable argument 
approach taken treat tasks sets similar fashion allocating tasks cyclic schedule 
tasks having period require sets sets assigned tasks de nition composite task section set chosen free variable argument results largest period composite task obtained 
likelihood task set schedulable increased 
free variable approach result tasks having greater sets necessary provide better results 
constraint assignment sets tasks sets increased 
event set values provided su cient constraint broken map timing requirements tasks ect number slots increased 
choice sets greater task set table considered free variable argument result tasks sets respectively 
invalid modi ed value task set original 
choice sets tasks valid respectively 
free variable argument period composite task equal cases task deadlines may treated similar manner sets 
consideration de nition composite task section choice deadline composite task maximised task deadline equal set task largest set transaction 
example table deadlines task 
evidence ectiveness understand composite form analysis ective requires comparison exact approach 
analysis attempted task set characteristics generated pseudo randomly realistic range iteration rate ms ms 
due typical sizes common multiple case large number tasks computational complexity allow comparison carried 
analysis task set characteristics feasibly expected computed 
task set characteristics 
iteration rates ms ms ms ms 

worst case execution time tasks range ms 
sets assigned randomly range task iteration rate free variable argument 

deadlines maximised tasks sets deadline equal period 
tasks sets deadline equal set task set st de ned section 
case task largest set particular iteration rate member set st deadline equal period task 
figures comparisons approaches inexact analysis section exact analysis section composite analysis section discussed chapter 
comparisons free variable argument free variable argument respectively 
gures label inexact refers analysis task sets neglecting sets described section label comp refers results composite analysis label exact refers results exact form analysis 
axis graphs give ectiveness rating evidence gathered samples data point relates probability approach nd solution 
analysis performed number task set sizes range resource bands 
resource band covers range processor utilisation lower limit particular resource band labeled axis 
example location line axis value point relates resource band 
graphs number lines drawn correspond number tasks set approach tasks comp represents composite analysis task sets tasks 
exact approach gives value ectiveness task sets schedulable 
reason analysis performed schedulable tasks schedulability exact approach 
exact tasks comp tasks comp tasks comp tasks comp tasks comp tasks inexact tasks inexact tasks inexact tasks inexact tasks inexact effectiveness resource band comparison approaches free variable argument results show facts 
free variable argument leads improvement schedulability 

resource range ectiveness composite set analysis 
ectiveness falls higher levels resource range 

composite approach signi cantly ective inexact approach 
ectiveness restricted computational model simulation study repeated improved analysis restricted computational model derived sections 
aim highlight bene ts improved analysis 
shows ectiveness composite approach labeled comp improved blocking model compared composite approach improved blocking model labeled exact tasks comp tasks comp tasks comp tasks comp tasks comp tasks inexact tasks inexact tasks inexact tasks inexact tasks inexact effectiveness resource band comparison approaches free variable argument impr 
model 
results generated conditions section 
results show improvement ectiveness obtained range task set sizes 
greatest bene illustrated resource levels greater equal range task set sizes 
ectiveness better improved schedulability analysis 
resource level impact blocking caused non preemptive scheduler tends important 
exact comp impr 
model effectiveness number tasks comparison composite approach new blocking model resource range improvement composite set analysis section considers composite set analysis pessimism introduces 
number sources pessimism analysis due ideal attributes tcomp ccomp calculated composite task 
free variable argument ectively improves values tcomp 
ccomp particularly severe source pessimism 
control loops tasks provide example pessimism may arise 
rst tasks deal sensor actuator respectively 
tasks comparatively small worstcase execution time 
second task deal data calculations invariably larger worst case execution time tasks 
approach section composite task worst exact comp impr 
model effectiveness number tasks comparison composite approach new blocking model resource range case execution time equal worst case execution time second task transaction 
composite task representing rst third tasks large amount pessimism composite approach 
amount pessimism substantially reduced varying value ccomp time 
composite task set st de ned ordered version worst case execution times tasks set st set st de ned section 
ordering accordance decreasing value worst case execution time 
task set table set st de ned ordered version worst case execution times tasks st ordered version 
clearly worst case execution times descending order required 
st 
equation calculating worst case execution time composite task response time ri 
ccomp st tl ri ri ol st tcomp st represents th index set st range number tasks set st 
equation provides composite task worst case execution time interference tasks form composite task 
result divided maximum number times composite task execute 
interference calculation tasks form composite task executing order descending worst case execution time 
task ordering assumed order ensure worst possible interference obtained guarantee test su cient 
equation represents value ccomp worst case average computation time tasks form composite task period interest 
observation 
worst case execution time composite task varied time worst case execution times tasks form composite task cyclically descending order 
argument task forms composite task execute period critical instant point time common multiple tasks periods time range critical instant critical instant period tasks forms composite task 
task execution order sorted accordance descending worst case execution time worstcase situation greatest interference caused tasks 
tasks worst case execution times cyclically order de ned set st starting task maximum worst case execution time 
reason worse interference caused dependent tasks worst case execution times follow task maximum worst case execution time 
example tasks form composite task worst case execution times follows 
worstcase sequence tasks start task execution time sequence task maximum worst case execution time sequence 
illustrate equation works example provided 
task set table current value ri 
case higher priority tasks set task priority analysed composite task 
example shows worst case execution time schedulability analysis equations ectively reduced improvement 
st ri ol tl st ri ol tl dg st ri oa ta st ri ob tb st ccomp ri oc tc st ri od td st ri tcomp ccomp show ectiveness approach simulation conditions section worst case execution times altered 
simulation performed transactions having tasks rst task having worst case execution time range second task having case execution time range 
shows ectiveness composite approach labeled comp improvement compared composite approach improvement labeled impr 
model 
comparison purposes results provided analysis sets ignored labeled ignore offsets 
numbers label comp indicate resource range resource utilisation task sets range task sets 
exact comp impr 
model ignore offsets comp impr 
model ignore offsets effectiveness number tasks comparison approaches shows scenario original composite approach ective compared approach simply ignores sets 
modi ed composite approach performs ectively ective approaches 
summary chapter attempted derive appropriate approach timing analysis task sets feature sets 
technique developed compares favourably criteria successful technology transfer 

certi cation approach provides analysis guarantees system timing behaviour 
results analysis part certi cation evidence system 

reuse standard schedulability analysis de ned earlier chapters reused 
changes necessary limited amount pre post processing 
processing establish sets tasks messages check convergence 

su ciency approach place restrictions computational model 
su ciency criterion satis ed 
reduced pessimism compared inexact approaches increases likelihood timing requirements met 
noted appropriate selection set requirements increases likelihood system schedulable 

understanding approach considered understandable demonstrated fact technology transferred rolls royce guards project 
guards project esprit funded project addresses development architectures methods techniques tools support design implementation validation critical real time systems 
additional bene computational complexity reduced compared exact analysis 
chapter transition uniprocessor distributed system hardware aspects system shown bene saving cost weight transition uniprocessor distributed system 
transition reduce amount processor units sensors actuators 
advantage transition increase available processing resource system 
production veri cation distributed real time systems complex particularly safety critical systems need certify product 
number technical issues associated distributed systems 
issues include allocation task attribute assignment increasing robustness change timing analysis 
chapter concentrates issues making assumption allocation functionality processors largely physical position devices 
real challenge distributed scheduling cient implementation veri cation transactions involving processor 
con icting requirements imposed di erent components 
chapter intended build performed uniprocessor systems chapters smooth transition attained 
bene ts strategy ability investment existing tools education sta providing ability break system smaller parts 
structure chapter follows 
section shows composite set analysis chapter may part distributed approach 
section presents example distributed analysis composite set analysis may applied system timing requirements transition uniprocessor distributed system 
section presents evidence ectiveness composite set analysis compared phase modi cation protocol analysis release jitter approaches described section 
composite set analysis section literature survey provides background previous approaches release jitter phase modi cation protocol developed problem distributed scheduling timing analysis 
section highlights anumber problems 
brief problems 
release jitter approach event driven system considered di cult certify pessimism great 
exact analysis high computational complexity 
approaches lack robustness change processor system wide impact 
local memory local memory local memory memory layer watchdog clock processing device watchdog clock processing device watchdog clock processing device processing layer layer basic architectural structure system architecture considered general 
architecture illustrates main points 
processors separated signi cant distance 
assumed communication processors performed back plane 

processors communicate fully interconnected xed priority messages routed processors bus need gateways multiple hops 

architecture multiple versions infrastructure processor timing watchdog real time clock local memory discussed chapters 
assumed mechanism providing global time base available 
aim section develop approach scheduling timing analysis composite set analysis developed chapter 
computational model computational model developed intended address drawbacks release jitter exact analysis whilst harnessing advantages 
computational model proposed goals mind 
increase robustness change 
sporadic tasks utilised 
existing uniprocessor scheduling techniques chapters reused 
low computational complexity 
pessimism release jitter approach 
implementation aspects approach phase modi cation protocol discussed section sets enforce precedence 
brief task transaction set greater equal response time preceding task message delivers data preceding task case tasks exist di erent processors transaction 
strategy achieves precedence tasks irrespective tasks exist processor di erent processors 
implementation model sets global time base necessary 
shows execution sequence anumber tasks form transaction distributed system messages communicate data tasks 
show time task message may execute controlled 
example case task duration allowed execution commences message de nitely arrived ot rm 
message scheduled task completed om rt 
giving task set dispatch release simplicity greater worst case response time event trigger worst case arrival time message precedence maintained distributed system 
controlling precedence sets means timing analysis required task sets tasks sets 
proposed timing analysis developed chapter 
processor processor processor processor messages time key represents time execution may occur best case release time deadline diagram illustrate timing analysis transaction free variable argument chapter highlights potential pessimism composite analysis value tasks sets small 
de nition composite task section means values sets small period composite task small 
causes problems schedulability analysis performed interference term equation 
reason composite task higher priority smaller period causes interference 
potential solution seen free variable argument introduced section 
approach taken split set tasks similar fashion allocating tasks cyclic scheduler 
tasks transaction having period assigned sets tasks execute required order td td td example mth task set td transaction deadline 
ect adopting approach means free variable levels system distributed transactions individual processor 
equation suggested applying free variable argument slot time td 
tasks transaction index th task transaction value slot time calculated equation represents start time slot allocated particular task transaction task having slot 
slots ordered accordance precedence available response time transaction 
free variable argument applied shown algorithm set assigned ensures task executes allocated slot time preceding task message completed 
algorithm satis es constraint sets decreased 
algorithm 
algorithm determining task sets preceding task message slot time set slot time set preceding task message observation concerning sets associated slot times analogy tdma time division multiple access communications model 
tdma commonly communications model message allocated xed slot round robin scheduler 
represents example communications model provide tdma 
di erence model de ned chapter tdma model whilst messages assigned slots messages may overlapping slots 
cases arbitration provided priorities 
problems maintainability traditionally associated cyclic scheduler arise 
approach section equally applied system tasks scheduled xed priority technique messages tdma approach 
bene ts associated processor task processor task offset phasing tasks di erent processors observation 
evolution technology taken smaller step resulting steep learning curve high probability certi cation evidence may reused 
helps increase likelihood acceptance technology transfer exercise 
robustness change perceived bene ts free variable argument robustness change enhances maintainability saving veri cation time 
reason de ned bounds change processor necessitate system wide re veri cation 
illustrates timing characteristics processor ed ra ob ecting scheduling processor da ob 
software processor modi ed processor needs re analysed long timing requirements met 
timing requirements longer met timing analysis task attribute assignment system repeated 
approach represents partial move integration task attribute assignment timing analysis helps meet reduction pessimism robust analysis objectives 
contrast release jitter exact approaches release time task transaction equal preceding task completion time 
means change system wide repercussions 
noted cost occasional system wide change comparable release jitter approach change signi cantly exact approach steps need taken 
number envisaged bene ts free variable argument including resources spread time value set small 
purpose free variable argument applied analysis reasons 
real gains may achieved manipulating requirements achieve lower pessimism better scalability 
advantages composite set approach listed section 
obvious disadvantage pessimism exists 
explanation distributed systems timing analysis composite set analysis purpose section example set system timing requirements ect transition uniprocessor distributed system may understood respect timing analysis approach release jitter exact analysis composite set 
system characteristics set requirements example illustrated task set table transactions table 
columns table represent id name tasks transactions worst case execution time task period task deadline task transition id table task set characteristics transaction st nd rd transaction id task task task deadline table transaction characteristics tables provide system timing characteristics 
system timing characteristics de ned columns id table 
addition system timing requirements includes transactions table 
transaction identi er precedence order st task followed nd task followed rd task deadline requirement 
example transaction refers transaction requirement task followed task followed task complete time 
table contains results schedulability analysis single processor case 
column rs worst case response time single processor case 
results obtained assuming attributes assigned approach chapter 
results column rs indicate timing requirements met tasks rs id rs table task set characteristics schedulability analysis results making transition distributed system simple architecture provides basic architecture required support transition 
table table provides scheduling information results transition uniprocessor distributed system 
architecture features processors fully interconnected common 
table provides additional scheduling information support transition 
column identi es processor task allocated migration distributed system 
column symbol signi es message 
identi ers messages pre xed additional schedulability analysis results columns table table represent rj worst case response time tasks executed processors analysed release jitter approach re worst case response time tasks executed processors analysed exact analysis approach rc worst case response time tasks executed processors analysed composite set approach id rs rj re rc table task set characteristics schedulability analysis results table provides information transaction implemented distributed architecture 
table provided precedence constraints just tasks table includes relevant messages transferring data 
example message carries data task task message carries data task task 
schedulability analysis performed exact analysis approach results show transition distributed architecture system timing requirements schedulable 
transaction st st nd nd rd transaction id task message task message task deadline table transaction characteristics release jitter approach analyse system results column rj 
time results indicate task system longer schedulable 
analysis terminated soon task failed requirements response time exceeds deadline 
worstcase response times tasks nal values 
nal values certainly larger tasks may deadline 
results exact analysis clearly show release jitter approach great deal pessimism 
fact results imply splitting functionality number processors reduce likelihood system schedulable 
increasing system resources timing margin suggests system schedulable 
assumes cause great overhead case doesn 
composite approach results column rc pessimistic comparison exact approach system schedulable tasks rc example shows composite approach provides useful alternative exact approach cases computational complexity exact approach prohibitive pessimism issue 
explanation composite approach table helps explain composite approach works 
columns table meaning table 
additional columns refers worst case response time task calculated composite free variable approach refers priority task message met 
refers task message meets deadline tasks rc table number tasks id form refers composite task representing tasks period xxxxx 
instance case task node task represents original tasks table 
task inherits non zero set message task follows message transaction task maintains zero set part transaction 
table shows task set characteristics lead results table 
id met 
table schedulability analysis results composite approach number steps table table illustrated 
task set equivalent worst case response time message 

task combined composite task characteristics minf minf minf minf maxfc 
schedulability analysis performed calculate response times 

worst case response time task calculated equation rc 
worst case response time task calculated equation rc id table results generated composite approach free variable argument demonstrated considering task forms task composite approach 
set task 
free variable argument period composite task free variable argument 
resulting periods illustrate bene free variable argument interference tasks considerably reduced 
interference reduced composite task period deadline increased leading reduced priority increased chance schedulability 
simulation demonstrate relative effectiveness di erent computational models simulation studies ective way understand behaviour large complex systems demonstrated chapter 
section presents simulation investigation considered appropriate realistic results obtained 
simulations performed purely pseudo random task set characteristics realistic range iteration rate 
due typical sizes common multiple large number tasks computational complexity allow form comparison carried 
analysis task set characteristics expected feasibly computed 
system characteristics 
iteration rates 

worst case execution time tasks range 

worst case communication time messages 

number nodes range 

number tasks range 

anumber transactions range 
transactions number tasks equal number nodes task executing di erent processor 
transaction deadline equal period 

value ectiveness produced samples 
ectiveness percentage task sets calculated schedulable compared exact analysis 
simulation results tasks processor graphs contained figures respectively 
analysis rj rj free free comp comp effectiveness 
nodes comparison simulation results tasks technique lines lines results resources range results resources range 
results clearly show straight forward composite approach worst virtually task sets 
straight forward composite approach relates composite approach free variable argument applied 
free variable argument applied generally pessimism release jitter approach 
particular resource level higher range composite set analysis free variable argument performs better non free variable argument 
improvement provided composite set approach signi cant top bene ts 
composite set analysis free variable argument viable solution distributed timing analysis 
release jitter approach performs better resource level small 
better performance consequence tasks response times smaller leads set release jitter relevant depen rj rj free free comp comp effectiveness 
nodes comparison simulation results tasks rj rj free free comp comp effectiveness 
nodes comparison simulation results tasks dent technique enforce precedence small 
set release release jitter small release jitter analysis pessimism composite set analysis 
summary chapter attempted achieve number goals investigate transition uniprocessor distributed systems timing reduce pessimism combining task attribute assignment timing analysis signi cantly increasing computational complexity 
chapter shows existing uniprocessor timing analysis may distributed systems 
previous approaches sporadic tasks introduce pessimism may di cult certify 
example represents transition executing functionality single processor executing functionality processors 
processors equivalent original single processor 
processors fully interconnected 
set schedulable single processor system processor system analysed release jitter approach 
shows making transition distributed system necessarily system schedulable processor resource available increased 
new approach derived sets realistically spread resource usage time help remove pessimism caused unnecessary clashes 
solve computational complexity issues usually set analysis composite set analysis chapter 
composite approach large amount pessimism 
free variable argument applied selection sets order better integrate task attribute assignment timing analysis 
combination sets model system interaction composite analysis achieved signi cantly better ectiveness tractable approaches 
bene ts include free variable argument gives properties non holistic de ned bounds sets analogous tdma system aid reuse 
technique developed compares favourably criteria successful technology transfer 

certi cation approach provides analysis guarantees system timing behaviour 
results analysis part certi cation evidence system 

reuse standard schedulability analysis de ned earlier chapters reused 
changes necessary limited amount pre post processing 
processing establish sets tasks messages check convergence 

understanding approach considered understandable demonstrated example 
addition approach accepted rolls royce considered projects 

su ciency approach place restrictions computational model provides lower level pessimism release jitter approach 
argued su ciency criterion satis ed 
chapter purpose chapter summarise evaluate thesis contributions providing insight performed 
principal aims thesis augment current scheduling timing analysis valid real industrial safety critical hard real time systems 
particular transitions supported 
cyclic scheduling xed priority scheduling uniprocessor distributed systems 
rst part thesis establish base line take place 
involved establishing characteristics current systems developed dealt chapter 
survey performed examine relevance existing results chapter 
support rst transition investigation required existing infrastructures reused ectively appropriate timing analysis derived task attributes assigned 
support second transition approach handling distributed transactions sought takes advantage performed rst transition 
guide investigation undertaken criteria successful technology transfer de ned certi cation understanding su ciency reuse 
criteria judge proposed solutions successful 
chapter contrasts requirements system developed existing theory available determine attention needed 
number areas identi ed 
part chapter scheduling approach periodic tasks executing non preemptively chosen 
approach maximises reuse existing system documentation reduces cost change eases certi cation 
revisits existing schedulability analysis provides signi cant reductions pessimism contained analysis 
chapter presents way implementing task scheduling takes advantage existing mechanisms tick driven time driven scheduling 
hybrid approach intended provide best compromise reuse su ciency 
technique uses clock tick cyclic scheduler release tasks cases task period integer multiple clock tick rate 
remaining tasks released manner 
approach existing 
advantages minimum possible change way tasks released restrictions placed timing requirements tasks released jitter 
having release jitter increases likelihood meeting timing requirements 
contribution chapter philosophy producing infrastructure tailored requirements whilst recognising importance reuse 
approach provides best possibility achieving system timing requirements time minimising changes system 
chapter presents algorithm assigning attributes tasks timing requirements met 
technique intended requirements existing single processor system 
requirements satis ed possible task attribute assignment process task jitter task separation transaction deadline 
task attributes manipulated sets deadlines 
approach novel contribution number reasons 
resulting task attributes relatively easy determine inspection timing requirements met assignment preserves attributes imposed constraints 
point considered important 
existing approaches task attribute assignment su er problem attributes considered exible 
experience shown tasks periods manipulated tasks deadlines increased 
existing constraints previously satis ed may broken 
existing techniques place restrictions task attribute assignment deemed unsuitable 
chapter uses realistic case study aircraft engine control system prove techniques developed chapters su cient 
part evaluation scheduler produced control aircraft engine 
evaluation showed scheduler controlled engine equivalent improved stability 
analysis provided better evidence certi cation previous methods cyclic scheduling 
approach deemed successful awaiting actual project 
key nding case study high level reuse obtained changes system scheduler module rest software hardware unchanged 
consequence case study ects transition xed priority scheduling typical process life cycle investigated 
part case study included techniques rolls royce 
part involved teaching engineers specialist knowledge scheduling timing analysis apply techniques 
engineers understand techniques complex real examples hour strong indication techniques suitable 
number issues need stringent requirements highlighted 
key issue ability certify approach 
considered detail show necessary evidence gathered 
part necessary evidence approach safe existing approaches additional hazards introduced system 
author colleagues deals issue certi cation approach 
chapter investigates timing analysis may performed task sets tasks sets 
approach forming composite task analysis purposes zero sets replace tasks non zero sets 
approach supplemented free variable argument increases value task sets analysis pessimistic 
free variable argument assigns regularly spaced slots task 
number aims reuse existing analysis provide understandable technique pseudo computational complexity achieve low pessimism 
respect approach considered novel 
part investigated existing uniprocessor timing analysis improved speci computational model 
principal bene ts technique fact existing schedulability analysis limited amount pre post processing 
number bene ts able reuse analysis including fact existing tools training limited amount extra certi cation evidence needed 
chapter investigates scheduling timing analysis derived chapters distributed scheduling maximum reuse infrastructure timing analysis may attained 
approach derived sets control precedence distributed transactions 
task attributes derived represent system timing requirements including distributed ones 
allows veri cation performed individual processor time 
timing analysis set analysis developed chapter 
approach developed novel achieves number goals 
goals robustness change improved high levels reuse attained pessimism reduced compared existing published 
author contributed addressed certi cation issues 
principal bene ts reuse existing tools training standard uniprocessor schedulability analysis relatively small amount pre post processing 
number areas performed 

investigate pessimism set analysis improved techniques exact analysis analysis assumes critical instant composite analysis deemed preferable 
investigation consider conditions needed schedulability analysis analysis better absolutely necessary adopt exact analysis 
approach derived lower pessimism composite approach small increase average computational complexity 

context distributed scheduling free variable uses linear time slicing transaction execution window assigning individual tasks execution window 
investigation performed looked exible free variable arguments cases existing mechanism results solution 
task transaction new execution current laxity tasks transaction 
search mechanisms employed nd best set task attributes best schedulable greatest robustness change 

investigation optimised free variable argument selects value tasks sets iterative manner simple linear equation 
way achieved branch bound search range values sets minimum possible set maximum possible set choose best value 
best judged likelihood schedulable system obtained secondary criteria reduced computational complexity change 

examine best deal distributed transactions arbitrary deadlines 
preliminary inspections shown current technique sets composite analysis supports distributed transactions arbitrary deadlines 
required justify statement investigate ectiveness attained 
final comment chapter contention aimed supporting development veri cation schedulers industrial safety critical hard real time systems proposed simpli ed version xed priority scheduling ease problem meeting timing requirements immediate industrial safety critical embedded systems 
support contention criteria formed guide solutions successful technology transfer may achieved 
criteria certi cation su ciency understanding reuse 
criteria guided solutions derived possible criteria met 
brief summary approaches relate criteria 
certi cation timing analysis provides valuable evidence certi cation system argued changes infrastructure lower system integrity 
approaches derived relevant certi cation authorities approved aircraft engine 

su ciency approaches allows tasks released ciently reasonable overheads ectively jitter restrictions task attributes small selection possible iteration rates 

understanding success reinforced fact techniques transferred industry 
rolls royce evaluated techniques aircraft engine decided suitable project 
evaluation engineers understand techniques complex real examples hour strong indication techniques suitable 
distributed scheduling techniques evaluated current department trade industry funded industrial research project ministry defence funded industrial research project 

reuse approaches rolls royce changes necessary system software module scheduler applications actual hardware altered 
addition tools produced task attribute assignment schedulability analysis 
approach demonstrates high level reuse attained 
list seen largely met objectives 
bibliography military standard system safety program requirements tech 
rep department defence january 
burns mcdermid real time safety critical systems analysis synthesis software engineering journal vol 
pp 
nov 
softw 
eng 

uk 
multi integrity level software uni processor systems master thesis department computer science university york 
turner customer needs controls design control generation civil military engines variable cycle engines role pp 
november 
thompson application cots technologies aerospace gas turbine engine control iee colloquium cots safety critical systems 
digest number january 
locke software architecture hard real time applications cyclic executives vs xed priority executives real time systems vol 
pp 
march 
real time syst 
netherlands 
yeh dependability primary ight control system th ifip working conference dependable computing critical applications 
edwards parr key issues integrated modular avionics viewpoint era avionics conference pp 
avionics application software standard interface draft 
airlines electronic engineering committee june th 
liu layland scheduling algorithms multiprogramming hard real time environment acm vol 
pp 

baker task scheduling real time processes journal real time systems vol 
pp 

carpenter driscoll ni scheduling problem ieee real time systems symposium 
incidence transfer limited ieee transactions engineering management vol 
pp 
november 
making university industry collaborative research succeed research technology management vol 
pp 

models technology transfer universities research laboratories technology management pp 

fundamentals implementing real time control applications distributed computer systems real time systems vol 
pp 
may 
locke goodenough generic avionics software speci cation tech 
rep cmu sei tr software engineering institute 
knight enforcement software safety policies th annual ieee conference computer assurance june 
graham control theory including optimal control 
wiley 
thompson oxford quick dictionary 
oxford university press 
luck observability delay compensation control systems 
phd thesis department mechanical engineering state university usa 
de nition design implementation control laws variable cycle gas turbine aircraft engines design control generation civil military engines variable cycle engines role november 
ray integrated communication control systems part analysis part design considerations asme journal dynamic systems measurements control pp 
december 
wittenmark nilsson timing problems realtime control systems problem formulation proceedings american control conference 
rushby kernel safety safe secure computing systems ed 
united kingdom ministry defence defence standard requirements safety related software defence equipment july 
mcdermid formal methods relevance development safety critical systems computer journal vol 

burns wellings bailey fyfe attitude orbital control system case study hard real time system design implementation pp 
springer verlag 
burns wellings safety kernels speci cation implementation design development safety kernels vol 
york software engineering health safety executive nuclear research programme 
locke best ort decision making real time scheduling 
phd thesis computer science department carnegie mellon university usa 
tannenbaum computer networks 
prentice hall ed 
united kingdom ministry defence defence standard issue safety management requirements defence systems december 
rtca software considerations airborne systems equipment certi cation ed december 
defence procurement safety critical software defence equipment interim defence standard def stan tech 
rep april 
papadopoulos mcdermid potential generic approach certi cation safety critical systems transportation sector reliability engineering system safety vol 
pp 
elsevier january 
burns mcdermid vickers xed priority scheduler aircraft application th euromicro workshop real time systems italy pp 
june 
mcdermid software engineer book 
butterworth heinemann 
software engineering 
addison wesley th ed 
booch bryan software engineering ada 
benjamin cummins rd ed 
spark spade ada kernel edition tech 
rep program validation limited 
koza calculating maximum time real time programs real time systems vol 
pp 

park predicting program execution times analyzing static dynamic program paths real time systems vol 
pp 

park shaw source level tool predicting deterministic execution times programs tech 
rep department computer science engineering university washington usa 
leveson system safety computers 
addison wesley 
garey johnson computers intractability 
burns hayes richardson generating feasible cyclic schedules control engineering practice vol 
pp 

sha lui goodenough real time scheduling theory ada computer vol 
pp 
april 
computer usa 
architecture space shuttle primary avionics software system communications acm vol 
pp 
sept 
commun 
acm usa 
scheduling time critical processes proceedings afips spring computing conference 
lehoczky sha ding rate monotonic scheduling algorithm exact characterization average case behaviour proceedings ieee real time systems symposium pp 

audsley burns davis wellings fixed priority pre emptive scheduling historical perspective real time systems vol 
pp 
march may 
real time syst 
netherlands 
katcher engineering analysis xed priority schedulers ieee trans 
software engineering vol 
pp 
sept 
ieee trans 
softw 
eng 
usa 
leung note preemptive scheduling periodic real time tasks information processing letters vol 
november 
audsley flexible scheduling hard real time systems 
phd thesis department computer science university york december 
lehoczky fixed priority scheduling periodic task sets arbitrary deadlines real time systems symposium pp 
december 
harter response times level structured systems tech 
rep cu cs department computer science university colorado usa 
harter response times level structured systems acm trans 
computer systems vol 
pp 
aug 
acm trans 
comput 
syst 
usa 
joseph problem real time computing information processing letters vol 
pp 

joseph finding response times real time system computer journal vol pp 
oct 
comput 

uk 
audsley burns richardson wellings hard real time scheduling deadline monotonic approach proceedings th ieee workshop real time operating systems software pp 

leung whitehead complexity xed periodic real time tasks performance evaluation vol 
pp 

holistic scheduling analysis distributed hard real time systems 
department computer science university york 
gerber hong guaranteeing timing constraints calibrating intermediate processes ieee real time systems symposium 
scalability real time systems 
phd thesis computer science department old dominion university august 
lampson redell experience processes monitors mesa communications acm vol 
pp 
feb 
commun 
acm usa 
rajkumar sha lehoczky real time synchronisation protocols multiprocessors ieee real time systems symposium pp 

sha rajkumar lehoczky priority inheritance protocols approach real time synchronization ieee trans 
computers vol 
pp 
sept 
ieee trans 
comput 
usa 
rajkumar sha lehoczky ramamritham optimal priority inheritance protocol real time synchronisation tech 
rep coins technical report 
clark holistic schedulability analysis distributed hard real time systems microprogramming vol 
pp 
april 
gutierrez garcia harbour schedulability analysis distributed real time systems th euromicro workshop real time systems pp 
burns wellings ective analysis engineering real time xed priority schedulers ieee transactions software engineering vol 
pp 
may 
burns wellings fyfe attitude orbital control system case study hard real time system design implementation 
dept computer science university york bailey british aerospace space systems january 
sun liu synchronization protocols distributed real time systems th international conference computing systems may 

liu scheduling meet deadlines distributed systems proceedings ieee international conference distributed computing systems pp 
june 
di stankovic dynamic guarantees distributed real time systems proceedings ieee real time systems symposium pp december 
shin jonsson robust adaptive metrics deadline assignment distributed hard real time systems submitted ieee transactions computers 
garcia harbour optimized priority assignment tasks messages distributed real time systems ieee parallel distributed systems pp 
aarts korst simulated annealing boltzmann machines 
chichester john wiley sons techniques 
algorithm tutorial tech 
rep cs 
kopetz real time systems 
design principles applications 
kluwer academic publications 
kopetz schutz design real time systems speci cation implementation veri cation software engineering journal vol 
pp 
may 
softw 
eng 

uk 
kopetz fault tolerant membership service synchronous distributed real time systems tech 
rep institut fur technische informatik technische wien february 
edwards phase concept summary proceedings era avionics conference exhibition london uk 
gosling joy steel java language speci cation 
addison wesley 
fletcher wake bradley integrated modular avionics certi cation ima design team view seminar certi cation ground air systems institute electrical engineers february 
audsley timing analysis integrated modular avionics systems proceedings era avionics conference exhibition 
shin 
chang reservation algorithm scheduling periodic aperiodic real time tasks ieee transactions computers vol 
pp 
december 
stankovic real time computer systems generation tech 
rep coins technical report number 
audsley burns road static cyclic scheduling proceedings th euromicro workshop real time systems pp 
department defence manual ada programming language 
ansi mul std 
ada language manual 

iso iec 
barnes high integrity ada spark approach 
addison wesley 
iso wg guidance ada programming language high integrity systems ed september 
mcdermid cots expensive solution iee colloquium cots safety critical systems 
digest number january 
burns wellings real time systems programming languages 
addison wesley nd ed 
hayes technology transfer certi cation issues safety critical real time systems digest iee colloquium real time systems april 
campbell randell error recovery asynchronous systems ieee trans 
software engineering vol 
vol se pp 
aug 
ieee trans 
softw 
eng 
usa 
bertossi mancini scheduling algorithms fault tolerance hard real time systems real time systems vol 
pp 
nov 
real time syst 
netherlands 
gerber hong guaranteeing real time requirements resource calibration periodic processes ieee trans 
software engineering vol 
pp 
july 
ieee trans 
softw 
eng 
usa 
gutierrez garcia harbour best case analysis improving worst case schedulability test distributed hard real time systems th euromicro workshop real time systems pp 

audsley burns putting xed priority scheduling engineering practice safety critical applications proceedings real time technology applications symposium pp 
ieee technical committee real time systems 
burns flexible scheduling engine controllers tech 
rep uk patent application number patent application number patent ce may 
audsley burns flexible scheduling theory advanced engine controllers iee hybrid control real time systems institute electrical engineers december 
wilson mcdermid spineless safety cases structured method comprehensive tool support nd international conference control instrumentation nuclear installations institution nuclear engineers april 
fixed priority scheduling hard real time systems 
phd thesis department computer science university york 
oh son processor cient scheme supporting faulttolerance rate monotonic scheduling tech 
rep cs department computer science university virginia 
koza heuristic scheduling distributed real time systems tech 
rep research report institut fur technische informatik technische wien austria 
knight cass fernandez fixed priority scheduling periodic tasks multiprocessor systems tech 
rep cs department computer science university virginia 
burns kelly mcdermid building preliminary safety case example aerospace proceedings australian workshop industrial experience safety critical systems software october 

