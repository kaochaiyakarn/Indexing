siam comput 
vol 
pp 
society industrial applied mathematics compressed suffix arrays suffix trees applications text indexing string matching roberto grossi jeffrey scott vitter 
proliferation online text world wide web online databases motivates need space efficient text indexing methods support fast string searching 
model scenario follows consider text consisting symbols drawn fixed alphabet 
text represented lg bits encoding symbol lg bits 
goal support fast online queries searching string pattern symbols fully scanned index created preprocessing time 
text indexing schemes published literature greedy terms space usage require lg additional bits space worst case 
example standard unit cost ram suffix trees suffix arrays need memory words lg bits 
indexes larger text multiplicative factor lg significant constant size ascii unicode 
hand indexes support fast searching lg lgn time plus output sensitive cost occ listing occ pattern occurrences 
new text index compressed representations suffix arrays suffix trees 
achieves fast lg lg search time worst case constant lg bits storage 
result presents time efficient index size provably linear size text worst case scenarios space sublinear practice 
concrete example compressed suffix array typical mb ascii file require mb raw suffix array requires mb 
theoretical bounds improve time space previous indexing schemes 
listing pattern occurrences introduces slowdown factor output sensitive cost giving occ lg time result 
patterns sufficiently long auxiliary data structures lg bits obtain total search bound lg occ time optimal 
key words 
compression text indexing text retrieval compressed data structures suffix arrays suffix trees string searching pattern matching ams subject classifications 
doi 


great deal textual information available electronic form online databases world wide web devising efficient text indexing methods support fast string searching important topic investigation 
typical search scenario involves string matching text string length input pattern string length goal find occurrences symbol belongs fixed alphabet size occurrence pattern position means substring equal denotes concatenation symbols received editors february accepted publication revised form may published electronically october 
preliminary version results appears 
www siam org journals html dipartimento di informatica universit di pisa pisa italy grossi di unipi 
author supported part united nations educational scientific cultural organization unesco italian ministry research education 
department computer sciences purdue university west lafayette jsv purdue edu 
part done author duke university sabbatical inria sophia antipolis france 
supported part army research office muri daah daad daad national science foundation research ccr iis 
compressed suffix arrays positions 
consider types string matching queries existential counting enumerative 
existential query returns boolean value indicates contained counting query computes number occ occurrences occ enumerative query outputs list occ positions occurs efficient offline string matching algorithms knuth morris pratt answer individual query time efficient text scan 
large mass existing online text documents infeasible scan documents query typically larger pattern length number occurrences occ 
scenario text indexes preferable especially efficient string searches performed set text documents 
text needs entirely scanned preprocessing time indexes created 
searching output sensitive time complexity online query proportional lg occ lgn occ sufficiently large 
popular indexes currently inverted lists signature files 
inverted lists theoretically practically superior signature files 
versatility allows kinds queries exact boolean ranked answers variety output formats 
efficient indexes texts structured long sequences terms words partitioned nonoverlapping substrings ik jk terms ik jk ik refer set terms vocabulary 
distinct term vocabulary index maintains inverted list position list ik occurrences term result order search efficiently search queries limited terms prefixes allow efficient searching arbitrary substrings text string matching problem 
reason inverted files referred term level word level text indexes 
searching unstructured text answer string matching queries adds new difficulty text indexing 
case arises dna sequences eastern languages chinese welldefined notion terms 
set successful search keys possibly larger set terms structured texts consists feasible substrings distinct substrings worst case number distinct terms considered nonoverlapping substrings 
suffix arrays suffix trees similar tries automata prominent data structures unstructured texts 
handle search keys memory words referred full text indexes 
suffix tree text compact trie leaves represent text suffixes 

compact mean internal node children 
edge tree labeled symbols purposes search navigation 
leaf value represents suffix 
leaf values order traversal tree represent suffixes lexicographic order 
example suffix tree appears 
suffix array sa sa text consists values leaves suffix tree order tree structure information 
words sa means smallest suffix lexicographic order 
suffix array corresponding suffix tree appears 
roberto grossi jeffrey scott vitter bab fig 

suffix tree built text length character string symbol 
rightmost subtree triangle representing suffixes form bb expanded 
edge label edge leading leaf value denotes remaining characters suffix traversed 
example suffix lexicographic format suffix edge represents symbol substring follows prefix aa 
speed searches separate array maintained contains auxiliary information lengths longest common prefixes subset suffixes 
suffix trees suffix arrays organize suffixes support efficient search prefixes 
search pattern order find occurrence exploit property prefix suffix 
general existential counting queries take lg time automata suffix trees variations take lgn time suffix arrays longest common prefixes 
enumerative queries take additive output sensitive cost occ 
term suffix array denote array containing permutation positions longest common prefix information mentioned 
full text indexes suffix arrays powerful term level inverted lists full text indexes implement inverted lists efficiently storing suffixes ik correspond occurrences terms 

issues space efficiency 
suffix arrays suffix trees data structures increasing importance growing list applications 
string searching significant molecular biology data compression data mining text retrieval name applications 
sizes data sets applications extremely large space occupancy critical issue 
major disadvantage limits applicability text indexes suffix arrays suffix trees occupy significantly space inverted lists 
compressed suffix arrays abba ba 
fig 

suffix array text shown note array values correspond leaf values suffix tree traversed order 
illustrate point careful accounting space requirements unit cost ram model 
assume symbol text encoded lg bits total lg bits 
suffix arrays positions suffixes stored permutation lg bits kept array consisting words lg bits 
suffix trees require considerably space lg lg bits stored words 
contrast inverted lists require approximately text size suffix arrays suffix trees require significantly bits 
theoretical point view alphabet large lg lg suffix arrays require roughly number bits text 
practice alphabet size typically fixed constant electronic documents ascii larger unicode format dna sequences 
cases practice suffix arrays suffix trees larger text significant multiplicative factor lg lg 
example dna sequence symbols stored bits computer 
suffix array sequence requires words bytes bits times larger text 
hand resort inverted files support general search unstructured sequences 
notation lg log log log denote cth power base logarithm base specified implied base 
roberto grossi jeffrey scott vitter munro raman rao solve open question raised muthukrishnan showing represent suffix trees lg bits allowing time search binary pattern strings length result highlights conceptual barrier lg bits storage needed text indexing 
go step investigate possible design full text index lg bits supporting efficient search 
question space usage important theory practice 
prior state art taken granted lg bits needed represent permutation text positions efficient full text index 
hand note text symbols correspondence suffix array easily see simple information theoretic argument lg bits required represent permutation 
argument fact different text strings length alphabet different suffix arrays need lg bits distinguish 
interesting problem close gap order see efficient representation suffix arrays nearly lg bits worst case random strings 
order idea computational difficulty question follow simple approach saves space 
consider binary alphabets 
bunch lg bits word effect constructing large alphabet create text length lg pattern length lg suffix array new text requires lg lgn bits 
searching pattern length consider situations pattern aligned precise word boundaries 
searching cost 
appears handle lg situations slowdown factor lg time complexity search 
really pay larger slowdown factor search cost querying text index expensive running time algorithms scratch 
see examine situation pattern occurs positions right word boundary text 
order query index align pattern boundary padding bits left pattern 
know correct bits prepend pattern try possible settings bits 
lg query index times worst case 
see sparse suffix trees cited section partially alleviate drawback 
example shows small reduction index size querying index useless worst case cost performing full scan text scratch 
section describe previous results motivated need find efficient solution problem designing full text index saves space time worst case 
data structures functionality suffix trees suffix arrays appeared literature date lg lg bits support fast queries lg lgn worst case time 
goal simultaneously reduce space bound query time bound 

results 
study compressibility suffix arrays related full text indexes 
assume simplicity alphabet bounded size ascii unicode utf 
recall suffix array sa text stores suffixes lexicographic order shown 
represent sa form permutation starting positions compressed suffix arrays suffixes sa sa lexicographic order 
call entry sa suffix pointer 
text suffix array sa consider problem obtaining compressed suffix array sa support basic operations 
compress sa compress sa obtain succinct representation 
text retained sa discarded 

lookup compressed representation mentioned return sa suffix pointer ith suffix sa lexicographic order 
functionalities introduced 
primary measures performance query time lookup amount space occupied compressed suffix array preprocessing time space taken compress 
exploit implicit structure underlying permutation suffix pointers stored sa takes advantage fact permutations valid suffix arrays 
fixed value show implement operation compress lg lg bits call lookup takes worst case time lg time 
achieve lg lg lg bits calls lookup done lg lg time 
preprocessing time lg 
note auxiliary space preprocessing larger lg bits preprocessing requires suffix array uncompressed form output compressed form 
findings implications follows 
lg break space barrier lg bits suffix array retaining lg lookup time worst case 
refer reader literature described section 
implement form compressed suffix trees lg bits compressed suffix arrays techniques compact representation patricia tries 
occupy asymptotically small constant factor space text string indexed 

compressed suffix arrays compressed suffix trees provably inverted lists terms space usage theoretically 
worst case require asymptotically number bits 

build hybrid full text index lg bits suitable combination compressed suffix trees previous techniques 
answer existential counting queries pattern string length lg lg search time worst case min lg lgn smaller previous search bounds 
enumerative queries introduce slowdown factor output sensitive cost giving occ lg time result 
patterns sufficiently long lg lg lg auxiliary data structures lg bits obtain total search bound lg occ time optimal 
bounds claimed point need elaboration 
specifically searching takes time lg lg lg lg time 
achieve optimal lg search time sufficiently large lg enumerative queries retrieving occ occurrences 
cost lg occ lg conditions lg lg occ hold cost lg occ lg lg 
roberto grossi jeffrey scott vitter results described theoretical substantial practical value 
ideas described extensions described tested experimentally discussed section 
central algorithms definition function implications described section 
function heart subsequent papers compressed text indexing suffix links suffix trees binary search trees sorted dictionaries join operators relational databases major product findings 
ultimately related compression represents inverse mapping burrows wheeler transform 
refer interested reader section state art compressed text indexing section discussion function 

related 
seminal knuth morris pratt provides string matching solution time words scan text 
space requirement remarkably lowered words 
new paradigm compressed pattern matching introduced explored efficiently scanning compressed texts 
queries performed text better resort text indexing 
relevant introduced variant suffix tree solving text indexing problem string matching 
pointed importance text indexing tool avoid full scan text pattern search 
method takes lg search time plus output sensitive cost occ report occurrences occ plethora papers studied text indexing problem contexts different terminology see 
efficient resulting index data structures greedy terms space words lg bits 
numerous papers faced problem saving space data structures practice theory 
papers aimed improving lower order terms constants higher order terms achieving tradeoff space requirements search time complexity 
authors improved multiplicative constants lg bit practical implementations 
analysis constants refer reader :10.1.1.42.9224:10.1.1.14.8675
authors devised variations sparse suffix trees store subset suffixes 
wanted queries efficient occurrences aligned boundaries indexed suffixes 
sparsity saves space search arbitrary substrings difficult worst case expensive scanning text time 
interesting index lempel ziv index occupies bits takes time search patterns shorter lg output sensitive cost reporting occurrences longer patterns may occupy lg bits 
efficient practical compressed index discussed searches word level full text arbitrary substrings 
alternative line research built succinct representation trees bits navigational operations 
representation extended represent suffix tree lg bits plus extra lg lg expected number bits 
solution requiring lg bits search time described 
munro raman rao improved succinct representation balanced parentheses order get lg search time lg bits 
show get time compressed suffix arrays lg lg lg bits existential queries binary patterns 
preliminary version results stimulated search www scholar google com may interesting results appeared citing 
question raised concerns lower bounds 
assuming text read stronger version bit probe model demaine pez ortiz shown worst case text index alphabet size supports fast queries probing bits text bits extra storage space 
see general class lower bounds 
index space optimal sense 
second concerns compressible text 
ferragina manzini devised fast minute index fm index burrows wheeler transform asymptotically achieves order empirical entropy text allows obtain self indexing texts compressed text index sequence bits 
shown compressed suffix arrays self indexing texts space bound order entropy 
uses lemma section show store skip values suffix tree bits 
space compressed suffix arrays reduced order entropy multiplicative constant grossi gupta vitter novel analysis finite set model 
compressed suffix array fm index require lg auxiliary bits space preprocessing third question arises concerning construction 
hon sung shown build compressed suffix array fm index lg bits auxiliary space text small bookkeeping data structures 
numerous papers appeared representing new trend text indexing causing space efficiency longer major obstacle large scale application index data structures 
ideally find index uses bits possible supports enumerative queries query pattern sublinear time worst case addition output sensitive cost 

outline 
section describe ideas new data structure compressed suffix arrays including function 
details compressed suffix array construction section 
section show compressed suffix arrays construct compressed suffix trees general space efficient indexing mechanism speed text search 
give final comments section 
adopt standard unit cost ram analysis algorithms previous compare 
standard arithmetic boolean operations words lg bits 
operation takes constant time word read written constant time 

compressed suffix arrays 
compression suffix arrays falls general framework jacobson optimization data structures 
start specification data structure data type supported operations 
take time complexity natural space efficient implementation data structure 
define class cn distinct data structures storing elements 
simple information theoretic argument implies data structure canonically identified lg cn bits 
try give succinct implementation data structure lg cn bits supporting operations time complexity comparable natural implementation 
information theoretic argument guarantee operations supported efficiently 
roberto grossi jeffrey scott vitter define suffix array sa binary string data type supports operations compress lookup described 
adopt convention binary string length alphabet terminated nth position special string symbol discuss case alphabets size section 
suffix array sa permutation corresponds lexicographic ordering suffixes sa starting position ith suffix lexicographic order 
example shows suffix arrays corresponding binary strings length aaaa aabb abab abba baba babb bbbb natural explicit implementation suffix arrays requires lg bits supports lookup operation constant time 
optimization discussed suggests canonical way represent suffix arrays bits 
observation follows fact class cn suffix arrays distinct members binary strings length 

permutations necessarily suffix arrays 
intuitive correspondence suffix arrays length binary strings length 
correspondence suffix array sa infer associated binary string vice versa 
see entry sa corresponding suffix lexicographic order 
symbol positions pointed sa sa sa symbol positions pointed sa sa sa 
example suffix array th examples suffix corresponds second entry 
preceding entry string position 
subsequent entries bs positions 
resulting string 
optimization say regarding efficiency supported operations 
correspondence define trivial compress operation transforms sa sequence bits plus string 
drawback cost lookup 
takes time decompress single suffix pointer sa build suffix array scratch 
words trivial method proposed far support efficient lookup operations 
section describe efficient method represent suffix arrays bits fast lookup operations 
idea distinguish permutations relating suffixes corresponding strings studying 
mimic simple divide conquer deconstruction suffix arrays define permutation arbitrary random string recursively terms shorter permutations 
examples divide conquer usually symbol character explicitly stored implicitly represented blank symbol ordering convenient showing explicit correspondence suffix arrays binary strings 
compressed suffix arrays construction suffix arrays suffix trees see 
reverse construction process discover recursive structure permutations compression possible 
describe decomposition scheme section giving intuition compression section 
summarize results obtained section 

decomposition scheme 
decomposition scheme simple recursion mechanism 
sa suffix array binary string base case denote sa sa number entries 
simplicity exposition assume 
inductive phase start suffix array sak available induction 
nk entries stores permutation nk 
intuitively permutation resulting sorting suffixes suffix pointers multiples run main steps follows transform sak equivalent succinct representation step 
produce bit vector bk nk bits bk sak bk sak 
step 
map bk companion 
say certain companion certain odd entry sa associated entry sa associated 
denote correspondence partial function sak odd sak sak 
defined implies bk bk 
convenient total function setting sak bk 
summary nk wehave sak odd sak sak 
step 
compute number prefix bk 
function rank purpose rank counts bits bk 
step 
pack values sak divide 
resulting values form permutation nk nk nk 
store new suffix array sak nk entries remove old suffix array sak 
example illustrates effect single application steps 
sa sa 
new suffix array sa explicitly stores suffix pointers divided suffixes start positions original text example sa means third lexicographically smallest suffix starts position starting position 
sa rank sa roberto grossi jeffrey scott vitter procedure return sa return rank bk 
fig 

recursive lookup entry sak compressed suffix array 
lemma shows steps preserve information originally kept suffix array sak 
lemma 
suffix array sak bk rank sak result transformation performed steps phase reconstruct sak sak formula nk sak sak rank bk 
proof 
suppose bk 
step rank bk bk bk 
step sak step sak stored rank th entry sak 
words sak sak rank step bk obtain claimed formula 
suppose bk 
step sak sak bk 
consequently apply previous case analysis index get sak sak rank claimed formula follows replacing noting bk 
previous example sa sa rank 
give main ideas perform compression suffix array sa support lookup operations compressed representation 
procedure compress 
represent sa succinctly executing steps phases exact value lg lg determined section 
result levels information numbered form compressed representation suffix array sa follows 
level stores bk rank store sak refer sake discussion 
arrays rank stored explicitly stored specially compressed form described section 
level stores sa explicitly sufficiently small fit bits 
th level functionality structures rank needed result 
procedure lookup 
define lookup procedure described recursively level 
level performs direct lookup sa 
exploits lemma inductive hypothesis returns value sak rank bk sak 

compressibility 
previously mentioned bk rank key ingredients representing compressed suffix array 
storing bk rank succinctly constant time access done previous see 
focus function heart compressed suffix array compression challenging 
giving intuition compressibility comments order 
observe analogue suffix links mccreight compressed suffix arrays suffix tree construction 
recall suffix link node storing nonempty string points node storing 
clear consider extension defined section follows sak nk sak sak 
position sa suffix sa returns position sa suffix sa seen suffix link sa sa 
analogously see suffix links positions sak 
functions seen products suffix array construction 
inverse suffix array sa array satisfying sa sa sa sa note sa defined sa stores permutation sa sa analogous argument holds 
order see compressible focus 
consider values example section see particular order 
restrict focus positions having value leading character corresponding suffix sa observe values positions yield increasing sequence 
example choosing leading character condition find positions satisfying condition 
corresponding values respectively 
values form sorted sequence called list implicitly represented ways 
clearly represent lists distinct characters appear text list 
represent lists relating positions companion 
preceding character position sa sa sa 
implicitly associate preceding character position entry containing 
example case list positions corresponding preceding character exactly items list 
motivation nice property suffixes remain sorted relative order interspersed suffixes remove leading character 
exploiting relation implement constant time access values needing store explicitly 
details represent rank compressed form implement compress lookup section 

results 
main theorem gives resulting time space complexity able achieve 
theorem binary alphabets 
consider suffix array sa built binary string length 
implement compress lg lg lg lg bits preprocessing time call lookup takes lg lg time 
ii implement compress lg lg bits preprocessing time call lookup takes lg time fixed value 
coefficients second order terms tweaked theoretically elaborate encoding 
state results terms alphabets 
roberto grossi jeffrey scott vitter theorem general alphabets 
consider suffix array sa built string length alphabet size 
implement compress lg lg lg lg lg lg lg lg bits lg preprocessing time call lookup takes lg lg time 
ii implement compress lg lg lg lg lg bits lg preprocessing time call lookup takes lg time fixed value 
space bound reduces lg lg lg lg bits 
shown space complexity theorem ii theorem ii restated terms order entropy lg string giving result bits 
grossi gupta vitter shown attain order entropy hh lg lg lg bits hh 
lookup process sped need report contiguous entries enumerative string matching queries 
lcp denote length longest common prefix suffixes pointed sa sa convention lcp say sequence indices sa maximal lcp lcp strictly smaller lcp enumerative queries 
intuitively maximal sequence sa corresponds occurrences pattern theorem batch lookups 
cases stated theorems additional space lg bits batch procedure calls lookup lookup lookup maximal sequence 
total cost lg lg time lcp lg suffixes pointed sa sa lg symbols common ii time constant lcp lg suffixes pointed sa sa lg symbols 

algorithms compressed suffix arrays 
section constructively prove theorems showing ways implement recursive decomposition suffix arrays discussed section 
particular section address theorem section prove theorem ii 
section shows extend theorem deal alphabets size proving theorem 
section prove theorem showing batch lookup contiguous entries suffix arrays arises enumerative string matching queries 

compressed suffix arrays lg lg bits lg lg access time 
section describe method referenced theorem binary strings show achieves lg lg lookup time total space usage lg lg bits 
giving algorithmic details method continue recursive decomposition steps described section lg lg 
decomposition shows result example section compressed suffix arrays sa rank sa rank sa resulting suffix array sa level contains lg entries stored explicitly bits 
store bit vectors explicit form bits implicit representations rank rank rank 
implicit representations rank accessed constant time procedure described lemma shows achieve desired lookup constant time level total lg lg time 
remains investigate represent rank bits support constant time access 
bit vector bk nk bits jacobson shows support constant time access rank nk lg lg nk lg nk extra bits preprocessing time nk 
show represent implicitly 
explain representation example describe formally 
lemma show space represent lg lg bits 
nk index ith bk 
consider symbols positions sak sak oft symbols immediately precede sak th suffix suffix pointer sak times larger compression 
bit pattern symbols appears keep ordered list indices correspond record number items list 
continuing example get lists level list list list list level aa list aa list ab list ab list ba list ba list bb list bb list level aaaa list aaaa list list list list list list list list list baba list baba list aabb list aabb list babb list babb list list list list list abab list abab list list list abba list abba list list list list list bbbb list bbbb list roberto grossi jeffrey scott vitter suppose want compute 
bk trivially consider harder case bk means sak odd 
determine index sak sak 
wecan determine number bk index computing rank subtracting number bits bk 
consider lists concatenated lexicographic order bit prefixes 
denote lk resulting concatenated list lk nk total items 
need find hth entry lk 
example determine example find slots 
entries list entries list th entry fifth entry list index 
desired note sa sa consecutive values 
continuing example consider level recursive call need determine 
previously computed value rank value rank procedure needs determine sa calculating 
entries 
third entry concatenated list aa ab ba bb second entry ba list 
desired note sa sa consecutive values :10.1.1.14.8675
describe formally preprocess input text order form concatenated list lk level desired space constant time query performance 
consider variant inventories introduced elias get average bit efficiency storing sorted multisets 
show get worst case efficiency 
lemma constant time access compressed sorted integers 
integers sorted order containing bits store lg lg lg bits retrieving hth integer takes constant time 
proof 
take lg bits integer sorted sequence 
qs integers obtained called quotients qh qh 
note multiple values allowed 
rs remainders obtained deleting bits integer sorted sequence 
store qs table described requiring lg lg bits 
store rs table bits 
table simple concatenation bits representing rs 
unary representation copies followed represent integer 
take concatenation unary representation qs qs 
words take entry encoded unary unary difference consecutive entries nondecreasing order 
table binary string obtained concatenation augmented auxiliary data structure supporting select operations locate position hth constant time 
requires bits total space required lg lg bits big oh term due auxiliary data structure implements select 
order retrieve qh find position hth calling select compute number bits returning see number gives qh 
time complexity constant 
order obtain hth integer original sorted sequence find qh querying described find ri looking hth entry compressed suffix arrays output qh rh requested integer simply returning concatenation bit representations qh rh 
proceed implementation lemma 
store concatenated list lk lg lg bits accessing hth entry lk takes constant time 
preprocessing time 
proof 
lists may empty 
number lists composing lk 
integer list nk transformed integer lg nk bits prepending binary representation 
obtain corresponding constant time 
result lk contains nk integers increasing order integer bits 
lemma store lk lg lg lg bits retrieving hth integer takes constant time 
substituting values get space bound nk lg nk nk lg lg nk lg lg lg lg 
way appreciate utility data structure consider naive alternative 
imagine information stored naively form unsorted array nk entries entry specifies particular list entry belongs 
lists total number bits needed store array naive manner lg nk efficient terms space 
define natural ordering array entries say jor position array precedes position naive representation allow efficiently look hth ordered entry array equivalent finding hth entry concatenated list lk 
doesn allow search quickly occurrence entry equivalent finding item list contrast data structure described lemma supports query operations linear space constant time 
corollary 
unsorted array entries range represent array total lg bits find hth entry order array constant time 
represent array lg bits find occurrence array constant time 
operation viewed generalization select operation arbitrary input patterns 
proof 
type query identical finding hth item concatenated list lk bound space follows construction lemma 
corresponding values proof lemma lg lgs respectively 
second type query identical finding entry list turned type query compute value corresponds need find global position respect ofthe entry list explicitly store table gives location concatenated list lk corresponds entry list set type query 
list fewer entries detected query done value returned query nullified 
total space lg assumption lg approach substitute perfect hash function compute value space hash table lg lg 
roberto grossi jeffrey scott vitter putting 
point pieces needed finish proof theorem 
text suffix array proceed lg lg levels decomposition discussed procedure compress section 
level stores explicitly reduced suffix array lgn bits 
levels store data structures constant time access follows 
bit vector bk size nk nk preprocessing time 

function rank nk lg lg nk lg nk bits nk preprocessing time 

function lg lg bits nk preprocessing time see lemma 
summing levels substituting values lg lg nk get bound total space lg lg lg lg lg lg lg lg lg lg lg lg lg lg lg easy show lg lg lg combined gives desired space bound lg lg lg lg theorem 
total preprocessing time compress nk 
call lookup goes levels constant time level total cost lg lg 
completes proof theorem 

compressed suffix arrays bits lg access time 
section give proof theorem ii 
lg lg levels data structure discussed previous section uses bits way reduce space complexity store constant number levels cost increased access time 
example keep total levels level level level lg lg lg lg 
previous example levels chosen levels 
trick determine reconstruct sa sa reconstruct sa sa 
store indices sa correspond entries sa new dictionary similarly store indices sa correspond entries sa new dictionary 
efficient static dictionary representation need lg bits lg bits 
dictionary lookup requires constant time rank query know smaller equal indices stored dictionary 
data structure support function similar maps corresponding 
denote resulting composition nk sak nk sak sak 
implement merging concatenated lists lk concatenated lists example level shown section merge list compressed suffix arrays lk list need singleton list 
better storing lk separately 
computing amounts ith entry concatenated list longer need bit vector bk 
lemma 
store concatenated lists lg lg bits lg lg bits accessing hth entry takes constant time 
preprocessing time 
proof 
proof identical lemma nk nk 
list list store singleton list handled bit differently 
specifically encode 
create bit vector bits bit position list contains position contains position auxiliary information access ith bit vector constant time select select 
keep counter know total number bit vector note single occurrence corresponding bit vector th bit vector assumed difficult treat common case 
additional space lg lg due implementation select select 
suppose want recover hth entry list 
return position invoking select 
return hth bit vector invoking select 
invoke select get position bit vector th 
way simulate concatenation lists needed 
lg lg bits implement execute constant time 
order determine sa sa function walk indices 
sa sa sa sa reach index stored dictionary 
number steps walk rank index 
switch level reconstruct rth entry level explicit representation sa similar walk find index stored 
number steps walk rank index 
return sa value sa 
defer details reasons brevity 
maximum length walk max lg lookup procedure requires lg time 
get general result stated theorem ii need keep total levels constant 
formally assume integer 
maintain levels 
maximum length walk lg lookup procedure requires lg time 
analysis similar section total space bound lgn plus sum indices 
split sum parts remaining values apply lemma lg lg lg lg lg lg lg lg lg lg roberto grossi jeffrey scott vitter add contribution space dk lg lg lg taken dictionaries levels bound hidden lg lg term formula 
final bound lg lg stated theorem ii 

extension alphabets size 
discuss case alphabets symbols 
case encode symbol lg bits text seen array entries lg bits equivalently binary string occupies lg bits 
describe extend ideas sections 
redefine lg lg 
definitions suffix arrays sa sak bit vector bk functions rank 
representation change notable exception noted lemma analogue lemma 
lemma 
store concatenated list lk lg lg lg bits accessing hth entry lk takes constant time 
preprocessing time 
proof 
extension lk straightforward 
lg patterns symbols preceding sak th suffix keep ordered list list list described section 
lists may empty concatenation nonempty lists forms lk 
number lists lg 
note number entries lk remains unchanged nk 
integer list nk transformed integer lg bits prepending binary representation 
lemma store lk lg lg lg bits retrieving hth integer takes constant time 
substituting values get space bound nk lg lg nk nk lg lg nk lg lg lg replacing space complexity formula section obtain lg lg lg lg lg lg lg lg lg lg lg lg lg lg lg lg proving theorem 
prove theorem ii follow approach section 
need dictionaries dk functions 
definitions representations change representation need lemma analogue lemma 
lemma 
store concatenated lists lg lg lg bits accessing hth entry takes constant time 
preprocessing time 
store lg lg lg lg bits 
proof 
proof identical lemma nk nk 
better approach proof lemma 
associate lg bits character lexicographic order 
bit vector lg bits represent fth chunk lg bits encoding character represents fact compressed suffix arrays list contains position implement versions select version character 
version charge selecting ith occurrence encoded binary bit vector 
treats occurrence lg bits bit vector single occurrences rest characters single clear implementation version select done lg lg bits 
execute constant time proceed lemma generalized characters 
analysis similar formula section obtain lg lg lg lg lg lg lg split sum apply lemma get lg lg lg bits proving theorem ii 

output sensitive reporting multiple occurrences 
section prove theorem showing output contiguous set sa sa entries compressed suffix array hypothesis sequence maximal definition theorem corresponding suffixes share certain number initial symbols 
requires adding lg bits space compressed suffix array 
way output entries reduction dimensional orthogonal range search 
dimensional orthogonal range query data structure points grid space preprocessing time number occupied words lg bits cost searching retrieving points satisfying range query lemma 
fix range query data structure largest integer lg 
exists report sa sa lg lg time sequence maximal suffixes pointed sa sa symbols common 
preprocessing time lg space lg bits addition compressed version sa 
proof 
suppose hypothesis suffixes pointed sa sa common symbols 
requirement reduced 
denote symbols bl left right 
order define dimensional points need build compressed version suffix array sa reversal text denoted obtain points keep processing suffix pointers sa multiples refer suffixes starting positions 
specifically point corresponding pointer sa multiple coordinate second coordinate position sorted order induced sa words rank suffixes lexicographic order rank suffixes equivalently reversed prefixes 
point corresponding label keep track correspondence 
roberto grossi jeffrey scott vitter points stored build compressed suffix array theorem ii space lg lg lg bits 
preprocessing time lg 
describe query output sa sa inl stages range query stage 
stage perform range query points 
points output suffix pointers labeling 
locate leftmost suffix rightmost suffix sa starting bl 
purpose run simple binary search compressed version sa comparing lg bits time 
result determine positions sa lg lg time sequence maximal sa suffixes pointed sa sa start bl 
proceeding stages precompute sequences indices starting respectively done section 
function compressed version sa sa walk indices il sa sa sa sa 
analogous walk applies jl 
way function compressed version sa obtain gl hl 
run tth stage perform range query points jt gl hl 
points retrieve label output order see method works consider arbitrary suffix pointer sa sa 
definition points kept suffix pointer written nearest multiple 
show output correctly stage point label show jt gl hl setting border values gl hl 
recall suffixes pointed sa sa lexicographic order definition compressed suffix array share symbols 
remove lexicographic order preserved symbols equal 
consequently sa sa lexicographic order ranks ih jh respectively 
implies jt 
similar property holds gl hl conclude retrieved stage giving output 
fact maximal sequences respective suffix arrays implies suffix pointers sa sa reported 
cost stage plus output sensitive cost reported suffix pointers 
stage requires additional cost lg lg compute cost precompute sequences indices length walks total time complexity lg lg sum output sensitive costs reporting suffix pointers 
lemma prove theorem 
employ range query data structures takes lg preprocessing time perfect hash constant lookup time takes lg construction time 
space lg words query time lg lg 
plugging bounds lemma gives lg lg lg retrieval time suffix pointers sharing lg symbols 
preprocessing time lg additional space lg bits 
compressed suffix arrays second data structure preprocessing time lg space query time fixed value 
consequently lemma gives lg lg retrieval time suffix pointers sharing lg symbols choosing 
preprocessing time lg additional space lg bits 

text indexing string searching compressed suffix trees 
describe apply compressed suffix array obtain text index called compressed suffix tree efficient time space complexity 
show despite extra functionality compressed suffix trees compressed suffix arrays require asymptotic space bits inverted lists worst case 
inverted lists space efficient practice easily maintained dynamic setting 
lemma 
worst case inverted lists require bits binary text length proof 
take de bruijn sequence length substring lg bits different 
terms inverted lists obtained partitioning disjoint substrings length lgn 
data structure implements inverted lists able solve static dictionary problem terms requires lg bits simple information theoretic argument 
upper bound follows theorem theorem see compressed suffix arrays suffix trees generalizations inverted lists 
describe main result text indexing constant size alphabets 
pattern string symbols alphabet interested occurrences overlapping text string symbols nth symbol 
assume symbol encoded lg bits case ascii unicode text files symbols packed word 
theorem 
text string length alphabet constant size build full text index lg time index occupies lg bits fixed value supports queries pattern string symbols packed lg words existential counting queries done min lg lgn time particular take time lg lg lg time 
ii enumerative query listing occ occurrences done lg occ lg time 
auxiliary data structures lg bits reduce search bound lg occ lg lg time lg occ 
result enumerative query done optimal lg occ time sufficiently large patterns number occurrences lg lg lg occ 
order prove theorem show speed search compacted tries section 
index construction section 
give description search algorithm section 
briefly review important data structures needed 
data structure lempel ziv lz index 
powerful tool roberto grossi jeffrey scott vitter searching grams substrings length int lg fixed positive constant build lz index time lz index occupies bits pattern length lg searched occ time 
special case obtain occ time suitable table lookup 
unfortunately longer patterns lz index may take lg bits 
lz index allows concentrate patterns length lg second data structure patricia trie powerful tool text indexing 
binary tree stores set distinct binary strings internal node children leaf stores string 
purposes generalize handle alphabets size way tree 
internal node keeps integer called skip value locate position branching character descending leaf 
child arc implicitly labeled symbol alphabet 
space efficiency child arcs represent child arcs hash table entries 
particular perfect hash function see keys provides constant lookup time uses words space lg construction time worst case 
suffix trees implemented building patricia trie suffixes follows text encoded binary sequence lg bits suffixes encoded analogously 
second patricia trie built suffixes resulting suffix tree leaves lg 
third searching takes time retrieves suffix pointer leaves leaf reached branching skip values leaf corresponding occurrence 
terminology requires calls lookup operation worst case 
third data structure space efficient incarnation binary patricia tries builds previous succinctly represent binary trees patricia tries 
employed store suffixes regular patricia trie occupies lg bits 
amount space usage result separate factors patricia trie topology skip values string pointers 
compressed suffix arrays string pointers longer problem 
remaining items space efficient incarnation patricia tries cleverly avoids overhead patricia trie topology skip values 
able represent patricia trie storing suffixes bits provided suffix array separately case compressed suffix array 
searching query pattern takes lg time accesses min lg suffix pointers worst case 
traversed node corresponding skip value computed time skip value accessing suffix pointers leftmost rightmost descendant leaves 
terminology searching requires calls lookup worst case 

speeding patricia trie search 
discuss construct index need show search patricia tries normally proceeds level time improved sublinear time processing lg bits pattern time pattern length multiple lg 
consider way patricia trie pt outlined section storing binary strings length lg 
example suffixes text 
handle border situations assume strings implicitly padded lg symbols 
show reduce search time symbol pattern pt lg lg lg 
loss compressed suffix arrays generality suffices show achieve lg lg time bound extends exponent 
point worst case may traverse nodes need tool skip nodes 
ideally branch downward matching lg bits equivalently lg symbols constant time independently number traversed nodes 
purpose perfect hash function see keys length lg bits 
particular perfect hash function constant lookup time takes words space lg construction time keys worst case 
enumerate nodes pt preorder starting root number 
second build hash tables mimic downward traversal node starting point searching strings length equal lg symbols 
suppose traversal successfully match symbols reach node descendent 
general symbols added equal skip value number symbols 
represent successful traversal single entry hash table 
store pair position arguments seen single key lg bits 
formally relation parameters satisfy conditions case successful search node 
node node identified starting node traversing downward nodes pt symbols 
unique nonnegative integer string corresponding path prefix length condition hold proper ancestor rationale conditions defining shortcut links certain nodes descendents successful branching takes constant time matches symbols symbols check skips nodes downward 
search unsuccessful hash pair 
key mechanism scheme efficient adaptively follow trie topology patricia strings hash possible substrings lg lg symbols subset start distinct nodes patricia trie 
trie method inefficient 
see examine patricia edge corresponding substring length hash lg lg symbols rest symbols uniquely identified skip 
trie force traverse lg lg nodes 
order keep small number shortcut links set hash tables 
table stores entries strings consist lg symbols shortcut links stored selected adaptively top traversal pt create possible shortcut links root 
step links root set descendents 
recursively link nodes descendents fashion 
note pt partitioned depth lg set second table analogously 
examine individual subtrie start root subtrie strings length lg symbols 
note total number entries bounded number nodes pt 
roberto grossi jeffrey scott vitter summary preprocessing consists double traversal pt followed construction ino slg worst case time words space 
general case go recursively build hash tables total number entries 
preprocessing time change asymptotically 
ready describe search pattern encoded binary patricia trie pt augmented 
suffices show match longest prefix 
compute hash function root pt concatenation lg symbols pattern 
branch quickly root hash lookup succeeds gives pair skip symbols pattern recursively search node lg symbols pattern read time 
hash lookup fails pair fewer lg symbols left pattern switch take lg symbols pattern branch pt scheme compare lg symbols time 
fail branching match lg symbols remaining pattern 
complete task branching standard way symbol time 
rest search identical standard procedure patricia tries 
completes description search pt lemma 
patricia trie pt storing strings lg symbols alphabet preprocess pt lg time searching pattern length requires lg lg time 
note better search bound lemma improve final search time obtained theorem 
consider space efficient patricia trie 
speedup need searching easier obtain 
need skip nodes need compare lg bits time constant time precomputing suitable table 
search cost lg plus linear cost proportional number traversed nodes 
general property speedup patricia tries increase original number lookup calls originating data structures 

index construction 
blend tools mentioned far compressed suffix arrays section design hybrid index data structure called compressed suffix tree follows multilevel scheme adopted 
lz index suffices describe support searching patterns length lg assume case requires minor modifications 
text input build suffix array sa temporary area lg time suffix tree point start building levels compressed suffix tree top order remove sa follows 
level build regular patricia trie pt augmented shortcut links mentioned lemma 
leaves pt store lg suffixes pointed sa sa lg sa lg 
implicitly splits sa subarrays size lg smaller 
complexity 
size pt lg lg bits 
built lg time variation standard suffix tree construction preprocessing described lemma 
second level process subarrays level create compressed suffix arrays space efficient patricia tries denoted pt pt pt associate ith patricia pt ith subarray 
assume loss generality subarray consists sa sa sa lg value lg build pt lg suffixes pointed sa sa lg sa lg 
process splits subarray smaller subarrays subarray size lg complexity 
size pt bits accounting suffix array construction takes time 
total size lg bits total processing time lg 

remaining intermediate levels proceed second smaller subarrays level 
new level splits subarray lg creates set space efficient patricia tries size 
left small subarrays size 
build space efficient patricia tries remaining entries small subarrays 
complexity 
new level created total size lg bits total processing time lg 

level execute compress suffix array sa store compressed version level delete sa temporary area 
complexity 
theorem total size lg bits accessing pointer call lookup takes lg time cost compress lg time 
note fix value arbitrarily executing compress 
summing levels obtain compressed suffix tree takes lg bits lg construction time 
temporary storage lg bits 

search algorithm 
show searching arbitrary pattern text costs lg lg time 
search locates leftmost occurrence rightmost occurrence prefix suffixes represented sa having sa stored explicitly 
consequently successful search determines positions sequence maximal definition theorem sa sa sa contain pointers suffixes counting query returns existence checks matches 
enumerative query executes queries lookup lookup lookup list occurrences 
restrict discussion finding leftmost occurrence finding rightmost analogous 
search level compressed suffix tree section 
examine levels top manner 
searching levels execute lookup need ith pointer compressed sa 
searching level 
perform search pt bounds stated lemma 
result search locate subarray second level say th subarray 
go search pt method space efficient patricia tries described section 
repeat search intermediate levels 
eventually identify position level level contains compressed suffix array 
position corresponds leftmost occurrence sa 
complexity search procedure lg lg time level lemma 
intermediate levels cost lg time giving total lg lg 
account cost lookup roberto grossi jeffrey scott vitter operations 
calls originated levels 
level call lookup times intermediate levels call lookup times 
cost lookup theorem multiplying calls lg place obtain lg time addition lg lg 
cost retrieving occurrences stated theorem hypothesis satisfied suffixes pointed sa sa respectively leftmost rightmost sharing lg symbols 
combining cost lg cost retrieving single pointer theorem obtain lg occ lg time conditions lg lg occ hold lg occ lg lg time 
argument completes proof theorem complexity text index 


indexing data structure text symbols alphabet achieves worst case efficient lookup time linear space 
scenarios space requirement sublinear practice 
specifically algorithm uses min lg lgn search time lg bits space requires lg bits 
method notions compressed suffix arrays suffix trees 
pattern symbols encoded lg bits count number occurrences min lg lgn time 
searching takes time lg lg lg time 
achieve optimal lg search time sufficiently large lg 
enumerative query retrieving occ occurrences sufficiently long patterns lg lg lg obtain total search bound lg occ optimal 
searching takes lg occ lg time conditions lg lg occ hold lg occ lg lg time 
crucial results functions see section building blocks results compressed text indexing 
interesting open problem improve bit compressed suffix array call lookup takes constant time 
improvement decrease output sensitive time enumerative queries occ lg lg occ 
possibility devise range query data structure improves data structures section 
turn improve theorems 
related question characterize combinatorially permutations correspond suffix arrays 
better understanding correspondence may lead efficient compression methods 
additional open problems listed 
kinds queries examined basic involve exact occurrences pattern strings 
preliminary filters sophisticated queries performed smaller amount text 
interesting extension support sophisticated queries directly tolerate small number errors pattern match 
new data structures orthogonal range searching proceedings st annual ieee symposium foundations computer science pp 

compressed suffix arrays amir benson efficient dimensional compressed matching proceedings ieee data compression conference storer cohn eds ieee computer society press los alamitos ca pp 

amir benson farach sleeping files lie pattern matching compressed files comput 
system sci pp 

amir landau rodeh text indexing dictionary matching error algorithms pp 

andersson larsson swanson suffix trees words algorithmica pp 

andersson nilsson efficient implementation suffix trees software practice experience pp :10.1.1.14.8675

apostolico myriad virtues suffix trees combinatorial algorithms words apostolico galil eds nato advanced science institutes series computer system sciences springer verlag berlin pp 

apostolico landau schieber vishkin parallel construction suffix tree applications algorithmica pp 

bentley maurer efficient worst case data structures range searching acta inform pp 

blumer blumer haussler ehrenfeucht chen smallest automation recognizing subwords text theoret 
comput 
sci pp 

blumer blumer haussler mcconnell ehrenfeucht complete inverted files efficient text retrieval analysis acm pp 

ga approximate dictionary queries proceedings th annual symposium combinatorial pattern matching hirschberg myers eds lecture notes comput 
sci 
springer verlag berlin new york pp 

munro membership constant time minimum space siam comput pp 

burrows wheeler block sorting data compression algorithm tech 
report digital systems research center palo alto ca 
clark compact pat trees ph thesis department computer science university waterloo waterloo ontario canada 
clark munro efficient suffix trees secondary storage extended proceedings seventh annual acm siam symposium discrete algorithms siam philadelphia pp 

de col time space efficient data structure string searching large texts inform 
process 
lett pp 

crochemore transducers repetitions theoret 
comput 
sci pp 

crochemore perrin way string matching acm pp 

crochemore rytter text algorithms oxford university press oxford uk 
de moura navarro ziviani indexing compressed text proceedings south american workshop string processing carleton university press ottawa ontario canada pp 

demaine pez ortiz linear lower bound index size text retrieval proceedings th annual acm siam symposium discrete algorithms siam philadelphia pp 

elias efficient storage retrieval content address static files acm pp 

farach thorup string matching lempel ziv compressed strings algorithmica pp 

farach colton optimal suffix tree construction large alphabets proceedings th annual ieee symposium foundations computer science miami beach fl pp 

farach colton ferragina muthukrishnan sorting complexity suffix tree construction acm pp 

farach colton muthukrishnan optimal logarithmic time randomized suffix tree construction automata languages programming rd international colloquium meyer auf der heide monien eds lecture notes comput 
sci 
springer verlag berlin new york pp 

roberto grossi jeffrey scott vitter ferragina grossi string tree new data structure string search external memory applications acm pp 

ferragina manzini opportunistic data structures applications proceedings st annual ieee symposium foundations computer science pp 

ferragina manzini experimental study opportunistic index proceedings th annual acm siam symposium discrete algorithms siam philadelphia pp 

fredman koml szemer di storing sparse table worst case access time acm pp 

automata languages programming proceedings th international colloquium lecture notes comput 
sci 
springer berlin new york pp 

galil time space optimal string matching comput 
system sci pp 

giegerich kurtz stoye efficient implementation lazy suffix trees proceedings rd workshop algorithm engineering vitter eds lecture notes comput 
sci 
springer verlag berlin pp 

gonnet baeza yates snider new indices text pat trees pat arrays information retrieval data structures algorithms prentice hall englewood cliffs nj pp 

grossi gupta vitter high order entropy compressed text indexes proceedings th annual acm siam symposium discrete algorithms siam philadelphia pp 

grossi vitter compressed suffix arrays suffix trees applications text indexing string matching extended proceedings nd annual acm symposium theory computing portland pp 

gusfield algorithms strings trees sequences computer science computational biology cambridge university press cambridge uk 
hagerup pagh deterministic dictionaries algorithms pp 


hon 
sung breaking time space barrier constructing full text indices proceedings th annual ieee symposium foundations computer science focs pp 

irving suffix binary search trees tech 
report tr computing science department university glasgow glasgow uk 
jacobson space efficient static trees graphs proceedings th annual ieee symposium foundations computer science pp 

jacobson succinct static data structures tech 
report cmu cs department computer science carnegie mellon university pittsburgh pa 
rkk inen suffix cactus cross suffix tree suffix array combinatorial pattern matching lecture notes comput 
sci 
springer berlin new york pp 

rkk inen sutinen lempel ziv index grams algorithmica pp 

rkk inen ukkonen lempel ziv parsing sublinear size index structures string matching proceedings rd south american workshop string processing ziviani baeza yates es eds carleton university press ottawa ontario canada pp 

rkk inen ukkonen sparse suffix trees computing combinatorics lecture notes comput 
sci 
springer berlin pp 

knuth sorting searching nd ed art computer programming addison wesley reading ma 
knuth morris jr pratt fast pattern matching strings siam comput pp 

kosaraju real time pattern matching quasi real time construction suffix tree proceedings th acm symposium theory computing acm new york pp 

kosaraju delcher large scale assembly dna strings space efficient construction suffix trees proceedings seventh annual acm symposium theory computing las vegas nv pp 

compressed suffix arrays kosaraju delcher correction large scale assembly dna strings space efficient construction suffix trees proceedings th annual acm symposium theory computing philadelphia pa 
kurtz reducing space requirement suffix trees software practice experience pp 

compact suffix array combinatorial pattern matching lecture notes comput 
sci 
springer berlin new york pp 

manber myers suffix arrays new method line string searches siam comput pp 

manber wu glimpse tool search entire file systems proceedings usenix winter technical conference pp 

mccreight space economical suffix tree construction algorithm acm pp 

moffat zobel self indexing inverted files fast text retrieval acm trans 
inform 
systems pp 

morrison patricia practical algorithm retrieve information coded alphanumeric acm pp 

munro tables foundations software technology theoretical computer science lecture notes comput 
sci 
springer berlin pp 

munro raman succinct representation balanced parentheses static trees planar graphs proceedings th annual ieee symposium foundations computer science pp 

munro raman rao space efficient suffix trees algorithms pp 

pagh low redundancy static dictionaries constant query time siam comput pp 

compressed text databases efficient query algorithms compressed suffix array proceedings isaac lecture notes comput 
sci 
springer berlin new york pp 

succinct representations lcp information improvements compressed suffix arrays proceedings th annual acm siam symposium discrete algorithms siam philadelphia pp 

vishkin symmetry breaking suffix tree construction proceedings th annual symposium theory computing acm pp 

ukkonen line construction suffix trees algorithmica pp 

weiner linear pattern matching algorithm proceedings th annual ieee symposium switching automata theory pp 

willard application sheared retrieval orthogonal range queries proceedings second annual symposium computational geometry acm new york pp 

yao yao dictionary look error algorithms pp 

ziviani de moura navarro baeza yates compression key generation text retrieval systems ieee comput pp 

zobel moffat ramamohanarao inverted files versus signature files text indexing acm trans 
database systems pp 

