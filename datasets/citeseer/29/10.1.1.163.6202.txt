fist language stackable file systems erez zadok jason computer science department columbia university cs columbia edu traditional file system development difficult 
stackable file systems promise ease development file systems offering mechanism incremental development 
unfortunately existing methods require writing complex low level kernel code specific single operating system platform difficult port 
propose new language fist describe stackable file systems 
fist uses operations common file system interfaces 
single description fist compiler produces file system modules multiple platforms 
generated code handles kernel details freeing developers concentrate main issues file systems 
describes design implementation evaluation fist 
extended file system functionality portable way changing existing kernels 
built file systems fist solaris freebsd linux 
experiences examples shows benefits fist average code size stackable file systems reduced times average development time reduced times performance overhead stacking 
file systems proven useful enriching system functionality 
abstraction folders files containing data natural existing file browsers text editors tools 
modifying file systems popular method extending new functionality users 
developing file systems difficult involved 
developers existing code native kernel file systems starting point 
file systems difficult write port depend operating system specifics contain lines complex operating systems code seen table 
user level file systems easier develop port reside outside kernel 
media common avg 
code size type file system lines hard disks ufs ffs ext fs network nfs cd rom iso floppy ms dos table common native unix file systems code sizes medium performance poor due extra context switches file systems incur 
context switches affect performance order magnitude 
stackable file systems promise speed file system development providing extensible file system interface 
extensibility allows new features added incrementally 
new extensible interfaces proposed implemented 
improve performance stackable file systems designed run kernel 
unfortunately stackable interfaces requires writing lots complex kernel code specific single operating system platform difficult port 
introduced stackable template system called 
eases file system development providing built support common file system activities 
improves portability providing kernel templates operating systems 
working easier stackable file systems developers write kernel code port platform specific templates 
previous approaches performance portability achieved 
perform file system run kernel user level 
kernel code difficult write port userlevel code 
ease problems developing porting stackable file systems perform propose high level language describe file systems 
benefits language 
simplicity file system language provide familiar higher level primitives simplify file system development 
language define suitable defaults automatically 
reduce amount code developers need write lessen need extensive knowledge kernel internals allowing non experts develop file systems 

portability language describe file systems interface abstraction common operating systems 
language compiler bridge gaps different systems interfaces 
single description file system generate file system code different platforms 
improves portability considerably 
time language allow developers take advantage system specific features 

specialization language allows developers customize file system needs 
having large complex file system features may configured turned compiler produce special purpose file systems 
improves performance memory footprint specialized file systems include necessary code 
describes design implementation fist file system translator language stackable file systems 
fist lets developers describe stackable file systems high level operations common file system interfaces 
fist developers need describe core functionality file systems 
fist language code generator fistgen generates kernel file system modules platforms single description 
currently support solaris freebsd linux 
assist fistgen generating stackable file systems created minimal stackable file system template called basefs 
basefs adds stacking functionality missing systems relieves fistgen dealing platform dependent aspects file systems 
basefs require changes kernel existing file systems 
main function handle kernel details relating stacking 
basefs provides simple hooks fistgen insert code performs common tasks desired file system developers modifying file data inspecting file names 
way fistgen produce file system code platform port basefs 
hooks allow fistgen include necessary code improving performance reducing kernel memory usage 
built example file systems fist 
experiences examples shows benefits fist compared stackable file systems average code size reduced times development time reduced times performance overhead stacking stacking systems performance overhead native file systems 
focus demonstrate fist simplifies development file systems provides write run portability unix systems reduces stacking overhead file system specialization 
rest organized follows 
section details design fist describes fist language fistgen basefs 
section discusses key implementation portability details 
section describes example file systems written fist 
section evaluates ease development portability performance file systems 
section surveys related 
section concludes explores directions 
design fist high level language providing file system abstraction 
shows hierarchy different file system abstractions 
lowest level reside file systems native operating system disk network file systems 
lowest level interact directly device drivers 
native file systems stackable file systems examples section basefs 
file systems provide higher abstraction native file systems stackable file systems interact file systems defined virtual file system interface vfs 
vfs provides virtual nodes vnodes abstraction files different file systems 
levels system specific 
fist language stackable vfs file systems basefs templates cryptfs low level file systems ufs nfs fist structural diagram 
stackable file systems including basefs vfs level low level file systems 
fist descriptions provide higher abstraction provided vfs 
highest level define fist language 
fist abstracts different vnode interfaces different operating systems single common description language easier write file systems way 
vnode interfaces differ system system share similar features 
experience shows similar file system concepts exist non unix systems stacking generalized include 
designed fist language general possible mirror existing vnode interfaces extend fist language platform independent way 
allows modify vnode operations arguments pass arbitrary way providing great design flexibility 
time abstraction means stackable file systems easily access device drivers control example block layout files disks existing structure meta data inodes 
fist require applications changed 
default behavior produced code maintains compatibility existing file system apis 
fist allow creation special purpose file systems extend new functionality applications 
basefs templates fist input file fistgen stackable file system sources fist operational diagram 
fistgen reads fist input file basefs templates produces sources new file system 
operation fist system shown 
illustrates parts fist fist language fistgen basefs 
file system developers write fist input files implement file systems fist language 
fistgen fist language code parser file system code generator reads fist input files describe new file system functionality 
fistgen uses additional input files basefs templates 
templates contain stacking support code operating system hooks insert developer code 
fistgen combines functionality described fist input file basefs templates produces new kernel sources output 
implement functionality new file system 
developers example write simple fist code manipulate file data file names 
fistgen turn translates fist code code inserts right place templates additional support code may required 
developers turn certain file system features fistgen conditionally include code implements features 
quick example illustrate fist development process contrast traditional file system development methods simple example similar watchdogs 
suppose file system developer wants write file system warn possible unauthorized access users files 
main idea files owner root user allowed access 
user attempting find files belong user normally get permission denied error code 
system produce alert attempt 
new snooping file system log failed attempts 
place check lookup routine find file directory 
fist developer 
locate operating system available sources file system 
read understand code file system associated kernel code 
copy sources carefully modify include new functionality 
compile sources new file system possibly rebuilding new kernel rebooting system 
mount new file system test debug needed completing developer left modified file system operating system 
amount code read understood ranges thousands lines table 
process repeated new port new platform 
addition changes native file system accepted operating system maintainers maintained independently 
contrast normal procedure developing code fist 
write code fist 
run fistgen input file 
compile produced sources loadable kernel module load running system 
mount new file system test debug needed debugging code turned fist assist development new file system 
need kernel sources familiar need write port code platform need rebuild reboot kernel 
furthermore developer write small number lines fist code op lookup owner uid uid detected access uid pid file uid pid name short fist code inserts statement normal call lookup routine 
code checks previous lookup call failed particular errors owner directory effective running user decides print warning message 
single fist description portable compiled platform ported templates currently 
file system model fist produced file system runs kernel seen 
fist file systems mirror vnode interface 
interface user processes system call interface 
fist change system call interface vnode interface 
fist change information passed returned interfaces 
user process generally accesses file system executing system call traps kernel 
kernel vfs translates system call vnode operation calls corresponding file system 
fist produced file system may call stacked file system 
execution flow reached lowest file system error codes return values flowing upwards way user process 
system call interface vnode interface vnode interface system calls mount data ioctl data user process error codes virtual file system vfs file system data error codes 
fist produced file system file system data operations error codes 
lower file system user kernel information execution flow stackable system 
fist change system call vnode interfaces allows arbitrary data control operations flow directions 
fist model file system collection mounts files user processes running system 
mounts mounted instances file systems exist time 
fist produced file system access manipulate various mounts files data associated attributes functions operate 
furthermore file system access attributes correspond run time execution environment operating system user process currently executing 
information data control generally flows user processes mounted file system system call interface 
example file data flows user processes kernel read write system calls 
processes pass specific file system data mount system call 
addition mounted file systems may return arbitrary new error codes back user processes 
fist produced stackable file system caller file systems lot control ones vnode interface 
fist allows access multiple mounts files 
mount file may multiple attributes fist access 
fist determine apply vnode functions file 
maximum flexibility fist allows developer full control mounts files data attributes functions operate may created removed data attributes changed functions may augmented replaced reordered ignored 
controls operating system extension mechanism exchange arbitrary information user processes kernel file system layers changing interfaces 
fist allows developers define new define actions take create application specific file systems 
fist provides functions portable copying ioctl data user kernel spaces 
example encryption file system section uses ioctl set cipher keys 
traditional stackable file systems create single linear stack mounts hiding file system 
general stacking allows tree mount structure direct access layer 
interesting aspect stackable file systems called shown 
fan allows mounted file system access mounts 
fanout useful example replicated load balancing unifying caching file systems 
fan fan stackable file systems fan allows process access lower level mounts directly 
useful fast access lower level data needed 
example encryption file system backup utility backup data faster securely accessing ciphertext files lower level file system 
fan mounted file system overlay mounted directory mount point 
overlay mount hides lower level file system 
useful security applications 
example acl file system section hides certain important files normal view able control manipulate files 
fist language fist language high level language uses file system features common operating systems 
provides file system specific language constructs simplifying file system development 
addition fist language constructs conjunction additional code offer full flexibility system programming language familiar file system developers 
ability integrate fist code reflected general structure fist input files 
shows main sections fist input file 
declarations fist declarations fist rules additional code fist grammar outline fist grammar modeled yacc input files yacc familiar programmers purpose sections delimited matches different subdivisions desired file system code raw included header declarations declarations affect produced code globally actions perform matching vnode operations additional code :10.1.1.111.230:10.1.1.111.230
declarations enclosed include additional headers define macros typedefs list forward function prototypes declarations rest code 
fist declarations define global file system properties affect semantics produced code mounted file system behave 
properties useful allow developers common global changes simple manner 
section declare file system read include debugging code fan allowed level fan 
fist declarations define special data structures rest code file system 
define mount time data passed mount system call 
versioning file system example passed number indicating maximum number versions allow file 
fist define new error codes returned user processes understand additional modes failure 
example encryption file system return new error code indicating cipher key expired 
fist rules define actions generally determine behavior individual files 
fist rule piece code executes selected set vnode operations operation portion vnode operation 
rules allow developers control behavior file system functions portable manner 
fist rules section primary section actions produced code written 
section example choose change behavior unlink rename target file restored 
separated declarations rules sections programming ease developers know global declarations go actions affect vnode operations go 
additional code includes additional functions referenced code rest file system 
separated section rules section code modularity fist rules actions take vnode function additional code may contain arbitrary code called 
section provides flexible extension mechanism fist file systems 
code section may basic fist primitives discussed section helpful writing portable code 
allow developers write code takes advantage system specific features flexibility may result non portable code 
remainder section introduces fist language primitives various participants file system files mounts processes attributes extend store persistently control execution flow file system 
examples section helpful illustrate fist language 
fist syntax fist syntax allows referencing mounted file systems files accessing attributes calling fist functions 
mount vfs file shorter syntax expect appear fist code 
may followed name number distinguishes multiple instances especially useful fan 
attributes mounts files specified appending dot attribute name vfs blocksize name owner scope current vnode function executing 
instance running operating system 
similarly process context executing file system concerned 
fist need refer attributes 
read attributes summarized table 
scope readonly attributes global 
fist code call fist functions file system shown table 
scope fist functions global mounted file system 
functions form comprehensive library portable global meaning blocksize native disk block size gid effective group id pagesize native page size pid process id time current time seconds epoch uid effective user id table global read fist variables routines useful writing file systems 
names functions fist fist functions take variable number arguments omit arguments suitable defaults exist different types argument 
true functions nested may return single value 
function meaning print messages string comparison buffer copying similar get error code set return error code return error code immediately set ioctl value pass user process get ioctl value user process write arbitrary data file read arbitrary data file find file directory read directory hide name file directory execute arbitrary vnode operation table sample fist functions mount file attributes associated 
fist recognizes common attributes mounted file systems files defined system name owner modification time protection modes 
fist allows developers define new attributes optionally store persistently 
attributes accessed appending name attribute mount file single dot way dereferences structure field names 
example native block size mounted file system accessed vfs blocksize name file name 
fist allows users create new file attributes 
example acl file system may wish add timed access certain files 
fist declaration define new file attributes file system vnode int user extra user int group extra group time expire access expiration time definition place fist file system may refer additional user group allowed access file user group respectively 
expiration time accessed expire 
vnode declaration defines new attributes files attributes kept memory 
fist provides different methods define store access additional attributes persistently 
way file system developer flexibility deciding new attributes need remain memory saved permanently 
example encrypting file system may want store encryption key cipher id initialization vector iv file 
declared fist char key cipher key int cipher cipher id char iv initialization vector fist functions exist handling file formats fist 
routines store persistently retrieve respectively additional file system file attributes arbitrary data 
example save cipher id file called key int cid set cipher id key cipher cid fist function produce kernel code open file named key write value cid variable cipher field file format data structure stored key file 
mechanism adding new attributes mounts similar 
files declaration vnode mounts vfs 
routines data access arbitrary persistent data mounts files 
rules controlling execution information flow previous sections considered fist control flow information various layers 
section describe fist control execution flow various operations fist rules 
fist change interfaces call changes portable operating systems may require changing user applications 
fist exchanges information applications existing apis specific applications affect change 
control fist file systems file system vnode operations execute normal stackable setting 
highlights typical stackable vnode operation find vnode lower level mount repeat operation lower vnode 
int getattr vnode vp args 
int error vnode lower vp get lower vp pre call code goes call operation lower file system error vop getattr lower vp args post call code goes return error skeleton typical kernel code stackable vnode functions 
fist control sections vnode function pre call post call call 
example vnode function receives pointer vnode apply operation arguments 
function finds corresponding vnode lower level mount 
function calls lower level mounted file system standard vop macro applies operation file system corresponding type lower vnode 
macro uses lower level vnode rest arguments unchanged 
function returns caller status code lower level mount passed function 
key parts stackable function fist control code may run calling lower level mount pre call code may run post call actual call lower level mount 
fist insert arbitrary code pre call post call sections replace call part 
default pre call post call sections empty call section contains code pass operation lower level file system 
defaults produce file system stacks change behavior designed developers worry basic stacking behavior changes 
example useful pre call code encryption file system verify validity cipher keys 
replication file system may insert post call code repeat vnode operation replicas 
versioning file system replace actual call remove file call rename example fist code op unlink call name name general form fist rule table summarizes possible values fist rule 
defines collection operations operate 
defines call set subset operations single operation 
part defines part call code refers pre call call name newly defined ioctl 
code contains code enclosed braces 
call sets op refer single operation ops refer operations refer non state changing operations refer state changing operations operation types operations data operations manipulate file data name operations manipulate file names rest operation types specify vnode operations create getattr stat link lookup mkdir read readdir readlink rename rmdir setattr symlink unlink write 
call part part calling lower file system call actual call lower file system part calling lower file system ioctl name newly defined ioctl table possible values fist rules filter declarations filter functions fist file systems perform arbitrary manipulations data exchange layers 
useful time complex data manipulations stackable file system involve file data file names 
manipulate consistently fist developers careful changes places 
example file data manipulated read write mmap functions file names appear places lookup create unlink readdir mkdir fist simplifies task manipulating file data file names types filters 
filter function unix shell filters sed sort take input produce possibly modified output 
developers declare filter data fist file fistgen looks data coding functions additional code section fist file encode data decode data 
functions take input data page allocated output page size 
developers expected implement coding functions additional code section fist file 
functions fill output page encoding decoding appropriately return success failure status code 
encryption file system uses data filter encrypt decrypt data section 
fist declaration filter name fistgen inserts code calls encode decode strings representing file names 
file name coding functions encode name decode name take input file name string length 
allocate new string encode decode file name appropriately 
coding functions return number bytes newly allocated string negative error code 
fistgen inserts code caller level free memory allocated file name coding functions 
fist filters developers easily produce file systems perform complex manipulations data names exchanged file system layers 
fistgen fistgen fist language code generator 
fistgen reads input fist file right basefs templates produces files necessary build new file system described fist input file 
output files include file system source files headers sources user level utilities makefile compile platform 
fistgen implements subset language parser subset preprocessor 
handles conditional macros ifdef endif 
recognizes functions set declarations functions 
parses fist tags inserted basefs explained section mark special places templates 
fistgen handles fist variables fist functions fist lookup arguments 
parsing input file fistgen builds internal data structures symbol tables keywords handle 
fistgen reads templates generates output files file template directory 
file fistgen inserts needed code excludes unused code replaces existing code 
particular fistgen conditionally includes large portions code support fist filters code manipulate file data file names 
produces new files including comments useful compilation new file system header file common definitions source files containing auxiliary code 
code generated fistgen may contain automatically generated functions necessary support proper fist function semantics 
fist function replaced true function macro inlined code block code statements feature may portable operating systems compilers 
possible mechanisms macros handle fist language resulted unreadable code 
advantages fist system produces highly readable code 
developers edit code add features hand choose 
fistgen produces real functions specialized fist syntax trivially handled example function takes arguments represent names data structures names fields 
function pass arguments templates needed opted avoid requiring developers know language modern unix kernels written avoid interoperability problems produced code produced code running kernel 
preprocessor macros handle data structure names names fields exact portable function semantics 
solve problem fistgen replaces calls functions automatically generated specially named functions hard code names data structures fields manipulate 
fistgen generates functions needed 
basefs basefs template system derived 
provides basic stacking functionality changing file systems kernel 
achieve functionality kernel support features 
vfs data structures basefs requires field store pointers data structures layer 
second new file systems able call vfs functions 
third kernel export symbols may needed new loadable kernel modules 
requirements needed loadable kernel modules 
vfs basefs ext fs generic specific generic specific basefs fits inside kernel basefs handles internal details operating systems freeing developers dealing kernel specifics 
basefs provides stacking layer independent layers 
shows 
basefs appears upper vfs lower level file system 
basefs appears file systems vfs 
basefs repeats vnode operation lower level file system 
basefs performs data reading writing pages 
simplifies mixing regular reads writes memory mapped operations gives developers single paged interface 
currently file systems derived basefs manipulate data pages may change data size compression 
improve performance basefs copies caches data pages layer layers 
basefs saves memory caching lower layer file data manipulated fan usual conditions require caching layer 
basefs different ways 
substantial portions code manipulate file data file names debugging code included basefs default 
included file system needs 
including code necessary generate output code readable code multi nested ifdef endif pairs 
conditionally including code resulted improved performance reported section 
matching exceeding performance layered file systems design goals basefs 
second basefs adds support fan file systems natively 
code conditionally included complex single stack file systems adds performance overhead consumes memory 
complete discussion implementation behavior fan file systems scope 
third basefs includes conditionally compiled support features written hand 
added support thought library common functions opening reading writing closing arbitrary files storing extended attributes persistently user level utilities mount file systems manipulate inspecting modifying file attributes 
fourth basefs includes special tags help fistgen locate proper places insert certain code 
inserting code functions simple cases code add go 
example handling newly defined done basefs ioctl vnode function switch statement right default case 
implementation implemented fist system solaris linux freebsd operating systems span popular modern unix platforms sufficiently different 
forced understand generic problems addition problems 
access kernel sources platforms proved valuable heidemann proposed solution cache coherency problem centralized cache manager 
solution required modifications existing file systems rest kernel 
development templates 
platforms support loadable kernel modules sped development debugging process 
loadable kernel modules convenience implementing fist required 
implementation basefs simple improved previously reported efforts 
changes required solaris freebsd 
changes linux required statically linked modules 
dynamically loadable kernel modules linux lines code changed header file 
change passive impact linux kernel 
remainder section describes implementation fistgen 
fistgen translates fist code code implements file system described fist input file 
code compiled dynamically loadable kernel module statically linked kernel 
section describe implementation key features fist span full range capabilities 
implemented read execution environment variables section uid looking fields struct cred solaris struct freebsd 
vfs passes structures vnode functions 
linux vfs simplifies access credentials reading information disk inode memory vnode structure struct inode 
linux find uid credentials referencing field directly inode vfs passes 
vnode attributes listed section simple find 
linux part main vnode structure 
solaris freebsd perform vop getattr vnode operation find return appropriate field structure getattr function fills 
vnode attribute name complex implement kernels store file names initial name lookup routine translates name vnode 
linux implementing vnode name attribute simple part standard directory entry structure dentry 
solaris freebsd add code lookup vnode function stores initial file name private data vnode 
way access vnode attribute vnode attribute added vnode declaration 
implemented fields defined vfs fist declaration similar fashion 
fist declarations described section affect behavior generated file system 
implemented read access mode replacing call part file system function modifies state unlink mkdir return error code read file system implemented fan mount style ex cluding code uses mounted directory vnode mount point 
difficult part implementing ioctl declaration associated functions section finding copy data user space kernel space 
solaris freebsd routines copyin linux uses copy user copy user 
complex feature implemented fist declaration functions section 
consider small code excerpt fmt data structure file fmt field generate data structure named fmt 
implement open file read bytes size data structure map bytes temporary variable data structure type copy desired field data structure close file return error success status value function 
improve performance related functions called times inside vnode function keep file refer open call uses 
fistgen excluding templates highly portable compiled unix system 
total number source lines fistgen 
fistgen process kb template data seconds measured platform section 
examples section describes design implementation sample file systems wrote fist 
examples generally progress simple fist design complex design 
example introduces fist features 

cryptfs encryption file system 

adds simple access control lists 

joins contents file systems 
examples experimental intended illustrate kinds file systems written fist 
illustrate discuss important parts examples depict key features fist 
possible mention potential enhancements examples 
hope convince readers flexibility simplicity writing new file systems fist 
additional example described section 
cryptfs cryptfs strong encryption file system 
uses blowfish encryption algorithm cipher feedback cfb mode 
fixed initialization vector iv bit key mounted instance cryptfs 
cryptfs encrypts file data file names 
encrypting file names cryptfs avoid characters illegal file names 
additional design important details available 
fist implementation cryptfs shows additional features file data encoding ioctl calls vfs data 
cryptfs fist code uses sections fist file 
important code cryptfs include blowfish filter data filter name ioctl char vfs char key op ioctl char temp buf temp buf bf set key vfs key temp buf unsigned char global iv xfe int cryptfs encode data const page page int blowfish variables unsigned char iv iv global iv bf cfb encrypt pagesize vfs key iv bf encrypt return pagesize example omits call decode data calls encode decode file names similar behavior data encoding 
cryptfs defines ioctl named set bit encryption keys 
wrote simple user level tool prompts user sends md hash kernel ioctl 
ioctl called cryptfs stores cipher key private vfs data field key 
possible extensions cryptfs storing file directory keys auxiliary files remain hidden users view section types tion algorithms defining mount flags select 
allows additional uid gid share access directory owner group directory 
shows additional features fist disallowing fan secure special purpose auxiliary files hiding files users view 
fist code uses fist declarations fist rules sections fanin ioctl int int int int gr op ioctl owner uid int acl acl gr op lookup int acl acl gr uid gid dir name dir owner dir group op lookup name acl dir owner uid op readdir call name acl name looking file directory performs normal access checks lookup 
insert code normal lookup checks access file denied additional file named acl exists directory 
read uid gid acl file 
effective uid gid current process match listed acl file repeat lookup operation originally looked file ownership group credentials actual owner directory 
owner credentials lower file system deny request 
acl file modifiable directory owner 
accomplish special ioctl 
hide acl files owner 
insert code lookup returns error file directory owner attempted lookup acl file 
complete hiding acl files skip listing acl files reading directories 
shows full set arguments routine 
order arguments directory lookup name lookup vnode store newly looked entry credentials perform lookup uid gid respectively 
possible extensions implementation 
uid gid listed acl file contain arbitrarily long list user group ids allow access 
acl file may include sets permissions deny access negative integers distinguish access permissions 
granularity file basis file access permissions read file acl exists 
joins contents file systems similar union mounts bsd plan 
lower file systems considered branches stackable file system tree 
shows merge contents directories fist define behavior set file system operations 
fist code uses fist declarations fist rules sections fanout op lookup dir name op readdir dir call normal lookup try lower file system branch 
add code lookup second branch lookup find file 
file exists lower file systems branch 
normal directory reading augmented include contents second branch setting flag eliminate duplicates way files exist lower file systems listed 
files may exist branches removed unlink rmdir rename branches 
declare writing operations perform respective operations branch means new files created branch subsequent lookups 
issues file system semantics especially concerning error propagation partial failures scope 
extensions include larger fan outs masking existence file removed mount options decide order lookups writing operations individual file system branches 
evaluation evaluate effectiveness fist criteria code size development time performance 
show code size reduced dramatically fist corresponding improvements development porting times 
show performance overhead small comparable stacking 
report results example file systems described cryptfs 
tested different platforms linux solaris freebsd 
code size code size measure development effort necessary file system 
demonstrate savings code size achieved fist compare number lines code need written implement example file systems fist versus implementation approaches writing code stand version basefs writing code writing file systems scratch kernel modules particular wrote example file systems scratch writing fist 
example file systems code generated fist identical size modulo white spaces comments handwritten code 
chose include results basefs released year includes code writing file systems easier basefs directly 
counting lines code excluded comments empty lines separators 
cryptfs excluded lines code blowfish encryption algorithm write 
counting lines code implementing example file systems basefs stackable templates exclude code part templates count code specific example file system 
averaged code sizes platforms implemented file systems linux solaris freebsd 
results shown 
include code sizes basefs show number lines code required implement fist basefs 
number lines log basefs cryptfs file system fist basefs scratch average code size various file systems written fist written basefs templates written scratch shows large reductions code size comparing fist versus code hand written scratch generally writing tens lines thousands 
include results templates 
size reductions example file systems range factor average 
focus comparison fist versus stackable template systems 
represents conservative comparison shows file system additional number lines code written 
smallest average code size reduction fist versus basefs file systems ranges factor average reduction rate 
suggests size reduction classes 
moderate times savings achieved cryptfs 
reason lines fist code file systems produce lines code result translation terms number lines 
second largest savings appeared factor times 
reason fan file systems produce code affects vnode operations vnode operation handle lower vnode 
additional code part original implementation fan outs defined save memory improve performance 
exclude code handle fan outs added code lines producing savings factor 
freebsd lines long larger lines 
freebsd lines longer lines longer basefs 
shows code sizes platform 
savings gained fist multiplied port 
sum savings platforms reach reduction factors ranging times comparing fist code written templates 
aggregated reduction factor exceeds times comparing fist code written scratch 
ports basefs exist better cumulative savings 
development time estimating time develop kernel software difficult 
developers experience affect time significantly time generally reduced port 
section report personal experiences file system examples platforms worked figures represent controlled study 
shows number days spent developing various file systems porting different platforms 
log basefs cryptfs filesystem average estimated reduction development time estimated incremental time spent designing developing debugging file system assuming hour days source commit logs change logs 
estimated time took develop basefs example file systems 
measured time took develop file systems fist language 
file systems incremental time savings factor hand writing code platform time consuming fist provides part base templates additional library code comes basefs 
cryptfs time savings platform vast majority code cryptfs implementing encoding decoding functions implemented code unfortunately stacking infrastructure freebsd currently broken unable compare performance stacking freebsd additional code section fist file rest support cryptfs 
average platform reduction development time file systems factor fist versus templates 
assume development time correlates directly productivity corroborate results brooks report high level languages responsible factor improved productivity 
additional metric productivity comparing number lines code developed man day templates 
average number lines code wrote man day 
user templates create new migration file system called mfs average number lines code wrote man day 
difference rate productivity explained experienced writing file systems obvious savings development time come account multiple platforms 
clearer additional platform increases savings factor fist versus methods 
performance evaluate performance file systems written fist tested example file systems mounting top disk native file system running benchmarks mounted file system 
conducted measurements linux solaris freebsd 
native file systems ext ufs ffs respectively 
measured performance file systems building large package am utils contains lines code dozen small files builds binaries build process contains large number reads writes file lookups fair mix file system operations 
benchmark run warm cache executables libraries header files outside tested file system result discarded 
took new measurements averaged 
test tested file system ensured started test cold cache file system 
standard deviations measurements mean 
ran tests machine mb ram quantum gb ide hard disk 
shows performance overhead file system compared 
intent figures fold show basic stacking overhead small show performance benefits www internal ch schaefer mfs html overhead 
lower file system basefs vs basefs vs basefs 
basefs 
basefs min max 
basefs performance overhead various file systems large compile benchmark operating systems conditionally including code manipulating file names file data basefs 
basefs refers basefs code manipulating file names file data 
important performance metric basic overhead imposed templates 
overhead basefs file systems mounts just 
minimum overhead degradation previously reported null layer stacking 
addition overhead example file systems due new file system functionality greater basic stacking overhead imposed templates cases simple file systems 
regard performance developers extend file system functionality fist primarily need concerned performance cost new file system functionality opposed cost fist stacking infrastructure 
instance overhead cryptfs largest file systems shown due cost blowfish cipher 
note performance individual file systems vary greatly depending operating system question 
shows benefits having fist customize generated file system infrastructure file system functionality required 
comparison basefs versus basefs shows overhead including code manipulating file names file data basefs 
added overhead incurred basefs file systems derived requires file data file name manipulations 
cryptfs requires basefs functionality 
compared stackable file system fist ability conditionally include file system infrastructure code saves additional performance overhead 
performed micro benchmarks included series recursive copies cp recursive removals rm rf recursive find find grep find mnt print grep pattern file set large compile 
focus performance savings code size development time 
micro benchmarks confirmed previous results repeat 
change vfs stacking templates overhead rest system performance native file systems nfs ffs unaffected stacking 
related rosenthal implemented stacking sunos early 
projects followed including prototypes extensible file systems sunos ficus layered file system :10.1.1.35.6686
webber implemented file system interface extensions allow user level file servers 
unfortunately implementations required modifications existing file systems rest kernel limiting portability significantly affecting performance native file systems 
fist achieves portability minimal stackable base file system basefs ported platform weeks 
changes need existing kernels file systems performance penalty native file systems 
newer operating systems spring exokernel extensible file system interface 
set servers running mach microkernel collectively provide unix environment 
translators programs attached pathname perform specialized services pathname accessed 
writing translators entails implementing defined file access interface filling stub operations reading files creating directories listing directory contents sun microsystems laboratories built spring objectoriented research operating system 
spring designed set cooperating servers top microkernel 
provides generic modules offer services useful file system caching coherency memory mapping object naming security 
writing file system spring involves defining operations applied objects 
operations defined inherited parent object 
resulted spring solaris mc multi computer file system 
borrowed object oriented interfaces spring integrated existing solaris vnode interface provide distributed file system infrastructure special proxy file system 
solaris mc provides spring benefits requiring little change existing file systems ported gradually time 
solaris mc designed perform closely coupled cluster environment general network requires high performance networks nodes 
exokernel extensible operating system comes xn low level kernel stable storage system 
xn allows users describe disk data structures methods implement file system libraries called 
exokernel requires significant porting new platform run unmodified applications 
main disadvantages spring exokernel portable sufficiently developed stable available general 
comparison fist provides portable stacking widely available operating systems 
related extensible file systems come high level language developers describe file systems 
high level languages seldom generate code operating system components 
fist major language describe large component operating system file system 
previous area operating system component languages includes language describe video device drivers 
main contribution fist language describe stackable file systems 
time high level language describe stackable file systems 
single fist description generate code different platforms 
achieved portability fist uses api combines common features vnode interfaces 
fist saves developers dealing kernel internals lets developers concentrate core issues file system developing 
fist reduces learning curve involved writing file systems enabling non experts write file systems easily 
significant savings fist offers reduced development porting time 
average time took develop stackable file system fist times faster wrote code basefs 
showed fist descriptions concise hand written code times smaller average stackable file systems times smaller complex ones 
fist generates file system modules run kernel benefiting increased performance user level file servers 
minimum overhead imposed stacking infrastructure 
fist ported unix platforms weeks assuming developers access kernel sources 
benefits fist multiplied time ported new platform existing file systems described fist new platform modification 
developing support file systems change sizes compression 
main complexity supporting compression file offsets upper lower layers longer identical form efficient mapping needed operations appending file writing middle 
code complicates templates change language 
exploring layer collapsing fist method generate file system merges functionality fist descriptions saving layer stacking overheads 
plan port system windows nt 
nt different file system interface unix vnode interface 
nt subsystem defines file system interface 
nt filter drivers optional software modules inserted existing file systems 
task intercept possibly extend file system functionality 
example nt filter driver virus signature detector 
possible emulate file system stacking nt 
estimate porting basefs nt take months weeks predict unix ports 
acknowledgments anonymous usenix reviewers shepherd keith smith helpful comments reviewing 
partially possible nsf infrastructure numbers cda cda 
accetta baron bolosky golub rashid tevanian young 
mach new kernel foundation unix development 
usenix conf 
proc pages summer 
bershad pinkerton 
watchdogs extending unix file system 
usenix conf 
proc pages winter 
brooks 
silver bullet 
mythical man month anniversary ed pages 
addison wesley 
bushnell 
new strategy os design 
gnu bulletin 
free software foundation 
copies available writing gnu prep ai mit edu 
guy heidemann mak page jr popek 
implementation ficus replicated file system 
usenix conf 
proc pages summer 
heidemann popek 
performance cache coherence stackable filing 
fifteenth acm sosp 
acm sigops 
heidemann popek 
layered approach file system development 
tech report csd 
ucla 
heidemann popek 
file system development stackable layers 
acm tocs feb 
johnson :10.1.1.111.230
yacc compiler compiler unix programmer manual volume supplementary documents 
bell laboratories murray hill new jersey july 
kaashoek engler ganger brice hunt mazi res grimm jannotti mackenzie 
application performance flexibility exokernel systems 
sixteenth acm sosp pages 
kleiman 
vnodes architecture multiple file system types sun unix 
usenix conf 
proc pages summer 
khalidi shirriff 
solaris mc file system framework 
tech report tr 
sun labs 
www com html 
mitchell gibbons hamilton kessler khalidi nelson powell 
overview spring system 
compcon conf 
proc 

filter drivers 
windows nt file system internals developer guide pages 
reilly 
mckusick 
union mounts bsd lite 
usenix conf 
proc 
unix advanced computing systems pages winter 
williams 
amd bsd automounter 
user manual edition alpha 
march 
pike presotto thompson trickey 
plan bell labs 
proceedings summer conference pages july 
rosenthal 
requirements stacking vnode vfs interface 
ui document sd 
unix international 
rosenthal 
evolving vnode interface 
usenix conf 
proc pages 
usenix summer 
schneier 
algorithm types modes 
applied cryptography nd ed pages 
john wiley sons 
schneier 
blowfish 
applied cryptography second edition pages 
john wiley sons 
skinner wong 
stacking vnodes progress report 
usenix conf 
proc pages summer 
smcc 
loopback virtual file system 
sunos manual section 
sun microsystems march 
thibault marlet consel 
domain specific language video device drivers design implementation 
usenix conf 
domain specific languages pages 
webber 
operating system support portable filesystem extensions 
usenix conf 
proc pages winter 
zadok 
cryptfs stackable vnode level encryption file system 
technical report cucs 
computer science department columbia university 
zadok 
extending file systems stackable templates 
usenix conf 
proc 
software documentation additional papers available www cs columbia edu research fist 

