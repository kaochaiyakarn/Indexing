incremental complete bounded model checking full pltl tommi timo laboratory theoretical computer science helsinki university technology box fi finland tommi timo fi 
bounded model checking efficient method finding bugs system designs 
major drawback basic method prove properties disprove 
progress proving properties ltl 
incremental complete bounded model checking method full linear temporal logic past pltl 
compared previous works method improves extends current results ways encoding incremental resulting improvements performance ii prove non existence counterexample shallower depths cases iii support full pltl 
implemented method nusmv model checker report encouraging experimental results 
keywords bounded model checking incremental complete pltl nusmv bounded model checking bmc established efficient method finding bugs ltl specifications system designs 
method works searching witnesses length negation specification 
bounded search problem translated propositional satisfiability problem sat sat solver get answer 
problem bmc knowing large bound sure counterexample exists 
bound referred completeness threshold depends system property problem mapped sat 
computing tight bound completeness threshold challenging problem 
method finding small completeness thresholds invariant properties induction 
sheeran inductive scheme invariants 
show invariants proven automatically strengthening induction show path length breaks invariant initialised loop free path length 
longest initialised loop free path state graph called recurrence diameter 
inductive method easily generalised safety properties ltl properties liveness safety transformation supported academy finland projects research fellow post 
supported academy finland projects 
supported helsinki graduate school computer science academy finland projects nokia foundation 
generalised bdd model checking pltl 
safety transformation doubles number state variables model unnecessary bmc 
increases size large loop free predicate cases biggest bottleneck 
method sheeran generalised various ways 
show size loop free predicate optimised log vs sorting networks 
suggest ways leave state variables loop free predicate improve efficiency maintaining completeness 
papers consider strengthening induction doing deeper bmc queries 
focused computing completeness threshold general ltl properties 
clarke show completeness threshold computed general ltl properties computing recurrence diameter product system chi automaton 
somenzi apply approach refined method calculating completeness threshold 
papers problem explicit representation chi automata implementations potentially exponential number state bits size formula represent chi automaton 
furthermore generalised chi automata represent ltl properties proceed deeper prove properties method proposed methods generalised chi automata 
mcmillan uses interpolants derived unsatisfiability proofs bmc counterexample queries reachability 
deeper bmc query exact method complete extended ltl liveness safety transformation 
weakness method unsatisfiability proofs exponential size cause blow 
promising technique improving performance bmc incremental sat solving 
solver faced sequence related problems learning clauses see previous problems drastically improve solution time problem sequence 
bmc natural candidate incremental solving bmc instances bounds similar 
consider incremental bmc 
papers frameworks transforming sat problem sequence adding removing clauses current problem instance 
consider incremental bmc combined inductive scheme 
approach special syntactic structure bmc encoding invariants forward learned clauses need perform potentially expensive conflict analysis sequential problem instances 
jin somenzi efficient ways filtering conflict clauses creating problem instance 
framework incremental sat solving incremental compilation encoding sat pltl encoding original inefficient encoding 
contribution bmc encoding specifically adapted incremental setting pltl encoding 
encoding designed allow easy separation constraints remain active instances constraints removed bound increased 
addition tried minimise number constraints removed order allow maximal learning solver independent fashion 
achieved maintaining efficiency original encoding 
additionally encoding able prove properties full pltl smaller bounds previous methods ltl papers employ method translating generalised chi automata standard non generalised chi automata way preserve minimal length counterexamples 
implemented method nusmv model checker promising experimental results 
bounded model checking ltl main idea bounded model checking search bounded witnesses temporal property 
bounded witness infinite path property holds represented finite path length finite path represent infinite behaviour sense 
represents infinite extensions forms loop 
infinite path states loop sl sl sk finite state system restrict searching counterexamples ltl pltl property representable loop 
bmc possible length bounded witnesses negation specification encoded sat problem 
bound increased witness instance satisfiable sufficiently high value guarantee completeness reached 
pltl pltl commonly specification logic past temporal operators 
refer consisting temporal operators ltl 
semantics pltl formula defined infinite paths states 
state si labelled labelling function si ap ap set atomic propositions 
states part model total transition relation initial state constraint denote suffix starting th state 
semantics follows si ap 






simply write 
denote infinite initialised paths commonly abbreviations standard boolean shorthands ap derived temporal operators globally 
possible rewrite formula positive normal form negations appear front atomic propositions 
accomplished dualities form available operators 
rest assume formulas positive normal form 
maximum number nested past operators pltl formula called past operator depth 
definition 
past operator depth pltl formula denoted inductively defined ap max max 
set subformulas pltl formula denoted cl defined smallest set satisfying conditions cl cl cl cl cl 
incremental bounded model checking ltl start presenting incremental encoding ltl simple bmc encoding 
considerations need taken account incremental encoding 
encoding needs formulated easy derive case done separating encoding invariant part dependent part 
information learned invariant constraints reused bound increased information learned dependent constraints needs discarded 
try minimise dependent constraints encoding 
called base constraints invariant conditions constant ltl property new encoding state variables system split time actual state variables si system set variables subformulas subformula cl set variables called auxiliary translation subformula cl 
encoding contains additional variables referred explicitly 
rules encoding set boolean constraints 
paths length encoded model constraints 
encode initialised finite paths model length si si initial state predicate total transition relation 
loop constraints employ fresh loop selector variables lk 
constrain finite path system finite path case lk variables true loop case variable li true variables false 
dependent constraints original encoding eliminated introducing new special system state se fresh unconstrained state variables acting proxy state endpoint path 
dependent part proxy state se constrained equivalent sk 
variable true iff state si belongs loop part loop 
variable dependent true loop false 
encoded constraints denoted base invariant li si se li dependent li lk se sk ltl constraints restrict bounded path defined model constraints loop constraints witnesses ltl formula 
intuition understanding encoding fact loops semantics ctl ltl coincide 
loops encoding seen ctl model checker single loop selected loop constraints 
mentioned translation ltl uses time point subformula cl state variable denoted superscript needed order extend encoding pltl case holds ltl properties 
note transition relation unrolled formula state variables 
start introducing constraints free subformula variables 
proxy state sl associated free formula variables simplify notation bit 
loop case forced false order safely semantics ltl 
loop case pick truth value subformula loop state sl successor state se 
dependent rules bind truth values dk truth values dk min jump unrolling level needed pltl case 
cl constraints created base invariant dependent li min atomic propositions negations basic boolean connectives dealt straightforwardly invariant fashion 
encoding temporal subformulas follows recursive semantic definition ltl temporal subformulas 
base encoding guarantees loop case 
holds se subformula hold state loop 
release case true states loop release formula holds se 
case path care eventualities base encoding disabled 
rules globally just special case optimisations 
base invariant pi pi di di auxiliary encoding enforce eventualities 
referenced loop case consider loop case 
case de true iff holds state se unrolling pltl case 
implemented requiring di holds state loop requires di holds states loop 
formulation auxiliary encoding main differences encoding allows new optimisations sect 

base invariant dependent incremental encoding close symbolic chi automata construction ltl formulae adapted incremental bmc setting see connection 
restricting encoding looping counterexamples replacing auxiliary encoding encoding track chi acceptance conditions formulas encoding ltl essentially correspond incremental bmc version 
ltl generated full encoding extended pltl section correctness claims 
denote encoding bound set intuitively ltl formula bounded witness length iff encoding satisfiable 
moving instance bound instance bound dependent constraints course things learned sat solver need discarded 
generalising pltl generalisation full pltl bmc encoding pltl 
past operators encoding bmc problem slightly complicated 
main source complexity fact loop traversed forward time reach loop point looks past different 
fortunately ability pltl formula distinguish different loop points bounded past formula nesting depth 
evaluations past operators inside loop eventually stabilise 
exploited bmc virtually unrolling loop times ensure evaluations past operators stabilised 
consider simple counter increments variable step 
reaches value reset 
counter single execution corresponds loop 

loop state 
corresponding time step formula hold 
reach formula stabilised 
fig 
loop counter system virtually unrolled depth 
corresponding state depth 
encoding modified introducing time point fig 

virtual unrolling loop 
subformula cl formula variables 
please refer bmc pltl details 
rule encoding pltl property mentioned pltl distinguish different loop past depth formula 
invariant encoding past operators similar encoding 
basic idea recursive definitions past temporal operators 
history past operators evaluate corresponds straight black arrows fig 

construct determine previous time point past si current depth se previous depth see fig 

define ite obtain compact representation encoding 
largest change previous encoding translation identical 
done purpose virtual identical loop case allows optimisations sect 

subformulas state sk replaced subformulas proxy state se making constraints invariant 
combining components encoding pltl defined invariant invariant ite li ite li di ite li di ite li ite li ite li correctness claims stated proofs omitted due space considerations 
similarly ltl case moving pltl encoding instance instance dependent constraints course things learned sat solver need discarded 
theorem 
finite kripke structure pltl formula path iff exists satisfiable 
specifically loop satisfiable 
completeness pltl incremental encoding easily extended prove properties 
basic intuition similar induction strengthening invariants restricted forward direction extended pltl 
procedure starts bound 
create completeness formula denoted satisfied initialised finite paths length able extend bounded witness formula length longer 
furthermore completeness formula simple path formula satisfied exactly paths contain equivalent states 
conjunction completeness simple path formulas unsatisfiable model checked formula holds system procedure terminated 
witness formula created satisfied bounded witnesses length formula see theorem 
witness formula satisfiable witness procedure terminate model checked formula hold 
procedure repeated incrementing 
termination procedure guaranteed finitely equivalence classes states considered simple path formula 
soundness direct corollary minimal length loop counterexamples detected 
completeness procedure involved basically requires witness completeness simple path formulas compatible 
case completeness formula encoding dependent constraints discarded 
clearly witness formula bounds contain constraints unsatisfiable constrained formulas going unsatisfiable 
definition states equivalent simple path formula bit involved definition states si equivalent belong loop agree system state si formula state restricted virtual unrolling ii belong loop agree system state si formula state auxiliary formula state simple path formula expressed si intuition case states si agree system state formula state restricted virtual unrolling witness length detected bound 
similar reasoning applies case ii addition system state agree formula state please refer fig 
auxiliary formula state identical si order erroneously remove states witness needed fulfil temporal eventualities 
proof notion state equivalence sound formulation context procedure slightly involved give sketch 
assume bounded witness length contains equivalent states si case equivalent states type ii show slightly tedious straightforward analysis structure formulas exists bounded witness length system states sm removed system states indexes indexes decreased witness contains equivalent states shorter witness exists 
repeating procedure terminate situation equivalent states exist simple path formula remove minimal length witnesses 
result 
theorem 
model pltl formula iff unsatisfiable unsatisfiable optimising encoding straightforward ways optimising encoding 

example subformulas cl need formula state variable bit subformulas time points refer temporal subformulas need included 
table included optimisations 
class consists binding formula variables se invariant manner 
optimisations exploit monotonic nature unary ltl operators infer things loop system side closed 
example holds state superset state clearly hold 
optimisations enabled required subset relations hold black nodes fig 
approximation main encoding auxiliary encoding unary formulas exploited 
base pe li pe min min min min min invariant di de di experiments implemented version nusmv model checker 
built incremental sat solver interface nusmv allowing add constraints solver permanent temporary manner 
temporary constraints removed solver automatically removing constraints solver learned 
incremental sat solvers currently supported interface minisat zchaff 
experiments latest version zchaff sat solver 
memory limited mib cumulative time hour 
cone influence reductions benchmarking implementation contain invariant property class specific optimisations left 
benchmark problems systems involving pltl specifications earlier problems ii ibm benchmarks iii systems standard nusmv distribution involving ltl specifications prove true 
table reports results 
nusmv column refers nonincremental pltl bmc model checker nusmv column refers table 
experimental results 
nusmv new new non new new non counter ex 
counter ex 
completeness completeness problem time time time time time time abp brp dme pci srg ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv ibm ibm fv bmc barrel ctl ltl counter ctl ltl mutex ctl ltl periodic ctl ltl ring ctl ltl short implementation earlier non incremental pltl translation ported top nusmv new completeness new non completeness resp 
incremental non incremental resp 
implementation new translation completeness 
new counter ex new non counter ex column refers counter example version new non incremental implementation completeness check disabled simple path constraint 
column shows implementation able show property true false column shows maximum reached memory time limits time cumulative time seconds solve problem 
results show interesting things 
seen incrementality usually significantly improves running times enables higher bounds reached faster 
furthermore degraded performance considerably 
second compared counter example version completeness check essentially free significantly slows search 
third incremental sat solver technology new translation possible build bmc procedure completeness usually performs better standard nusmv bmc procedure completeness specifications simple invariants ibm problems 
new incremental implementation significantly better previously suggested compact encoding pltl column 
implementation experiments available www tcs hut fi experiments cav discussion created efficient incremental complete bmc procedure full pltl detecting counterexamples minimal bounds improvement complete bmc procedures ltl non generalised chi automata 
encoding similar unsurprising joint 
main aim create bdd symbolic model checker incremental bmc mind 
interesting feature new pltl encoding earlier version sound case replace function constant function returns 
case size encoding linear similar see 
fact limit maximum virtual unrolling depth formulas value zero minimal size encoding potentially longer counterexamples minimal length counterexamples larger encoding theorem holds 
limiting number virtual zero beneficial order prove completeness smaller bound 
order enhance performance completeness part translation efficient ways handling simple path constraints needed 
interesting improvement sat solver technology enhance constraint language solvers handle mutual disequality sets boolean vectors natively 
alternative approach develop incremental version compact loop free predicate 
addition haven tried adding simple path constraints lazily demand done 
current implementation new translation improved ways 
firstly suspect simple path formula refined new independent formula invariants developed 
interesting subsets pltl possibly benefit special case treatment especially completeness 
incremental complete bmc pltl backward traversal left 
authors viktor interesting discussions topic 

biere cimatti clarke zhu symbolic model checking bdds 
tacas 
volume lncs springer 
efficient computation recurrence diameters 

volume lncs springer 
sheeran singh st checking safety properties induction sat solver 
fmcad 
volume lncs springer 
biere efficient reduction finite state model checking reachability analysis 
international journal software tools technology transfer 
biere shortest counterexamples symbolic model checking ltl past 
tacas 
volume lncs springer 
de moura rue bounded model checking induction refutation verification 
cav 
volume lncs springer 
fix vardi sat induction temporal safety properties 
preliminary proceedings bmc 

clarke completeness complexity bounded model checking 

volume lncs springer 
somenzi proving properties bounded model checking 
cav 
volume lncs 

mcmillan interpolation sat model checking 
cav 
volume lncs springer 
zhang madigan moskewicz malik efficient conflict driven learning boolean satisfiability solver 
iccad ieee 
pruning techniques sat bounded model checking problem 

volume lncs springer 
kim sakallah new incremental satisfiability engine 
dac ieee 
temporal induction incremental sat solving 
international workshop bounded model checking 
volume entcs elsevier 
jin somenzi incremental algorithm check satisfiability bounded model checking 
preliminary proceedings bmc 

bernardini incremental compilation sat procedures 
seventh international conference theory applications satisfiability testing sat 

cimatti bounded model checking past ltl 
tools algorithms construction analysis systems 
volume lncs springer 
biere simple better efficient bounded model checking past ltl 

volume lncs springer 
cimatti clarke giunchiglia giunchiglia pistore roveri sebastiani nusmv opensource tool symbolic model checking 
cav 
volume lncs springer 
biere simple bounded ltl model checking 
fmcad 
volume lncs springer 
kupferman vardi model checking safety properties 
formal methods system design 
testing ltl formula translation chi automata 
international journal software tools technology transfer 
clarke grumberg look ltl model checking 
formal methods system design 

schnoebelen temporal logic past 
lics ieee computer society press 
extensible sat solver 
sat 
volume lncs springer 
moskewicz madigan zhao zhang malik chaff engineering efficient sat solver 
design automation conference ieee 
simple efficient improvements sat bounded model checking 
fmcad 
volume lncs springer 
kesten pnueli raviv algorithmic verification linear temporal properties 
icalp 
volume lncs springer 
