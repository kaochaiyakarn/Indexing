informatica vol 
institute mathematics informatics primitive recursion course value iteration categorically uustalu dept teleinformatics royal inst 
technology se kista sweden mail kth se vene inst 
computer science univ ee estonia mail cs ut ee received december 
mainstream categorical approach typed total functional programming datatypes modelled initial algebras terminal coalgebras 
basic function definition schemes iteration modelled constructions known catamorphisms anamorphisms 
primitive recursion captured construction called paramorphisms 
draw attention dual construction show examples primitive corecursion useful function definition scheme 
put forward study novel constructions viz capture powerful schemes course value iteration dual respectively argue helpful 
key words typed total functional programming category theory program calculation datatypes forms recursion 

known categorical approach typed total functional programming popular program calculation community 
approach datatypes modelled initial algebras terminal coalgebras iteration modelled constructions known catamorphisms anamorphisms 
primitive recursion universally recognized important generalization iteration nicely captured meertens paramorphisms 
aim draw attention dual construction described vos vene uustalu models little appreciated scheme call primitive corecursion 
put forward study novel constructions viz capture course value iteration dual respectively argue schemes helpful declaratively thinking programmer program reasoner loves languages programming program reasoning programs proofs properties programs easy write read 
uustalu vene tradition categorical functional programming follow started bird meertens formalism bird theory datatype lists 
malcolm fokkinga inspired hagino generalized approach arbitrary datatypes 
geuvers contains thorough category theoretic analysis primitive recursion versus iteration demonstration readily analysis primitive corecursion versus 
general appears primitive corecursion largely overlooked theoretical literature 
fokkinga ignores 
apart vos vene uustalu sole discussion primitive corecursion programming context know report clean extension categorical functional language charity possible define functions primitive recursion primitive corecursion 
probable reason situation young age programming 
aware whatsoever categorical constructions modelling course value iteration 
intermediate report ongoing research project program construction typed functional languages programs guaranteed terminate total functions programmed 
defence merits typed total functional programming see turner 
part material originates vene uustalu 
earlier uustalu vene discussed programming program construction datatypes different setting intuitionistic natural deduction 
shall proceed follows 
section setting notation 
section give short standard categorical approach datatypes iteration 
section introduce categorical construction primitive recursion prove laws 
dualize development introducing categorical primitive stating laws obeys show usefulness primitive corecursion examples 
section introduce novel construction course value iteration prove crucial laws hint programming examples course value iteration useful 
dualize development arriving categorical treatment dual course iteration 
section indicate possible directions conclude 
proofs carried structured calculational proof style grundy 

preliminaries default category require distributive finite products products products distribute coproducts 
typical example distributive category sets category sets total functions 
primitive recursion course value iteration categorically quite standard notation 
objects write fst snd left right projections product forg denotes unique morphism fst snd pairing 
notation shorthand fst snd left right injections coproduct denoted inl inr forg denotes unique morphism inl inr case analysis 
notation abbreviates inl inr denote unique morphisms inverse canonical map inl idc inr idc denoted distr inverse canonical map ida inl ida inr denoted distl 
predicate guard 
defined snd snd distr ida 
datatypes iteration categorically datatypes natural numbers lists traditionally modelled initial algebras numbers streams terminal coalgebras 
function definition schemes iteration modelled constructions termed catamorphisms anamorphisms 
theory section bit folklore source fokkinga 
initial algebras catamorphisms 
letf functor signature algebra short pair wherea called carrier object fa called structure morphism algebras morphism said homomorphism algebras ff 
easy verify morphism composition homomorphisms homomorphism 
algebra identity morphism id homomorphism 
follows algebras homomorphisms form category 
category alg category objects algebras morphisms homomorphisms 
composition identities inherited algebra said initial algebra initial object category alg 
initial algebra may may exist 
guaranteed exist preserves colimits chains 
polynomial functors functors built products sums identity functor constant functors initial algebras exist 
functor existence initial algebra inf means algebra exists unique homomorphism algebras inf uustalu vene 
fokkinga denote homomorphism characterized universal property inf ff cata charn type information summarized diagram inf ff fc morphisms form called catamorphisms derived greek preposition meaning downwards construction iterator 
example 
datatype natural numbers represented initial algebra inn functor defined nx nf id write nat 
function zero nat equals inn inl function succ nat nat nat equals inn inr 
functions catamorphism nat unique solution equation system zero succ function nat function add nat nat adds argument instance defined catamorphism succ example 
datatype lists set represented initial algebra la inla functor la defined la la id ida 
denote la lista 
function nil list equals inla inl function cons lista list equals inla inr 
functions catamorphism la list unique solution equation system nil cons ida foldr functional programming 
function function map list list applies element argument instance defined catamorphism nil cons idlist la primitive recursion course value iteration categorically catamorphisms obey nice laws cancellation law reflection law known identity law fusion promotion law especially important program calculation cancellation law describing certain program execution step inf cata cancel id inf cata refl ff cata fusion reflection fusion laws proved follows id cata charn inf functor inf id inf ff cata charn inf cata charn ff functor important simple result inf isomorphism inverse inf recorded lambek 
inf inf id inf inf idf lemma proved calculations inf inf cata fusion inf cata refl id inf inf cata charn inf inf functor inf inf id functor idf define inf inv def uustalu vene lemma gives characterization inf id inf idf inv charn example 
predecessor function pred nat nat defined zero terminal coalgebras anamorphisms 
dualize material initial algebras catamorphisms 
functor signature coalgebra short pair wherea called carrier object fa called structure morphism coalgebras morphism said homomorphism coalgebras ff 
coalgebras homomorphisms form category 
category coalg category objects coalgebras morphisms homomorphisms 
composition identities inherited coalgebra said terminal coalgebra terminal object category coalg 
terminal coalgebra may may exist 
guaranteed exist continuous preserves limits chains 
polynomial functors functors built products sums identity functor constant functors continuous terminal coalgebras exist 
existence terminal coalgebra outf means coalgebra exists unique homomorphism coalgebras outf 
homomorphism usually denoted characterized universal property outf ff ana charn type information summarized diagram outf fc ff morphisms form called anamorphisms derived greek preposition meaning upwards name due meijer construction 
catamorphisms anamorphisms enjoy various properties including cancellation reflection fusion laws outf id outf ana cancel ana refl ff ana fusion primitive recursion course value iteration categorically outf fis isomorphism inverse outf outf inv def outf id outf idf inv charn example 
streams set nicely represented terminal coalgebra sa functor sa defined sa sa ida write sa 
functions head tail equal fst snd respectively 
functions anamorphism unique sa solution equation system head tail function nats nat returns stream natural numbers starting natural number argument unique solution equation system head nats tail nats nats succ definable anamorphism succ 
function zip zips argument streams characterized follows head zip fst fst tail zip zip snd snd function defined fst fst snd snd sa example 
set represented terminal coalgebra la outla functor la write list la function anamorphism la unique solution list equation outla id ida function unfold functional programming 
uustalu vene 
primitive recursion paramorphisms example 
factorial function fact nat nat neatly characterized unique solution equation system fact zero succ zero fact succ mult fact succ function catamorphism 
problem value argument depends values immediate subparts argument immediate subparts directly 
meertens showed function characterized similarly factorial function definable composition left projection catamorphism 
relevant result morphisms wehave inf id fst inf snd lemma proved calculations inf id pairing fst id cata charn id inf pairing inf inf functor inf inf id pairing inf inf snd id functor id inf snd id pairing inf snd id fst inf snd primitive recursion course value iteration categorically fst inf snd inf fst inf snd inf cata fusion snd inf snd pairing inf snd inf cata charn fst inf snd inf snd pairing fst inf snd snd inf snd cata refl id example 
factorial function fact inf succ zero mult fact succ succ zero mult succ fact consequently get definition factorial fact fst succ zero mult succ inf snd fst succ zero mult succ zero succ snd programming program reasoning easier introduce new construction study properties 
morphism morphism fst inf snd para def morphisms form called paramorphisms greek preposition meaning near side name due meertens 
construction primitive recursor 
lemma get characterization paramorphisms universal property inf id para charn uustalu vene type information summarized diagram id inf example 
paramorphism succ zero mult succ defines factorial function 
generally functions nat paramorphism nat unique solution equation system zero succ calculational properties paramorphisms similar catamorphisms 
particular cancellation reflection fusion laws inf id para cancel id inf fst para refl id para fusion reflection fusion laws proved follows id para charn inf functor inf id pairing inf fst id id functor inf fst id id inf fst primitive recursion course value iteration categorically id para charn inf para charn id id id functor id id pairing id definition paramorphism composition left projection catamorphism 
converse paramorphisms viewed generalization catamorphisms sense catamorphism definable certain paramorphism fst para cata law verified calculation para charn inf fst cata charn pairing fst id functor fst id morphism source carrier paramorphism inf snd para observation recorded meertens proved follows uustalu vene para charn inf functor inf id pairing inf snd id functor inf snd id inf snd law short step definition morphism paramorphism snd para inv proof proceeds follows para inf snd inv charn snd 
dualize know paramorphisms 
morphism define morphism composition certain anamorphism left injection inr outf inl apo def morphisms form dual paramorphisms 
vos vene uustalu morphisms called greek preposition meaning apart far away construction course primitive 
characterizing universal property outf id apo charn type information summarized diagram curious thing wrote vene uustalu unaware earlier existence vos happened come exactly new name 
primitive recursion course value iteration categorically outf id laws just duals paramorphisms 
cancellation reflection fusion laws outf id apo cancel id inl outf apo refl id apo fusion paramorphisms generalized catamorphisms generalization anamorphisms 
inl apo ana morphism target carrier terminal coalgebra 
inr outf apo morphism nice definition inr apo inv example 
function modifies input stream applying function head leaving tail unchanged definable composition certain anamorphism left injection constructs value argument value head elements tail 
head inr tail head inr tail inl sa head inr tail sa inr inl sa natural definition function constructs value argument value head tail 
head inr tail sa example 
assume set linearly ordered predicate 
function function insert uustalu vene inserts element input immediately element equal returned stream sorted stream characterized equation ys head ys head tail insert ys head insert tail ys 
function insert naturally defined constructs value argument certain initial segment elementwise remainder insert inr ida inl test sa test sa test fst snd fst snd 
head tail example 
function list function append list list appends input naturally definable constructs value argument elements argument append inl inr ida inr outla inr ida inl outla la la inr outla inr la inl outla la 
course value iteration example 
famous fibonacci function fibo nat nat smoothly characterized unique solution equation system fibo zero fibo fibo succ succ add fibo succ fibo succ zero 
nice characterization give definition fibo terms catamorphisms 
problem value fibo argument defined values immediate subparts argument values subparts depth 
characterization fibo function fibo nat nat nat argument returns pair formed value fibo zero value fibo predecessor trickier equation system viz primitive recursion course value iteration categorically fibo fst fibo fibo zero zero fibo succ add fst fibo leads definition fibo composition left projection catamorphism fibo fst add zero fst nat 
programming program reasoning easier introduce new construction capture natural definition scheme fibonacci function closely similar functions start studying properties 
provide partial solution problem manifested fibonacci example imagine functions value argument naturally defined values subparts depth introduce construction captures course value iteration function definition scheme value function argument may depend values just subparts 
start result knowledge novel denote functor fx ida fh 
morphisms wehave inf fst outf id lemma proving quite tricky 
inf pairing fst pairing fst id ana charn fst outf cata charn inf inv charn outf inf ana charn id pairing pairing inf inv charn pairing id fst id inf inf inf uustalu vene fst outf id inf fst outf id inf cata charn inv charn fst id id pairing id ana charn outf id pairing fst outf id snd outf inv charn cata charn snd outf id inv charn pairing id pairing fst id id id snd id inf id snd id id id id morphism define morphism letting fst id def morphisms form called 
construction easily seen course value iterator 
lemma characterizing universal property inf charn type information summarized diagram primitive recursion course value iteration categorically inf example 
neat definition fibonacci function fibo snd add id fst distl cancellation reflection fusion laws inf cancel id inf fst outf refl id outf fusion reflection law proved calculation id charn inf functor inf id pairing inf fst id pairing inf fst id id id ana charn inf fst outf id functor inf fst outf id inf fst outf fusion law proved follows uustalu vene id outf charn inf charn id outf functor id outf ana fusion id outf ana charn id id pairing pairing pairing id similarly paramorphisms viewed generalization catamorphisms fst cata fact verified calculation charn inf cata charn pairing fst pairing fst id ana charn fst outf functor fst outf fst outf primitive recursion course value iteration categorically 
introduce construction dual 
denote functor fx ida fh 
morphism define morphism letting id inl def name morphisms form 
construction dual course value argument 
characterizing universal property outf charn type information summarized diagram outf straightforward dualization laws gives laws outf cancel id inf inl outf refl inf id fusion inf inl ana example 
function exch pairwise exchanges elements argument characterized equation system head exch head tail head tail exch head tail tail exch exch tail tail 
function nicely definable exch head tail sa inr head sa inl tail tail sa 

categorical treatment function definition schemes primitive recursion course value iteration duals 
schemes generalizations uustalu vene basic schemes iteration 
value iterative function argument depends solely values immediate subparts value primitive recursive function may additionally depend immediate subparts directly value course value iterative function depends values subparts argument 
dually argument function value may determine argument immediate subparts value argument primitive function may alternatively determine immediate subparts directly argument argument function may determine arguments subparts value 
primitive recursion course value iteration liberal iteration easier write programs prove properties programs 
associating notions coinduction bisimulation widely analysis processes specifiable transition systems state machines jacobs rutten :10.1.1.37.1418
processes understood functions states optionally streams input tokens behaviors sequential composition processes natural example function elegantly definable concrete process specified finite transition state machine natural example function elegantly definable 
leads believe may turn viable constructions modelling processes 
check conjecture possible direction continuing reported 

reported partially supported estonian science foundation 
diagrams produced xy pic macro package rose 
bird 

theory lists 
broy ed logic programming calculi discrete design nato asi series vol 

springer verlag berlin 
pp 

fokkinga 

law order algorithmics 
phd thesis university twente 
iv pp 
geuvers 

inductive coinductive types iteration recursion 
nordstr pettersson plotkin eds informal proceedingsof workshop types proofs programs stad june 
dept computer sciences chalmers univ technology teborg univ pp 

url ftp ftp cs chalmers se pub cs reports 
grundy 

browsable format proof presentation 
universalis 
url saxon pip com pl 
hagino 

categorical programming language 
phd thesis cst univ edinburgh 
vii pp 
jacobs rutten 

tutorial algebras induction 
bulletin eatcs 
lambek 

fixpoint theorem complete categories 
mathematische zeitschrift 
malcolm 

data structures program transformation 
science computer programming 
meertens 

paramorphisms 
formal aspects computing 
turner 

elementary strong functional programming 
hartel plasmeijer eds proceedings st internat 
symp 
functional programming languages education lecture notes computer science nijmegen dec vol 

springer verlag berlin 
pp 

primitive recursion course value iteration categorically uustalu vene 

cube proof systems intuitionistic predicate logic 
haveraaen owe eds selected papers th nordic workshop programming theory oslo dec research report dept informatics univ oslo 
pp 

vene uustalu 

functional programming corecursion 
proceedings estonian academy sciences physics mathematics 


typechecking charity term logic 
unpublished notes 
pp 
url www cpsc ucalgary ca projects charity home html 
vos 

program construction generation recursive types 
msc thesis inf scr univ utrecht 
pp 
uustalu received msc degree system computer sciences technical university phd degree computer science royal institute technology stockholm sweden 
presently senior lecturer royal institute technology 
scientific interests include structural proof theory theorem proving semantics programming languages program verification transformations construction philosophy logic computing 
vene obtained msc degree computer science university estonia 
researcher phd student computer science university 
scientific interests programming language design implementation functional programming type theory semantics program manipulation category theory 
uustalu vene ko ir miu ko po uustalu vene da emis emis ko 
es es ir ko es ties ir 

eta ir ko pat ties schema 
etos dvi ir omos es miu es 
