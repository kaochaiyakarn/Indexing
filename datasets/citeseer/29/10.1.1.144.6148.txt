polynomial time algorithms prime factorization discrete logarithms quantum computer arxiv quant ph jan peter shor digital computer generally believed efficient universal computing device believed able simulate physical computing device increase computation time polynomial factor 
may true quantum mechanics taken consideration 
considers factoring integers finding discrete logarithms problems generally thought hard classical computer basis proposed cryptosystems 
efficient randomized algorithms problems hypothetical quantum computer 
algorithms take number steps polynomial input size number digits integer factored 
keywords algorithmic number theory prime factorization discrete logarithms church thesis quantum computers foundations quantum mechanics spin systems fourier transforms ams subject classifications preliminary version appeared proceedings th annual symposium foundations computer science santa fe nm nov ieee computer society press pp 

research room mountain ave murray hill nj 
shor results mathematics computation underlies subsequent development theoretical computer science distinction computable non computable functions shown papers church turing post 
central result church thesis says computing devices simulated turing machine 
thesis greatly simplifies study computation reduces potential field study infinite number potential computing devices turing machines 
church thesis mathematical theorem require precise mathematical description computing device 
description leave open possibility practical computing device satisfy precise mathematical description resulting mathematical theorem weaker church original thesis 
development practical computers apparent distinction computable non computable functions coarse computer scientists interested exact efficiency specific functions computed 
exact efficiency hand precise quantity easily 
generally accepted compromise coarseness precision distinguishes efficiently inefficiently computable functions length computation scales polynomially input size 
class problems solved algorithms having number steps polynomial input size known classification sense need machine independent 
need know function computable polynomial time independent kind computing device 
corresponds quantitative version church thesis called strong church thesis half invariance thesis van emde boas 
thesis quantitative church thesis 
physical computing device simulated turing machine number steps polynomial resources computing device 
statements thesis turing machine augmented random number generator determined pseudorandom number generators efficiently simulate truly random number generators purposes 
readers comfortable turing machines may think digital computers having amount memory grows linearly length computation classes computing machines efficiently simulate 
escape clauses thesis 
word physical researchers produced machine models violate quantitative church thesis ruled reason physical built 
escape clause thesis word resources meaning completely specified 
generally resources limit ability digital computers solve large problems time computation steps space memory 
resources pertinent analog computation proposed analog machines able solve np complete problems polynomial time required machining factoring quantum computer exponentially precise parts exponential amount energy 
see steiglitz issue implicit papers canny reif choi dimensional shortest paths 
quantum computation addition space time third potentially important resource precision 
quantum computer currently envisioned implementation able changes quantum states objects atoms photons nuclear spins 
changes clearly perfectly accurate contain small amount inherent imprecision 
imprecision constant depend size input known compute functions polynomial time quantum computer computed polynomial time classical computer random number generator 
precision grow polynomially input size number bits precision grow logarithmically input size appear obtain powerful type computer 
allowing polynomial growth precision appear confer extra computing power classical mechanics allowing exponential growth precision hartmanis simon 
far know precision possible quantum state manipulation dictated fundamental physical laws properties materials architecture quantum computer built 
currently clear architectures give high precision precision 
precision quantum computer large powerful classical computer order understand potential important think precision resource vary 
treating precision large constant certain constant machine comparable treating classical digital computer finite automaton computer fixed amount memory view technically correct particularly useful 
remarkable effectiveness mathematical models computation computer scientists tended forget computation dependent laws physics 
seen statement quantitative church thesis van emde boas word physical phrasing replaced word reasonable difficult imagine definition reasonable context mean physically realizable computing machine built 
computer scientists convinced truth quantitative church thesis failure proposed counter examples 
proposed counter examples laws classical mechanics universe reality quantum mechanical 
quantum mechanical objects behave quite differently intuition classical mechanics tells 
plausible natural computing power classical mechanics corresponds turing machines natural computing power quantum mechanics greater 
believe question settled worthy investigation 
see steiglitz 
particular turbulence candidate counterexample quantitative church thesis non trivial dynamics length scales may difficult simulate classical computer 
shor person look interaction computation quantum mechanics appears 
ask quantum mechanics conferred extra power computation showed reversible unitary evolution sufficient realize computational power turing machine showing quantum mechanics powerful computationally classical computer 
fundamental making investigation quantum computers possible 
feynman suggest quantum mechanics powerful computationally turing machine 
gave arguments quantum mechanics intrinsically expensive computationally simulate classical computer 
raised possibility computer quantum mechanical principles avoid problem implicitly asking converse question quantum mechanics computer compute efficiently classical computer 
deutsch ask question explicitly 
order study question defined quantum turing machines quantum circuits investigated properties 
question quantum mechanics computer allows obtain computational power addressed deutsch jozsa brassard 
papers showed problems quantum computers quickly solve exactly classical computers solve quickly high probability aid random number generator 
papers show solve problem quantum polynomial time known solvable polynomial time aid random number generator allowing small probability error characterization complexity class bpp widely viewed class efficiently solvable problems 
problem stimulated bernstein vazirani 
results contained oracle problem problem involving black box subroutine computer allowed perform code accessible done polynomial time quantum turing machine requires super polynomial time classical computer 
result improved simon gave simpler construction oracle problem takes polynomial time quantum computer requires exponential time classical computer 
bernstein problem appears contrived simon problem looks quite natural 
simon algorithm inspired 
number theory problems studied extensively polynomial time algorithms discovered finding discrete logarithms factoring integers gordon lenstra lenstra adleman mccurley 
problems widely believed hard cryptosystems difficulty proposed including widely rsa public key cryptosystem developed rivest shamir adleman 
show problems solved polynomial time quantum computer small probability error 
currently knows build quantum computer possible laws quantum mechanics 
suggestions possible designs computers teich lloyd factoring quantum computer sleator chuang substantial difficulty building landauer landauer unruh chuang palma 
difficult obstacles appear involve decoherence quantum superpositions interaction computer environment implementation quantum state transformations precision give accurate results computation steps 
obstacles difficult size computer grows may turn possible build small quantum computers scaling machines large interesting computations may fundamental difficulties 
useful quantum computer built research illuminate problem simulating quantum mechanics classical computer 
method doing arbitrary hamiltonian necessarily able simulate quantum computer 
general method simulating quantum mechanics polynomial slowdown lead polynomial time algorithm factoring 
rest organized follows 
introduce model quantum computation quantum gate array rest 
explain subroutines algorithms reversible modular exponentiation quantum fourier transforms 
give algorithm prime factorization give algorithm extracting discrete logarithms 
give brief discussion practicality quantum computation suggest possible directions 
quantum computation section give brief quantum computation emphasizing properties 
describe quantum gate arrays quantum acyclic circuits analogous acyclic circuits classical computer science 
models quantum computers see quantum turing machines deutsch bernstein vazirani yao quantum cellular automata feynman margolus lloyd 
allowed small probability error quantum turing machines quantum gate arrays compute functions polynomial time yao 
may true various models quantum cellular automata proved 
gives evidence class functions computable quantum polynomial time small probability error robust depend exact architecture quantum computer 
analogy classical class bpp class called bqp 
consider system components states 
classical physics complete description state system requires bits quantum physics complete description state system requires complex numbers 
precise state quantum system point dimensional vector space 
possible classical positions components basis state vector space represent example meaning bit second bit 
ket notation means pure quantum state 
mixed states shor discussed define see quantum theory book peres definition 
hilbert space associated quantum system complex vector space states basis vectors state system time represented unit length vector hilbert space 
multiplying state vector unit length complex phase change behavior state need complex numbers completely describe state 
represent superposition states ai si amplitudes ai complex numbers ai si basis vector hilbert space 
machine measured respect basis particular step probability seeing basis state si ai measuring state machine projects state observed basis vector si looking machine computation invalidate rest computation 
consider measurements respect canonical basis 
greatly restrict model computation measurements reasonable bases simulated quantum computation perform change basis performing measurement canonical basis 
order physical system computation able change state system 
laws quantum mechanics permit unitary transformations state vectors 
unitary matrix conjugate transpose equal inverse requiring state transformations represented unitary matrices ensures summing probabilities obtaining possible outcome result 
definition quantum circuits quantum turing machines allows local unitary transformations unitary transformations fixed number bits 
physically justified general unitary transformation bits clear efficiently implement physically bit transformations theory implemented relatively simple physical systems sleator chuang 
general bit transformations built bit transformations sleator lloyd deutsch number required exponential 
set bit transformations form set building blocks quantum circuits manner analogous way universal set classical gates gates form set building blocks classical circuits 
fact universal set quantum gates sufficient take bit gates single type bit gate controlled negates second bit bit 
example informative point 
quantum gate expressed truth table input basis vector need give output gate 
gate factoring quantum computer 
truth tables correspond physically feasible quantum gates truth tables give rise unitary transformations 
gate represented matrix 
rows correspond input basis vectors 
columns correspond output basis vectors 
entry gives ith basis vector input gate coefficient jth basis vector corresponding output gate 
truth table correspond matrix 
quantum gate feasible corresponding matrix unitary inverse conjugate transpose 
suppose machine superposition states apply unitary transformation represented state 
resulting output result multiplying vector matrix 
machine go superposition states 
example shows potential effects interference quantum computation 
started state state chance observing state application gate 
start superposition states probability amplitudes state cancel possibility observing application gate 
notice output gate started superposition states probabilities particular configuration observed superposition 
apply gate bits longer basis vector circuit wires multiply gate matrix bits gate shor applied leave bits 
corresponds multiplying state tensor product gate matrix bits identity matrix remaining bits 
quantum gate array set quantum gates logical wires connecting inputs outputs 
input gate array possibly extra bits initially set fed sequence quantum gates 
values bits observed quantum gate values output 
compare gate arrays quantum turing machines need add conditions gate arrays uniform complexity class 
words different gate array size input need keep designer gate arrays hiding non computable hard compute information arrangement gates 
quantum gate arrays uniform add things definition gate arrays 
standard requirement design gate array produced polynomial time classical computation 
second requirement standard part definition analog complexity classes analog complexity classes widely studied requirement widely known 
requirement entries unitary matrices describing gates computable numbers 
specifically log bits entry classically computable time polynomial solovay 
keeps non computable hard compute information hidden bits amplitudes quantum gates 
reversible logic modular exponentiation definition quantum gate arrays gives rise completely reversible computation 
knowing quantum state wires leading gate tells uniquely quantum state wires leading gate 
reflection fact despite macroscopic arrow time laws physics appear completely reversible 
imply built laws physics completely reversible classical computers get fact energy making computations irreversible 
appears impossible quantum computers superpositions quantum states need maintained computation 
quantum computers necessarily reversible computation 
imposes extra costs doing classical computations quantum computer necessary subroutines quantum computations 
reversibility quantum computation deterministic computation quantum computer reversible 
luckily shown deterministic computation reversible bennett 
fact reversible classical gate arrays studied 
result classical computation done nand gates universal gates reversible computation 
toffoli gates toffoli fredkin gates fredkin toffoli illustrated table 
toffoli gate just controlled controlled bit negated bits 
toffoli gate third input bit set third output bit nand input bits 
nand factoring quantum computer table truth tables toffoli fredkin gates 
toffoli gate fredkin gate input output input output universal gate classical gate arrays shows toffoli gate universal 
fredkin gate bits swapped bit left untouched bit 
fredkin gate third input bit set second output bit input bits input bits set respectively second output bit input bit 
gates realizable fredkin gates showing fredkin gate universal 
results reversible computation bennett compute polynomial time function long keep input computer 
adapting method computing function non reversibly 
results easily extended gate arrays toffoli fredkin toffoli 
gates changed fredkin toffoli gates obtains additional input bits preset specified values additional output bits contain information needed reverse computation 
additional input bits difficulties designing quantum computers additional output bits reset affect interference patterns quantum computation 
bennett method resetting bits shown top half table 
non reversible gate array may turned reversible gate array follows 
duplicate input bits times necessary input bit gate array 
keeping copy input toffoli fredkin gates simulate gates putting extra output bits record register 
extra output bits preserve record operations enable computation gate array reversed 
output computed copy register preset zero undo computation erase output register record register 
erase replace addition polynomial time algorithm need polynomial time algorithm computing need polynomial time computable 
method computation table 
stages computation 

second stage shown bottom half table note method compute non reversibly polynomial time technique reversibly map 
reversible computation shor table bennett method making computation reversible 
input input output record input output record output input output input input record output input record output output reverse go 
put pieces take 
discussion shows computations reversible constant factor cost time method uses space time 
classical computation requires space time making reversible manner result large increase space required 
methods space time computations reversible bennett levine sherman 
general method cause increase space time specific algorithms reversible paying large penalty space time section show modular exponentiation subroutine necessary quantum factoring 
bottleneck quantum factoring algorithm piece factoring algorithm consumes time space modular exponentiation 
modular exponentiation problem find xr mod 
best classical method doing repeatedly square mod get mod log multiply subset powers mod get xr mod 
working bit numbers requires multiplications bit numbers mod 
asymptotically best classical result gate arrays multiplication sch strassen algorithm sch strassen knuth sch 
gives gate array integer multiplication uses log log log gates multiply bit numbers 
asymptotically modular exponentiation requires log log log time 
making reversible na cost amount space reuse space repeated squaring part algorithm reduce amount space needed essentially required multiplying bit numbers simple method reducing space versatile section 
modular exponentiation done log log log time log log log space 
sch strassen algorithm best multiplication algorithm discovered date large scale small small numbers best gate arrays multiplication essentially elementary school multiplication binary 
method requires time multiply bit numbers modular exponentiation requires time method 
gate arrays reversible space 
give method constructing reversible gate array takes factoring quantum computer space time compute xa mod bit numbers 
basic building block gate array takes input outputs mod 
note gate array input built structure gate array 
addition mod computable log time classically reversible gate array log gates log bits techniques explained earlier section 
technique computing xa mod essentially classical method 
repeated squaring compute mod obtain xa mod multiply powers mod appears binary expansion algorithm factoring need compute xa mod superposition states fixed integer 
things easier reversible gate array treated input built structure gate array 
algorithm described pseudocode ai represents ith bit binary bits indexed right left rightmost bit 
power ai power power endif endfor mod variable left unchanged code mod output variable power 
code takes pair values mod 
pseudocode easily turned gate array hard part fourth line multiply variable power mod need fairly complicated gate array subroutine 
recall mod computed classically built structure gate array 
implement line need reversible gate array takes input gives bc mod output structure gate array depend course step reversible gcd common factors distinct values mapped value bc mod case fortunately need factoring algorithm 
show build gate array stages 
stage directly analogous exponentiation repeated multiplication obtain multiplication repeated addition mod 
pseudocode stage follows 
result bi result result ic mod endif endfor mod precomputed built structure gate array 
shor pseudocode takes input gives bc mod output 
get desired result need erase recall gcd mod mod 
multiplication reversibly take bc mod bc mod bcc mod bc mod 
just reverse operation want working reversible computing turn operation erase pseudocode follows 
result ic mod endif endfor result ith bit result 
note stage computation 
set directly zero reversible operation impossible quantum computer relatively complicated sequence operations ended fact depended multiplication group mod 
point somewhat measure see 
know error quantum computation results worthless computer start 
find know just observed exactly 
measurement may bring quantum computation back track amplitude non zero eliminated 
probability observe state proportional square amplitude state depending error model doing modular exponentiation measuring time know may higher probability success computation done repeated measurements quantum watchdog quantum zeno effect peres 
argument show repeated measurement beneficial cost time measuring implemented checked analysis experiment benefit measurements exceeds cost 
believe partial measurements promising way trying stabilize quantum computations 
currently sch strassen algorithm choice multiplying large numbers multiplication algorithm choice small numbers 
multiplication algorithms efficiencies algorithms best algorithms intermediate length numbers karatsuba knuth sch 
clear algorithms best size numbers 
may known extent classical computation sch data algorithms better classical computers misleading reasons classical computers need reversible cost making algorithm reversible depends algorithm 
second existing computers generally multiplication bit numbers built hardware increase optimal factoring quantum computer points asymptotically faster algorithms multiplication algorithms take better advantage hardwired multiplication 
order program quantum computers efficiently needs done best way implementing elementary arithmetic operations quantum computers 
tantalizing fact sch strassen fast multiplication algorithm uses fast fourier transform basis fast algorithms quantum computers discovered date tempting speculate integer multiplication speeded quantum algorithm possible result somewhat faster asymptotic bound factoring quantum computer breaking rsa quantum computer asymptotically faster encrypting rsa classical computer 
quantum fourier transforms quantum computation deals unitary transformations helpful able build certain useful unitary transformations 
section give technique constructing polynomial time quantum computers particular unitary transformation essentially discrete fourier transform 
transformation matrix rows columns indexed states 
states correspond binary representations integers computer particular rows columns indexed specified 
transformations follows 
consider number number bits polynomial 
perform transformation takes state state exp iac 
apply unitary matrix entry exp iac 
fourier transform heart algorithms call matrix aq 
aq exponential size show transformation done polynomial time 
give simple construction aq power discovered independently coppersmith deutsch see jozsa 
construction essentially standard fast fourier transform fft algorithm knuth adapted quantum computer description follows jozsa 
earlier version shor gave construction aq special class smooth numbers small prime power factors 
fact cleve shown construct aq smooth numbers prime factors log 
take represent integer binary quantum fourier transform aq need types quantum gates 
gates rj operates jth bit quantum computer rj shor sj operates bits positions sj ei perform quantum fourier transform apply matrices order left right rl sl rl sl sl rl apply gates rj reverse order rl rj rj apply gates sj example bits matrices applied order 
take fourier transform aq need quantum gates 
applying sequence transformations result quantum state exp iac bit reversal binary number obtained reading bits right left 
obtain actual quantum fourier transform need computation reverse bits obtain leave bits place read reverse order alternative easy implement 
show operation performs quantum fourier transform consider amplitude going bl 
factors matrices multiply produce factor need worry exp iac phase factor expression 
matrices sj change values bits merely change phases 
way switch jth bit aj bj appropriate entry matrix rj 
entry adds phase bits aj bj leaves unchanged 
matrix sj adds phase aj bk leaves unchanged 
phase path expression rewritten 

bit reversal expression rewritten making substitution sum get 
factoring quantum computer adding multiples affect phase obtain phase sum obtaining aj ck equality follows distributive law multiplication 
aj similarly expression equal ac phase amplitude transformation 
large gate sj multiplying small phase factor 
difficult accurately physically somewhat disturbing necessary quantum computation 
luckily coppersmith shown define approximate fourier transform ignores tiny phase factors approximates fourier transform closely factoring 
fact technique reduces number quantum gates needed approximate fourier transform considerably leaves gates sj prime factorization known euclid integer uniquely decomposable product primes 
mathematicians interested question factor number product primes nearly long 
researchers applied paradigms theoretical computer science number theory looked asymptotic running times factoring algorithms adleman 
resulted great improvement efficiency factoring algorithms 
best factoring algorithm asymptotically currently number field sieve lenstra lenstra lenstra order factor integer takes asymptotic running time exp log log log constant input log bits length algorithm exponential time algorithm 
quantum factoring algorithm takes asymptotically log log log log log log steps quantum computer polynomial log amount post processing time classical computer convert output quantum computer factors post processing principle done quantum computer reason classical computer efficient practice 
giving quantum computer algorithm factoring directly give quantum computer algorithm finding order element multiplicative group mod integer mod 
known randomization factorization reduced finding order element miller briefly give reduction 
find factor odd number method computing order choose random mod find order compute gcd 
gcd greatest common divisor largest integer divides euclidean algorithm knuth compute gcd polynomial time 
mod gcd shor fails non trivial divisor odd mod 
criterion shown procedure applied random mod yields factor probability number distinct odd prime factors brief sketch proof result follows 
suppose pai ri order mod ai 
common multiple ri 
consider largest power dividing ri 
algorithm fails powers agree odd exist equal larger mod mod chinese remainder theorem knuth hardy wright theorem choosing mod random choosing number xi mod ai random pai ith prime power factor multiplicative group mod odd prime power cyclic knuth odd prime power ai probability choosing xi having particular power largest divisor order ri 
powers probability agreeing previous ones agree probability chance choose 
scheme long odd prime power finding factors prime powers done efficiently classical methods 
describe algorithm finding order mod quantum computer 
algorithm quantum registers hold integers represented binary 
amount workspace 
workspace gets reset subroutine algorithm include write state machine 
find order xr mod 
find power include write state machine change values 
quantum gate array need keep values memory built structure gate array 
put register uniform superposition states representing numbers mod 
leaves machine state 
step relatively easy entails putting bit register superposition 
compute xa mod second register described 
keep register done reversibly 
leaves machine state mod 
perform fourier transform aq register described mapping exp iac 
factoring quantum computer apply unitary matrix entry equal exp iac 
leaves machine state exp iac mod 
observe machine 
sufficient observe solely value register clarity assume observe xa mod compute probability machine ends particular state xk mod may assume summing possible ways reach state xk mod find probability exp iac 
sum mod 
order sum satisfying mod 
writing br find probability exp br 
ignore term exp factored sum magnitude 
replace rc rc rc residue congruent rc mod range rc 
leaves expression exp ib rc 
show rc small amplitudes sum nearly direction close phase sum large 
turning sum integral obtain exp ib rc db exp rc 
rc error term expression easily seen bounded 
show rc integral large probability obtaining state xk mod large 
note condition depends independent substituting rb integral get exp rc du 
approximating upper limit integration results error expression 
obtain integral exp rc du 
shor probability observing values 
letting rc vary absolute magnitude integral easily seen minimized rc case absolute value expression 
square quantity lower bound probability see particular state mod rc probability asymptotically bounded sufficiently large probability seeing state xk mod rc rc dq 
dividing rq rearranging terms gives 
know fraction satisfies inequality 
obtain fraction lowest terms rounding nearest fraction having denominator smaller fraction polynomial time continued fraction expansion factoring quantum computer finds best approximations fractions hardy wright chapter knuth 
exact probabilities equation example case plotted 
value occur factoring chosen example 
taken smaller values plot distinguishable change functional structure 
note high probability observed value near integral multiple 
fraction lowest terms happens relatively prime give count number states mod enable compute way 
possible values relatively prime euler function knuth hardy wright 
fractions close fraction 
possible values xk order states mod enable obtain states occurs probability obtain probability 
theorem log log constant hardy wright theorem shows find log log fraction time repeating experiment log log times assured high probability success 
practice assuming quantum computation expensive classical computation worthwhile alter algorithm perform quantum computation postprocessing 
observed state wise try numbers close reasonable chance close fraction qd second common factor small 
observed value rounded lowest terms candidate consider small multiples 
see actual order technique reduce expected number trials required find constant factor second technique reduce expected number trials hardest log log log multiples considered 
third technique candidate say test common multiple candidate third technique able reduce expected number trials constant knill cases techniques fail 
note algorithm determining order element properties multiplication mod 
fact permutation mapping set kth iterate computable time polynomial log log algorithm able find order element minimum discrete logarithms prime multiplicative group mod cyclic generators 
comprise non zero residues mod hardy wright theorem knuth 
suppose prime shor generator discrete logarithm number respect integer mod 
fastest algorithm known finding discrete logarithms modulo arbitrary primes gordon adaptation number field sieve runs time exp log log log 
show find discrete logarithms quantum computer modular exponentiations quantum fourier transforms 
algorithm quantum registers 
find power close 
put registers quantum computer uniform superposition mod compute mod third register 
leaves machine state mod 
fourier transform aq send exp ac bd 
take state state probability amplitude leaves quantum computer state exp ac bd 
exp ac bd mod 
observe state quantum computer 
probability observing state mod rb exp ac bd sum rb mod 
note moduli deal keeping track things confusing pose serious problems 
relation br br substitute expression obtain amplitude gk mod br exp brc kc bd 
absolute value square amplitude probability observing state mod analyze expression 
factor factoring quantum computer exp taken terms ignored change probability 
split exponent parts factor obtain exp rc br bt exp br 
mean residue mod equation 
classify possible outputs observed states quantum computer bad show get outputs able deduce furthermore chance getting output constant 
idea rc jq closest integer varies phase exponential term equation varies half unit circle 
phase second exponential term equation farther exp 
conditions hold say output show conditions hold contribution probability corresponding term significant 
furthermore conditions hold constant probability reasonable sample condition holds allow deduce give lower bound probability output output satisfies conditions 
know ranges phase exp ranges iw rc jq equation 
component amplitude exponential summand direction exp iw cos 
condition phase vary due second exponential exp iv 
applying variation manner minimizes component direction get component direction cos 
shor get absolute value amplitude cos 
replacing sum integral get absolute value amplitude cos du pq 
condition error term 
varies pq integral minimized probability arriving state satisfies conditions cos du 
count number pairs satisfying conditions 
number pairs holds exactly number possible exactly holds 
gcd large number holds approximately large number 
pairs satisfying conditions 
multiplying number possible gives approximately pq states combining calculation lower bound probability observing state gives probability observing state 
note probability observed values value state want recover pair mod equation obtained condition dividing thing notice multiplier fraction denominator evenly divides need round nearest multiple divide mod integer find candidate show quantum calculation need repeated polynomial number times find correct requires details 
problem divide number relatively prime 
discrete log algorithm know possible values generated reasonable likelihood know twelfth 
additional difficulty step harder corresponding step factoring quantum computer algorithm factoring 
knew remainder modulo prime powers dividing chinese remainder theorem recover polynomial time 
able prove find remainder primes larger little extra able recover recall pair generated probability twelfth possible pair 
equation follows mapped rounding nearest integral multiple 
exactly close 
corresponds exactly show prime power dividing random contain pi 
willing accept large constant algorithm just ignore prime powers know modulo prime powers try possible residues primes large constant factor increase running time 
twelfth pair twelfth 
prime power random divisible probability probability having prime power divides means evenly divides sum prime powers greater divide 
sum integers converges goes factor increase constant 
recall obtained probability experiment 
experiments obtain sample chosen equally able find set prime powers dividing relatively prime obtain polynomial time algorithm need try possible sets size practice algorithm find sets large common factors 
set gives residue primes larger 
prime pi possibilities residue modulo exponent prime pi prime factorization 
try possibilities residues modulo powers primes possibility calculate corresponding chinese remainder theorem check see desired discrete logarithm 
program algorithm ways efficiency increased efficiency shown 
example estimate number low especially weaker conditions suffice 
means number times experiment need run reduced 
improbable distribution bad values relationship primes true need treat small prime powers separately 
algorithm properties zp algorithm find discrete logarithms fields zp long field shor cyclic multiplicative group 
need know order generator multiply take inverses elements polynomial time 
order generator fact computed quantum order finding algorithm 
boneh lipton generalized algorithm able find discrete logarithms group abelian cyclic 
comments open problems currently believed difficult aspect building actual quantum computer dealing problems imprecision decoherence 
shown bennett quantum gates need precision order reasonable probability completing steps quantum computation amplitudes unitary matrices representing quantum gates perturbed quantum computer reasonable chance producing desired output 
similarly decoherence needs polynomially small order reasonable probability completing steps computation successfully 
holds simple model decoherence bit fixed probability time step complicated models decoherence derived fundamental quantum mechanical considerations unruh palma chuang 
building quantum computers high precision low decoherence accurately perform long computations may formidable difficulties experimental physicists 
classical computers error probabilities reduced hardware software redundancy errorcorrecting codes 
obvious method redundancy quantum computers ruled theorem quantum bits cloned peres argument rule complicated ways reducing inaccuracy decoherence software 
fact progress direction reducing inaccuracy decoherence shor 
result bennett quantum bits faithfully transmitted noisy quantum channel gives hope quantum computations similarly faithfully carried noisy quantum bits noisy quantum gates 
discrete logarithms factoring widely useful problems 
useful crucial public key cryptography application turn possible presumed difficult 
true generalizations boneh lipton algorithms 
uses quantum computation remain discrete logarithms factoring special purpose technique raison tre thwart public key cryptosystems 
may hard problems solved asymptotically faster quantum computers 
particular interesting problems known np complete problem finding short vector lattice adleman adleman mccurley potentially amenable solution quantum computer 
history computer science important problems turned polynomial time np complete 
quantum computers widely useful solve np complete problems 
solving np factoring quantum computer complete problems efficiently holy grail theoretical computer science people expect possible classical computer 
finding polynomial time algorithms solving problems quantum computer discovery 
weak indications quantum computers powerful solve np complete problems bennett believe potentiality ruled 
jeff lagarias finding fixing critical error version discrete log algorithm 
david applegate charles bennett gilles brassard andrew odlyzko dan simon bob solovay umesh vazirani correspondents numerous list productive discussions corrections improvements early drafts pointers literature 
adleman algorithmic number theory complexity contribution proceedings th annual symposium foundations computer science ieee computer society press los alamitos ca pp 

adleman mccurley open problems number theoretic complexity ii proceedings algorithmic number theory symposium ithaca ny may lecture notes computer science adleman 
huang eds springer appear 
bennett cleve margolus shor sleator elementary gates quantum computation phys 
rev pp 

deutsch jozsa conditional quantum dynamics logic gates phys 
rev lett pp 

computer physical system microscopic quantum mechanical hamiltonian model computers represented turing machines statist 
phys pp 

quantum mechanical hamiltonian models turing machines statist 
phys pp 

quantum mechanical hamiltonian models turing machines dissipate energy phys 
rev lett pp 

bennett logical reversibility computation ibm res 
develop pp 

time space trade offs reversible computation siam comput pp 

bennett bernstein brassard vazirani strengths weaknesses quantum computing preprint 
bennett brassard popescu schumacher wooters purification noisy entanglement faithful teleportation noisy channels phys 
rev lett appear 
bernstein vazirani quantum complexity theory proceedings th annual acm symposium theory computing acm new york pp 

shor brassard quantum challenge structural complexity theory proceedings seventh annual structure complexity theory conference ieee computer society press los alamitos ca pp 

oracle quantum computing proceedings workshop physics computation ieee computer society press los alamitos ca pp 

deutsch jozsa stabilisation quantum computations proceedings workshop physics computation ieee computer society press los alamitos ca pp 

quantum computers simple hamiltonians proceedings workshop physics computation ieee computer society press los alamitos ca pp 

boneh lipton quantum cryptanalysis hidden linear functions advances cryptology crypto proceedings th annual international cryptology conference santa barbara ca aug coppersmith ed 
springer pp 

canny reif new lower bound techniques robot motion planning problems proceedings th annual symposium foundations computer science ieee computer society press los alamitos ca pp 

choi sellen 
yap precision sensitive euclidean shortest path space proceedings th annual symposium computational geometry acm new york pp 

chuang shor zurek quantum computers factoring decoherence science pp 

chuang yamamoto simple quantum computer phys 
rev pp 

church unsolvable problem elementary number theory amer 
math pp 

quantum computations cold trapped ions phys 
rev lett pp 

cleve note computing fourier transforms quantum programs preprint 
coppersmith approximate fourier transform useful quantum factoring ibm research report rc 
deutsch quantum theory church turing principle universal quantum computer proc 
roy 
soc 
london ser 
pp 

quantum computational networks proc 
roy 
soc 
london ser 
pp 

deutsch universality quantum computation proc 
roy 
soc 
london ser 
pp 

deutsch jozsa rapid solution problems quantum computation proc 
roy 
soc 
london ser 
pp 

bit gates universal quantum computation phys 
rev pp 

jozsa shor quantum algorithm numbers rev mod 
phys appear 
feynman simulating physics computers internat 
theoret 
phys pp 

factoring quantum computer quantum mechanical computers 
phys pp 

originally appeared optics news february pp 

fredkin toffoli conservative logic internat 
theoret 
phys pp 

gordon discrete logarithms gf number field sieve siam discrete math pp 

hardy wright theory numbers fifth ed oxford university press new york 
hartmanis simon power multiplication random access machines proceedings th annual symposium switching automata theory ieee computer society long beach ca pp 

karatsuba yu 
multiplication numbers automata dokl 
akad 
nauk sssr pp 
russian 
english translation sov 
phys 
dokl pp 

knuth art computer programming vol 
algorithms second ed addison wesley 
knill personal communication 
landauer quantum mechanics useful 
philos 
trans 
roy 
soc 
london ser 
appear 
quantum mechanically coherent computation useful 
proceedings drexel symposium quantum quantum classical correspondence feng 
hu eds international press appear 
machines de turing 
cursive en de est un de codes acad 
fran sci pp 

lenstra lenstra jr eds 
development number field sieve lecture notes mathematics vol 
springer 
lenstra lenstra jr manasse pollard number field sieve proceedings nd annual acm symposium theory computing acm new york pp 

expanded version appeared lenstra lenstra pp 

levine sherman note bennett time space tradeoff reversible computation siam comput pp 

lloyd potentially realizable quantum computer science pp 

envisioning quantum supercomputer science 
quantum logic gate universal phys 
rev lett pp 

margolus quantum computation ann 
new york acad 
sci pp 

parallel quantum computation complexity entropy physics information santa fe institute studies sciences complexity vol 
viii zurek ed addison wesley pp 

miller riemann hypothesis tests primality comput 
system sci pp 

odlyzko personal communication 
palma 
quantum computers dissipation proc 
roy 
soc 
london ser 
submitted 
shor peres quantum theory concepts methods kluwer academic publishers 
fast rigorous factorization discrete logarithm algorithms discrete algorithms complexity proceedings japan joint seminar june kyoto johnson wilf eds academic press pp 

post finite combinatory processes 
formulation symbolic logic pp 

rivest shamir adleman method obtaining digital signatures public key cryptosystems comm 
assoc 
comput 
mach pp 

digital simulation analog computation church thesis symbolic logic pp 

sch asymptotically fast algorithms numerical multiplication division polynomials complex coefficients computer algebra lecture notes computer science vol 
ed springer pp 

sch vetter fast algorithms turing machine implementation mannheim germany 
sch strassen zahlen computing pp 

shor algorithms quantum computation discrete logarithms factoring proceedings th annual symposium foundations computer science ieee computer society press los alamitos ca pp 

scheme reducing decoherence quantum memory phys 
rev pp 

simon power quantum computation proceedings th annual symposium foundations computer science ieee computer society press los alamitos ca pp 

sleator realizable universal quantum logic gates phys 
rev lett pp 

solovay personal communication 
steiglitz non standard paradigms computation analog machines cellular automata performance limits communication theory practice proceedings nato advanced study institute il italy july ed kluwer academic publishers pp 

teich obermayer mahler structural basis quantum systems ii effective particle dynamics phys 
rev pp 

toffoli reversible computing automata languages programming seventh colloquium lecture notes computer science vol 
de bakker van leeuwen eds springer pp 

turing computable numbers application entscheidungsproblem proc 
london math 
soc 
pp 

corrections proc 
london math 
soc 
pp 

unruh maintaining coherence quantum computers phys 
rev pp 

van emde boas machine models simulations handbook theoretical computer science vol 
van leeuwen ed elsevier amsterdam pp 

steiglitz dickinson complexity analog computation math 
comput 
simulation pp 

yao quantum circuit complexity proceedings th annual symposium foundations computer science ieee computer society press los alamitos ca pp 

