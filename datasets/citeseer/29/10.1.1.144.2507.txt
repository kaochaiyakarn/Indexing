generalized search trees database systems joseph hellerstein je rey naughton avi pfe er cs wisc edu avi cs berkeley edu june introduces generalized search tree gist index structure supporting extensible set queries data types 
gist allows new data types indexed manner supporting queries natural types contrast previous tree extensibility supported traditional set equality range predicates 
single data structure gist provides basic search tree logic required database system unifying disparate structures trees trees single piece code opening application search trees general extensibility 
illustrate exibility gist provide simple method implementations allow behave tree tree rd tree new index data set valued attributes 
preliminary performance analysis rd trees leads discussion nature tree indices behave various datasets 
cient implementation search trees crucial database system 
traditional relational systems trees com su cient sorts queries posed usual set alphanumeric data types 
today database systems increasingly deployed support new applications geographic information systems multimedia systems cad tools document libraries sequence databases ngerprint identi cation systems biochemical databases support growing set applications search trees extended maximum exibility 
requirement motivated major research approaches extending search tree technology 
specialized search trees large variety search trees developed solve speci problems 
best known trees spatial search trees trees gut 
signi cant impact particular domains approach developing domain speci search trees problematic 
ort required implement maintain data structures high 
new applications need supported new tree structures developed scratch requiring new implementations usual tree facilities search maintenance concurrency control recovery 

search trees extensible data types alternative developing new data structures existing data structures trees trees extensible data types support sto 
example trees index data linear ordering supporting equality linear range queries data 
provides extensibility data indexed extend set queries supported tree 
regardless type data stored tree queries bene tree containing equality linear range predicates 
similarly tree queries tree containing equality overlap containment predicates 
exibility presents signi cant problems new applications traditional queries linear orderings spatial location pertinent new data types 
third direction extending search tree technology 
introduce new data structure called generalized search tree gist easily extensible data types index queries support 
extensibility queries particularly important allows new data types indexed manner supports queries natural types 
addition providing extensibility new data types gist uni es previously disparate structures currently common data types 
example trees trees implemented extensions gist resulting single code base indexing multiple dissimilar applications 
gist easy con gure adapting tree di erent uses requires registering methods database system encapsulate structure behavior object class keys tree 
illustration exibility provide method implementations allow gist tree tree rd tree new index data set valued attributes 
gist adapted avariety known search tree structures partial sum trees trees rob ch trees exodus large objects cdg hb trees ls trees mcd tv trees implementing new set methods gist signi cantly easier task implementing new tree package scratch example postgres gro shore cdf implementations trees trees order lines code method implementations gist order lines code 
addition providing uni ed highly extensible data structure general treatment search trees sheds initial light fundamental question dataset indexed gist resulting tree provide cient lookup 
answer question discussion illustrate issues ect ciency search tree 
leads interesting question build cient search tree queries non standard domains question explored experimenting gist 
structure section illustrate generalize basic nature database search trees 
section introduces generalized search tree object structure properties behavior 
section provide gist implementations di erent sorts search trees 
section presents performance results explore issues involved building ective search tree 
section examines details need considered implementing full edged dbms 
section concludes discussion signi cance directions research 
related survey search trees provided knuth knu trees variants covered detail comer com 
variety search trees trees gut variants trees bkss trees srf 
multidimensional search trees include quad trees fb trees rob hb trees ls 
multidimensional data transformed unidimensional data space lling curve jag transformation tree index resulting unidimensional data 
extensible key indices introduced postgres sto included illustra sto extensible tree tree implementations 
extensible indices allow types data indexed support xed set query predicates 
example postgres trees support usual ordering predicates postgres trees support predicates left right overlap right contains contained equal gro 
extensible trees provide sizable subset gist functionality 
knowledge represents rst demonstration trees index data mapped spatial domain 
limited extensibility trees lack anumber features supported key key 
internal nodes directory leaf nodes linked list sketch database search tree 
gist 
trees provide sort key predicate contains allow user speci cation penalty algorithms described lack optimizations data linearly ordered domains 
despite limitations extensible trees close allow initial method implementations performance experiments describe section 
classi cation trees id qui similar spirit gist major di erences 
signi cantly classi cation trees intended search structures suited indexing large amounts data 
additionally id built pre de ned discrete classes gist dynamic structure develops unspeci ed data buckets leaves potentially overlapping keys 
classi cation trees generally extensible de ned traditional tuple objects attributes numeric nitely enumerated domains 
extensions gist may able leverage lessons learned development classi cation trees particularly implementing methods picking way split nodes method described choosing keys union compress methods described 
predicate trees valduriez vv similar classi cation trees index data sets de ned traditional alphanumeric predicates 
predicate trees generate hash keys 
limited notion interval hierarchy index le simple conjunctive ordering predicates 
analyses tree performance appeared fk 
dependent onthe spatial nature typical tree data generally applicable gist 
similar ideas may prove relevant questions build cient indices arbitrary domains 
getting gist database search trees instructive review search trees simpli ed manner 
people database experience notion search trees discussion purposely vague goal simply illustrate notion leaves details unspeci ed 
highlighting unspeci ed details proceed describe structure leaves details open user speci cation 
canonical rough picture database search tree appears 
balanced tree high fanout 
internal nodes directory 
leaf nodes contain pointers actual data stored linked list allow partial complete scanning 
internal node series keys pointers 
search tuples match query predicate starts root node 
pointer node associated key consistent key rule possibility data stored pointer may match traverses subtree pointer matching data 
illustration review notion consistency familiar tree structures 
trees queries form range predicates nd keys logically delineate range data pointer contained 
query range pointer key range overlap consistent pointer traversed 
trees queries form region predicates nd overlaps keys delineate bounding box data pointer contained 
query region pointer key box overlap pointer traversed 
note description restriction placed key logically match datum stored consistency check valid data 
trees trees keys essentially containment predicates describe contiguous region data contained 
containment predicates possible key constructs 
example predicate elected cial criminal record acceptable key data item stored associated pointer satis es predicate 
trees overlap keys node may hold simultaneously tuple 
exibility allows generalize notion search key search key may arbitrary predicate holds datum key 
data structure exible search keys user free form tree organizing data arbitrary nested sub categories labelling characteristic predicate 
turn lets capture essential nature database search tree hierarchy categorizations categorization holds data stored hierarchy 
searches arbitrary predicates may conducted categorization 
order support searches predicate user provide boolean method tell consistent search key 
search proceeds traversing pointer associated searchkey 
grouping data categories may user supplied node splitting algorithm characterization categories done user supplied search keys 
exposing key methods tree split method user arbitrary search trees may constructed supporting extensible set queries 
ideas form basis gist proceed describe detail 
generalized search tree section data type object generalized search tree gist 
de ne structure invariant properties extensible methods built algorithms 
matter convention refer indexed datum tuple object oriented object relational dbms indexed datum arbitrary data object 
structure gist balanced tree variable fanout km exception root node constant termed minimum ll factor tree 
leaf nodes contain ptr pairs predicate search key ptr identi er tuple database 
non leaf nodes contain ptr pairs predicate search key ptr pointer tree node 
predicates contain number free variables long single tuple referenced leaves tree instantiate variables 
note key compression predicate may take little zero bytes storage 
purposes exposition assume entries tree uniform size 
discussion variable sized entries deferred section 
assume implementation entry ptr access node currently resides 
prove helpful implementing key methods described 
properties properties invariant gist 
node contains km index entries root 

index entry ptr leaf node true instantiated values indicated tuple holds tuple 

index entry ptr non leaf node true instantiated values tuple reachable ptr 
note trees entry ptr reachable ptr require merely hold tuples reachable ptr 
root children leaf 

leaves appear level 
property particular interest 
tree require bounding boxes tree arranged containment hierarchy 
tree approach unnecessarily restrictive predicates keys node hold data need keys restate predicates re ned manner 
choose keys characterize sets entirely orthogonal classi cation 
advantage information content size keys 
key methods principle keys gist may arbitrary predicates 
practice keys come object class provides particular set methods required gist 
examples key structures include ranges integers data trees bounding boxes regions trees bounding sets set valued data data rd trees described section key class open rede nition user set methods required gist consistent entry ptr query predicate returns false guaranteed unsatis able true 
note accurate test satis ability required consistent may return true incorrectly ecting correctness tree algorithms 
penalty errors performance may result exploration irrelevant subtrees search 
union set entries ptr pn ptr returns predicate holds tuples stored ptr ptr done nding predicate pn compressed repre compress entry ptr returns entry ptr sentation decompress compressed representation ptr compress returns entry ptr note potentially lossy compression require penalty entries ptr ptr returns domain speci penalty inserting subtree rooted 
aid split insert algorithms described 
typically penalty metric representation increase size union 
example penalty keys de ned area union area gut 
set entries ptr splits sets entries size km 
choice minimum ll factor tree controlled 
typically itis desirable split minimize badness metric akin multi way penalty left open user 
methods gist user needs supply 
note consistent compress union penalty able handle predicate input 
full generality di cult especially consistent 
typically limited set predicates tree set constrained method implementation 
number options key compression 
simple implementation compress decompress identity function 
complex implementation compress ptr generate valid compact predicate decompress identity function 
technique shore trees example insertion take polygon compress bounding box valid polygon 
pre trees com truncate split keys initial substring 
involved implementations complex methods compress decompress 
tree methods key methods previous section provided designer key class 
tree methods section provided gist may invoke required key methods 
note keys compressed placed node decompressed read node 
consider implicit mention describing methods 
search search comes avors 
rst method section search query predicate traversing tree necessary satisfy query 
general search technique analogous trees 
cient technique queries linear orders described section 
input gist rooted predicate output tuples satisfy algorithm search sketch recursively descend paths tree keys consistent search subtrees leaf check entry determine consistent 
entries consistent invoke search subtree root node referenced ptr 
search leaf node leaf check entry determine consistent 
consistent qualifying entry 
point ptr fetched check accurately check left calling process 
note query predicate exact match equality predicate predicate satis able values 
category includes range window predicates trees general predicates contiguous areas set containment predicates supersets 
search linearly ordered domains domain indexed linear ordering queries typically equality range containment predicates cient search method possible findmin methods de ned section 
option available user take extra steps creating tree 
ag isordered set true 
isordered static property tree set creation 
defaults false 

additional method compare registered 
entries ptr ptr compare returns negative number precedes returns positive number follows returns 
compare insert entries order node 

method ensure entries compare 
methods assure keys node overlap pair entries node consistent false 
steps carried equality range containment queries may evaluated calling findmin repeatedly calling query predicates may evaluated general search method 
findmin cient traversing tree search findmin visit non leaf nodes root leaf path 
technique typical range lookup trees 
input gist rooted predicate algorithm findmin output minimum tuple linear order satis es sketch descend leftmost branch tree keys consistent leaf node reached return rst key consistent fm search subtrees leaf nd rst entry order consistent invoke findmin subtree root node referenced ptr 
entry return null 
fm search leaf node leaf nd rst entry consistent return entry exists return null 
element satis es predicate method returns existing element satis es null 
su ciently general nd entry non leaf levels tree prove useful section 
search purposes invoked leaf entries 
appropriate entry may doing binary search entries node 
discussion intra node search optimizations appears section 
algorithm input gist rooted predicate current entry output entry linear order satis es sketch return entry level tree satis es return null 
node rightmost entry node entry right order consistent return consistent return null 
neighboring node entry node node right level tree tree traversal sideways pointers tree available ly 
non existent return null 
leftmost entry consistent return return null 
insert insertion routines guarantee gist remains balanced 
similar insertion routines trees generalize simpler insertion routines trees 
insertion allows speci cation level insert 
allows subsequent methods insert entries internal nodes tree 
assume level numbers increase tree leaf nodes level 
new entries tree inserted level 
algorithm insert input gist rooted entry ptr level predicate holds tuples reachable ptr 
output new gist resulting insert level sketch nd go add splitting necessary room 

invoke nd go 
room install order compare isordered 
invoke split 

propagate changes upward 
nd best node insertion level tree 
isordered property holds penalty method carefully written assure arrives correct leaf node order 
example done section 
algorithm input subtree rooted entry ptr level output node level best suited hold entry characteristic predicate sketch recursively descend tree minimizing penalty cs 
level return cs 
entries ptr nd penalty minimal 
return ptr 
split algorithm user de ned method choose split elements node including new tuple inserted tree 
elements split groups split generates new node groups inserts tree updates keys new node 
algorithm split input gist node new entry ptr 
output gist split inserted 
sketch split keys groups 
put group new node insert new node parent ofn 
sp invoke union elements feg put partitions node put remaining partition new node sp insert entry parent ptr union entries ptr pointer room parent install parent order isordered 
invoke split parent sp modify entry points union entries step sp split modi es parent node re ect changes changes propagated upwards rest tree step insert algorithm propagates changes due insertion algorithm ensures keys set predicates hold tuples appropriately speci specify technique nd parent node implementation interacts issues related concurrency control discussed section 
depending techniques parent pointer stack re traversal tree 
input gist rooted tree node algorithm output gist ancestors containing correct speci keys sketch ascend parents tree making predicates accurate characterizations subtrees 
root predicate accurate 
pr root entry points accurate representation union entries return 
pr modify entry points union entries parent 
note typically performs isordered true domains predicates partition entire domain ranges need modi cation simple insertion deletion 
routine detects step pr avoids calling higher nodes tree 
domains may circumvented entirely desired 
delete deletion algorithms maintain balance tree attempt keep keys speci possible 
algorithm uses tree borrow coalesce technique ow linear order 
uses tree reinsertion technique 
input gist leaf entry ptr output balanced gist removed algorithm delete sketch remove leaf node 
causes ow adjust tree accordingly 
update predicates ancestors keep speci possible 
find node containing entry invoke search nd leaf node containing 
delete entry 
remove propagate changes 
invoke shorten tree 
root node child tree adjusted child new root 
algorithm input gist containing leaf node output gist invariant properties maintained sketch fewer km elements eliminate relocate entries borrow entries put propagate node elimination upwards necessary 
adjust predicates path root making speci appropriate 
ct initialize 
set set set eliminated nodes empty 
ct root go ct 
parent en points entry ct handle full node fewer km entries ct isordered delete isordered add elements set delete invoke 
ct isordered try borrow entries coalesce neighbor neighboring node order 
number keys combined km greater evenly split entries nodes 
place entries delete en invoke 
ct adjust covering predicate deleted ct propagate deletes deleted goto ct ct re insert orphaned entries empty invoke insert level elements implementations considered preferable leave node full delete expectation ll soon js 
support behavior step algorithm delete invoke avoid 
gist applications section brie describe implementations key classes gist behave tree tree rd tree new tree index set valued data 
trees example index integer data 
compression key tree pair integers representing interval contained key 
particularly key represents predicate contains variable query predicates support key class contains interval equal number 
interval contains query may open 
boundary interval integers trivially converted closed open 
loss generality assume intervals closed left open right 
implementations contains equal query predicates follows contains return true 
return false 
equal return true 
return false 
implementations gist methods consistent entry ptr query predicate know contains xp yp contains xq yq equal xq 
rst case return true xp yq yp xq false 
second case return true xp xq yp false 
union ptr en xn yn ptr return min max yn 
compress ptr leftmost key non leaf node return byte object 
return decompress ptr construct interval 
leftmost key non leaf node 
rightmost key non leaf node 
key non leaf node value stored key method 
leaf node 
return ptr 
penalty ptr ptr leftmost pointer node return max 
rightmost pointer node return max 
return max max 
jp rst right 
note guarantees minimum additions ordered keys isordered true entries order go left group jp ll factor entries go compare ptr ptr return 
number interesting features note set methods 
compress decompress methods produce typical split keys trees stored keys pointers leftmost rightmost boundaries node left unspeci ed 
key pointer pairs split keys gist uses space keys traditional tree compresses rst pointer node zero bytes 
second penalty method allows gist choose correct insertion point 
inserting new key value interval cause penalty positive contained interval 
step cs method place new data appropriate spot set keys node partitions entire domain order minimize penalty choose partition contained 
observe fairly easily support complex predicates including disjunctions intervals query predicates ranked intervals key predicates supporting cient sampling 
polygons trees example data dimensional polygons cartesian plane 
compression keys tree tuples reals representing upper left lower right corners rectilinear bounding rectangles polygons 
akey ul ul lr lr represents predicate contains ul ul lr lr ul ul upper left corner bounding box lr lr lower right corner free variable 
query predicates support key class contains box overlap box equal box box tuple 
implementations query predicates follows contains ul ul lr lr ul ul lr return true lr return false 
lr lr ul ul lr lr ul ul overlap ul ul lr lr ul ul lr return true lr return false 
ul lr ul lr lr ul lr ul equal ul ul lr lr ul ul lr return true lr return false 
ul ul ul gist method implementations ul lr lr lr lr 
queries return false 
consistent entry ptr know contains ul ul lr lr contains overlap equal argument ul ul lr lr return true overlap ul ul lr lr union eq ul ul lr lr ptr en max return min ul xn ul ul ul lr lr ul yn ul xn lr yn lr ul yn max ul lr xn min lr lr yn lr 
compress ptr form bounding box polygon polygon stored set line segments li xi yi xi yi form imin xi ul imax yi ul imax xi lr imin yi 
return lr ptr 
decompress ul ul lr lr ptr identity function return penalty ptr ptr compute union return area area 
metric change area proposed guttman gut 
variety algorithms proposed tree splitting 
omit method implementation discussion refer interested reader gut bkss 
implementations gist algorithms described previous chapters give behavior identical guttman tree 
series variations trees proposed notably tree bkss tree srf 
tree di ers basic tree ways algorithm small changes algorithm varies slightly policy node split 
di cult implement tree gist tree algorithm implemented method gist modi cations introduced careful implementation penalty method reinsertion policy tree easily added built gist tree methods see section 
trees hand mimicked gist 
tree places duplicate copies data entries multiple leaf nodes violating gist principle search tree hierarchy data 
observe fairly easily support complex predicates including dimensional analogs disjunctive queries ranked keys mentioned trees 
examples include arbitrary variations usual overlap ordering queries nd polygons overlap box nd polygons overlap clock point returns polygons region bounded exit angles polar coordinates 
note nite region de ned polygon line segments query expressed typical tree predicates 
rd trees previous sections demonstrated gist provide functionality known data structures trees trees 
section demonstrate gist provide support new search tree indexes set valued data 
problem handling set valued data attracting increasing attention object oriented database community kg fairly natural traditional relational database applications 
example database table students student attribute courses passed type setof integer 
ciently support containment queries nd students passed courses prerequisite set 
handle gist sets containment keys tree uses bounding boxes containment keys 
call resulting structure rd tree russian doll tree 
keys rd tree sets integers rd tree derives name fact traverses branch tree key contains key branch 
proceed give gist method implementations rd trees 
compression keys rd trees sets integers 
key represents predicate contains set valued variable query predicates allowed rd tree contains set overlap set equal set 
implementation query predicates straightforward contains return true false 
overlap return true false 
equal return true false 
gist method implementations consistent ptr keys predicates know contains contains overlap equal 
return true overlap false 
union ptr ptr return compress ptr avariety compression techniques sets hp 
brie describe 
elements sorted converted set disjoint ranges 
conversion done algorithm initialize consider element range 
ranges remain find pair adjacent ranges interval form single range pair resulting structure called 
shown algorithm produces items minimal addition elements hp 
decompress ptr easily converted back sets enumerating elements ranges 
je 
alternatively return change weighted cardinality element weight jsj sum weights elements penalty ptr ptr return je data overlap trees compression loss space factors ecting gist performance guttman quadratic algorithm tree split works naturally 
referred gut details 
reader gist supports usual tree query predicates containment keys uses traditional tree algorithm 
result able implement methods illustra extensible trees get behavior identical gist behavior 
exercise gave sense complexity gist class implementation lines code allowed performance studies described section 
trees limit choices predicates split penalty algorithms merit exploration build rd trees 
gist performance issues balanced trees trees overlapping keys maximum number nodes examined easy bound point query duplicate free data height tree log database tuples 
upper bound guaranteed keys tree gist overlapping keys cause searches multiple paths tree 
performance gist varies directly amount keys nodes tend overlap 
major causes key overlap data overlap information loss due key compression 
rst issue straightforward data objects overlap signi cantly keys tree overlap 
example dataset entirely identical items produce ine cient index queries match items 
workloads simply amenable indexing techniques processed sequential scans 
loss due key compression causes problems slightly subtle way sets data may overlap keys sets may overlap compress decompress methods produce exact keys 
consider trees example compress method produces bounding boxes 
objects box keys represent inaccurate may indicate overlaps 
trees problem compression loss largely ignored spatial data objects geographic entities regions brain tend relatively box shaped 
need case 
example consider tree index dataset corresponding plate spaghetti single intersects dimensions bounding boxes intersect 
better approximations bounding boxes considered doing spatial joins bkss 
proposes bounding boxes tree accurate approximations main memory post processing steps 
performance issues described displayed graph 
origin graph trees data overlap lossless key compression optimal logarithmic performance described 
note trees duplicate free data origin graph 
moves axis performance expected degrade 
worst case axis keys consistent query tree traversed query 
worst case axis data identical tree traversed query consistent data 
section initial experiments rd trees explore space 
chose rd trees reasons 
able implement methods illustra trees 

set data arbitrary overlap opposed polygon data contiguous boundaries harder manipulate 
example trivial construct distant hot spots shared sets rd tree geometrically di cult polygons tree 
believe set valued data particularly useful experimenting overlap 
validate intuition performance space generated datasets corresponding point space 
dataset contained set valued objects 
object regularly spaced set ranges comb laid number line 
teeth comb integers wide spaces teeth integers wide large accommodate tooth object dataset 
datasets formed changing variables number ranges set overlap amount comb overlapped predecessor 
varying adjusted compression loss compress method allowed ranges comb teeth inter tooth spaces erroneously included compressed representation 
amount controlled left edge comb overlap rst comb started second third combs overlapped 
overlap rst comb started second third datasets generated forming combinations overlap 
ofthe datasets queries performed 
query searched objects overlapping di erent tooth rst comb 
query performance measured number os numbers averaged dataset 
performance shown appendix illustrative plot shown axes axis represents average number os 
landscape expected slopes upwards axis 
general insights data overlap compression loss veri ed experiment number performance variables remain unexplored 
issues concern hot spots correlation factor hot spots 
hot spots rd trees integers appear sets 
general hot spots thought speci predicates satis able tuples dataset 
correlation factor integers rd tree likelihood appears set appear 
general correlation factor hot spots likelihood holds tuple holds 
interesting question gist behaves data sets produce hot spots correlations 
question similar issues prove area research 
implementation issues previous sections described gist demonstrated exibility discussed performance index secondary storage 
full edged database system just secondary storage manager avg 
number os compression loss data overlap performance parameter space surface generated data appendix compression loss calculated data overlap calculated overlap 

section brie address gist implemented account important database system issues 
memory ciency streamlining intra node operations gist index secondary storage 
result algorithms described focus minimizing node accesses operations involve secondary storage structures implemented eye algorithmic ciency situations bene cial streamline memory operations single node 
facilitate optimizations gist situations exploited default behavior general purpose relied correctness scenarios 
sake simplicity generality algorithms described compare input predicates entry node 
cient schemes may particular domains 
example ordered domains appropriate entries node may binary search 
example hb tree entries node indexed tree ben nding appropriate entries node 
alternative optimizations may exist depending domain key predicates 
facilitate techniques additional extensibility gist may optionally leveraged high performance 
node object gist may methods searching inserting deleting entries node may specialized 
sake brevity describe node interface detail give illustrative example 
default behavior node object store entries typical slotted page format intra node search linear fashion 
behavior may specifying subclass node object tree member overloaded member functions intra node insertion deletion search maintain exploit tree 
improved node methods streamline intra node search operations mentioned steps fm fm cs 
small overheads may incurred steps insert delete modify entries nodes 
memory optimization avoid overhead calling user methods operation 
done writing methods inline code recompiling system 
discussed detail section 
concurrency control recovery consistency high concurrency recoverability degree consistency critical factors full edged database system 
concurrency control trees understood problem lehman yao link variant ly atypical way implementing high concurrency trees 
recovery link trees explored lomet salzberg ls show tree generalizes link tree reconstructed gradually interim state 
analogous results existed trees 
main stumbling block fact lehman yao techniques linear ordering data sideways pointers introduced level tree connect nodes level linked list ordered key value 
tree data natural ordering imposing arti cial ordering balancing techniques tree 
fortunately extends lehman yao sideways pointer techniques recovery techniques trees 
ng kameda nk generating pending update list node tree applying lomet salzberg results trees context 
banks stonebraker bks kb simpler solution marks keys nodes sequence numbers uses sequence numbers determine order nodes 
approaches provide solutions degree consistency ng kameda aborting transactions read banks predicate locking 
techniques way trees 
sequence number approach attractive gist simple generalization original link approach 
result original approach case linearly ordered data complex sequence number approach unordered data 
full implementation concurrency recoverability consistency gist certainly revisit issues bulk problems addressed 
variable length keys convenient allow keys vary length particularly compress method available 
unfortunately variable length keys cause problems gist trees due possible scenario 
new entry inserted leaf node 
full new node generated data split 
split new entry assigned results key 

key grows size longer ts parent node 

entry key removed parent node point unpleasant situation having detached tree 
traditional split propagation algorithm works detached node 
new technique required handle 
linearly ordered domains situation outlined occur key propagation necessary recall discussion section unordered domains problem occur 
suggest possible solutions reinsertion scenario described handled calling insert method reinsert orphaned nodes original level 
care taken ensure problem described re occur reinsert 
new entry new node alternative force new entry placed split 
know su ciently small key appropriate particular old key valid split 
old key may unacceptably general advisable search speci key small rst solution advantage exible potentially improving performance tree re ned data placement bkss 
may require modi cations concurrency control techniques described previous section 
second solution simpler presents problem nding key requires su ciently little storage 
possible ensure generality decreases storage required compressed key increase 
guaranteed general natural domains sets 
bulk loading unordered domains clear ciently build index large pre existing dataset 
ordering sort data sorted data partitioned linked list nodes tree may constructed list 
sort order partitioning results relatively full tree low overlap keys 
various sort orders developed trees kf jag solutions speci spatial domain generally applicable extensible structure gist 
extending new domains prove interesting 
extensible method may added gist accommodate bulk loading various domains 
optimizer integration integrate query optimizer optimizer know query predicates match gist 
done registering predicates supported consistent method optimizer 
trees isordered true additionally specify optimizer predicates evaluated findmin technique 
planning query optimizer sees boolean factor sac registered predicates knows consider probing gist potential access paths 
question estimating cost probing gist di cult defer section 
coding details propose implementing gist ways extensible gist designed easy extensibility template gist designed maximal ciency 
little care implementations built code base replication logic 
extensible gist package object library providing gist class class 
skeleton users may inherit method names described section provide domain speci implementations 
terminology methods virtual member functions meaning time method compress invoked key object appropriate implementation compress looked invoked 
invoking virtual member functions ine cient architecture allows great exibility new key classes may implemented demand dynamically linked running dbms index new data types halting dbms 
analogous extensible indexing scheme postgres suitable prototyping systems high availability important 
template gist package provides template gist class source code library 
users develop key class liking say appropriate methods 
declare class gist code 
compiling code gist index behaves desired ine ciencies invoking virtual member functions 
note may implement key methods inline code particularly trivial operations identity function compress decompress methods 
eliminates pathlength involved making function call masking complexity extensibility features 
template gist spirit extensible database toolkits build custom designed cient systems 
summary incorporation new data types today database systems requires indexes support extensible set queries 
facilitate isolated essential nature search trees providing clean characterization alike 
insight developed generalized search tree uni es previously distinct search tree structures 
gist extremely extensible allowing arbitrary data sets indexed ciently queried new ways 
exibility opens question generate ective search trees 
gist uni es trees trees single structure immediately useful systems require functionality 
addition extensibility gist opens number interesting research problems pursue primary theoretical question raised gist nd general characterization workloads amenable indexing 
gist provides means index arbitrary domains arbitrary queries lack theory describe trying index data set practical set queries 
indexing non standard domains practical matter interested building indices unusual domains sets terms images sequences graphs video sound clips ngerprints molecular structures pursuit applied results provide interesting feedback loop theoretical explorations described 
investigation rd trees set data begun rd trees shore illustra trees gist 
shift trees gist able experiment new methods new predicates sets 
query optimization cost estimation cost estimates query optimization need take account costs searching gist 
currently estimates reasonably accurate trees trees 
tree cost estimation done fk required bring bear general 
additional problem user de ned gist methods may time consuming operations cpu cost registered optimizer hs 
optimizer correctly incorporate cpu cost methods estimate cost probing particular gist 
lossy key compression techniques new data domains indexed necessary nd new lossy compression techniques preserve properties gist 
algorithmic improvements gist algorithms insertion trees 
noted section trees somewhat modi ed algorithms provide performance gain spatial data 
particular tree policy forced reinsert split may generally bene cial 
investigation tree modi cations needs carried non spatial domains 
techniques prove bene cial incorporated gist option default behavior 
additional required unify tree modi cations techniques concurrency control recovery 
believe domain speci search tree enhancements take account generality issues raised 
reason develop new distinct search tree structures comparable performance obtained uni ed framework 
gist provides framework plan implement library package exploited avariety systems 
praveen seshadri marcel mike olson kurt brown jim gray anonymous reviewers helpful input 
debts gratitude due sta illustra information systems mike stonebraker paula providing exible industrial research environment mike olson je meredith kevin brown michael wei hong help technical matters 
finkelstein insights rd trees 
simon hellerstein responsible acronym gist 
ira singer provided hardware loan possible 
sacks crucial resource course 
aoki 
implementation extended indexes postgres 
sigir forum 
ben bentley 
multidimensional binary search trees database applications 
ieee transactions software engineering se july 
bks douglas banks marcel michael stonebraker 
high concurrency locking trees 
technical report sequoia university california berkeley june 
bkss norbert beckmann hans peter kriegel ralf schneider bernhard seeger 
tree cient robust access method points rectangles 
proc 
acm sigmod international conference management data atlantic city may pages 
bkss thomas hans peter kriegel ralf schneider bernhard seeger 
multi step processing spatial joins 
proc 
acm sigmod international conference management data minneapolis may pages 
cdf michael carey david dewitt michael franklin nancy hall mark je rey naughton daniel schuh marvin solomon tan seth white michael 
persistent applications 
proc 
acm sigmod international conference management data minneapolis may pages 
cdg carey dewitt graefe richardson schuh shekita 
exodus extensible dbms project overview 
stan zdonik david maier editors readings object oriented database systems 
morgan kaufmann publishers 
com douglas comer 
ubiquitous tree 
computing surveys june 
fb finkel bentley 
quad trees data structure retrieval composite keys 
acta informatica 
fk christos faloutsos ibrahim kamel 
uniformity independence analysis trees concept fractal dimension 
proc 
th acm sigact sigmod sigart symposium principles database systems pages minneapolis may 
gro gut postgres group 
postgres manual version 
technical report electronics research laboratory university california berkeley april 
guttman 
trees dynamic index structure spatial searching 
proc 
acm sigmod international conference management data boston june pages 
hp hs jag js kb kf kg joseph hellerstein avi pfe er 
rd tree index structure sets 
technical report university wisconsin madison october 
joseph hellerstein michael stonebraker 
predicate migration optimizing queries expensive predicates 
proc 
acm sigmod international conference management data washington may pages 
jagadish 
linear clustering objects multiple attributes 
proc 
acm sigmod international conference management data atlantic city may pages 
johnson shasha 
inserts deletes trees free empty better merge half 
journal computer sciences systems august 
marcel douglas banks 
high concurrency locking trees 
submitted publication 
ibrahim kamel christos faloutsos 
packing trees 
second international conference information knowledge management cikm november 
won kim jorge 
requirements performance benchmark object oriented systems 
won kim editor modern database systems object model interoperability 
acm press june 
won kim chang kim alfred dale 
indexing techniques object oriented databases 
won kim fred lochovsky editors object oriented concepts databases applications pages 
acm press addison wesley publishing 
knu donald knuth 
sorting searching volume art computer programming 
addison wesley publishing 
king ip lin jagadish christos faloutsos 
tv tree index structure high dimensional data 
vldb journal october 
ls ls david lomet betty salzberg 
hb tree multiattribute indexing method 
acm transactions database systems december 
david lomet betty salzberg 
access method concurrency recovery 
proc 
acm sigmod international conference management data pages san diego june 
ly lehman yao 
cient locking concurrent operations trees 
acm transactions database systems 
mcd cio marco casanova marcelo 
trees storage method long vector data 
proc 
th international conference onvery large data bases pages santiago september 
nk vincent ng kameda 
link tree recoverable index structure spatial data 
proc 
fifth international conference database expert systems applications dexa pages athens 
bernd uwe pagel hans werner heinrich peter widmayer 
analysis range query performance spatial data structures 
proc 
th acm sigact sigmod sigart symposium principles database systems pages washington may 
qui ross quinlan 
programs machine learning 
morgan kaufmann publishers 
rob robinson 
tree search structure large multidimensional dynamic indexes 
proc 
acm sigmod international conference management data pages ann arbor april may 
sac srf sto sto vv patricia selinger astrahan chamberlin raymond lorie price 
access path selection relational database management system 
proc 
acm sigmod international conference management data boston june 
sellis nick roussopoulos christos faloutsos 
tree dynamic index multi dimensional objects 
proc 
th international conference large data bases pages brighton september 
michael stonebraker 
inclusion new types relational database systems 
proceedings ieee fourth international conference data engineering pages washington february 
michael stonebraker 
miro dbms 
proc 
acm sigmod international conference management data washington may page 
patrick valduriez yann 
multikey hashing scheme predicate trees 
proc 
acm sigmod international conference management data boston june pages 
kai wong murray 
interval hierarchies application predicate les 
acm transactions database systems september 
wong easton 
cient method weighted sampling replacement 
siam journal computing february 
query performance comb data overlap query query query query query average 
