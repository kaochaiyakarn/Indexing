backward conditioning new program specialisation technique program comprehension chris college university london wc kingdom tel fax dcs kcl ac uk mark harman rob university ub kingdom tel fax mark harman brunel ac uk sebastian college university cross london se kingdom tel fax sebastian mcs gold ac uk keywords conditioned program slicing program specialisation path condition analysis introduces backward conditioning 
ward conditioning conditioned slicing backward conditioning consists specialising program condition inserted program 
forward conditioning deletes state ments executed initial state satisfies condition backward conditioning deletes cause execution enter state satisfies condition 
relationship backward conditioning reminiscent relationship backward forward slicing forward conditioning addresses program comprehension questions form happens state satisfying condition backward conditioning addresses questions form parts ofthe program potentially lead program arriving state satisfying condition illustrates backward conditioning program comprehension assistant presents gorithm constructing backward conditioned programs 

program comprehension starts source code asking questions happens initial value balance zero program get state greater point constructing hypotheses program get point file lock flag set true 
questions answers important aspects ofthe comprehension activity 
previous conditioned slicing con sidered way questions investigated 
helps answer comprehension questions concern propagation state information forward direction initial states 
conditioned slicing answering questions second unfortunately questions concern intermediate final states information needs condition 
traditional conditioned slicing forward propagation technique 
intro duces counterpart traditional conditioning termed backward conditioning 
condition inthe traditional approach conditioned slicing referred forward condition condition eliminate program code proceeds refered backward condition constructing slice respect backward condition consists removing statements lead program state satisfies code slice 
contains code potentially lead program state satisfies illustrate consider simple example fragment 
program idealized fragment bank account management 
programmer interested see parts finish state account balance bal negative 
condition interest bal point interest fragment 
con slice respect backward condition yields slice depicted right hand column fig ure 
case backward conditioning removed assignment bal indicating remain ing assignment lead program state bal negative 
way backward conditioning assists focusing attention statements potentially cause situation interest arise program 
conditioned slice constructed respect conditions applied forward backward direction 
need denote general conditioned slicing criterion 
condition applied forward direction denoted downward pointing subscript arrow condition contained ceiling brackets dpe 
distinguishes condition backward direction denoted upward pointing superscript arrow condi tion contained floor brackets bpc 
ar rows indicate direction condition respect program text optional distinctive brackets aid disambiguation scope arrows complex conditions 
furthermore condition ei ther forward backward inserted program just code conditioned slicing 
need restrict oneself single condition 
condi tioned slicing criterion generalised set pairs 
pair contains ffl traditional static criterion set variables interest ffl condition program point pair general form static part direction forward static slicing mirrors backward slicing way backward conditions mirror forward conditions 
focus backward conditions program possibility explored generalised notation conditioned slicing criterion bank account program denoted rest organised follows 
section presents simple case study show backward conditioning program comprehension setting section presents algorithm computing backward conditioned programs augmentation approach 
section describes relationship traditional slicing backward forward con section concludes 

application program comprehension section briefly illustrates way backward condi tions assist program comprehension 
consider simple tax calculation program illustrate forward conditions implemented system program represents computation tax codes amounts tax including citizen tax year april april 
person personal allowance un income 
personal allowance depends status person reflected boolean married integer variable age 
tax bands tax charged 
width tax band subject status person fixed individuals 
set taxation rules constitutes governmental business system represents attempt capture rules program code forward conditions helpful understanding program backward conditions provide useful addi tional tool program comprehension 
example suppose programmer personal allowance 
maximum personal allowance individual obtain uk tax ation rules 
entitled allowance 
backward conditioning condition personal inserted program 
variable case final value personal 
conditioned slicing criterion bal bal bal bal bal bal gap bal gap bal gold cust gap top gold cust gap top bal bal bal bal bal bal printf bal printf bal 
original result backward conditioning 
backward conditioning bal line slicing respect criterion yields 
program contains computations lead final value variable personal 
removes computation leave program state 
programmer con clude program award personal allowance individual blind age 
way backward conditioning allows program behaviour investigated 
general answer questions com pletely programmer program code consider 
assists human auto matically removing portions code relevant question consideration occasionally programmer phrase question execution backward condition re definitive answer 
happens slice empty revealing backward condition 
helpful asking questions serve sanity checks 
example case taxation uk law receive income tax burden 
checked program backward condition tax income income captures original value individual gross income 
condition asserts amount tax paid gross income 
possible conditioning program respect backward empty program 
formally empty slice obtained slicing criterion tax income 
computing backward conditioned slices conventional forward slicing conditioning requires symbolic execution automatic theorem proving 
eliminate vant paths statement statement block algorithm determine paths state ment lead negation required condition 
achieved extending notion symbolic path leads negation required condition distinguished value ii determining paths lead statement irrelevant purpose obtaining required condition theorem proving computationally expensive 
reduce number theorems proved practical system slice program default slicing criterion consisting ofthe variables mentioned required backwards condition conceptually system comprised components 
static slicer 
symbolic executor 
theorem prover slicer eliminates statements program depen dence grounds 
symbolic executor theorem prover essentially seek eliminate additional statements path condition grounds symbolic executor provides set path state pairs fhp statement information theorem prover determine relevant paths statements 
simplify main fint age blind widow married income int personal tax scanf age scanf blind scanf married scanf widow scanf income age personal age personal personal age income ft personal income personal personal blind personal personal married age pc married age pc married widow pc pc married age income ft pc income pc pc income personal tax income personal income pc tax income pc income income pc income tax tax income tax income income tax tax income ggg blind married age code blind age married code age age married blind code age age married blind code code 
uk income taxation calculation program implementation introduce backward condi tion line bpc way new program inserted line order determine statement block scan contribute obtaining desired condition need determine execution paths pn related symbolic states sn 
path pk state ment block shown lead negation evaluated corresponding state sk block canbe coloured irrelevant obtaining desired condition algorithm backward condition path reduction steps 
label statements 

find execution paths symbolic states 

associate path labels path 

eliminate statement path support required condition 
detail steps follows 
statement statement block associated identifier line number 
symbolic executor finds possible paths program 
leaves execution tree conventional program pairs path conditions symbolic states 
behaviour symbolic executor extended away paths required condition obtained distinguished value sym path state 
leaves execution tree correspond withthe symbolic result possible path execution 
associate leaf execution tree set identifiers denote statements executed corresponding path 
sake simplicity talk eliminating individual statements algorithm 
generally better consider blocks individual statements reduces time complexity algorithm number calls theorem prover determined number symbolic execution paths product number statements paths single backward condition statements leading condition need considered 
purpose symbolic execution different numbers non zero iterations terminating loop considered equivalent 
main fint age blind int personal scanf age scanf blind age personal blind personal personal 
highest personal allowance 
paths statement associated statement identifier 
shown support statement eliminated 
effect eliminating code paths shown lead negation required condition 
implementation requires incorporation prover symbolic executor 
currently implementation focused stanford svc able reason effectively arithmetic expressions linear inequalities isabelle general purpose theorem prover 
svc isabelle suc integrated prolog symbolic executor java slicer espresso achieve forward con program slicing 
underway extend implementation incorporate backward condition ing algorithm 

example backward conditioning simple example program containing backward condition 
conditional expressions declared relevant symbolic state 
condition occurring context generated program evalu ated symbolic states arise various paths expression path state pairs generated symbolic execution path condition corresponding evaluated symbolic state write treating partial function vari ables symbolic values 
essentially gives interpretation program statement state asin ordinary state program semantics state symbolic state order perform backward conditioning necessary check statement statement allow obtain required condition 
paths statement low demonstrate negation condition holds statement deleted plots key statements paths appear 
path state 
determine path satisfaction required condition question sequent means derive 
case negation condition asserted statement evalu ated appropriate symbolic state 
sequent shown valid path give rise condition 
paths statement block give rise required condition block elided 
evaluating backward condition final sym state path gives valid path ii 
performing substitution gives 
valid summarising proofs path 


valid path ii program code comment main int scanf statement occurs path ii 
point empty symbolic state constant standing unknown input value 
write 
added capture initial value path condition symbolic state 
statement call occurs path 
path condition state statement call occurs path ii 
path condition symbolic state 
path condition symbolic states point ii 
statement added state condition interest 
essence indicates interested determining parts program responsible decreasing value variable compared input value recorded 
simple program paths 




valid executions path statement definitely allow asserted condition true executions path ii state ment 
computations path satisfy asserted condition statements ex path eliminated 
condition 
derivation 


valid path ii 




valid see execution paths condition true execution paths necessarily lead condition include computations condition true 
statement eliminated 

related program slicing introduced weiser 
intention slicing assist program debugging weiser empirically investigated slicing assist program comprehension 
weiser slicing criterion consisted set variables interest anda point interest original program 
statements affect values variables re moved form slice 
example consider program section fig ure 
slicing program respect criterion fxg yields slice section 
slicing program comprehension removing computation allowing programmer focus compu tation korel laski introduced dynamic slicing asa counterpart weiser original static formulation investigated dynamic slicing pro gram comprehension 
dynamic slicing criterion int ag path path ii 

execution paths explicit augments static criterion sequence input val ues 
dynamic criterion triple iis input sequence static slicing criterion conditioned slicing augments weiser traditional static slicing criterion condition cap tures set initial program states interest 
allows programmer specialize program ing statements contribute computation variables interest program executed initial states interest conditioned slicing criterion triple initial condition interest components static slicing criterion 
example conditioned slice original program sec tion criterion fxg section 
slice dynamic slice input sequences element ofthe sequence satisfies condition conditioned slicing useful comprehension static dynamic slices subsumes 
demonstrated situations generalise conditions conditioning program allowing backward forward conditions 
gen requires notation allows slicing criteria contain arbitrary number forward back ward conditions 
generalised notation slicing criterion traditional conditioned slice section reformulated dx fxg forward conditioning assists programmer consid ering effect propagating state information forward condition 
addresses questions form happen program state satisfying 
program conditioning exploits form feasible path analysis 
kind analysis context program testing 
effect backward conditioning mirror image forward conditioning 
example section shows effect backward condition ing original program section respect condition bx fxg slice removes leave program final state satisfying backward conditioning assists programmer considering effect propagating state information back ward condition 
addresses questions form program arrived state satisfying 
course generalisation forms condition combined 
example consider conditioned slicing criterion bx dx fxg criterion empty program revealing impossible program start finish negative 
example delete pro gram statement informative colour display 
idea colouring state ments adopted backward condition informative subsequent example con dition changed colours particular statement executed backward condition true part condi tional second example status backward condition contingent part ofthe conditional examples 
may appropriate aim remove irrelevant state ments path merely eliminate irrelevant paths 
way achieved factual reasoning 
statement symbolically execute program statement removed show variables interest value compared original program 
statement may safely removed 
essentially scanf scanf scanf scanf printf original slice fxg conditioned dx conditioned bx 
comparison forward backward conditioning semantic slicing 
expensive cases standard static slicing achieve results cheaply 

introduces new program specialisation tech nique call backward conditioning counterpart forward conditioning conditioned program slicing argued backward conditioning useful supporting technology program comprehension 
allows explore answer questions program reach point value statements equal 
backward conditioning propagates state condition point delete statements cause execution satisfy condition forward conditioning propagates state information forward condition delete statements executed condition satisfied 
way backward conditioning provides complement tra ditional forward conditioning allows questions statements equal point happens execution continues negative value 
interesting combine backward backward forward slicing single unified program analysis technique 
potentially create powerful highly general technique allow programmer explore answer sophisticated questions part program comprehension activity 
combination backward forward conditioning problem 
ball eick 
visualizing program slices 
ambler kimura editors proceedings symposium visual languages pages los alamitos ca usa oct 
ieee computer society press 
barrett dill levitt 
validity checking theories equality 
srivas editors formal methods computer volume lecture notes computer science pages 
springer verlag november 
california november 
barrett dill levitt 
decision pro cedure bit vector arithmetic 
proceedings th design automation conference june 
san francisco ca 
canfora cimitile de lucia 
conditioned pro gram slicing 
harman gallagher editors information software technology special issue volume pages 
elsevier science danicic fox harman hierons 
conditioned program slicer 
ieee international confer ence software maintenance icsm pages san jose california usa oct 
ieee computer press los alamitos california usa 
danicic harman 
espresso slicer generator 
symposium applied computing sac page appear como italy mar de lucia munro 
understanding function behaviours program slicing 
th program comprehension pages berlin germany mar 
ieee computer society press california usa 
goldberg wang zimmerman 
feasible path analysis program testing 
proceedings international symposium software testing pages seattle wa usa august 
horwitz reps binkley 
interprocedural dependence graphs 
acm transactions programming languages systems jasper brennan williamson zimmerman 
test data generation feasible path anal ysis 
proceedings international symposium software testing analysis pages seattle august 
korel laski 
dynamic program slicing 
informa tion processing letters oct 
korel 
dynamic program slicing standing program execution 
th ieee international workshop program iwpc pages michigan usa may 
ieee computer society press los alamitos california usa lyle weiser 
automatic program bug location program slicing 
nd international conference applications pages 
ieee computer society press los alamitos california usa 
paulson 
isabelle generic theorem prover 
computer science xvii 
paulson 
isabelle manual 
technical report university cambridge computer laboratory 
paulson 
strategic principles design isabelle cade workshop strategies automated deduction pages germany weiser 
program slices formal psychological practical investigations automatic program tion method 
phd thesis university michigan ann arbor mi weiser 
programmers slicing debugging 
communications acm july weiser 
program slicing 
ieee transactions software engineering 
